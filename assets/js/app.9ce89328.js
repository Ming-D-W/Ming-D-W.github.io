(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,r,s=e[0],l=e[1],c=e[2],u=0,p=[];u<s.length;u++)r=s[u],Object.prototype.hasOwnProperty.call(a,r)&&a[r]&&p.push(a[r][0]),a[r]=0;for(i in l)Object.prototype.hasOwnProperty.call(l,i)&&(n[i]=l[i]);for(d&&d(e);p.length;)p.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],i=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(i=!1)}i&&(o.splice(e--,1),n=r(r.s=t[0]))}return n}var i={},a={1:0},o=[];function r(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,r),t.l=!0,t.exports}r.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=a[n]=[e,i]}));e.push(t[2]=i);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,r.nc&&s.setAttribute("nonce",r.nc),s.src=function(n){return r.p+"assets/js/"+({}[n]||n)+"."+{2:"f5951ee7",3:"a5286238",4:"d14eaad4",5:"80fa8520",6:"6e6d5e8a",7:"74e99897",8:"00efa629",9:"a3a07a71",10:"01f08460",11:"6965dc33",12:"04b2320f",13:"f5967695",14:"120f01ce",15:"8f34ae65",16:"da36ec39",17:"d6154bd1",18:"d2e78319",19:"d63bd086",20:"e9ef98ac",21:"69f7540a",22:"a88cba2e",23:"ddbc3ed5",24:"8aa156d2",25:"2d310d73",26:"83a32a24",27:"45caf8fe",28:"9e25c263",29:"f59ebaf6",30:"7a276a76",31:"efca4faf",32:"81d02bc9",33:"162743ea",34:"2cdd6ead",35:"2231b486",36:"84f851d4",37:"b9c7b886",38:"898dcd14",39:"48b68a5d",40:"19416517",41:"b9fc92e5",42:"ce346e99",43:"f188fedb",44:"bb6f56d2",45:"69c867be",46:"3c9d28a8",47:"10b373c1",48:"d9e402f5",49:"60a8fab4",50:"81c21077",51:"1cc4bb83",52:"8d2cdae4",53:"e570f209",54:"1e06951c",55:"64e72812",56:"4cae741a",57:"ef803625",58:"1ea37da9",59:"43780741",60:"ce437f17",61:"2751887b",62:"8895dde5",63:"fa94ccc8",64:"fa6c97a4",65:"ecccf6b5",66:"00e32ac7",67:"38c5d4fc",68:"9354682a",69:"798d4c5c",70:"ad5d9eba",71:"d8b7dd18",72:"cbcd658e",73:"2b2bdfbd",74:"9ef8250a",75:"ee74c53b",76:"b3741378",77:"de9d53ee",78:"66cca25d",79:"438142bf",80:"89eb3fa4",81:"4c11e07f",82:"d8694b66",83:"92e9cb8e",84:"923e6345",85:"a8975b01",86:"7c63a86c",87:"1b4d6359",88:"8e86e14b",89:"5f99d004",90:"97d4e502",91:"f015f724",92:"c4d04cfe",93:"9ab5bc13",94:"c0d85f9c",95:"43bed309",96:"b8a54cf9",97:"5357cbc5",98:"4bbda207",99:"e3e97233",100:"67cdec04",101:"0179f79a",102:"193ab642",103:"adb7b3ef",104:"bb50b48e",105:"9b0076e6",106:"810351da",107:"770b25d4",108:"4cc2b80c",109:"bb88a410",110:"1057d2bb",111:"6976aaa5",112:"091e3496",113:"361d9f2b",114:"5ab74754",115:"a1eb5f2c",116:"d25015c5",117:"449026c8",118:"822157f1",119:"10a0c829",120:"10699888",121:"c637a980",122:"4c9109a0",123:"58026fde",124:"c495d639",125:"9394c1b7",126:"c97b7f50",127:"7f281e80",128:"c95cb2f1",129:"49bfff21",130:"d6d35cac"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+i+": "+o+")",l.name="ChunkLoadError",l.type=i,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},r.m=n,r.c=i,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)r.d(t,i,function(e){return n[e]}.bind(null,i));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="/",r.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;o.push([109,0]),t()}([function(n,e,t){"use strict";function i(n,e,t,i,a,o,r,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),i&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),r?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(r)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return i}))},function(n,e,t){"use strict";var i=function(n){return n&&n.Math===Math&&n};n.exports=i("object"==typeof globalThis&&globalThis)||i("object"==typeof window&&window)||i("object"==typeof self&&self)||i("object"==typeof global&&global)||i("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";var i="object"==typeof document&&document.all;n.exports=void 0===i&&void 0!==i?function(n){return"function"==typeof n||n===i}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";var i=t(27),a=Function.prototype,o=a.call,r=i&&a.bind.bind(o,o);n.exports=i?r:function(n){return function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var i=t(2);n.exports=function(n){return"object"==typeof n?null!==n:i(n)}},function(n,e,t){var i=t(70),a="object"==typeof self&&self&&self.Object===Object&&self,o=i||a||Function("return this")();n.exports=o},function(n,e,t){"use strict";var i=t(3),a=t(32),o=i({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return o(a(n),e)}},function(n,e,t){var i=t(167),a=t(170);n.exports=function(n,e){var t=a(n,e);return i(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return i})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return r})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(13);const i=/#.*$/,a=/\.(md|html)$/,o=/\/$/,r=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(i,"").replace(a,"")}function l(n){return r.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(i),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function p(n,e){const t=n.hash,a=function(n){const e=n&&n.match(i);if(e)return e[0]}(e);if(a&&t!==a)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const a=e.split("/");t&&a[a.length-1]||a.pop();const o=n.replace(/^\//,"").split("/");for(let n=0;n<o.length;n++){const e=o[n];".."===e?a.pop():"."!==e&&a.push(e)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));const i=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,i){const{pages:a,themeConfig:o}=t,r=i&&o.locales&&o.locales[i]||o;if("auto"===(n.frontmatter.sidebar||r.sidebar||o.sidebar))return g(n);const s=r.sidebar||o.sidebar;if(s){const{base:t,config:i}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,s);return"auto"===i?g(n):i?i.map(n=>function n(e,t,i,a=1){if("string"==typeof e)return m(t,e,i);if(Array.isArray(e))return Object.assign(m(t,e[0],i),{title:e[1]});{a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=e.children||[];return 0===o.length&&e.path?Object.assign(m(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map(e=>n(e,t,i,a+1)),collapsable:!1!==e.collapsable}}}(n,a,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";var i=t(26),a=t(32),o=t(33),r=t(146),s=t(148);i({target:"Array",proto:!0,arity:1,forced:t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=a(this),t=o(e),i=arguments.length;s(t+i);for(var l=0;l<i;l++)e[t]=arguments[l],t++;return r(e,t),t}})},function(n,e,t){var i=t(16),a=t(152),o=t(153),r=i?i.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":r&&r in Object(n)?a(n):o(n)}},function(n,e,t){"use strict";var i=t(5),a=t(17),o=t(35);n.exports=i?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(8).Symbol;n.exports=i},function(n,e,t){"use strict";var i=t(5),a=t(65),o=t(104),r=t(48),s=t(56),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(r(n),e=s(e),r(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var i=d(n,e);i&&i.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:i.configurable,enumerable:"enumerable"in t?t.enumerable:i.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(r(n),e=s(e),r(t),a)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw new l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){"use strict";var i=t(3),a=i({}.toString),o=i("".slice);n.exports=function(n){return o(a(n),8,-1)}},function(n,e,t){var i=t(157),a=t(158),o=t(159),r=t(160),s=t(161);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=r,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(i(n[t][0],e))return t;return-1}},function(n,e,t){var i=t(10)(Object,"create");n.exports=i},function(n,e,t){var i=t(179);n.exports=function(n,e){var t=n.__data__;return i(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var i=t(46);n.exports=function(n){if("string"==typeof n||i(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var i,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,i.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(i.barSelector),d=i.speed,u=i.easing;return l.offsetWidth,r((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===i.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var a,r=e.querySelector(i.barSelector),l=n?"-100":o(t.status||0),d=document.querySelector(i.parent);return s(r,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),i.showSpinner||(a=e.querySelector(i.spinnerSelector))&&p(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var r=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((i=n[a]+o)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&i(n,t,a);else i(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),i=t+e;l(t,e)||(n.className=i.substring(1))}function d(n,e){var t,i=u(n);l(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=a)},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-comment","version":"0.7.3","description":"Comment plugin in vuepress, such as Gitalk, Valine...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"author":"dongyuanxin","license":"MIT","bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"}}')},function(n,e,t){"use strict";var i=t(1),a=t(54).f,o=t(15),r=t(100),s=t(38),l=t(66),c=t(128);n.exports=function(n,e){var t,d,u,p,m,h=n.target,g=n.global,f=n.stat;if(t=g?i:f?i[h]||s(h,{}):i[h]&&i[h].prototype)for(d in e){if(p=e[d],u=n.dontCallGetSet?(m=a(t,d))&&m.value:t[d],!c(g?d:h+(f?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&o(p,"sham",!0),r(t,d,p,n)}}},function(n,e,t){"use strict";var i=t(4);n.exports=!i((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){"use strict";var i=t(50),a=t(36);n.exports=function(n){return i(a(n))}},function(n,e,t){"use strict";var i=t(1),a=t(2),o=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?o(i[n]):i[n]&&i[n][e]}},function(n,e,t){"use strict";var i=t(2),a=t(115),o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(a(n)+" is not a function")}},function(n,e,t){"use strict";var i=t(1),a=t(62),o=t(9),r=t(64),s=t(60),l=t(59),c=i.Symbol,d=a("wks"),u=l?c.for||c:c&&c.withoutSetter||r;n.exports=function(n){return o(d,n)||(d[n]=s&&o(c,n)?c[n]:u("Symbol."+n)),d[n]}},function(n,e,t){"use strict";var i=t(36),a=Object;n.exports=function(n){return a(i(n))}},function(n,e,t){"use strict";var i=t(126);n.exports=function(n){return i(n.length)}},function(n,e,t){"use strict";var i=t(27),a=Function.prototype.call;n.exports=i?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){"use strict";n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var i=t(55),a=TypeError;n.exports=function(n){if(i(n))throw new a("Can't call method on "+n);return n}},function(n,e,t){"use strict";var i=t(63),a=t(1),o=t(38),r=n.exports=a["__core-js_shared__"]||o("__core-js_shared__",{});(r.versions||(r.versions=[])).push({version:"3.37.1",mode:i?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){"use strict";var i=t(1),a=Object.defineProperty;n.exports=function(n,e){try{a(i,n,{value:e,configurable:!0,writable:!0})}catch(t){i[n]=e}return e}},function(n,e,t){var i=t(151),a=t(12),o=Object.prototype,r=o.hasOwnProperty,s=o.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(n){return a(n)&&r.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var i=t(10)(t(8),"Map");n.exports=i},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var i=t(171),a=t(178),o=t(180),r=t(181),s=t(182);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=r,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var i=t(6),a=t(46),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;n.exports=function(n,e){if(i(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(r.test(n)||!o.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var i=t(14),a=t(12);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==i(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var i=t(7),a=String,o=TypeError;n.exports=function(n){if(i(n))return n;throw new o(a(n)+" is not an object")}},function(n,e,t){"use strict";var i=t(26),a=t(1),o=t(132),r=t(133),s=a.WebAssembly,l=7!==new Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=r(n,e,l),i({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=r("WebAssembly."+n,e,l),i({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return o(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return o(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return o(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return o(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return o(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return o(n,this,arguments)}})),c("URIError",(function(n){return function(e){return o(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return o(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return o(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return o(n,this,arguments)}}))},function(n,e,t){"use strict";var i=t(3),a=t(4),o=t(18),r=Object,s=i("".split);n.exports=a((function(){return!r("z").propertyIsEnumerable(0)}))?function(n){return"String"===o(n)?s(n,""):r(n)}:r},function(n,e,t){"use strict";n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,o=/^0o[0-7]+$/i,r=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||o.test(n)?r(n.slice(2),s?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,a,o,r,s,l,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=i,o=a;return i=a=void 0,c=e,r=n.apply(o,t)}function x(n){return c=n,s=setTimeout(w,e),d?b(n):r}function y(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=o}function w(){var n=m();if(y(n))return k(n);s=setTimeout(w,function(n){var t=e-(n-l);return f?p(t,o-(n-c)):t}(n))}function k(n){return s=void 0,v&&i?b(n):(i=a=void 0,r)}function _(){var n=m(),t=y(n);if(i=arguments,a=this,l=n,t){if(void 0===s)return x(l);if(f)return s=setTimeout(w,e),b(l)}return void 0===s&&(s=setTimeout(w,e)),r}return e=g(e)||0,h(t)&&(d=!!t.leading,o=(f="maxWait"in t)?u(g(t.maxWait)||0,e):o,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,i=l=a=s=void 0},_.flush=function(){return void 0===s?r:k(m())},_}},function(n,e,t){"use strict";var i=t(5),a=t(34),o=t(111),r=t(35),s=t(28),l=t(56),c=t(9),d=t(65),u=Object.getOwnPropertyDescriptor;e.f=i?u:function(n,e){if(n=s(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return r(!a(o.f,n,e),n[e])}},function(n,e,t){"use strict";n.exports=function(n){return null==n}},function(n,e,t){"use strict";var i=t(112),a=t(57);n.exports=function(n){var e=i(n,"string");return a(e)?e:e+""}},function(n,e,t){"use strict";var i=t(29),a=t(2),o=t(58),r=t(59),s=Object;n.exports=r?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){"use strict";var i=t(3);n.exports=i({}.isPrototypeOf)},function(n,e,t){"use strict";var i=t(60);n.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){"use strict";var i=t(61),a=t(4),o=t(1).String;n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol("symbol detection");return!o(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},function(n,e,t){"use strict";var i,a,o=t(1),r=t(113),s=o.process,l=o.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(a=(i=d.split("."))[0]>0&&i[0]<4?1:+(i[0]+i[1])),!a&&r&&(!(i=r.match(/Edge\/(\d+)/))||i[1]>=74)&&(i=r.match(/Chrome\/(\d+)/))&&(a=+i[1]),n.exports=a},function(n,e,t){"use strict";var i=t(37);n.exports=function(n,e){return i[n]||(i[n]=e||{})}},function(n,e,t){"use strict";n.exports=!1},function(n,e,t){"use strict";var i=t(3),a=0,o=Math.random(),r=i(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+r(++a+o,36)}},function(n,e,t){"use strict";var i=t(5),a=t(4),o=t(103);n.exports=!i&&!a((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){"use strict";var i=t(9),a=t(121),o=t(54),r=t(17);n.exports=function(n,e,t){for(var s=a(e),l=r.f,c=o.f,d=0;d<s.length;d++){var u=s[d];i(n,u)||t&&i(t,u)||l(n,u,c(e,u))}}},function(n,e,t){"use strict";var i=t(125);n.exports=function(n){var e=+n;return e!=e||0===e?0:i(e)}},function(n,e,t){"use strict";var i=t(134),a=t(7),o=t(36),r=t(135);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=i(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,i){return o(t),r(i),a(t)?(e?n(t,i):t.__proto__=i,t):t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,i=e.length,a=n.length;++t<i;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var i=t(19),a=t(162),o=t(163),r=t(164),s=t(165),l=t(166);function c(n){var e=this.__data__=new i(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=r,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var i=t(14),a=t(41);n.exports=function(n){if(!a(n))return!1;var e=i(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var i=t(183),a=t(12);n.exports=function n(e,t,o,r,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:i(e,t,o,r,n,s))}},function(n,e,t){var i=t(77),a=t(186),o=t(78);n.exports=function(n,e,t,r,s,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,f=2&t?new i:void 0;for(l.set(n,e),l.set(e,n);++h<d;){var v=n[h],b=e[h];if(r)var x=c?r(b,v,h,e,n,l):r(v,b,h,n,e,l);if(void 0!==x){if(x)continue;g=!1;break}if(f){if(!a(e,(function(n,e){if(!o(f,e)&&(v===n||s(v,n,t,r,l)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!s(v,b,t,r,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var i=t(42),a=t(184),o=t(185);function r(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new i;++e<t;)this.add(n[e])}r.prototype.add=r.prototype.push=a,r.prototype.has=o,n.exports=r},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var i=t(196),a=t(202),o=t(83);n.exports=function(n){return o(n)?i(n):a(n)}},function(n,e,t){(function(n){var i=t(8),a=t(198),o=e&&!e.nodeType&&e,r=o&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===o?i.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(52)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var i=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==i||"symbol"!=i&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var i=t(199),a=t(200),o=t(201),r=o&&o.isTypedArray,s=r?a(r):i;n.exports=s},function(n,e,t){var i=t(73),a=t(44);n.exports=function(n){return null!=n&&a(n.length)&&!i(n)}},function(n,e,t){var i=t(10)(t(8),"Set");n.exports=i},function(n,e,t){var i=t(41);n.exports=function(n){return n==n&&!i(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var i=t(88),a=t(23);n.exports=function(n,e){for(var t=0,o=(e=i(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var i=t(6),a=t(45),o=t(213),r=t(216);n.exports=function(n,e){return i(n)?n:a(n,e)?[n]:o(r(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(149),a=t(154),o=t(225),r=t(233),s=t(242),l=t(108),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),r(i(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var i=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=i.exec(t);if(!a)return t;var o="",r=0,s=0;for(r=a.index;r<t.length;r++){switch(t.charCodeAt(r)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==r&&(o+=t.substring(s,r)),s=r+1,o+=e}return s!==r?o+t.substring(s,r):o}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var i=t(249),a=t(250),o=t(251),r=!1,s=t(252).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),d=/^\uFEFF/;function u(n,t){var a,o,r=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(o=e.resolveInclude(n,t.filename),i.existsSync(o)&&(a=o)),a||Array.isArray(r)&&r.some((function(t){return o=e.resolveInclude(n,t,!0),i.existsSync(o)}))&&(a=o),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function p(n,t){var i,a=n.filename,o=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(i=e.cache.get(a))return i;o||(t=h(a).toString().replace(d,""))}else if(!o){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=h(a).toString().replace(d,"")}return i=e.compile(t,n),n.cache&&e.cache.set(a,i),i}function m(n,t,i){var a;if(!i){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,i){try{e(a=p(n)(t))}catch(n){i(n)}}));throw new Error("Please provide a callback function")}try{a=p(n)(t)}catch(n){return i(n)}i(null,a)}function h(n){return e.fileLoader(n)}function g(n,e,t,i,a){var o=e.split("\n"),r=Math.max(i-3,0),s=Math.min(o.length,i+3),l=a(t),c=o.slice(r,s).map((function(n,e){var t=e+r+1;return(t==i?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+i+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var i={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],i.client=t.client||!1,i.escapeFunction=t.escape||t.escapeFunction||o.escapeXML,i.compileDebug=!1!==t.compileDebug,i.debug=!!t.debug,i.filename=t.filename,i.openDelimiter=t.openDelimiter||e.openDelimiter||"<",i.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",i.delimiter=t.delimiter||e.delimiter||"%",i.strict=t.strict||!1,i.context=t.context,i.cache=t.cache||!1,i.rmWhitespace=t.rmWhitespace,i.root=t.root,i.outputFunctionName=t.outputFunctionName,i.localsName=t.localsName||e.localsName||"locals",i.views=t.views,i.async=t.async,i.destructuredLocals=t.destructuredLocals,i.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,i.strict?i._with=!1:i._with=void 0===t._with||t._with,this.opts=i,this.regex=this.createRegex()}e.cache=o.cache,e.fileLoader=i.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var i=a.dirname,o=a.extname,r=(0,a.resolve)(t?e:i(e),n);return o(n)||(r+=".ejs"),r},e.compile=function(n,e){return e&&e.scope&&(r||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),r=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var i=e||{},a=t||{};return 2==arguments.length&&o.shallowCopyFromList(a,i,l),p(a,n)(i)},e.renderFile=function(){var n,e,t,i=Array.prototype.slice.call(arguments),a=i.shift(),r={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=i.pop()),i.length?(e=i.shift(),i.length?o.shallowCopy(r,i.pop()):(e.settings&&(e.settings.views&&(r.views=e.settings.views),e.settings["view cache"]&&(r.cache=!0),(t=e.settings["view options"])&&o.shallowCopy(r,t)),o.shallowCopyFromList(r,e,c)),r.filename=a):e={},m(r,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=o.escapeRegExpChars(this.opts.delimiter),t=o.escapeRegExpChars(this.opts.openDelimiter),i=o.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,i),new RegExp(n)},compile:function(){var n,e,t,i=this.opts,r="",s="",l=i.escapeFunction;if(!this.source){if(this.generateSource(),r+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',i.outputFunctionName&&(r+="  var "+i.outputFunctionName+" = __append;\n"),i.destructuredLocals&&i.destructuredLocals.length){for(var c="  var __locals = ("+i.localsName+" || {}),\n",d=0;d<i.destructuredLocals.length;d++){var m=i.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}r+=c+";\n"}!1!==i._with&&(r+="  with ("+i.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=r+this.source+s}n=i.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(i.filename?JSON.stringify(i.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,i.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,i.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),i.strict&&(n='"use strict";\n'+n),i.debug&&console.log(n),i.compileDebug&&i.filename&&(n=n+"\n//# sourceURL="+i.filename+"\n");try{if(i.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(i.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(i.filename&&(n.message+=" in "+i.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",i.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=i.client?e:function(n){return e.apply(i.context,[n||{},l,function(e,t){var a=o.shallowCopy({},n);return t&&(a=o.shallowCopy(a,t)),function(n,e){var t=o.shallowCopy({},e);return t.filename=u(n,t),p(t)}(e,i)(a)},g])};if(h.dependencies=this.dependencies,i.filename&&"function"==typeof Object.defineProperty){var f=i.filename,v=a.basename(f,a.extname(f));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,i=this.parseTemplateText(),a=this.opts.delimiter,r=this.opts.openDelimiter,s=this.opts.closeDelimiter;i&&i.length&&i.forEach((function(l,c){var p,m,g,f,b,x;if(0===l.indexOf(r+a)&&0!==l.indexOf(r+a+a)&&(m=i[c+2])!=a+s&&m!="-"+a+s&&m!="_"+a+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(g=l.match(/^\s*include\s+(\S+)/))&&(p=i[c-1])&&(p==r+a||p==r+a+"-"||p==r+a+"_"))return f=o.shallowCopy({},t.opts),b=function(n,e){var t,i,a=o.shallowCopy({},e);i=h(t=u(n,a)).toString().replace(d,""),a.filename=t;var r=new v(i,a);return r.generateSource(),{source:r.source,filename:t,template:i}}(g[1],f),x=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=x,void t.dependencies.push(e.resolveInclude(g[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,i=t.exec(e),a=[];i;)0!==(n=i.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(i[0]),e=e.slice(i[0].length),i=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,i=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case i+t:case i+t+"_":this.mode=v.modes.EVAL;break;case i+t+"=":this.mode=v.modes.ESCAPED;break;case i+t+"-":this.mode=v.modes.RAW;break;case i+t+"#":this.mode=v.modes.COMMENT;break;case i+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(i+t+t,i+t)+'")\n';break;case t+t+a:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=o.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){var i;"undefined"!=typeof self&&self,i=function(){return function(n){var e={};function t(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return n[i].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{configurable:!1,enumerable:!0,get:i})},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=7)}([function(n,e,t){n.exports=!t(6)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e){n.exports=function(n,e,t,i,a){var o,r=n=n||{},s=typeof n.default;"object"!==s&&"function"!==s||(o=n,r=n.default);var l,c="function"==typeof r?r.options:r;if(e&&(c.render=e.render,c.staticRenderFns=e.staticRenderFns),i&&(c._scopeId=i),a?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),t&&t.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(a)},c._ssrRegister=l):t&&(l=t),l){var d=c.functional,u=d?c.render:c.beforeCreate;d?c.render=function(n,e){return l.call(e),u(n,e)}:c.beforeCreate=u?[].concat(u,l):[l]}return{esModule:o,exports:r,options:c}}},function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(n,e){var t=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=t)},function(n,e,t){var i=t(23),a=t(24),o=t(26),r=Object.defineProperty;e.f=t(0)?Object.defineProperty:function(n,e,t){if(i(n),e=o(e,!0),i(t),a)try{return r(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var i,a,o;a=[e,t(8),t(11)],void 0===(o="function"==typeof(i=function(n,e,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.Tabs=n.Tab=void 0;var i=o(e),a=o(t);function o(n){return n&&n.__esModule?n:{default:n}}n.default={install:function(n){n.component("tab",i.default),n.component("tabs",a.default)}},n.Tab=i.default,n.Tabs=a.default})?i.apply(e,a):i)||(n.exports=o)},function(n,e,t){var i=t(2)(t(9),t(10),null,null,null);n.exports=i.exports},function(n,e,t){var i,a,o;a=[e],void 0===(o="function"==typeof(i=function(n){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.default={props:{id:{default:null},name:{required:!0},prefix:{default:""},suffix:{default:""},isDisabled:{default:!1}},data:function(){return{isActive:!1,isVisible:!0}},computed:{header:function(){return this.prefix+this.name+this.suffix},computedId:function(){return this.id?this.id:this.name.toLowerCase().replace(/ /g,"-")},hash:function(){return this.isDisabled?"#":"#"+this.computedId}}}})?i.apply(e,a):i)||(n.exports=o)},function(n,e){n.exports={render:function(){var n=this.$createElement;return(this._self._c||n)("section",{directives:[{name:"show",rawName:"v-show",value:this.isActive,expression:"isActive"}],staticClass:"tabs-component-panel",attrs:{"aria-hidden":!this.isActive,id:this.computedId,role:"tabpanel"}},[this._t("default")],2)},staticRenderFns:[]}},function(n,e,t){var i=t(2)(t(12),t(29),null,null,null);n.exports=i.exports},function(n,e,t){var i,a,o;a=[e,t(13)],void 0===(o="function"==typeof(i=function(n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var t,i=(t=e)&&t.__esModule?t:{default:t};n.default={props:{cacheLifetime:{default:5},options:{type:Object,required:!1,default:function(){return{useUrlFragment:!0,defaultTabHash:null}}}},data:function(){return{tabs:[],activeTabHash:"",activeTabIndex:0,lastActiveTabHash:""}},computed:{storageKey:function(){return"vue-tabs-component.cache."+window.location.host+window.location.pathname}},created:function(){this.tabs=this.$children},mounted:function(){var n=this;if(window.addEventListener("hashchange",(function(){return n.selectTab(window.location.hash)})),this.findTab(window.location.hash))this.selectTab(window.location.hash);else{var e=i.default.get(this.storageKey);this.findTab(e)?this.selectTab(e):null!==this.options.defaultTabHash&&this.findTab("#"+this.options.defaultTabHash)?this.selectTab("#"+this.options.defaultTabHash):this.tabs.length&&this.selectTab(this.tabs[0].hash)}},methods:{findTab:function(n){return this.tabs.find((function(e){return e.hash===n}))},selectTab:function(n,e){e&&!this.options.useUrlFragment&&e.preventDefault();var t=this.findTab(n);t&&(t.isDisabled?e.preventDefault():this.lastActiveTabHash!==t.hash?(this.tabs.forEach((function(n){n.isActive=n.hash===t.hash})),this.$emit("changed",{tab:t}),this.activeTabHash=t.hash,this.activeTabIndex=this.getTabIndex(n),this.lastActiveTabHash=this.activeTabHash=t.hash,i.default.set(this.storageKey,t.hash,this.cacheLifetime)):this.$emit("clicked",{tab:t}))},setTabVisible:function(n,e){var t=this.findTab(n);t&&(t.isVisible=e,t.isActive&&(t.isActive=e,this.tabs.every((function(n,e,t){return!n.isVisible||(n.isActive=!0,!1)}))))},getTabIndex:function(n){var e=this.findTab(n);return this.tabs.indexOf(e)},getTabHash:function(n){var e=this,t=this.tabs.find((function(t){return e.tabs.indexOf(t)===n}));if(t)return t.hash},getActiveTab:function(){return this.findTab(this.activeTabHash)},getActiveTabIndex:function(){return this.getTabIndex(this.activeTabHash)}}}})?i.apply(e,a):i)||(n.exports=o)},function(n,e,t){var i,a,o;a=[e,t(14),t(15)],void 0===(o="function"==typeof(i=function(n,e,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=o(e),a=o(t);function o(n){return n&&n.__esModule?n:{default:n}}var r=function(){function n(){(0,i.default)(this,n)}return(0,a.default)(n,[{key:"get",value:function(n){var e=JSON.parse(localStorage.getItem(n));return e?new Date(e.expires)<new Date?(localStorage.removeItem(n),null):e.value:null}},{key:"set",value:function(n,e,t){var i=(new Date).getTime(),a=new Date(i+6e4*t);localStorage.setItem(n,JSON.stringify({value:e,expires:a}))}}]),n}();n.default=new r})?i.apply(e,a):i)||(n.exports=o)},function(n,e,t){"use strict";e.__esModule=!0,e.default=function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}},function(n,e,t){"use strict";e.__esModule=!0;var i,a=t(16),o=(i=a)&&i.__esModule?i:{default:i};e.default=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),(0,o.default)(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}()},function(n,e,t){n.exports={default:t(17),__esModule:!0}},function(n,e,t){t(18);var i=t(4).Object;n.exports=function(n,e,t){return i.defineProperty(n,e,t)}},function(n,e,t){var i=t(19);i(i.S+i.F*!t(0),"Object",{defineProperty:t(5).f})},function(n,e,t){var i=t(3),a=t(4),o=t(20),r=t(22),s=t(28),l=function(n,e,t){var c,d,u,p=n&l.F,m=n&l.G,h=n&l.S,g=n&l.P,f=n&l.B,v=n&l.W,b=m?a:a[e]||(a[e]={}),x=b.prototype,y=m?i:h?i[e]:(i[e]||{}).prototype;for(c in m&&(t=e),t)(d=!p&&y&&void 0!==y[c])&&s(b,c)||(u=d?y[c]:t[c],b[c]=m&&"function"!=typeof y[c]?t[c]:f&&d?o(u,i):v&&y[c]==u?function(n){var e=function(e,t,i){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(e);case 2:return new n(e,t)}return new n(e,t,i)}return n.apply(this,arguments)};return e.prototype=n.prototype,e}(u):g&&"function"==typeof u?o(Function.call,u):u,g&&((b.virtual||(b.virtual={}))[c]=u,n&l.R&&x&&!x[c]&&r(x,c,u)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},function(n,e,t){var i=t(21);n.exports=function(n,e,t){if(i(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,i){return n.call(e,t,i)};case 3:return function(t,i,a){return n.call(e,t,i,a)}}return function(){return n.apply(e,arguments)}}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},function(n,e,t){var i=t(5),a=t(27);n.exports=t(0)?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(1);n.exports=function(n){if(!i(n))throw TypeError(n+" is not an object!");return n}},function(n,e,t){n.exports=!t(0)&&!t(6)((function(){return 7!=Object.defineProperty(t(25)("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var i=t(1),a=t(3).document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var i=t(1);n.exports=function(n,e){if(!i(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!i(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!i(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!i(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e){n.exports={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"tabs-component"},[t("ul",{staticClass:"tabs-component-tabs",attrs:{role:"tablist"}},n._l(n.tabs,(function(e,i){return t("li",{directives:[{name:"show",rawName:"v-show",value:e.isVisible,expression:"tab.isVisible"}],key:i,staticClass:"tabs-component-tab",class:{"is-active":e.isActive,"is-disabled":e.isDisabled},attrs:{role:"presentation"}},[t("a",{staticClass:"tabs-component-tab-a",attrs:{"aria-controls":e.hash,"aria-selected":e.isActive,href:e.hash,role:"tab"},domProps:{innerHTML:n._s(e.header)},on:{click:function(t){n.selectTab(e.hash,t)}}})])}))),n._v(" "),t("div",{staticClass:"tabs-component-panels"},[n._t("default")],2)])},staticRenderFns:[]}}])},n.exports=i()},function(n,e,t){"use strict";t.r(e);var i={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(245),t(0)),o=Object(a.a)(i,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);var i={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},a=(t(246),t(0)),o=Object(a.a)(i,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,i){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":i===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(i)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var i=t(2),a=t(17),o=t(105),r=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(i(t)&&o(t,c,s),s.global)l?n[e]=t:r(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){"use strict";n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var i=t(140),a=String;n.exports=function(n){if("Symbol"===i(n))throw new TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){"use strict";var i=t(1),a=t(7),o=i.document,r=a(o)&&a(o.createElement);n.exports=function(n){return r?o.createElement(n):{}}},function(n,e,t){"use strict";var i=t(5),a=t(4);n.exports=i&&a((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){"use strict";var i=t(3),a=t(4),o=t(2),r=t(9),s=t(5),l=t(117).CONFIGURABLE,c=t(118),d=t(119),u=d.enforce,p=d.get,m=String,h=Object.defineProperty,g=i("".slice),f=i("".replace),v=i([].join),b=s&&!a((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===g(m(e),0,7)&&(e="["+f(m(e),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!r(n,"name")||l&&n.name!==e)&&(s?h(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&r(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&r(t,"constructor")&&t.constructor?s&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var i=u(n);return r(i,"source")||(i.source=v(x,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return o(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){"use strict";var i=t(62),a=t(64),o=i("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){"use strict";var i=t(3),a=t(9),o=t(28),r=t(123).indexOf,s=t(51),l=i([].push);n.exports=function(n,e){var t,i=o(n),c=0,d=[];for(t in i)!a(s,t)&&a(i,t)&&l(d,t);for(;e.length>c;)a(i,t=e[c++])&&(~r(d,t)||l(d,t));return d}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(256)},function(n,e,t){"use strict";var i=t(26),a=t(129).left,o=t(130),r=t(61);i({target:"Array",proto:!0,forced:!t(131)&&r>79&&r<83||!o("reduce")},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var i={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!i.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:i},function(n,e,t){"use strict";var i=t(34),a=t(7),o=t(57),r=t(114),s=t(116),l=t(31),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,l=r(n,d);if(l){if(void 0===e&&(e="default"),t=i(l,n,e),!a(t)||o(t))return t;throw new c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){"use strict";n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){"use strict";var i=t(30),a=t(55);n.exports=function(n,e){var t=n[e];return a(t)?void 0:i(t)}},function(n,e,t){"use strict";var i=String;n.exports=function(n){try{return i(n)}catch(n){return"Object"}}},function(n,e,t){"use strict";var i=t(34),a=t(2),o=t(7),r=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&a(t=n.toString)&&!o(s=i(t,n)))return s;if(a(t=n.valueOf)&&!o(s=i(t,n)))return s;if("string"!==e&&a(t=n.toString)&&!o(s=i(t,n)))return s;throw new r("Can't convert object to primitive value")}},function(n,e,t){"use strict";var i=t(5),a=t(9),o=Function.prototype,r=i&&Object.getOwnPropertyDescriptor,s=a(o,"name"),l=s&&"something"===function(){}.name,c=s&&(!i||i&&r(o,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){"use strict";var i=t(3),a=t(2),o=t(37),r=i(Function.toString);a(o.inspectSource)||(o.inspectSource=function(n){return r(n)}),n.exports=o.inspectSource},function(n,e,t){"use strict";var i,a,o,r=t(120),s=t(1),l=t(7),c=t(15),d=t(9),u=t(37),p=t(106),m=t(51),h=s.TypeError,g=s.WeakMap;if(r||u.state){var f=u.state||(u.state=new g);f.get=f.get,f.has=f.has,f.set=f.set,i=function(n,e){if(f.has(n))throw new h("Object already initialized");return e.facade=n,f.set(n,e),e},a=function(n){return f.get(n)||{}},o=function(n){return f.has(n)}}else{var v=p("state");m[v]=!0,i=function(n,e){if(d(n,v))throw new h("Object already initialized");return e.facade=n,c(n,v,e),e},a=function(n){return d(n,v)?n[v]:{}},o=function(n){return d(n,v)}}n.exports={set:i,get:a,has:o,enforce:function(n){return o(n)?a(n):i(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw new h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){"use strict";var i=t(1),a=t(2),o=i.WeakMap;n.exports=a(o)&&/native code/.test(String(o))},function(n,e,t){"use strict";var i=t(29),a=t(3),o=t(122),r=t(127),s=t(48),l=a([].concat);n.exports=i("Reflect","ownKeys")||function(n){var e=o.f(s(n)),t=r.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var i=t(107),a=t(101).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,a)}},function(n,e,t){"use strict";var i=t(28),a=t(124),o=t(33),r=function(n){return function(e,t,r){var s=i(e),l=o(s);if(0===l)return!n&&-1;var c,d=a(r,l);if(n&&t!=t){for(;l>d;)if((c=s[d++])!=c)return!0}else for(;l>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:r(!0),indexOf:r(!1)}},function(n,e,t){"use strict";var i=t(67),a=Math.max,o=Math.min;n.exports=function(n,e){var t=i(n);return t<0?a(t+e,0):o(t,e)}},function(n,e,t){"use strict";var i=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:i)(e)}},function(n,e,t){"use strict";var i=t(67),a=Math.min;n.exports=function(n){var e=i(n);return e>0?a(e,9007199254740991):0}},function(n,e,t){"use strict";e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var i=t(4),a=t(2),o=/#|\.prototype\./,r=function(n,e){var t=l[s(n)];return t===d||t!==c&&(a(e)?i(e):!!e)},s=r.normalize=function(n){return String(n).replace(o,".").toLowerCase()},l=r.data={},c=r.NATIVE="N",d=r.POLYFILL="P";n.exports=r},function(n,e,t){"use strict";var i=t(30),a=t(32),o=t(50),r=t(33),s=TypeError,l="Reduce of empty array with no initial value",c=function(n){return function(e,t,c,d){var u=a(e),p=o(u),m=r(u);if(i(t),0===m&&c<2)throw new s(l);var h=n?m-1:0,g=n?-1:1;if(c<2)for(;;){if(h in p){d=p[h],h+=g;break}if(h+=g,n?h<0:m<=h)throw new s(l)}for(;n?h>=0:m>h;h+=g)h in p&&(d=t(d,p[h],h,u));return d}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var i=t(4);n.exports=function(n,e){var t=[][n];return!!t&&i((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var i=t(1),a=t(18);n.exports="process"===a(i.process)},function(n,e,t){"use strict";var i=t(27),a=Function.prototype,o=a.apply,r=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(i?r.bind(o):function(){return r.apply(o,arguments)})},function(n,e,t){"use strict";var i=t(29),a=t(9),o=t(15),r=t(58),s=t(68),l=t(66),c=t(137),d=t(138),u=t(139),p=t(142),m=t(143),h=t(5),g=t(63);n.exports=function(n,e,t,f){var v=f?2:1,b=n.split("."),x=b[b.length-1],y=i.apply(null,b);if(y){var w=y.prototype;if(!g&&a(w,"cause")&&delete w.cause,!t)return y;var k=i("Error"),_=e((function(n,e){var t=u(f?e:n,void 0),i=f?new y(n):new y;return void 0!==t&&o(i,"message",t),m(i,_,i.stack,2),this&&r(w,this)&&d(i,this,_),arguments.length>v&&p(i,arguments[v]),i}));if(_.prototype=w,"Error"!==x?s?s(_,k):l(_,k,{name:!0}):h&&"stackTraceLimit"in y&&(c(_,y,"stackTraceLimit"),c(_,y,"prepareStackTrace")),l(_,y),!g)try{w.name!==x&&o(w,"name",x),w.constructor=_}catch(n){}return _}}},function(n,e,t){"use strict";var i=t(3),a=t(30);n.exports=function(n,e,t){try{return i(a(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){"use strict";var i=t(136),a=String,o=TypeError;n.exports=function(n){if(i(n))return n;throw new o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){"use strict";var i=t(7);n.exports=function(n){return i(n)||null===n}},function(n,e,t){"use strict";var i=t(17).f;n.exports=function(n,e,t){t in n||i(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var i=t(2),a=t(7),o=t(68);n.exports=function(n,e,t){var r,s;return o&&i(r=e.constructor)&&r!==t&&a(s=r.prototype)&&s!==t.prototype&&o(n,s),n}},function(n,e,t){"use strict";var i=t(102);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:i(n)}},function(n,e,t){"use strict";var i=t(141),a=t(2),o=t(18),r=t(31)("toStringTag"),s=Object,l="Arguments"===o(function(){return arguments}());n.exports=i?o:function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),r))?t:l?o(e):"Object"===(i=o(e))&&a(e.callee)?"Arguments":i}},function(n,e,t){"use strict";var i={};i[t(31)("toStringTag")]="z",n.exports="[object z]"===String(i)},function(n,e,t){"use strict";var i=t(7),a=t(15);n.exports=function(n,e){i(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){"use strict";var i=t(15),a=t(144),o=t(145),r=Error.captureStackTrace;n.exports=function(n,e,t,s){o&&(r?r(n,e):i(n,"stack",a(t,s)))}},function(n,e,t){"use strict";var i=t(3),a=Error,o=i("".replace),r=String(new a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(r);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=o(n,s,"");return n}},function(n,e,t){"use strict";var i=t(4),a=t(35);n.exports=!i((function(){var n=new Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var i=t(5),a=t(147),o=TypeError,r=Object.getOwnPropertyDescriptor,s=i&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(a(n)&&!r(n,"length").writable)throw new o("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){"use strict";var i=t(18);n.exports=Array.isArray||function(n){return"Array"===i(n)}},function(n,e,t){"use strict";var i=TypeError;n.exports=function(n){if(n>9007199254740991)throw i("Maximum allowed index exceeded");return n}},function(n,e,t){var i=t(69),a=t(150);n.exports=function n(e,t,o,r,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var d=e[l];t>0&&o(d)?t>1?n(d,t-1,o,r,s):i(s,d):r||(s[s.length]=d)}return s}},function(n,e,t){var i=t(16),a=t(39),o=t(6),r=i?i.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(r&&n&&n[r])}},function(n,e,t){var i=t(14),a=t(12);n.exports=function(n){return a(n)&&"[object Arguments]"==i(n)}},function(n,e,t){var i=t(16),a=Object.prototype,o=a.hasOwnProperty,r=a.toString,s=i?i.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var i=!0}catch(n){}var a=r.call(n);return i&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var i=t(155),a=t(211),o=t(47),r=t(6),s=t(222);n.exports=function(n){return"function"==typeof n?n:null==n?o:"object"==typeof n?r(n)?a(n[0],n[1]):i(n):s(n)}},function(n,e,t){var i=t(156),a=t(210),o=t(86);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||i(t,n,e)}}},function(n,e,t){var i=t(71),a=t(75);n.exports=function(n,e,t,o){var r=t.length,s=r,l=!o;if(null==n)return!s;for(n=Object(n);r--;){var c=t[r];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++r<s;){var d=(c=t[r])[0],u=n[d],p=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new i;if(o)var h=o(u,p,d,n,e,m);if(!(void 0===h?a(p,u,3,o,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var i=t(20),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=i(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var i=t(20);n.exports=function(n){var e=this.__data__,t=i(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var i=t(20);n.exports=function(n){return i(this.__data__,n)>-1}},function(n,e,t){var i=t(20);n.exports=function(n,e){var t=this.__data__,a=i(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var i=t(19);n.exports=function(){this.__data__=new i,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var i=t(19),a=t(40),o=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof i){var r=t.__data__;if(!a||r.length<199)return r.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(r)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var i=t(73),a=t(168),o=t(41),r=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(i(n)?p:s).test(r(n))}},function(n,e,t){var i,a=t(169),o=(i=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+i:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var i=t(8)["__core-js_shared__"];n.exports=i},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var i=t(172),a=t(19),o=t(40);n.exports=function(){this.size=0,this.__data__={hash:new i,map:new(o||a),string:new i}}},function(n,e,t){var i=t(173),a=t(174),o=t(175),r=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=r,l.prototype.set=s,n.exports=l},function(n,e,t){var i=t(21);n.exports=function(){this.__data__=i?i(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var i=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(i){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var i=t(21),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return i?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var i=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=i&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var i=t(22);n.exports=function(n){var e=i(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this,n).get(n)}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this,n).has(n)}},function(n,e,t){var i=t(22);n.exports=function(n,e){var t=i(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var i=t(71),a=t(76),o=t(187),r=t(190),s=t(206),l=t(6),c=t(80),d=t(82),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),v=l(e),b=f?"[object Array]":s(n),x=v?"[object Array]":s(e),y=(b="[object Arguments]"==b?u:b)==u,w=(x="[object Arguments]"==x?u:x)==u,k=b==x;if(k&&c(n)){if(!c(e))return!1;f=!0,y=!1}if(k&&!y)return g||(g=new i),f||d(n)?a(n,e,t,m,h,g):o(n,e,b,t,m,h,g);if(!(1&t)){var _=y&&p.call(n,"__wrapped__"),T=w&&p.call(e,"__wrapped__");if(_||T){var S=_?n.value():n,E=T?e.value():e;return g||(g=new i),h(S,E,t,m,g)}}return!!k&&(g||(g=new i),r(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length;++t<i;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var i=t(16),a=t(188),o=t(72),r=t(76),s=t(189),l=t(43),c=i?i.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,i,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&i;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;i|=2,p.set(n,e);var f=r(m(n),m(e),i,c,u,p);return p.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var i=t(8).Uint8Array;n.exports=i},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,i){t[++e]=[i,n]})),t}},function(n,e,t){var i=t(191),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,r,s){var l=1&t,c=i(n),d=c.length;if(d!=i(e).length&&!l)return!1;for(var u=d;u--;){var p=c[u];if(!(l?p in e:a.call(e,p)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++u<d;){var v=n[p=c[u]],b=e[p];if(o)var x=l?o(b,v,p,e,n,s):o(v,b,p,n,e,s);if(!(void 0===x?v===b||r(v,b,t,o,s):x)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var y=n.constructor,w=e.constructor;y==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof w&&w instanceof w||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var i=t(192),a=t(193),o=t(79);n.exports=function(n){return i(n,o,a)}},function(n,e,t){var i=t(69),a=t(6);n.exports=function(n,e,t){var o=e(n);return a(n)?o:i(o,t(n))}},function(n,e,t){var i=t(194),a=t(195),o=Object.prototype.propertyIsEnumerable,r=Object.getOwnPropertySymbols,s=r?function(n){return null==n?[]:(n=Object(n),i(r(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,a=0,o=[];++t<i;){var r=n[t];e(r,t,n)&&(o[a++]=r)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var i=t(197),a=t(39),o=t(6),r=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&a(n),u=!t&&!d&&r(n),p=!t&&!d&&!u&&l(n),m=t||d||u||p,h=m?i(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var i=t(14),a=t(44),o=t(12),r={};r["[object Float32Array]"]=r["[object Float64Array]"]=r["[object Int8Array]"]=r["[object Int16Array]"]=r["[object Int32Array]"]=r["[object Uint8Array]"]=r["[object Uint8ClampedArray]"]=r["[object Uint16Array]"]=r["[object Uint32Array]"]=!0,r["[object Arguments]"]=r["[object Array]"]=r["[object ArrayBuffer]"]=r["[object Boolean]"]=r["[object DataView]"]=r["[object Date]"]=r["[object Error]"]=r["[object Function]"]=r["[object Map]"]=r["[object Number]"]=r["[object Object]"]=r["[object RegExp]"]=r["[object Set]"]=r["[object String]"]=r["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!r[i(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var i=t(70),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,r=o&&o.exports===a&&i.process,s=function(){try{var n=o&&o.require&&o.require("util").types;return n||r&&r.binding&&r.binding("util")}catch(n){}}();n.exports=s}).call(this,t(52)(n))},function(n,e,t){var i=t(203),a=t(204),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!i(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var i=t(205)(Object.keys,Object);n.exports=i},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var i=t(207),a=t(40),o=t(208),r=t(84),s=t(209),l=t(14),c=t(74),d=c(i),u=c(a),p=c(o),m=c(r),h=c(s),g=l;(i&&"[object DataView]"!=g(new i(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||o&&"[object Promise]"!=g(o.resolve())||r&&"[object Set]"!=g(new r)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,i=t?c(t):"";if(i)switch(i){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var i=t(10)(t(8),"DataView");n.exports=i},function(n,e,t){var i=t(10)(t(8),"Promise");n.exports=i},function(n,e,t){var i=t(10)(t(8),"WeakMap");n.exports=i},function(n,e,t){var i=t(85),a=t(79);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],r=n[o];e[t]=[o,r,i(r)]}return e}},function(n,e,t){var i=t(75),a=t(212),o=t(219),r=t(45),s=t(85),l=t(86),c=t(23);n.exports=function(n,e){return r(n)&&s(e)?l(c(n),e):function(t){var r=a(t,n);return void 0===r&&r===e?o(t,n):i(e,r,3)}}},function(n,e,t){var i=t(87);n.exports=function(n,e,t){var a=null==n?void 0:i(n,e);return void 0===a?t:a}},function(n,e,t){var i=t(214),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,r=i((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,i,a){e.push(i?a.replace(o,"$1"):t||n)})),e}));n.exports=r},function(n,e,t){var i=t(215);n.exports=function(n){var e=i(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var i=t(42);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var i=arguments,a=e?e.apply(this,i):i[0],o=t.cache;if(o.has(a))return o.get(a);var r=n.apply(this,i);return t.cache=o.set(a,r)||o,r};return t.cache=new(a.Cache||i),t}a.Cache=i,n.exports=a},function(n,e,t){var i=t(217);n.exports=function(n){return null==n?"":i(n)}},function(n,e,t){var i=t(16),a=t(218),o=t(6),r=t(46),s=i?i.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(r(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,a=Array(i);++t<i;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var i=t(220),a=t(221);n.exports=function(n,e){return null!=n&&a(n,e,i)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var i=t(88),a=t(39),o=t(6),r=t(81),s=t(44),l=t(23);n.exports=function(n,e,t){for(var c=-1,d=(e=i(e,n)).length,u=!1;++c<d;){var p=l(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&s(d)&&r(p,d)&&(o(n)||a(n))}},function(n,e,t){var i=t(223),a=t(224),o=t(45),r=t(23);n.exports=function(n){return o(n)?i(r(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var i=t(87);n.exports=function(n){return function(e){return i(e,n)}}},function(n,e,t){var i=t(47),a=t(226),o=t(228);n.exports=function(n,e){return o(a(n,e,i),n+"")}},function(n,e,t){var i=t(227),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,r=-1,s=a(o.length-e,0),l=Array(s);++r<s;)l[r]=o[e+r];r=-1;for(var c=Array(e+1);++r<e;)c[r]=o[r];return c[e]=t(l),i(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var i=t(229),a=t(232)(i);n.exports=a},function(n,e,t){var i=t(230),a=t(231),o=t(47),r=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:i(e),writable:!0})}:o;n.exports=r},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var i=t(10),a=function(){try{var n=i(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,i=0;return function(){var a=t(),o=16-(a-i);if(i=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var i=t(77),a=t(234),o=t(239),r=t(78),s=t(240),l=t(43);n.exports=function(n,e,t){var c=-1,d=a,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=o;else if(u>=200){var g=e?null:s(n);if(g)return l(g);p=!1,d=r,h=new i}else h=e?[]:m;n:for(;++c<u;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(f)}else d(h,v,t)||(h!==m&&h.push(v),m.push(f))}return m}},function(n,e,t){var i=t(235);n.exports=function(n,e){return!!(null==n?0:n.length)&&i(n,e,0)>-1}},function(n,e,t){var i=t(236),a=t(237),o=t(238);n.exports=function(n,e,t){return e==e?o(n,e,t):i(n,a,t)}},function(n,e){n.exports=function(n,e,t,i){for(var a=n.length,o=t+(i?1:-1);i?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var i=t-1,a=n.length;++i<a;)if(n[i]===e)return i;return-1}},function(n,e){n.exports=function(n,e,t){for(var i=-1,a=null==n?0:n.length;++i<a;)if(t(e,n[i]))return!0;return!1}},function(n,e,t){var i=t(84),a=t(241),o=t(43),r=i&&1/o(new i([,-0]))[1]==1/0?function(n){return new i(n)}:a;n.exports=r},function(n,e){n.exports=function(){}},function(n,e,t){var i=t(83),a=t(12);n.exports=function(n){return a(n)&&i(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e){},function(n,e){function t(n,e){for(var t=0,i=n.length-1;i>=0;i--){var a=n[i];"."===a?n.splice(i,1):".."===a?(n.splice(i,1),t++):t&&(n.splice(i,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function i(n,e){if(n.filter)return n.filter(e);for(var t=[],i=0;i<n.length;i++)e(n[i],i,n)&&t.push(n[i]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var o=a>=0?arguments[a]:process.cwd();if("string"!=typeof o)throw new TypeError("Arguments to path.resolve must be strings");o&&(n=o+"/"+n,e="/"===o.charAt(0))}return(e?"/":"")+(n=t(i(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var o=e.isAbsolute(n),r="/"===a(n,-1);return(n=t(i(n.split("/"),(function(n){return!!n})),!o).join("/"))||o||(n="."),n&&r&&(n+="/"),(o?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(i(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function i(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=i(n.split("/")),o=i(t.split("/")),r=Math.min(a.length,o.length),s=r,l=0;l<r;l++)if(a[l]!==o[l]){s=l;break}var c=[];for(l=s;l<a.length;l++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,i=-1,a=!0,o=n.length-1;o>=1;--o)if(47===(e=n.charCodeAt(o))){if(!a){i=o;break}}else a=!1;return-1===i?t?"/":".":t&&1===i?"/":n.slice(0,i)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,i=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===i&&(a=!1,i=e+1);return-1===i?"":n.slice(t,i)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,i=-1,a=!0,o=0,r=n.length-1;r>=0;--r){var s=n.charCodeAt(r);if(47!==s)-1===i&&(a=!1,i=r+1),46===s?-1===e?e=r:1!==o&&(o=1):-1!==e&&(o=-1);else if(!a){t=r+1;break}}return-1===e||-1===i||0===o||1===o&&e===i-1&&e===t+1?"":n.slice(e,i)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var i=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(i,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},o=/[&<>'"]/g;function r(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(o,r)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var i=0;i<t.length;i++){var a=t[i];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var i=Object.freeze({}),a=Array.isArray;function o(n){return null==n}function r(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return r(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,v,2):String(n)}function v(n,e){return e&&e.__v_isRef?e.value:e}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function x(n,e){for(var t=Object.create(null),i=n.split(","),a=0;a<i.length;a++)t[i[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}x("slot,component",!0);var y=x("key,ref,slot,slot-scope,is");function w(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var i=n.indexOf(e);if(i>-1)return n.splice(i,1)}}var k=Object.prototype.hasOwnProperty;function _(n,e){return k.call(n,e)}function T(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,E=T((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),j=T((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,C=T((function(n){return n.replace(I,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function P(n,e){for(var t in e)n[t]=e[t];return n}function D(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function $(n,e,t){}var B=function(n,e,t){return!1},M=function(n){return n};function L(n,e){if(n===e)return!0;var t=d(n),i=d(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return L(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var r=Object.keys(n),s=Object.keys(e);return r.length===s.length&&r.every((function(t){return L(n[t],e[t])}))}catch(n){return!1}}function O(n,e){for(var t=0;t<n.length;t++)if(L(n[t],e))return t;return-1}function N(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function F(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var H=["component","directive","filter"],G=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],V={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:$,parsePlatformTagName:M,mustUseProp:B,async:!0,_lifecycleHooks:G},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function J(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var R=new RegExp("[^".concat(q.source,".$_\\d]"));var W="__proto__"in{},K="undefined"!=typeof window,Z=K&&window.navigator.userAgent.toLowerCase(),Y=Z&&/msie|trident/.test(Z),Q=Z&&Z.indexOf("msie 9.0")>0,X=Z&&Z.indexOf("edge/")>0;Z&&Z.indexOf("android");var nn=Z&&/iphone|ipad|ipod|ios/.test(Z);Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z);var en,tn=Z&&Z.match(/firefox\/(\d+)/),an={}.watch,on=!1;if(K)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){on=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var sn=function(){return void 0===en&&(en=!K&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),en},ln=K&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function cn(n){return"function"==typeof n&&/native code/.test(n.toString())}var dn,un="undefined"!=typeof Symbol&&cn(Symbol)&&"undefined"!=typeof Reflect&&cn(Reflect.ownKeys);dn="undefined"!=typeof Set&&cn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=null;function mn(n){void 0===n&&(n=null),n||pn&&pn._scope.off(),pn=n,n&&n._scope.on()}var hn=function(){function n(n,e,t,i,a,o,r,s){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new hn;return e.text=n,e.isComment=!0,e};function fn(n){return new hn(void 0,void 0,void 0,String(n))}function vn(n){var e=new hn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}"function"==typeof SuppressedError&&SuppressedError;var bn=0,xn=[],yn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,xn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,i=e.length;t<i;t++){0,e[t].update()}},n}();yn.target=null;var wn=[];function kn(n){wn.push(n),yn.target=n}function _n(){wn.pop(),yn.target=wn[wn.length-1]}var Tn=Array.prototype,Sn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];J(Sn,n,(function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];var a,o=e.apply(this,t),r=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&r.observeArray(a),r.dep.notify(),o}))}));var En=Object.getOwnPropertyNames(Sn),jn={},In=!0;function Cn(n){In=n}var zn={notify:$,depend:$,addSub:$,removeSub:$},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new yn,this.vmCount=0,J(n,"__ob__",this),a(n)){if(!t)if(W)n.__proto__=Sn;else for(var i=0,o=En.length;i<o;i++){J(n,s=En[i],Sn[s])}e||this.observeArray(n)}else{var r=Object.keys(n);for(i=0;i<r.length;i++){var s;Dn(n,s=r[i],jn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&_(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!In||!t&&sn()||!a(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Fn(n)||n instanceof hn?void 0:new An(n,e,t)}function Dn(n,e,t,i,o,r,s){void 0===s&&(s=!1);var l=new yn,c=Object.getOwnPropertyDescriptor(n,e);if(!c||!1!==c.configurable){var d=c&&c.get,u=c&&c.set;d&&!u||t!==jn&&2!==arguments.length||(t=n[e]);var p=o?t&&t.__ob__:Pn(t,!1,r);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=d?d.call(n):t;return yn.target&&(l.depend(),p&&(p.dep.depend(),a(e)&&Mn(e))),Fn(e)&&!o?e.value:e},set:function(e){var i=d?d.call(n):t;if(F(i,e)){if(u)u.call(n,e);else{if(d)return;if(!o&&Fn(i)&&!Fn(e))return void(i.value=e);t=e}p=o?e&&e.__ob__:Pn(e,!1,r),l.notify()}}}),l}}function $n(n,e,t){if(!Nn(n)){var i=n.__ob__;return a(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),i&&!i.shallow&&i.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||i&&i.vmCount?t:i?(Dn(i.value,e,t,void 0,i.shallow,i.mock),i.dep.notify(),t):(n[e]=t,t)}}function Bn(n,e){if(a(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Nn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function Mn(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),a(e)&&Mn(e)}function Ln(n){return On(n,!0),J(n,"__v_isShallow",!0),n}function On(n,e){if(!Nn(n)){Pn(n,e,sn());0}}function Nn(n){return!(!n||!n.__v_isReadonly)}function Fn(n){return!(!n||!0!==n.__v_isRef)}function Hn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Fn(n))return n.value;var i=n&&n.__ob__;return i&&i.dep.depend(),n},set:function(n){var i=e[t];Fn(i)&&!Fn(n)?i.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Gn;var Vn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Gn,!n&&Gn&&(this.index=(Gn.scopes||(Gn.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Gn;try{return Gn=this,n()}finally{Gn=e}}else 0},n.prototype.on=function(){Gn=this},n.prototype.off=function(){Gn=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}},n}();function qn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Un=T((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function Jn(n,e){function t(){var n=t.fns;if(!a(n))return Ie(n,null,arguments,e,"v-on handler");for(var i=n.slice(),o=0;o<i.length;o++)Ie(i[o],null,arguments,e,"v-on handler")}return t.fns=n,t}function Rn(n,e,t,i,a,r){var l,c,d,u;for(l in n)c=n[l],d=e[l],u=Un(l),o(c)||(o(d)?(o(c.fns)&&(c=n[l]=Jn(c,r)),s(u.once)&&(c=n[l]=a(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)o(n[l])&&i((u=Un(l)).name,e[l],u.capture)}function Wn(n,e,t){var i;n instanceof hn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),w(i.fns,l)}o(a)?i=Jn([l]):r(a.fns)&&s(a.merged)?(i=a).fns.push(l):i=Jn([a,l]),i.merged=!0,n[e]=i}function Kn(n,e,t,i,a){if(r(e)){if(_(e,t))return n[t]=e[t],a||delete e[t],!0;if(_(e,i))return n[t]=e[i],a||delete e[i],!0}return!1}function Zn(n){return l(n)?[fn(n)]:a(n)?function n(e,t){var i,c,d,u,p=[];for(i=0;i<e.length;i++)o(c=e[i])||"boolean"==typeof c||(d=p.length-1,u=p[d],a(c)?c.length>0&&(Yn((c=n(c,"".concat(t||"","_").concat(i)))[0])&&Yn(u)&&(p[d]=fn(u.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Yn(u)?p[d]=fn(u.text+c):""!==c&&p.push(fn(c)):Yn(c)&&Yn(u)?p[d]=fn(u.text+c.text):(s(e._isVList)&&r(c.tag)&&o(c.key)&&r(t)&&(c.key="__vlist".concat(t,"_").concat(i,"__")),p.push(c)));return p}(n):void 0}function Yn(n){return r(n)&&r(n.text)&&!1===n.isComment}function Qn(n,e){var t,i,o,s,l=null;if(a(n)||"string"==typeof n)for(l=new Array(n.length),t=0,i=n.length;t<i;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(un&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)l.push(e(u.value,l.length)),u=c.next()}else for(o=Object.keys(n),l=new Array(o.length),t=0,i=o.length;t<i;t++)s=o[t],l[t]=e(n[s],s,t);return r(l)||(l=[]),l._isVList=!0,l}function Xn(n,e,t,i){var a,o=this.$scopedSlots[n];o?(t=t||{},i&&(t=P(P({},i),t)),a=o(t)||(c(e)?e():e)):a=this.$slots[n]||(c(e)?e():e);var r=t&&t.slot;return r?this.$createElement("template",{slot:r},a):a}function ne(n){return At(this.$options,"filters",n,!0)||M}function ee(n,e){return a(n)?-1===n.indexOf(e):n!==e}function te(n,e,t,i,a){var o=V.keyCodes[e]||t;return a&&i&&!V.keyCodes[e]?ee(a,i):o?ee(o,n):i?C(i)!==e:void 0===n}function ie(n,e,t,i,o){if(t)if(d(t)){a(t)&&(t=D(t));var r=void 0,s=function(a){if("class"===a||"style"===a||y(a))r=n;else{var s=n.attrs&&n.attrs.type;r=i||V.mustUseProp(e,s,a)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=E(a),c=C(a);l in r||c in r||(r[a]=t[a],o&&((n.on||(n.on={}))["update:".concat(a)]=function(n){t[a]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e||re(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),i}function oe(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(a(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&se(n[i],"".concat(e,"_").concat(i),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function le(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var i in e){var a=t[i],o=e[i];t[i]=a?[].concat(a,o):o}}else;return n}function ce(n,e,t,i){e=e||{$stable:!t};for(var o=0;o<n.length;o++){var r=n[o];a(r)?ce(r,e,t):r&&(r.proxy&&(r.fn.proxy=!0),e[r.key]=r.fn)}return i&&(e.$key=i),e}function de(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function ue(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=oe,n._n=b,n._s=f,n._l=Qn,n._t=Xn,n._q=L,n._i=O,n._m=ae,n._f=ne,n._k=te,n._b=ie,n._v=fn,n._e=gn,n._u=ce,n._g=le,n._d=de,n._p=ue}function me(n,e){if(!n||!n.length)return{};for(var t={},i=0,a=n.length;i<a;i++){var o=n[i],r=o.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,o.context!==e&&o.fnContext!==e||!r||null==r.slot)(t.default||(t.default=[])).push(o);else{var s=r.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(he)&&delete t[c];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,a){var o,r=Object.keys(t).length>0,s=e?!!e.$stable:!r,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&a&&a!==i&&l===a.$key&&!r&&!a.$hasNormal)return a;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=ve(n,t,c,e[c]))}else o={};for(var d in t)d in o||(o[d]=be(t,d));return e&&Object.isExtensible(e)&&(e._normalized=o),J(o,"$stable",s),J(o,"$key",l),J(o,"$hasNormal",r),o}function ve(n,e,t,i){var o=function(){var e=pn;mn(n);var t=arguments.length?i.apply(null,arguments):i({}),o=(t=t&&"object"==typeof t&&!a(t)?[t]:Zn(t))&&t[0];return mn(e),t&&(!o||1===t.length&&o.isComment&&!ge(o))?void 0:t};return i.proxy&&Object.defineProperty(e,t,{get:o,enumerable:!0,configurable:!0}),o}function be(n,e){return function(){return n[e]}}function xe(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};J(e,"_v_attr_proxy",!0),ye(e,n.$attrs,i,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,i,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Hn(n,e,t)}))}}}function ye(n,e,t,i,a){var o=!1;for(var r in e)r in n?e[r]!==t[r]&&(o=!0):(o=!0,we(n,r,i,a));for(var r in n)r in e||(o=!0,delete n[r]);return o}function we(n,e,t,i){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[i][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function Te(n,e){return(n.__esModule||un&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Se(n){if(a(n))for(var e=0;e<n.length;e++){var t=n[e];if(r(t)&&(r(t.componentOptions)||ge(t)))return t}}function Ee(n,e,t,i,u,p){return(a(t)||l(t))&&(u=i,i=t,t=void 0),s(p)&&(u=2),function(n,e,t,i,l){if(r(t)&&r(t.__ob__))return gn();r(t)&&r(t.is)&&(e=t.is);if(!e)return gn();0;a(i)&&c(i[0])&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===l?i=Zn(i):1===l&&(i=function(n){for(var e=0;e<n.length;e++)if(a(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||V.getTagNamespace(e),u=V.isReservedTag(e)?new hn(V.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!r(m=At(n.$options,"components",e))?new hn(e,t,i,void 0,void 0,n):wt(m,t,n,i,e)}else u=wt(e,t,n,i);return a(u)?u:r(u)?(r(p)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(r(e.children))for(var a=0,l=e.children.length;a<l;a++){var c=e.children[a];r(c.tag)&&(o(c.ns)||s(i)&&"svg"!==c.tag)&&n(c,t,i)}}(u,p),r(t)&&function(n){d(n.style)&&Ve(n.style);d(n.class)&&Ve(n.class)}(t),u):gn()}(n,e,t,i,u)}function je(n,e,t){kn();try{if(e)for(var i=e;i=i.$parent;){var a=i.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(i,n,e,t))return}catch(n){Ce(n,i,"errorCaptured hook")}}Ce(n,e,t)}finally{_n()}}function Ie(n,e,t,i,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&g(o)&&!o._handled&&(o.catch((function(n){return je(n,i,a+" (Promise/async)")})),o._handled=!0)}catch(n){je(n,i,a)}return o}function Ce(n,e,t){if(V.errorHandler)try{return V.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!K||"undefined"==typeof console)throw n;console.error(n)}var Ae,Pe=!1,De=[],$e=!1;function Be(){$e=!1;var n=De.slice(0);De.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&cn(Promise)){var Me=Promise.resolve();Ae=function(){Me.then(Be),nn&&setTimeout($)},Pe=!0}else if(Y||"undefined"==typeof MutationObserver||!cn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&cn(setImmediate)?function(){setImmediate(Be)}:function(){setTimeout(Be,0)};else{var Le=1,Oe=new MutationObserver(Be),Ne=document.createTextNode(String(Le));Oe.observe(Ne,{characterData:!0}),Ae=function(){Le=(Le+1)%2,Ne.data=String(Le)},Pe=!0}function Fe(n,e){var t;if(De.push((function(){if(n)try{n.call(e)}catch(n){je(n,e,"nextTick")}else t&&t(e)})),$e||($e=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function He(n){return function(e,t){if(void 0===t&&(t=pn),t)return function(n,e,t){var i=n.$options;i[e]=jt(i[e],t)}(t,n,e)}}He("beforeMount"),He("mounted"),He("beforeUpdate"),He("updated"),He("beforeDestroy"),He("destroyed"),He("activated"),He("deactivated"),He("serverPrefetch"),He("renderTracked"),He("renderTriggered"),He("errorCaptured");var Ge=new dn;function Ve(n){return function n(e,t){var i,o,r=a(e);if(!r&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof hn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(r)for(i=e.length;i--;)n(e[i],t);else if(Fn(e))n(e.value,t);else for(o=Object.keys(e),i=o.length;i--;)n(e[o[i]],t)}(n,Ge),Ge.clear(),n}var qe,Ue=0,Je=function(){function n(n,e,t,i,a){var o,r;o=this,void 0===(r=Gn&&!Gn._vm?Gn:n?n._scope:void 0)&&(r=Gn),r&&r.active&&r.effects.push(o),(this.vm=n)&&a&&(n._watcher=this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ue,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new dn,this.newDepIds=new dn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!R.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=$)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;je(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ve(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&w(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Re(n,e){qe.$on(n,e)}function We(n,e){qe.$off(n,e)}function Ke(n,e){var t=qe;return function i(){var a=e.apply(null,arguments);null!==a&&t.$off(n,i)}}function Ze(n,e,t){qe=n,Rn(e,t||{},Re,We,Ke,n),qe=void 0}var Ye=null;function Qe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e,t,i){void 0===i&&(i=!0),kn();var a=pn,o=Gn;i&&mn(n);var r=n.$options[e],s="".concat(e," hook");if(r)for(var l=0,c=r.length;l<c;l++)Ie(r[l],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),i&&(mn(a),o&&o.on()),_n()}var tt=[],it=[],at={},ot=!1,rt=!1,st=0;var lt=0,ct=Date.now;if(K&&!Y){var dt=window.performance;dt&&"function"==typeof dt.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return dt.now()})}var ut=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(lt=ct(),rt=!0,tt.sort(ut),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=it.slice(),i=tt.slice();st=tt.length=it.length=0,at={},ot=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i&&i._watcher===t&&i._isMounted&&!i._isDestroyed&&et(i,"updated")}}(i),function(){for(var n=0;n<xn.length;n++){var e=xn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}xn.length=0}(),ln&&V.devtools&&ln.emit("flush")}function mt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,rt){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);ot||(ot=!0,Fe(pt))}}function ht(n,e){if(n){for(var t=Object.create(null),i=un?Reflect.ownKeys(n):Object.keys(n),a=0;a<i.length;a++){var o=i[a];if("__ob__"!==o){var r=n[o].from;if(r in e._provided)t[o]=e._provided[r];else if("default"in n[o]){var s=n[o].default;t[o]=c(s)?s.call(e):s}else 0}}return t}}function gt(n,e,t,o,r){var l,c=this,d=r.options;_(o,"_uid")?(l=Object.create(o))._original=o:(l=o,o=o._original);var u=s(d._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||i,this.injections=ht(d.inject,o),this.slots=function(){return c.$slots||fe(o,n.scopedSlots,c.$slots=me(t,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(o,n.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=fe(o,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,i){var r=Ee(l,n,e,t,i,p);return r&&!a(r)&&(r.fnScopeId=d._scopeId,r.fnContext=o),r}:this._c=function(n,e,t,i){return Ee(l,n,e,t,i,p)}}function ft(n,e,t,i,a){var o=vn(n);return o.fnContext=t,o.fnOptions=i,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function vt(n,e){for(var t in e)n[E(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}pe(gt.prototype);var xt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;xt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;r(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,o){var r=a.data.scopedSlots,s=n.$scopedSlots,l=!!(r&&!r.$stable||s!==i&&!s.$stable||r&&n.$scopedSlots.$key!==r.$key||!r&&n.$scopedSlots.$key),c=!!(o||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a),n.$options._renderChildren=o;var u=a.data.attrs||i;n._attrsProxy&&ye(n._attrsProxy,u,d.data&&d.data.attrs||i,n,"$attrs")&&(c=!0),n.$attrs=u,t=t||i;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||i,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ze(n,t,p),e&&n.$options.props){Cn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],v=n.$options.props;m[f]=Pt(f,v,e,n)}Cn(!0),n.$options.propsData=e}c&&(n.$slots=me(o,a.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,et(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,it.push(e)):nt(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Xe(e))||e._inactive)){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);et(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(xt);function wt(n,e,t,l,c){if(!o(n)){var u=t.$options._base;if(d(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(o(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&r(n.errorComp))return n.errorComp;if(r(n.resolved))return n.resolved;var t=_e;if(t&&r(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&r(n.loadingComp))return n.loadingComp;if(t&&!r(n.owners)){var i=n.owners=[t],a=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return w(i,t)}));var u=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=N((function(t){n.resolved=Te(t,e),a?i.length=0:u(!0)})),m=N((function(e){r(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return d(h)&&(g(h)?o(n.resolved)&&h.then(p,m):g(h.component)&&(h.component.then(p,m),r(h.error)&&(n.errorComp=Te(h.error,e)),r(h.loading)&&(n.loadingComp=Te(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),r(h.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&m(null)}),h.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,i,a){var o=gn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:i,tag:a},o}(p,e,t,l,c);e=e||{},Jt(n),r(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var o=e.on||(e.on={}),s=o[i],l=e.model.callback;r(s)?(a(s)?-1===s.indexOf(l):s!==l)&&(o[i]=[l].concat(s)):o[i]=l}(n.options,e);var m=function(n,e,t){var i=e.options.props;if(!o(i)){var a={},s=n.attrs,l=n.props;if(r(s)||r(l))for(var c in i){var d=C(c);Kn(a,l,c,d,!0)||Kn(a,s,c,d,!1)}return a}}(e,n);if(s(n.options.functional))return function(n,e,t,o,s){var l=n.options,c={},d=l.props;if(r(d))for(var u in d)c[u]=Pt(u,d,e||i);else r(t.attrs)&&vt(c,t.attrs),r(t.props)&&vt(c,t.props);var p=new gt(t,c,s,o,n),m=l.render.call(null,p._c,p);if(m instanceof hn)return ft(m,t,p.parent,l,p);if(a(m)){for(var h=Zn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=ft(h[f],t,p.parent,l,p);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var i=yt[t],a=e[i],o=xt[i];a===o||a&&a._merged||(e[i]=a?kt(o,a):o)}}(e);var v=bt(n.options)||c;return new hn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}var _t=$,Tt=V.optionMergeStrategies;function St(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var i,a,o,r=un?Reflect.ownKeys(e):Object.keys(e),s=0;s<r.length;s++)"__ob__"!==(i=r[s])&&(a=n[i],o=e[i],t&&_(n,i)?a!==o&&p(a)&&p(o)&&St(a,o):$n(n,i,o));return n}function Et(n,e,t){return t?function(){var i=c(e)?e.call(t,t):e,a=c(n)?n.call(t,t):n;return i?St(i,a):a}:e?n?function(){return St(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function jt(n,e){var t=e?n?n.concat(e):a(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,i){var a=Object.create(n||null);return e?P(a,e):a}Tt.data=function(n,e,t){return t?Et(n,e,t):e&&"function"!=typeof e?n:Et(n,e)},G.forEach((function(n){Tt[n]=jt})),H.forEach((function(n){Tt[n+"s"]=It})),Tt.watch=function(n,e,t,i){if(n===an&&(n=void 0),e===an&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var o={};for(var r in P(o,n),e){var s=o[r],l=e[r];s&&!a(s)&&(s=[s]),o[r]=s?s.concat(l):a(l)?l:[l]}return o},Tt.props=Tt.methods=Tt.inject=Tt.computed=function(n,e,t,i){if(!n)return e;var a=Object.create(null);return P(a,n),e&&P(a,e),a},Tt.provide=function(n,e){return n?function(){var t=Object.create(null);return St(t,c(n)?n.call(this):n),e&&St(t,c(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var i,o,r={};if(a(t))for(i=t.length;i--;)"string"==typeof(o=t[i])&&(r[E(o)]={type:null});else if(p(t))for(var s in t)o=t[s],r[E(s)]=p(o)?o:{type:o};else 0;n.props=r}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(a(t))for(var o=0;o<t.length;o++)i[t[o]]={from:t[o]};else if(p(t))for(var r in t){var s=t[r];i[r]=p(s)?P({from:r},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];c(i)&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var i=0,o=e.mixins.length;i<o;i++)n=zt(n,e.mixins[i],t);var r,s={};for(r in n)l(r);for(r in e)_(n,r)||l(r);function l(i){var a=Tt[i]||Ct;s[i]=a(n[i],e[i],t,i)}return s}function At(n,e,t,i){if("string"==typeof t){var a=n[e];if(_(a,t))return a[t];var o=E(t);if(_(a,o))return a[o];var r=j(o);return _(a,r)?a[r]:a[t]||a[o]||a[r]}}function Pt(n,e,t,i){var a=e[n],o=!_(t,n),r=t[n],s=Mt(Boolean,a.type);if(s>-1)if(o&&!_(a,"default"))r=!1;else if(""===r||r===C(n)){var l=Mt(String,a.type);(l<0||s<l)&&(r=!0)}if(void 0===r){r=function(n,e,t){if(!_(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(i)&&"Function"!==$t(e.type)?i.call(n):i}(i,a,n);var d=In;Cn(!0),Pn(r),Cn(d)}return r}var Dt=/^\s*function (\w+)/;function $t(n){var e=n&&n.toString().match(Dt);return e?e[1]:""}function Bt(n,e){return $t(n)===$t(e)}function Mt(n,e){if(!a(e))return Bt(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Bt(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:$,set:$};function Ot(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Nt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props=Ln({}),a=n.$options._propKeys=[];n.$parent&&Cn(!1);var o=function(o){a.push(o);var r=Pt(o,e,t,n);Dn(i,o,r,void 0,!0),o in n||Ot(n,"_props",o)};for(var r in e)o(r);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var i=n._setupContext=xe(n);mn(n),kn();var a=Ie(t,null,[n._props||Ln({}),i],n,"setup");if(_n(),mn(),c(a))e.render=a;else if(d(a))if(n._setupState=a,a.__sfc){var o=n._setupProxy={};for(var r in a)"__sfc"!==r&&Hn(o,a,r)}else for(var r in a)U(r)||Hn(n,a,r);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?$:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return je(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,i&&_(i,o)||U(o)||Ot(n,"_data",o)}var r=Pn(e);r&&r.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=sn();for(var a in e){var o=e[a],r=c(o)?o:o.get;0,i||(t[a]=new Je(n,r||$,$,Ft)),a in n||Ht(n,a,o)}}(n,e.computed),e.watch&&e.watch!==an&&function(n,e){for(var t in e){var i=e[t];if(a(i))for(var o=0;o<i.length;o++)qt(n,t,i[o]);else qt(n,t,i)}}(n,e.watch)}var Ft={lazy:!0};function Ht(n,e,t){var i=!sn();c(t)?(Lt.get=i?Gt(e):Vt(t),Lt.set=$):(Lt.get=t.get?i&&!1!==t.cache?Gt(e):Vt(t.get):$,Lt.set=t.set||$),Object.defineProperty(n,e,Lt)}function Gt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Vt(n){return function(){return n.call(this,this)}}function qt(n,e,t,i){return p(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var Ut=0;function Jt(n){var e=n.options;if(n.super){var t=Jt(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var a in t)t[a]!==i[a]&&(e||(e={}),e[a]=t[a]);return e}(n);i&&P(n.extendOptions,i),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Rt(n){this._init(n)}function Wt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,a=n._Ctor||(n._Ctor={});if(a[i])return a[i];var o=bt(n)||bt(t.options);var r=function(n){this._init(n)};return(r.prototype=Object.create(t.prototype)).constructor=r,r.cid=e++,r.options=zt(t.options,n),r.super=t,r.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(r),r.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ht(n.prototype,t,e[t])}(r),r.extend=t.extend,r.mixin=t.mixin,r.use=t.use,H.forEach((function(n){r[n]=t[n]})),o&&(r.options.components[o]=r),r.superOptions=t.options,r.extendOptions=n,r.sealedOptions=P({},r.options),a[i]=r,r}}function Kt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Zt(n,e){return a(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Yt(n,e){var t=n.cache,i=n.keys,a=n._vnode,o=n.$vnode;for(var r in t){var s=t[r];if(s){var l=s.name;l&&!e(l)&&Qt(t,r,i,a)}}o.componentOptions.children=void 0}function Qt(n,e,t,i){var a=n[e];!a||i&&a.tag===i.tag||a.componentInstance.$destroy(),n[e]=null,w(t,e)}Rt.prototype._init=function(n){var e=this;e._uid=Ut++,e._isVue=!0,e.__v_skip=!0,e._scope=new Vn(!0),e._scope.parent=void 0,e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var a=i.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt(Jt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=me(e._renderChildren,a),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):i,n._c=function(e,t,i,a){return Ee(n,e,t,i,a,!1)},n.$createElement=function(e,t,i,a){return Ee(n,e,t,i,a,!0)};var o=t&&t.data;Dn(n,"$attrs",o&&o.attrs||i,null,!0),Dn(n,"$listeners",e._parentListeners||i,null,!0)}(e),et(e,"beforeCreate",void 0,!1),function(n){var e=ht(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){Dn(n,t,e[t])})),Cn(!0))}(e),Nt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var i=qn(n),a=un?Reflect.ownKeys(t):Object.keys(t),o=0;o<a.length;o++){var r=a[o];Object.defineProperty(i,r,Object.getOwnPropertyDescriptor(t,r))}}}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=$n,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(p(e))return qt(this,n,e,t);(t=t||{}).user=!0;var i=new Je(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'.concat(i.expression,'"');kn(),Ie(e,this,[i.value],this,a),_n()}return function(){i.teardown()}}}(Rt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(a(n))for(var o=0,r=n.length;o<r;o++)i.$on(n[o],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(a(n)){for(var i=0,o=n.length;i<o;i++)t.$off(n[i],e);return t}var r,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((r=s[l])===e||r.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var i=A(arguments,1),a='event handler for "'.concat(n,'"'),o=0,r=t.length;o<r;o++)Ie(t[o],e,i,e,a)}return e}}(Rt),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,a=t._vnode,o=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var r=t;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||w(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Rt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Fe(n,this)},n.prototype._render=function(){var n=this,e=n.$options,t=e.render,i=e._parentVnode;i&&n._isMounted&&(n.$scopedSlots=fe(n.$parent,i.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&ke(n._slotsProxy,n.$scopedSlots)),n.$vnode=i;var o,r=pn,s=_e;try{mn(n),_e=n,o=t.call(n._renderProxy,n.$createElement)}catch(e){je(e,n,"render"),o=n._vnode}finally{_e=s,mn(r)}return a(o)&&1===o.length&&(o=o[0]),o instanceof hn||(o=gn()),o.parent=i,o}}(Rt);var Xt=[String,RegExp,Array],ni={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Xt,exclude:Xt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,i=this.keyToCache;if(t){var a=t.tag,o=t.componentInstance,r=t.componentOptions;n[i]={name:Kt(r),tag:a,componentInstance:o},e.push(i),this.max&&e.length>parseInt(this.max)&&Qt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Yt(n,(function(n){return Zt(e,n)}))})),this.$watch("exclude",(function(e){Yt(n,(function(n){return!Zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Se(n),t=e&&e.componentOptions;if(t){var i=Kt(t),a=this.include,o=this.exclude;if(a&&(!i||!Zt(a,i))||o&&i&&Zt(o,i))return e;var r=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;r[l]?(e.componentInstance=r[l].componentInstance,w(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return V}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:P,mergeOptions:zt,defineReactive:Dn},n.set=$n,n.delete=Bn,n.nextTick=Fe,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),H.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,ni),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Wt(n),function(n){H.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Rt),Object.defineProperty(Rt.prototype,"$isServer",{get:sn}),Object.defineProperty(Rt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Rt,"FunctionalRenderContext",{value:gt}),Rt.version="2.7.16";var ei=x("style,class"),ti=x("input,textarea,option,select,progress"),ii=x("contenteditable,draggable,spellcheck"),ai=x("events,caret,typing,plaintext-only"),oi=x("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ri="http://www.w3.org/1999/xlink",si=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},li=function(n){return si(n)?n.slice(6,n.length):""},ci=function(n){return null==n||!1===n};function di(n){for(var e=n.data,t=n,i=n;r(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=ui(i.data,e));for(;r(t=t.parent);)t&&t.data&&(e=ui(e,t.data));return function(n,e){if(r(n)||r(e))return pi(n,mi(e));return""}(e.staticClass,e.class)}function ui(n,e){return{staticClass:pi(n.staticClass,e.staticClass),class:r(n.class)?[n.class,e.class]:e.class}}function pi(n,e){return n?e?n+" "+e:n:e||""}function mi(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,a=n.length;i<a;i++)r(e=mi(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var hi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},gi=x("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fi=x("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vi=function(n){return gi(n)||fi(n)};var bi=Object.create(null);var xi=x("text,number,password,search,email,tel,url");var yi=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(hi[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),wi={create:function(n,e){ki(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ki(n,!0),ki(e))},destroy:function(n){ki(n,!0)}};function ki(n,e){var t=n.data.ref;if(r(t)){var i=n.context,o=n.componentInstance||n.elm,s=e?null:o,l=e?void 0:o;if(c(t))Ie(t,i,[s],i,"template ref function");else{var d=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Fn(t),m=i.$refs;if(u||p)if(d){var h=u?m[t]:t.value;e?a(h)&&w(h,o):a(h)?h.includes(o)||h.push(o):u?(m[t]=[o],_i(i,t,m[t])):t.value=[o]}else if(u){if(e&&m[t]!==o)return;m[t]=l,_i(i,t,s)}else if(p){if(e&&t.value!==o)return;t.value=s}else 0}}}function _i(n,e,t){var i=n._setupState;i&&_(i,e)&&(Fn(i[e])?i[e].value=t:i[e]=t)}var Ti=new hn("",{},[]),Si=["create","activate","update","remove","destroy"];function Ei(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&r(n.data)===r(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=r(t=n.data)&&r(t=t.attrs)&&t.type,a=r(t=e.data)&&r(t=t.attrs)&&t.type;return i===a||xi(i)&&xi(a)}(n,e)||s(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function ji(n,e,t){var i,a,o={};for(i=e;i<=t;++i)r(a=n[i].key)&&(o[a]=i);return o}var Ii={create:Ci,update:Ci,destroy:function(n){Ci(n,Ti)}};function Ci(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,a,o=n===Ti,r=e===Ti,s=Ai(n.data.directives,n.context),l=Ai(e.data.directives,e.context),c=[],d=[];for(t in l)i=s[t],a=l[t],i?(a.oldValue=i.value,a.oldArg=i.arg,Di(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(Di(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var u=function(){for(var t=0;t<c.length;t++)Di(c[t],"inserted",e,n)};o?Wn(e,"insert",u):u()}d.length&&Wn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)Di(d[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||Di(s[t],"unbind",n,n,r)}(n,e)}var zi=Object.create(null);function Ai(n,e){var t,i,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++){if((i=n[t]).modifiers||(i.modifiers=zi),a[Pi(i)]=i,e._setupState&&e._setupState.__sfc){var o=i.def||At(e,"_setupState","v-"+i.name);i.def="function"==typeof o?{bind:o,update:o}:o}i.def=i.def||At(e.$options,"directives",i.name)}return a}function Pi(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Di(n,e,t,i,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,i,a)}catch(i){je(i,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var $i=[wi,Ii];function Bi(n,e){var t=e.componentOptions;if(!(r(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var i,a,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(i in(r(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)a=d[i],c[i]!==a&&Mi(l,i,a,e.data.pre);for(i in(Y||X)&&d.value!==c.value&&Mi(l,"value",d.value),c)o(d[i])&&(si(i)?l.removeAttributeNS(ri,li(i)):ii(i)||l.removeAttribute(i))}}function Mi(n,e,t,i){i||n.tagName.indexOf("-")>-1?Li(n,e,t):oi(e)?ci(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ii(e)?n.setAttribute(e,function(n,e){return ci(e)||"false"===e?"false":"contenteditable"===n&&ai(e)?e:"true"}(e,t)):si(e)?ci(t)?n.removeAttributeNS(ri,li(e)):n.setAttributeNS(ri,e,t):Li(n,e,t)}function Li(n,e,t){if(ci(t))n.removeAttribute(e);else{if(Y&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var Oi={create:Bi,update:Bi};function Ni(n,e){var t=e.elm,i=e.data,a=n.data;if(!(o(i.staticClass)&&o(i.class)&&(o(a)||o(a.staticClass)&&o(a.class)))){var s=di(e),l=t._transitionClasses;r(l)&&(s=pi(s,mi(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Fi,Hi={create:Ni,update:Ni};function Gi(n,e,t){var i=Fi;return function a(){var o=e.apply(null,arguments);null!==o&&Ui(n,a,t,i)}}var Vi=Pe&&!(tn&&Number(tn[1])<=53);function qi(n,e,t,i){if(Vi){var a=lt,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}Fi.addEventListener(n,e,on?{capture:t,passive:i}:t)}function Ui(n,e,t,i){(i||Fi).removeEventListener(n,e._wrapper||e,t)}function Ji(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},i=n.data.on||{};Fi=e.elm||n.elm,function(n){if(r(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}r(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Rn(t,i,qi,Ui,Gi,e.context),Fi=void 0}}var Ri,Wi={create:Ji,update:Ji,destroy:function(n){return Ji(n,Ti)}};function Ki(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,i,a=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(r(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(a[t]="");for(t in c){if(i=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=i;var d=o(i)?"":String(i);Zi(a,d)&&(a.value=d)}else if("innerHTML"===t&&fi(a.tagName)&&o(a.innerHTML)){(Ri=Ri||document.createElement("div")).innerHTML="<svg>".concat(i,"</svg>");for(var u=Ri.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;u.firstChild;)a.appendChild(u.firstChild)}else if(i!==l[t])try{a[t]=i}catch(n){}}}}function Zi(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(r(i)){if(i.number)return b(t)!==b(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Yi={create:Ki,update:Ki},Qi=T((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Xi(n){var e=na(n.style);return n.staticStyle?P(n.staticStyle,e):e}function na(n){return Array.isArray(n)?D(n):"string"==typeof n?Qi(n):n}var ea,ta=/^--/,ia=/\s*!important$/,aa=function(n,e,t){if(ta.test(e))n.style.setProperty(e,t);else if(ia.test(t))n.style.setProperty(C(e),t.replace(ia,""),"important");else{var i=ra(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[i]=t[a];else n.style[i]=t}},oa=["Webkit","Moz","ms"],ra=T((function(n){if(ea=ea||document.createElement("div").style,"filter"!==(n=E(n))&&n in ea)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<oa.length;t++){var i=oa[t]+e;if(i in ea)return i}}));function sa(n,e){var t=e.data,i=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(i.staticStyle)&&o(i.style))){var a,s,l=e.elm,c=i.staticStyle,d=i.normalizedStyle||i.style||{},u=c||d,p=na(e.data.style)||{};e.data.normalizedStyle=r(p.__ob__)?P({},p):p;var m=function(n,e){var t,i={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Xi(a.data))&&P(i,t);(t=Xi(n.data))&&P(i,t);for(var o=n;o=o.parent;)o.data&&(t=Xi(o.data))&&P(i,t);return i}(e,!0);for(s in u)o(m[s])&&aa(l,s,"");for(s in m)a=m[s],aa(l,s,null==a?"":a)}}var la={create:sa,update:sa},ca=/\s+/;function da(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function ua(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(ca).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pa(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,ma(n.name||"v")),P(e,n),e}return"string"==typeof n?ma(n):void 0}}var ma=T((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ha=K&&!Q,ga="transition",fa="transitionend",va="animation",ba="animationend";ha&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ga="WebkitTransition",fa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(va="WebkitAnimation",ba="webkitAnimationEnd"));var xa=K?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function ya(n){xa((function(){xa(n)}))}function wa(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),da(n,e))}function ka(n,e){n._transitionClasses&&w(n._transitionClasses,e),ua(n,e)}function _a(n,e,t){var i=Sa(n,e),a=i.type,o=i.timeout,r=i.propCount;if(!a)return t();var s="transition"===a?fa:ba,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=r&&c()};setTimeout((function(){l<r&&c()}),o+1),n.addEventListener(s,d)}var Ta=/\b(transform|all)(,|$)/;function Sa(n,e){var t,i=window.getComputedStyle(n),a=(i[ga+"Delay"]||"").split(", "),o=(i[ga+"Duration"]||"").split(", "),r=Ea(a,o),s=(i[va+"Delay"]||"").split(", "),l=(i[va+"Duration"]||"").split(", "),c=Ea(s,l),d=0,u=0;return"transition"===e?r>0&&(t="transition",d=r,u=o.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(r,c))>0?r>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&Ta.test(i[ga+"Property"])}}function Ea(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ja(e)+ja(n[t])})))}function ja(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ia(n,e){var t=n.elm;r(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=pa(n.data.transition);if(!o(i)&&!r(t._enterCb)&&1===t.nodeType){for(var a=i.css,s=i.type,l=i.enterClass,u=i.enterToClass,p=i.enterActiveClass,m=i.appearClass,h=i.appearToClass,g=i.appearActiveClass,f=i.beforeEnter,v=i.enter,x=i.afterEnter,y=i.enterCancelled,w=i.beforeAppear,k=i.appear,_=i.afterAppear,T=i.appearCancelled,S=i.duration,E=Ye,j=Ye.$vnode;j&&j.parent;)E=j.context,j=j.parent;var I=!E._isMounted||!n.isRootInsert;if(!I||k||""===k){var C=I&&m?m:l,z=I&&g?g:p,A=I&&h?h:u,P=I&&w||f,D=I&&c(k)?k:v,$=I&&_||x,B=I&&T||y,M=b(d(S)?S.enter:S);0;var L=!1!==a&&!Q,O=Aa(D),F=t._enterCb=N((function(){L&&(ka(t,A),ka(t,z)),F.cancelled?(L&&ka(t,C),B&&B(t)):$&&$(t),t._enterCb=null}));n.data.show||Wn(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),D&&D(t,F)})),P&&P(t),L&&(wa(t,C),wa(t,z),ya((function(){ka(t,C),F.cancelled||(wa(t,A),O||(za(M)?setTimeout(F,M):_a(t,s,F)))}))),n.data.show&&(e&&e(),D&&D(t,F)),L||O||F()}}}function Ca(n,e){var t=n.elm;r(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=pa(n.data.transition);if(o(i)||1!==t.nodeType)return e();if(!r(t._leaveCb)){var a=i.css,s=i.type,l=i.leaveClass,c=i.leaveToClass,u=i.leaveActiveClass,p=i.beforeLeave,m=i.leave,h=i.afterLeave,g=i.leaveCancelled,f=i.delayLeave,v=i.duration,x=!1!==a&&!Q,y=Aa(m),w=b(d(v)?v.leave:v);0;var k=t._leaveCb=N((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(ka(t,c),ka(t,u)),k.cancelled?(x&&ka(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(_):_()}function _(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),x&&(wa(t,l),wa(t,u),ya((function(){ka(t,l),k.cancelled||(wa(t,c),y||(za(w)?setTimeout(k,w):_a(t,s,k)))}))),m&&m(t,k),x||y||k())}}function za(n){return"number"==typeof n&&!isNaN(n)}function Aa(n){if(o(n))return!1;var e=n.fns;return r(e)?Aa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pa(n,e){!0!==e.data.show&&Ia(e)}var Da=function(n){var e,t,i={},c=n.modules,d=n.nodeOps;for(e=0;e<Si.length;++e)for(i[Si[e]]=[],t=0;t<c.length;++t)r(c[t][Si[e]])&&i[Si[e]].push(c[t][Si[e]]);function u(n){var e=d.parentNode(n);r(e)&&d.removeChild(e,n)}function p(n,e,t,a,o,l,c){if(r(n.elm)&&r(l)&&(n=l[c]=vn(n)),n.isRootInsert=!o,!function(n,e,t,a){var o=n.data;if(r(o)){var l=r(n.componentInstance)&&o.keepAlive;if(r(o=o.hook)&&r(o=o.init)&&o(n,!1),r(n.componentInstance))return m(n,e),h(t,n.elm,a),s(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,r(o=s.data)&&r(o=o.transition)){for(o=0;o<i.activate.length;++o)i.activate[o](Ti,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var u=n.data,p=n.children,f=n.tag;r(f)?(n.elm=n.ns?d.createElementNS(n.ns,f):d.createElement(f,n),b(n),g(n,p,e),r(u)&&v(n,e),h(t,n.elm,a)):s(n.isComment)?(n.elm=d.createComment(n.text),h(t,n.elm,a)):(n.elm=d.createTextNode(n.text),h(t,n.elm,a))}}function m(n,e){r(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),b(n)):(ki(n),e.push(n))}function h(n,e,t){r(n)&&(r(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function g(n,e,t){if(a(e)){0;for(var i=0;i<e.length;++i)p(e[i],t,n.elm,null,!0,e,i)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return r(n.tag)}function v(n,t){for(var a=0;a<i.create.length;++a)i.create[a](Ti,n);r(e=n.data.hook)&&(r(e.create)&&e.create(Ti,n),r(e.insert)&&t.push(n))}function b(n){var e;if(r(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)r(e=t.context)&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;r(e=Ye)&&e!==n.context&&e!==n.fnContext&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function y(n,e,t,i,a,o){for(;i<=a;++i)p(t[i],o,n,e,!1,t,i)}function w(n){var e,t,a=n.data;if(r(a))for(r(e=a.hook)&&r(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(r(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var i=n[e];r(i)&&(r(i.tag)?(_(i),w(i)):u(i.elm))}}function _(n,e){if(r(e)||r(n.data)){var t,a=i.remove.length+1;for(r(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),r(t=n.componentInstance)&&r(t=t._vnode)&&r(t.data)&&_(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);r(t=n.data.hook)&&r(t=t.remove)?t(n,e):e()}else u(n.elm)}function T(n,e,t,i){for(var a=t;a<i;a++){var o=e[a];if(r(o)&&Ei(n,o))return a}}function S(n,e,t,a,l,c){if(n!==e){r(e.elm)&&r(a)&&(e=a[l]=vn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))r(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;r(h)&&r(m=h.hook)&&r(m=m.prepatch)&&m(n,e);var g=n.children,v=e.children;if(r(h)&&f(e)){for(m=0;m<i.update.length;++m)i.update[m](n,e);r(m=h.hook)&&r(m=m.update)&&m(n,e)}o(e.text)?r(g)&&r(v)?g!==v&&function(n,e,t,i,a){var s,l,c,u=0,m=0,h=e.length-1,g=e[0],f=e[h],v=t.length-1,b=t[0],x=t[v],w=!a;for(0;u<=h&&m<=v;)o(g)?g=e[++u]:o(f)?f=e[--h]:Ei(g,b)?(S(g,b,i,t,m),g=e[++u],b=t[++m]):Ei(f,x)?(S(f,x,i,t,v),f=e[--h],x=t[--v]):Ei(g,x)?(S(g,x,i,t,v),w&&d.insertBefore(n,g.elm,d.nextSibling(f.elm)),g=e[++u],x=t[--v]):Ei(f,b)?(S(f,b,i,t,m),w&&d.insertBefore(n,f.elm,g.elm),f=e[--h],b=t[++m]):(o(s)&&(s=ji(e,u,h)),o(l=r(b.key)?s[b.key]:T(b,e,u,h))?p(b,i,n,g.elm,!1,t,m):Ei(c=e[l],b)?(S(c,b,i,t,m),e[l]=void 0,w&&d.insertBefore(n,c.elm,g.elm)):p(b,i,n,g.elm,!1,t,m),b=t[++m]);u>h?y(n,o(t[v+1])?null:t[v+1].elm,t,m,v,i):m>v&&k(e,u,h)}(u,g,v,t,c):r(v)?(r(n.text)&&d.setTextContent(u,""),y(u,null,v,0,v.length-1,t)):r(g)?k(g,0,g.length-1):r(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),r(h)&&r(m=h.hook)&&r(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&r(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var j=x("attrs,class,staticClass,staticStyle,key");function I(n,e,t,i){var a,o=e.tag,l=e.data,c=e.children;if(i=i||l&&l.pre,e.elm=n,s(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(l)&&(r(a=l.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return m(e,t),!0;if(r(o)){if(r(c))if(n.hasChildNodes())if(r(a=l)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!I(u,c[p],t,i)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else g(e,c,t);if(r(l)){var h=!1;for(var f in l)if(!j(f)){h=!0,v(e,t);break}!h&&l.class&&Ve(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!o(e)){var l,c=!1,u=[];if(o(n))c=!0,p(e,u);else{var m=r(n.nodeType);if(!m&&Ei(n,e))S(n,e,u,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&I(n,e,u))return E(e,u,!0),n;l=n,n=new hn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=d.parentNode(h);if(p(e,u,h._leaveCb?null:g,d.nextSibling(h)),r(e.parent))for(var v=e.parent,b=f(e);v;){for(var x=0;x<i.destroy.length;++x)i.destroy[x](v);if(v.elm=e.elm,b){for(var y=0;y<i.create.length;++y)i.create[y](Ti,v);var _=v.data.hook.insert;if(_.merged)for(var T=_.fns.slice(1),j=0;j<T.length;j++)T[j]()}else ki(v);v=v.parent}r(g)?k([n],0,0):r(n.tag)&&w(n)}}return E(e,u,c),e.elm}r(n)&&w(n)}}({nodeOps:yi,modules:[Oi,Hi,Wi,Yi,la,K?{create:Pa,activate:Pa,remove:function(n,e){!0!==n.data.show?Ca(n,e):e()}}:{}].concat($i)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Ha(n,"input")}));var $a={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?Wn(t,"postpatch",(function(){$a.componentUpdated(n,e,t)})):Ba(n,e,t.context),n._vOptions=[].map.call(n.options,Oa)):("textarea"===t.tag||xi(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Na),n.addEventListener("compositionend",Fa),n.addEventListener("change",Fa),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Ba(n,e,t.context);var i=n._vOptions,a=n._vOptions=[].map.call(n.options,Oa);if(a.some((function(n,e){return!L(n,i[e])})))(n.multiple?e.value.some((function(n){return La(n,a)})):e.value!==e.oldValue&&La(e.value,a))&&Ha(n,"change")}}};function Ba(n,e,t){Ma(n,e,t),(Y||X)&&setTimeout((function(){Ma(n,e,t)}),0)}function Ma(n,e,t){var i=e.value,a=n.multiple;if(!a||Array.isArray(i)){for(var o,r,s=0,l=n.options.length;s<l;s++)if(r=n.options[s],a)o=O(i,Oa(r))>-1,r.selected!==o&&(r.selected=o);else if(L(Oa(r),i))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function La(n,e){return e.every((function(e){return!L(e,n)}))}function Oa(n){return"_value"in n?n._value:n.value}function Na(n){n.target.composing=!0}function Fa(n){n.target.composing&&(n.target.composing=!1,Ha(n.target,"input"))}function Ha(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ga(n){return!n.componentInstance||n.data&&n.data.transition?n:Ga(n.componentInstance._vnode)}var Va={model:$a,show:{bind:function(n,e,t){var i=e.value,a=(t=Ga(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&a?(t.data.show=!0,Ia(t,(function(){n.style.display=o}))):n.style.display=i?o:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=Ga(t)).data&&t.data.transition?(t.data.show=!0,i?Ia(t,(function(){n.style.display=n.__vOriginalDisplay})):Ca(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,a){a||(n.style.display=n.__vOriginalDisplay)}}},qa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ua(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ua(Se(e.children)):n}function Ja(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var a=t._parentListeners;for(var i in a)e[E(i)]=a[i];return e}function Ra(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Wa=function(n){return n.tag||ge(n)},Ka=function(n){return"show"===n.name},Za={name:"transition",props:qa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Wa)).length){0;var i=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Ua(a);if(!o)return a;if(this._leaving)return Ra(n,a);var r="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?r+"comment":r+o.tag:l(o.key)?0===String(o.key).indexOf(r)?o.key:r+o.key:o.key;var s=(o.data||(o.data={})).transition=Ja(this),c=this._vnode,d=Ua(c);if(o.data.directives&&o.data.directives.some(Ka)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!ge(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=P({},s);if("out-in"===i)return this._leaving=!0,Wn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ra(n,a);if("in-out"===i){if(ge(o))return c;var p,m=function(){p()};Wn(s,"afterEnter",m),Wn(s,"enterCancelled",m),Wn(u,"delayLeave",(function(n){p=n}))}}return a}}},Ya=P({tag:String,moveClass:String},qa);function Qa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Xa(n){n.data.newPos=n.elm.getBoundingClientRect()}function no(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,a=e.top-t.top;if(i||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate(".concat(i,"px,").concat(a,"px)"),o.transitionDuration="0s"}}delete Ya.mode;var eo={Transition:Za,TransitionGroup:{props:Ya,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],r=Ja(this),s=0;s<a.length;s++){if((d=a[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))o.push(d),t[d.key]=d,(d.data||(d.data={})).transition=r;else;}if(i){var l=[],c=[];for(s=0;s<i.length;s++){var d;(d=i[s]).data.transition=r,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qa),n.forEach(Xa),n.forEach(no),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;wa(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(fa,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(fa,n),t._moveCb=null,ka(t,e))})}})))},methods:{hasMove:function(n,e){if(!ha)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){ua(t,n)})),da(t,e),t.style.display="none",this.$el.appendChild(t);var i=Sa(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};function to(n,e){for(var t in e)n[t]=e[t];return n}Rt.config.mustUseProp=function(n,e,t){return"value"===t&&ti(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Rt.config.isReservedTag=vi,Rt.config.isReservedAttr=ei,Rt.config.getTagNamespace=function(n){return fi(n)?"svg":"math"===n?"math":void 0},Rt.config.isUnknownElement=function(n){if(!K)return!0;if(vi(n))return!1;if(n=n.toLowerCase(),null!=bi[n])return bi[n];var e=document.createElement(n);return n.indexOf("-")>-1?bi[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:bi[n]=/HTMLUnknownElement/.test(e.toString())},P(Rt.options.directives,Va),P(Rt.options.components,eo),Rt.prototype.__patch__=K?Da:$,Rt.prototype.$mount=function(n,e){return function(n,e,t){var i;n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),i=function(){n._update(n._render(),t)},new Je(n,i,$,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1;var a=n._preWatchers;if(a)for(var o=0;o<a.length;o++)a[o].run();return null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&K?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},K&&setTimeout((function(){V.devtools&&ln&&ln.emit("init",Rt)}),0);var io=/[!'()*]/g,ao=function(n){return"%"+n.charCodeAt(0).toString(16)},oo=/%2C/g,ro=function(n){return encodeURIComponent(n).replace(io,ao).replace(oo,",")};function so(n){try{return decodeURIComponent(n)}catch(n){0}return n}var lo=function(n){return null==n||"object"==typeof n?n:String(n)};function co(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=so(t.shift()),a=t.length>0?so(t.join("=")):null;void 0===e[i]?e[i]=a:Array.isArray(e[i])?e[i].push(a):e[i]=[e[i],a]})),e):e}function uo(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ro(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(ro(e)):i.push(ro(e)+"="+ro(n)))})),i.join("&")}return ro(e)+"="+ro(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var po=/\/?$/;function mo(n,e,t,i){var a=i&&i.options.stringifyQuery,o=e.query||{};try{o=ho(o)}catch(n){}var r={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:vo(e,a),matched:n?fo(n):[]};return t&&(r.redirectedFrom=vo(t,a)),Object.freeze(r)}function ho(n){if(Array.isArray(n))return n.map(ho);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ho(n[t]);return e}return n}var go=mo(null,{path:"/"});function fo(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function vo(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||uo)(i)+a}function bo(n,e,t){return e===go?n===e:!!e&&(n.path&&e.path?n.path.replace(po,"")===e.path.replace(po,"")&&(t||n.hash===e.hash&&xo(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&xo(n.query,e.query)&&xo(n.params,e.params))))}function xo(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((function(t,a){var o=n[t];if(i[a]!==t)return!1;var r=e[t];return null==o||null==r?o===r:"object"==typeof o&&"object"==typeof r?xo(o,r):String(o)===String(r)}))}function yo(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var i in t.instances){var a=t.instances[i],o=t.enteredCbs[i];if(a&&o){delete t.enteredCbs[i];for(var r=0;r<o.length;r++)a._isBeingDestroyed||o[r](a)}}}}var wo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var r=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,u=!1;a&&a._routerRoot!==a;){var p=a.$vnode?a.$vnode.data:{};p.routerView&&d++,p.keepAlive&&a._directInactive&&a._inactive&&(u=!0),a=a.$parent}if(o.routerViewDepth=d,u){var m=c[s],h=m&&m.component;return h?(m.configProps&&ko(h,o,m.route,m.configProps),r(h,o,i)):r()}var g=l.matched[d],f=g&&g.components[s];if(!g||!f)return c[s]=null,r();c[s]={component:f},o.registerRouteInstance=function(n,e){var t=g.instances[s];(e&&t!==n||!e&&t===n)&&(g.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){g.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[s]&&(g.instances[s]=n.componentInstance),yo(l)};var v=g.props&&g.props[s];return v&&(to(c[s],{route:l,configProps:v}),ko(f,o,l,v)),r(f,o,i)}};function ko(n,e,t,i){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,i);if(a){a=e.props=to({},a);var o=e.attrs=e.attrs||{};for(var r in a)n.props&&r in n.props||(o[r]=a[r],delete a[r])}}function _o(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),r=0;r<o.length;r++){var s=o[r];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function To(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var So=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},Eo=Fo,jo=Po,Io=function(n,e){return $o(Po(n,e),e)},Co=$o,zo=No,Ao=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Po(n,e){for(var t,i=[],a=0,o=0,r="",s=e&&e.delimiter||"/";null!=(t=Ao.exec(n));){var l=t[0],c=t[1],d=t.index;if(r+=n.slice(o,d),o=d+l.length,c)r+=c[1];else{var u=n[o],p=t[2],m=t[3],h=t[4],g=t[5],f=t[6],v=t[7];r&&(i.push(r),r="");var b=null!=p&&null!=u&&u!==p,x="+"===f||"*"===f,y="?"===f||"*"===f,w=t[2]||s,k=h||g;i.push({name:m||a++,prefix:p||"",delimiter:w,optional:y,repeat:x,partial:b,asterisk:!!v,pattern:k?Mo(k):v?".*":"[^"+Bo(w)+"]+?"})}}return o<n.length&&(r+=n.substr(o)),r&&i.push(r),i}function Do(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function $o(n,e){for(var t=new Array(n.length),i=0;i<n.length;i++)"object"==typeof n[i]&&(t[i]=new RegExp("^(?:"+n[i].pattern+")$",Oo(e)));return function(e,i){for(var a="",o=e||{},r=(i||{}).pretty?Do:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=o[l.name];if(null==d){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(So(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=r(d[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):r(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function Bo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Mo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Lo(n,e){return n.keys=e,n}function Oo(n){return n&&n.sensitive?"":"i"}function No(n,e,t){So(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,a=!1!==t.end,o="",r=0;r<n.length;r++){var s=n[r];if("string"==typeof s)o+=Bo(s);else{var l=Bo(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Bo(t.delimiter||"/"),u=o.slice(-d.length)===d;return i||(o=(u?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=a?"$":i&&u?"":"(?="+d+"|$)",Lo(new RegExp("^"+o,Oo(t)),e)}function Fo(n,e,t){return So(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Lo(n,e)}(n,e):So(n)?function(n,e,t){for(var i=[],a=0;a<n.length;a++)i.push(Fo(n[a],e,t).source);return Lo(new RegExp("(?:"+i.join("|")+")",Oo(t)),e)}(n,e,t):function(n,e,t){return No(Po(n,t),e,t)}(n,e,t)}Eo.parse=jo,Eo.compile=Io,Eo.tokensToFunction=Co,Eo.tokensToRegExp=zo;var Ho=Object.create(null);function Go(n,e,t){e=e||{};try{var i=Ho[n]||(Ho[n]=Eo.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Vo(n,e,t,i){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var o=(a=to({},n)).params;return o&&"object"==typeof o&&(a.params=to({},o)),a}if(!a.path&&a.params&&e){(a=to({},a))._normalized=!0;var r=to(to({},e.params),a.params);if(e.name)a.name=e.name,a.params=r;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;a.path=Go(s,r,e.path)}else 0;return a}var l=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",d=l.path?_o(l.path,c,t||a.append):c,u=function(n,e,t){void 0===e&&(e={});var i,a=t||co;try{i=a(n||"")}catch(n){i={}}for(var o in e){var r=e[o];i[o]=Array.isArray(r)?r.map(lo):lo(r)}return i}(l.query,a.query,i&&i.options.parseQuery),p=a.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var qo,Uo=function(){},Jo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,a=t.resolve(this.to,i,this.append),o=a.location,r=a.route,s=a.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=r.redirectedFrom?mo(null,Vo(r.redirectedFrom),null,t):r;l[h]=bo(i,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(po,"/").indexOf(e.path.replace(po,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,g);var f=l[h]?this.ariaCurrentValue:null,v=function(n){Ro(n)&&(e.replace?t.replace(o,Uo):t.push(o,Uo))},b={click:Ro};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:r,navigate:v,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=b,x.attrs={href:s,"aria-current":f};else{var w=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=to({},w.data);for(var _ in k.on=k.on||{},k.on){var T=k.on[_];_ in b&&(k.on[_]=Array.isArray(T)?T:[T])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=v;var E=w.data.attrs=to({},w.data.attrs);E.href=s,E["aria-current"]=f}else x.on=b}return n(this.tag,x,this.$slots.default)}};function Ro(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Wo="undefined"!=typeof window;function Ko(n,e,t,i,a){var o=e||[],r=t||Object.create(null),s=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,a,o,r){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return To(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var u={path:d,regex:Zo(d,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:r,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=r?To(r+"/"+a.path):void 0;n(e,t,i,a,u,o)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:a.children};n(e,t,i,h,o,u.path||"/")}l&&(i[l]||(i[l]=u))}(o,r,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:r,nameMap:s}}function Zo(n,e){return Eo(n,[],e)}function Yo(n,e){var t=Ko(n),i=t.pathList,a=t.pathMap,o=t.nameMap;function r(n,t,r){var s=Vo(n,t,!1,e),c=s.name;if(c){var d=o[c];if(!d)return l(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&u.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Go(d.path,s.params),l(d,s,r)}if(s.path){s.params={};for(var m=0;m<i.length;m++){var h=i[m],g=a[h];if(Qo(g.regex,s.path,s.params))return l(g,s,r)}}return l(null,s)}function s(n,t){var i=n.redirect,a="function"==typeof i?i(mo(n,t,null,e)):i;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,d=s.path,u=t.query,p=t.hash,m=t.params;if(u=s.hasOwnProperty("query")?s.query:u,p=s.hasOwnProperty("hash")?s.hash:p,m=s.hasOwnProperty("params")?s.params:m,c){o[c];return r({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return _o(n,e.parent?e.parent.path:"/",!0)}(d,n);return r({_normalized:!0,path:Go(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,i){return n&&n.redirect?s(n,i||t):n&&n.matchAs?function(n,e,t){var i=r({_normalized:!0,path:Go(t,e.params)});if(i){var a=i.matched,o=a[a.length-1];return e.params=i.params,l(o,e)}return l(null,e)}(0,t,n.matchAs):mo(n,t,i,e)}return{match:r,addRoute:function(n,e){var t="object"!=typeof n?o[n]:void 0;Ko([e||n],i,a,o,t),t&&t.alias.length&&Ko(t.alias.map((function(n){return{path:n,children:[e]}})),i,a,o,t)},getRoutes:function(){return i.map((function(n){return a[n]}))},addRoutes:function(n){Ko(n,i,a,o)}}}function Qo(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var a=1,o=i.length;a<o;++a){var r=n.keys[a-1];r&&(t[r.name||"pathMatch"]="string"==typeof i[a]?so(i[a]):i[a])}return!0}var Xo=Wo&&window.performance&&window.performance.now?window.performance:Date;function nr(){return Xo.now().toFixed(3)}var er=nr();function tr(){return er}function ir(n){return er=n}var ar=Object.create(null);function or(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=to({},window.history.state);return t.key=tr(),window.history.replaceState(t,"",e),window.addEventListener("popstate",lr),function(){window.removeEventListener("popstate",lr)}}function rr(n,e,t,i){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=tr();if(n)return ar[n]}(),r=a.call(n,e,t,i?o:null);r&&("function"==typeof r.then?r.then((function(n){mr(n,o)})).catch((function(n){0})):mr(r,o))}))}}function sr(){var n=tr();n&&(ar[n]={x:window.pageXOffset,y:window.pageYOffset})}function lr(n){sr(),n.state&&n.state.key&&ir(n.state.key)}function cr(n){return ur(n.x)||ur(n.y)}function dr(n){return{x:ur(n.x)?n.x:window.pageXOffset,y:ur(n.y)?n.y:window.pageYOffset}}function ur(n){return"number"==typeof n}var pr=/^#\d/;function mr(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var a=pr.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var o=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(a,o={x:ur((t=o).x)?t.x:0,y:ur(t.y)?t.y:0})}else cr(n)&&(e=dr(n))}else i&&cr(n)&&(e=dr(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var hr,gr=Wo&&((-1===(hr=window.navigator.userAgent).indexOf("Android 2.")&&-1===hr.indexOf("Android 4.0")||-1===hr.indexOf("Mobile Safari")||-1!==hr.indexOf("Chrome")||-1!==hr.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function fr(n,e){sr();var t=window.history;try{if(e){var i=to({},t.state);i.key=tr(),t.replaceState(i,"",n)}else t.pushState({key:ir(nr())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vr(n){fr(n,!0)}var br={redirected:2,aborted:4,cancelled:8,duplicated:16};function xr(n,e){return wr(n,e,br.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return kr.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yr(n,e){return wr(n,e,br.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function wr(n,e,t,i){var a=new Error(i);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var kr=["params","query","hash"];function _r(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Tr(n,e){return _r(n)&&n._isRouter&&(null==e||n.type===e)}function Sr(n,e,t){var i=function(a){a>=n.length?t():n[a]?e(n[a],(function(){i(a+1)})):i(a+1)};i(0)}function Er(n){return function(e,t,i){var a=!1,o=0,r=null;jr(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=zr((function(e){var a;((a=e).__esModule||Cr&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:qo.extend(e),t.components[s]=e,--o<=0&&i()})),d=zr((function(n){var e="Failed to resolve async component "+s+": "+n;r||(r=_r(n)?n:new Error(e),i(r))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),a||i()}}function jr(n,e){return Ir(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ir(n){return Array.prototype.concat.apply([],n)}var Cr="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zr(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var Ar=function(n,e){this.router=n,this.base=function(n){if(!n)if(Wo){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=go,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Pr(n,e,t,i){var a=jr(n,(function(n,i,a,o){var r=function(n,e){"function"!=typeof n&&(n=qo.extend(n));return n.options[e]}(n,e);if(r)return Array.isArray(r)?r.map((function(n){return t(n,i,a,o)})):t(r,i,a,o)}));return Ir(i?a.reverse():a)}function Dr(n,e){if(e)return function(){return n.apply(e,arguments)}}Ar.prototype.listen=function(n){this.cb=n},Ar.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ar.prototype.onError=function(n){this.errorCbs.push(n)},Ar.prototype.transitionTo=function(n,e,t){var i,a=this;try{i=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(i,(function(){a.updateRoute(i),e&&e(i),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(i,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(i)})))}),(function(n){t&&t(n),n&&!a.ready&&(Tr(n,br.redirected)&&o===go||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ar.prototype.confirmTransition=function(n,e,t){var i=this,a=this.current;this.pending=n;var o,r,s=function(n){!Tr(n)&&_r(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(bo(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&rr(this.router,a,n,!1),s(((r=wr(o=a,n,br.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",r));var d=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return Pr(n,"beforeRouteLeave",Dr,!0)}(p),this.router.beforeHooks,function(n){return Pr(n,"beforeRouteUpdate",Dr)}(u),m.map((function(n){return n.beforeEnter})),Er(m)),g=function(e,t){if(i.pending!==n)return s(yr(a,n));try{e(n,a,(function(e){!1===e?(i.ensureURL(!0),s(function(n,e){return wr(n,e,br.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):_r(e)?(i.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(xr(a,n)),"object"==typeof e&&e.replace?i.replace(e):i.push(e)):t(e)}))}catch(n){s(n)}};Sr(h,g,(function(){Sr(function(n){return Pr(n,"beforeRouteEnter",(function(n,e,t,i){return function(n,e,t){return function(i,a,o){return n(i,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,i)}))}(m).concat(i.router.resolveHooks),g,(function(){if(i.pending!==n)return s(yr(a,n));i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){yo(n)}))}))}))},Ar.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ar.prototype.setupListeners=function(){},Ar.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=go,this.pending=null};var $r=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Br(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,i=gr&&t;i&&this.listeners.push(or());var a=function(){var t=n.current,a=Br(n.base);n.current===go&&a===n._startLocation||n.transitionTo(a,(function(n){i&&rr(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,a=this.current;this.transitionTo(n,(function(n){fr(To(i.base+n.fullPath)),rr(i.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,a=this.current;this.transitionTo(n,(function(n){vr(To(i.base+n.fullPath)),rr(i.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Br(this.base)!==this.current.fullPath){var e=To(this.base+this.current.fullPath);n?fr(e):vr(e)}},e.prototype.getCurrentLocation=function(){return Br(this.base)},e}(Ar);function Br(n){var e=window.location.pathname,t=e.toLowerCase(),i=n.toLowerCase();return!n||t!==i&&0!==t.indexOf(To(i+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Mr=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=Br(n);if(!/^\/#/.test(e))return window.location.replace(To(n+"/#"+e)),!0}(this.base)||Lr()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=gr&&e;t&&this.listeners.push(or());var i=function(){var e=n.current;Lr()&&n.transitionTo(Or(),(function(i){t&&rr(n.router,i,e,!0),gr||Hr(i.fullPath)}))},a=gr?"popstate":"hashchange";window.addEventListener(a,i),this.listeners.push((function(){window.removeEventListener(a,i)}))}},e.prototype.push=function(n,e,t){var i=this,a=this.current;this.transitionTo(n,(function(n){Fr(n.fullPath),rr(i.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,a=this.current;this.transitionTo(n,(function(n){Hr(n.fullPath),rr(i.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Or()!==e&&(n?Fr(e):Hr(e))},e.prototype.getCurrentLocation=function(){return Or()},e}(Ar);function Lr(){var n=Or();return"/"===n.charAt(0)||(Hr("/"+n),!1)}function Or(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Nr(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Fr(n){gr?fr(Nr(n)):window.location.hash=n}function Hr(n){gr?vr(Nr(n)):window.location.replace(Nr(n))}var Gr=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){var n=e.current;e.index=t,e.updateRoute(i),e.router.afterHooks.forEach((function(e){e&&e(i,n)}))}),(function(n){Tr(n,br.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ar),Vr=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Yo(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!gr&&!1!==n.fallback,this.fallback&&(e="hash"),Wo||(e="abstract"),this.mode=e,e){case"history":this.history=new $r(this,n.base);break;case"hash":this.history=new Mr(this,n.base,this.fallback);break;case"abstract":this.history=new Gr(this,n.base);break;default:0}},qr={currentRoute:{configurable:!0}};Vr.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},qr.currentRoute.get=function(){return this.history&&this.history.current},Vr.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof $r||t instanceof Mr){var i=function(n){t.setupListeners(),function(n){var i=t.current,a=e.options.scrollBehavior;gr&&a&&"fullPath"in n&&rr(e,n,i,!1)}(n)};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Vr.prototype.beforeEach=function(n){return Jr(this.beforeHooks,n)},Vr.prototype.beforeResolve=function(n){return Jr(this.resolveHooks,n)},Vr.prototype.afterEach=function(n){return Jr(this.afterHooks,n)},Vr.prototype.onReady=function(n,e){this.history.onReady(n,e)},Vr.prototype.onError=function(n){this.history.onError(n)},Vr.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},Vr.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},Vr.prototype.go=function(n){this.history.go(n)},Vr.prototype.back=function(){this.go(-1)},Vr.prototype.forward=function(){this.go(1)},Vr.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Vr.prototype.resolve=function(n,e,t){var i=Vo(n,e=e||this.history.current,t,this),a=this.match(i,e),o=a.redirectedFrom||a.fullPath;return{location:i,route:a,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?To(n+"/"+i):i}(this.history.base,o,this.mode),normalizedTo:i,resolved:a}},Vr.prototype.getRoutes=function(){return this.matcher.getRoutes()},Vr.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==go&&this.history.transitionTo(this.history.getCurrentLocation())},Vr.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==go&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Vr.prototype,qr);var Ur=Vr;function Jr(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Vr.install=function n(e){if(!n.installed||qo!==e){n.installed=!0,qo=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",wo),e.component("RouterLink",Jo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Vr.version="3.6.5",Vr.isNavigationFailure=Tr,Vr.NavigationFailureType=br,Vr.START_LOCATION=go,Wo&&window.Vue&&window.Vue.use(Vr);t(110);t(49),t(13);var Rr={NotFound:()=>Promise.all([t.e(0),t.e(14)]).then(t.bind(null,369)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,367))},Wr={"v-afcb83d6":()=>t.e(18).then(t.bind(null,382)),"v-d24fe506":()=>t.e(19).then(t.bind(null,383)),"v-66492ece":()=>t.e(20).then(t.bind(null,384)),"v-675813ce":()=>t.e(21).then(t.bind(null,385)),"v-478ae4fa":()=>t.e(22).then(t.bind(null,386)),"v-4c983d83":()=>t.e(23).then(t.bind(null,387)),"v-299b6b72":()=>t.e(25).then(t.bind(null,388)),"v-190f784c":()=>t.e(26).then(t.bind(null,389)),"v-891c8d58":()=>t.e(27).then(t.bind(null,390)),"v-c56c268c":()=>t.e(24).then(t.bind(null,391)),"v-3f70b542":()=>t.e(28).then(t.bind(null,392)),"v-ca1a868a":()=>t.e(29).then(t.bind(null,393)),"v-930608a0":()=>t.e(30).then(t.bind(null,394)),"v-1a4c07c0":()=>t.e(31).then(t.bind(null,395)),"v-9b071a1c":()=>t.e(32).then(t.bind(null,396)),"v-d4457084":()=>t.e(33).then(t.bind(null,397)),"v-36e24b0a":()=>t.e(35).then(t.bind(null,398)),"v-72bd17b5":()=>t.e(36).then(t.bind(null,399)),"v-45001122":()=>t.e(37).then(t.bind(null,400)),"v-3c877a2e":()=>t.e(38).then(t.bind(null,401)),"v-d0ab1154":()=>t.e(39).then(t.bind(null,402)),"v-23ff7de0":()=>t.e(40).then(t.bind(null,403)),"v-f69f579a":()=>t.e(42).then(t.bind(null,404)),"v-5eb8472a":()=>t.e(41).then(t.bind(null,405)),"v-70df8a60":()=>t.e(44).then(t.bind(null,406)),"v-0a54f67d":()=>t.e(45).then(t.bind(null,407)),"v-e278e442":()=>t.e(43).then(t.bind(null,408)),"v-615081d1":()=>t.e(46).then(t.bind(null,409)),"v-2882db09":()=>t.e(47).then(t.bind(null,410)),"v-6de5f26a":()=>t.e(48).then(t.bind(null,411)),"v-715f666a":()=>t.e(49).then(t.bind(null,412)),"v-313dd5d4":()=>t.e(51).then(t.bind(null,413)),"v-3e18e141":()=>t.e(52).then(t.bind(null,414)),"v-0e1882ae":()=>t.e(50).then(t.bind(null,415)),"v-77cb82b4":()=>t.e(53).then(t.bind(null,416)),"v-66522d6e":()=>t.e(54).then(t.bind(null,417)),"v-ccbc51b8":()=>t.e(55).then(t.bind(null,418)),"v-d19a1a44":()=>t.e(56).then(t.bind(null,419)),"v-2dafa1e7":()=>t.e(57).then(t.bind(null,420)),"v-cb6ea65e":()=>t.e(58).then(t.bind(null,421)),"v-1c9909ea":()=>t.e(60).then(t.bind(null,422)),"v-3d06597e":()=>t.e(61).then(t.bind(null,423)),"v-f6eeff0a":()=>t.e(59).then(t.bind(null,424)),"v-1641573c":()=>t.e(62).then(t.bind(null,425)),"v-79fd1563":()=>t.e(63).then(t.bind(null,426)),"v-104cfd4b":()=>t.e(64).then(t.bind(null,427)),"v-499dee9f":()=>t.e(65).then(t.bind(null,428)),"v-c52e6f90":()=>t.e(66).then(t.bind(null,429)),"v-f52fa3a8":()=>t.e(67).then(t.bind(null,430)),"v-2b3bacab":()=>t.e(68).then(t.bind(null,431)),"v-28360899":()=>t.e(69).then(t.bind(null,432)),"v-efaad25e":()=>t.e(70).then(t.bind(null,433)),"v-9bc8aa68":()=>t.e(72).then(t.bind(null,434)),"v-21b79325":()=>t.e(71).then(t.bind(null,435)),"v-7be86aa5":()=>t.e(74).then(t.bind(null,436)),"v-45374f90":()=>t.e(73).then(t.bind(null,437)),"v-63b092c7":()=>t.e(75).then(t.bind(null,438)),"v-6369ee9a":()=>t.e(78).then(t.bind(null,439)),"v-5fb11738":()=>t.e(77).then(t.bind(null,440)),"v-16dd473a":()=>t.e(80).then(t.bind(null,441)),"v-6a2bce46":()=>t.e(76).then(t.bind(null,442)),"v-c17e9308":()=>t.e(79).then(t.bind(null,443)),"v-4df113c3":()=>t.e(81).then(t.bind(null,444)),"v-751178aa":()=>t.e(34).then(t.bind(null,370)),"v-14bf4ff7":()=>t.e(84).then(t.bind(null,445)),"v-8efda230":()=>t.e(82).then(t.bind(null,446)),"v-82f6dcc4":()=>t.e(83).then(t.bind(null,447)),"v-14211e26":()=>t.e(85).then(t.bind(null,448)),"v-354f58fa":()=>t.e(86).then(t.bind(null,449)),"v-09f97d06":()=>t.e(87).then(t.bind(null,450)),"v-5d5b1b5c":()=>t.e(88).then(t.bind(null,451)),"v-7f849213":()=>t.e(90).then(t.bind(null,452)),"v-7c7210d4":()=>t.e(91).then(t.bind(null,453)),"v-66b3d6ef":()=>t.e(92).then(t.bind(null,454)),"v-5df3ba47":()=>t.e(89).then(t.bind(null,455)),"v-5fd17c76":()=>t.e(94).then(t.bind(null,456)),"v-597ab59a":()=>t.e(93).then(t.bind(null,457)),"v-6566d8f7":()=>t.e(95).then(t.bind(null,458)),"v-50562c58":()=>t.e(96).then(t.bind(null,459)),"v-1effc226":()=>t.e(97).then(t.bind(null,460)),"v-3fcbe812":()=>t.e(98).then(t.bind(null,461)),"v-1980a5d5":()=>t.e(99).then(t.bind(null,462)),"v-fe63d31a":()=>t.e(102).then(t.bind(null,463)),"v-1ecc7688":()=>t.e(100).then(t.bind(null,464)),"v-0367b534":()=>t.e(103).then(t.bind(null,465)),"v-60ac27e4":()=>t.e(101).then(t.bind(null,466)),"v-798ab013":()=>t.e(104).then(t.bind(null,467)),"v-11e8e024":()=>t.e(105).then(t.bind(null,468)),"v-27fb31be":()=>t.e(107).then(t.bind(null,469)),"v-98bdb7cc":()=>t.e(106).then(t.bind(null,470)),"v-50e5c0bc":()=>t.e(108).then(t.bind(null,471)),"v-1bce0795":()=>t.e(109).then(t.bind(null,472)),"v-222a195f":()=>t.e(110).then(t.bind(null,473)),"v-004ed419":()=>t.e(112).then(t.bind(null,474)),"v-c0cdc776":()=>t.e(113).then(t.bind(null,475)),"v-0843e2a1":()=>t.e(111).then(t.bind(null,476)),"v-211f711c":()=>t.e(115).then(t.bind(null,477)),"v-31fbd7e5":()=>t.e(116).then(t.bind(null,478)),"v-6ef34192":()=>t.e(114).then(t.bind(null,479)),"v-528260fe":()=>t.e(117).then(t.bind(null,480)),"v-1760b555":()=>t.e(121).then(t.bind(null,481)),"v-0574d59f":()=>t.e(119).then(t.bind(null,482)),"v-7f6d28b2":()=>t.e(123).then(t.bind(null,483)),"v-57a8012f":()=>t.e(122).then(t.bind(null,484)),"v-24efff4c":()=>t.e(124).then(t.bind(null,485)),"v-78bd3772":()=>t.e(125).then(t.bind(null,486)),"v-7c27afd4":()=>t.e(126).then(t.bind(null,487)),"v-5f4699cc":()=>t.e(127).then(t.bind(null,488)),"v-1179473f":()=>t.e(118).then(t.bind(null,489)),"v-dfe9f282":()=>t.e(120).then(t.bind(null,490)),"v-543ef8d8":()=>t.e(4).then(t.bind(null,363))};function Kr(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Zr=/-(\w)/g,Yr=Kr(n=>n.replace(Zr,(n,e)=>e?e.toUpperCase():"")),Qr=/\B([A-Z])/g,Xr=Kr(n=>n.replace(Qr,"-$1").toLowerCase()),ns=Kr(n=>n.charAt(0).toUpperCase()+n.slice(1));function es(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(ns(Yr(e))):n(ns(e))||n(Xr(e))}const ts=Object.assign({},Rr,Wr),is=n=>ts[n],as=n=>Wr[n],os=n=>Rr[n],rs=n=>Rt.component(n);function ss(n){return es(as,n)}function ls(n){return es(os,n)}function cs(n){return es(is,n)}function ds(n){return es(rs,n)}function us(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ds(n)&&cs(n)){const e=await cs(n)();Rt.component(n,e.default)}}))}function ps(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ms=t(94),hs=t.n(ms),gs=t(95),fs=t.n(gs),vs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=xs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return hs()([{name:"description",content:this.$description}],n,this.siteMeta,ws)},updateCanonicalLink(){bs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",xs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),bs()}};function bs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function xs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ws(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ks=t(53),_s={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ks)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+t;for(let n=0;n<e.length;n++){const o=e[n],r=e[n+1],s=0===n&&0===t||t>=o.parentElement.offsetTop+10&&(!r||t<r.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(o.hash)){const t=o;if(a===i)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Ts=t(24),Ss=t.n(Ts),Es={mounted(){Ss.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Rt.component(n.name)||Ss.a.start(),t()}),this.$router.afterEach(()=>{Ss.a.done(),this.isSidebarOpen=!1})}};t(243),t(244);class js{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Is={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new js).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}},Cs="auto",zs="zoom-in",As="zoom-out",Ps="grab",Ds="move";function $s(n,e,t){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};i?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Bs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ms(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ls(n,e,t){!function(n){var e=Os,t=Ns;if(n.transition){var i=n.transition;delete n.transition,n[e]=i}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var i=n.style,a={};for(var o in e)t&&(a[o]=i[o]||""),i[o]=e[o];return a}var Os="transition",Ns="transform",Fs="transform",Hs="transitionend";var Gs=function(){},Vs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Gs,onClose:Gs,onGrab:Gs,onMove:Gs,onRelease:Gs,onBeforeOpen:Gs,onBeforeClose:Gs,onBeforeGrab:Gs,onBeforeRelease:Gs,onImageLoading:Gs,onImageLoaded:Gs},qs={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Js(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var i=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(i)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Us(n)&&!Js(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Us(n)&&!Js(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,i=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,i)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,i=e.clientY;this.move(t,i)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Us(n){return 0===n.button}function Js(n){return n.metaKey||n.ctrlKey}var Rs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ls(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),$s(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ls(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ws="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ks=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),Zs=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},Ys={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ms(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,i=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ps:As,transition:Fs+"\n        "+i+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ls(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ls(this.el,{transform:"none"})},grab:function(n,e,t){var i=Qs(),a=i.x-n,o=i.y-e;Ls(this.el,{cursor:Ds,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var i=Qs(),a=i.x-n,o=i.y-e;Ls(this.el,{transition:Fs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ls(this.el,this.styleClose)},restoreOpenStyle:function(){Ls(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Qs(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,i=this.instance.options,a=i.customSize,o=i.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":Ws(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var r=this.rect.width/2,s=this.rect.height/2,l=Qs(),c={x:l.x-r,y:l.y-s},d=c.x/r,u=c.y/s,p=o+Math.min(d,u);if(a&&"string"==typeof a){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(a)*m/(100*this.rect.width),f=parseFloat(a)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function Qs(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Xs(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(i){$s(n,i,e[i],t)}))}var nl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ys),this.overlay=Object.create(Rs),this.handler=Object.create(qs),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Zs({},Vs,e),this.overlay.init(this),this.handler.init(this)}return Ks(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=zs,$s(n,"click",this.handler.click),this.options.preloadImage&&Bs(Ms(n)));return this}},{key:"config",value:function(n){return n?(Zs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var i="string"==typeof n?document.querySelector(n):n;if("IMG"===i.tagName){if(this.options.onBeforeOpen(i),this.target.init(i,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(i),Bs(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),$s(document,"scroll",this.handler.scroll),$s(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&$s(window,"resize",this.handler.resizeWindow);var o=function n(){$s(i,Hs,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Xs(document,e.handler,!0),t(i)};return $s(i,Hs,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Cs,this.overlay.fadeOut(),this.target.zoomOut(),$s(document,"scroll",this.handler.scroll,!1),$s(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&$s(window,"resize",this.handler.resizeWindow,!1);var i=function i(){$s(t,Hs,i,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Xs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return $s(t,Hs,i),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){$s(a,Hs,n,!1),i(a)};return $s(a,Hs,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ds,this.target.move(n,e,t);var a=this.target.el,o=function n(){$s(a,Hs,n,!1),i(a)};return $s(a,Hs,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Cs,this.target.restoreOpenStyle();var i=function i(){$s(t,Hs,i,!1),n.lock=!1,n.released=!0,e(t)};return $s(t,Hs,i),this}}}]),n}();const el=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),tl=Number("500");class il{constructor(){this.instance=new nl(el)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=tl){setTimeout(()=>this.update(n),e)}}var al=[vs,_s,Es,Is,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new il,this.$vuepress.zooming.updateDelay()}}],ol={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ps("layout",n),Rt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},rl=t(0),sl=Object(rl.a)(ol,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(sl,"mixins",al);const ll=[{name:"v-afcb83d6",path:"/tool/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-afcb83d6").then(t)}},{path:"/tool/index.html",redirect:"/tool/"},{path:"/00.目录页/00.导航栏 - 目录页/10.工具 - 知识体系.html",redirect:"/tool/"},{name:"v-d24fe506",path:"/basics/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-d24fe506").then(t)}},{path:"/basics/index.html",redirect:"/basics/"},{path:"/00.目录页/00.导航栏 - 目录页/15.前端 - 知识体系.html",redirect:"/basics/"},{name:"v-66492ece",path:"/javascript/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-66492ece").then(t)}},{path:"/javascript/index.html",redirect:"/javascript/"},{path:"/00.目录页/00.导航栏 - 目录页/17.JS - 知识体系.html",redirect:"/javascript/"},{name:"v-675813ce",path:"/more/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-675813ce").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/00.导航栏 - 目录页/88.更多 - 知识体系.html",redirect:"/more/"},{name:"v-478ae4fa",path:"/JSbasics/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-478ae4fa").then(t)}},{path:"/JSbasics/index.html",redirect:"/JSbasics/"},{path:"/00.目录页/03.JS - 目录页/01.基础 - 知识体系.html",redirect:"/JSbasics/"},{name:"v-4c983d83",path:"/JS-ES6/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-4c983d83").then(t)}},{path:"/JS-ES6/index.html",redirect:"/JS-ES6/"},{path:"/00.目录页/03.JS - 目录页/02.ES6 - 知识体系.html",redirect:"/JS-ES6/"},{name:"v-299b6b72",path:"/webpack/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-299b6b72").then(t)}},{path:"/webpack/index.html",redirect:"/webpack/"},{path:"/00.目录页/12.工具 - 目录页/03.Webpack - 知识体系.html",redirect:"/webpack/"},{name:"v-190f784c",path:"/more/advanced/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-190f784c").then(t)}},{path:"/more/advanced/index.html",redirect:"/more/advanced/"},{path:"/00.目录页/17.更多 - 目录页/03.进阶 - 知识体系.html",redirect:"/more/advanced/"},{name:"v-891c8d58",path:"/basics/HTML/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-891c8d58").then(t)}},{path:"/basics/HTML/index.html",redirect:"/basics/HTML/"},{path:"/01.前端基础/01.HTML/01.HTML.html",redirect:"/basics/HTML/"},{name:"v-c56c268c",path:"/git/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-c56c268c").then(t)}},{path:"/git/index.html",redirect:"/git/"},{path:"/00.目录页/12.工具 - 目录页/02.Git - 知识体系.html",redirect:"/git/"},{name:"v-3f70b542",path:"/basics/CSS2/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-3f70b542").then(t)}},{path:"/basics/CSS2/index.html",redirect:"/basics/CSS2/"},{path:"/01.前端基础/02.CSS/02.CSS基础.html",redirect:"/basics/CSS2/"},{name:"v-ca1a868a",path:"/pages/c7b8e9/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-ca1a868a").then(t)}},{path:"/pages/c7b8e9/index.html",redirect:"/pages/c7b8e9/"},{path:"/01.前端基础/02.CSS/03.CSS复合选择器、背景盒子透明、三大元素、圆角、阴影.html",redirect:"/pages/c7b8e9/"},{name:"v-930608a0",path:"/pages/33f061/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-930608a0").then(t)}},{path:"/pages/33f061/index.html",redirect:"/pages/33f061/"},{path:"/01.前端基础/02.CSS/04.CSS三大特性、盒子模型、边距、过渡动画.html",redirect:"/pages/33f061/"},{name:"v-1a4c07c0",path:"/pages/64cb20/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1a4c07c0").then(t)}},{path:"/pages/64cb20/index.html",redirect:"/pages/64cb20/"},{path:"/01.前端基础/02.CSS/05.CSS3选择器、伪元素、光标类型、浮动.html",redirect:"/pages/64cb20/"},{name:"v-9b071a1c",path:"/pages/915fc4/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-9b071a1c").then(t)}},{path:"/pages/915fc4/index.html",redirect:"/pages/915fc4/"},{path:"/01.前端基础/02.CSS/06.CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局.html",redirect:"/pages/915fc4/"},{name:"v-d4457084",path:"/pages/602c76/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-d4457084").then(t)}},{path:"/pages/602c76/index.html",redirect:"/pages/602c76/"},{path:"/01.前端基础/02.CSS/20.CSS进阶.html",redirect:"/pages/602c76/"},{name:"v-36e24b0a",path:"/javascript/c8f971/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-36e24b0a").then(t)}},{path:"/javascript/c8f971/index.html",redirect:"/javascript/c8f971/"},{path:"/20.JS/10.基础/01.JS语法与变量.html",redirect:"/javascript/c8f971/"},{name:"v-72bd17b5",path:"/pages/6f1d80/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-72bd17b5").then(t)}},{path:"/pages/6f1d80/index.html",redirect:"/pages/6f1d80/"},{path:"/20.JS/10.基础/02.JS基本数据类型.html",redirect:"/pages/6f1d80/"},{name:"v-45001122",path:"/pages/5c5ad9/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-45001122").then(t)}},{path:"/pages/5c5ad9/index.html",redirect:"/pages/5c5ad9/"},{path:"/20.JS/10.基础/03.JS表达式与操作符.html",redirect:"/pages/5c5ad9/"},{name:"v-3c877a2e",path:"/pages/4b4e62/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-3c877a2e").then(t)}},{path:"/pages/4b4e62/index.html",redirect:"/pages/4b4e62/"},{path:"/20.JS/10.基础/04.JS流程控制.html",redirect:"/pages/4b4e62/"},{name:"v-d0ab1154",path:"/pages/39d0fd/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-d0ab1154").then(t)}},{path:"/pages/39d0fd/index.html",redirect:"/pages/39d0fd/"},{path:"/20.JS/10.基础/05.JS数组.html",redirect:"/pages/39d0fd/"},{name:"v-23ff7de0",path:"/pages/428206/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-23ff7de0").then(t)}},{path:"/pages/428206/index.html",redirect:"/pages/428206/"},{path:"/20.JS/10.基础/06.JS函数.html",redirect:"/pages/428206/"},{name:"v-f69f579a",path:"/pages/067486/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-f69f579a").then(t)}},{path:"/pages/067486/index.html",redirect:"/pages/067486/"},{path:"/20.JS/20.ES6/02.ES6语法扩展.html",redirect:"/pages/067486/"},{name:"v-5eb8472a",path:"/pages/75e0f9/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5eb8472a").then(t)}},{path:"/pages/75e0f9/index.html",redirect:"/pages/75e0f9/"},{path:"/20.JS/20.ES6/01.ES6基础入门.html",redirect:"/pages/75e0f9/"},{name:"v-70df8a60",path:"/pages/65b11e/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-70df8a60").then(t)}},{path:"/pages/65b11e/index.html",redirect:"/pages/65b11e/"},{path:"/20.JS/20.ES6/04.ES6之Module模块.html",redirect:"/pages/65b11e/"},{name:"v-0a54f67d",path:"/git/introduce/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-0a54f67d").then(t)}},{path:"/git/introduce/index.html",redirect:"/git/introduce/"},{path:"/40.工具/20.开发管理 - Git/01.Git - 介绍与安装.html",redirect:"/git/introduce/"},{name:"v-e278e442",path:"/pages/8bebf7/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-e278e442").then(t)}},{path:"/pages/8bebf7/index.html",redirect:"/pages/8bebf7/"},{path:"/20.JS/20.ES6/03.ES6之Promise与Class类.html",redirect:"/pages/8bebf7/"},{name:"v-615081d1",path:"/git/common-commands/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-615081d1").then(t)}},{path:"/git/common-commands/index.html",redirect:"/git/common-commands/"},{path:"/40.工具/20.开发管理 - Git/03.Git - 常用命令.html",redirect:"/git/common-commands/"},{name:"v-2882db09",path:"/git/basic-principles/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-2882db09").then(t)}},{path:"/git/basic-principles/index.html",redirect:"/git/basic-principles/"},{path:"/40.工具/20.开发管理 - Git/05.Git - 基本原理.html",redirect:"/git/basic-principles/"},{name:"v-6de5f26a",path:"/git/ssh-login/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-6de5f26a").then(t)}},{path:"/git/ssh-login/index.html",redirect:"/git/ssh-login/"},{path:"/40.工具/20.开发管理 - Git/07.Git - SSH免密登录.html",redirect:"/git/ssh-login/"},{name:"v-715f666a",path:"/git/idea/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-715f666a").then(t)}},{path:"/git/idea/index.html",redirect:"/git/idea/"},{path:"/40.工具/20.开发管理 - Git/09.Git - IDEA集成.html",redirect:"/git/idea/"},{name:"v-313dd5d4",path:"/git/commit-emo/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-313dd5d4").then(t)}},{path:"/git/commit-emo/index.html",redirect:"/git/commit-emo/"},{path:"/40.工具/20.开发管理 - Git/15.Git - Commit常用表情.html",redirect:"/git/commit-emo/"},{name:"v-3e18e141",path:"/pages/c87550/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-3e18e141").then(t)}},{path:"/pages/c87550/index.html",redirect:"/pages/c87550/"},{path:"/40.工具/20.开发管理 - Git/16.变更Git作者邮箱信息.html",redirect:"/pages/c87550/"},{name:"v-0e1882ae",path:"/git/built-code-platform/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-0e1882ae").then(t)}},{path:"/git/built-code-platform/index.html",redirect:"/git/built-code-platform/"},{path:"/40.工具/20.开发管理 - Git/11.Git - 自建代码托管平台.html",redirect:"/git/built-code-platform/"},{name:"v-77cb82b4",path:"/pages/c955d9/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-77cb82b4").then(t)}},{path:"/pages/c955d9/index.html",redirect:"/pages/c955d9/"},{path:"/40.工具/30.构建工具-webpack/01.Babel与webpack.html",redirect:"/pages/c955d9/"},{name:"v-66522d6e",path:"/more/feynmanLearningMethod/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-66522d6e").then(t)}},{path:"/more/feynmanLearningMethod/index.html",redirect:"/more/feynmanLearningMethod/"},{path:"/55.更多/01.学习/00.费曼学习法.html",redirect:"/more/feynmanLearningMethod/"},{name:"v-ccbc51b8",path:"/pages/e60c81/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-ccbc51b8").then(t)}},{path:"/pages/e60c81/index.html",redirect:"/pages/e60c81/"},{path:"/55.更多/01.学习/01.笔记方法.html",redirect:"/pages/e60c81/"},{name:"v-d19a1a44",path:"/pages/a8692ab3bdcb4588/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-d19a1a44").then(t)}},{path:"/pages/a8692ab3bdcb4588/index.html",redirect:"/pages/a8692ab3bdcb4588/"},{path:"/55.更多/01.学习/02.提高学习效率的策略.html",redirect:"/pages/a8692ab3bdcb4588/"},{name:"v-2dafa1e7",path:"/pages/996822b2a2ca6e3b/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-2dafa1e7").then(t)}},{path:"/pages/996822b2a2ca6e3b/index.html",redirect:"/pages/996822b2a2ca6e3b/"},{path:"/55.更多/01.学习/03.提高记忆的技巧.html",redirect:"/pages/996822b2a2ca6e3b/"},{name:"v-cb6ea65e",path:"/pages/c3f302a03c8daf79/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-cb6ea65e").then(t)}},{path:"/pages/c3f302a03c8daf79/index.html",redirect:"/pages/c3f302a03c8daf79/"},{path:"/55.更多/01.学习/04.自律小建议.html",redirect:"/pages/c3f302a03c8daf79/"},{name:"v-1c9909ea",path:"/pages/ce818a/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1c9909ea").then(t)}},{path:"/pages/ce818a/index.html",redirect:"/pages/ce818a/"},{path:"/55.更多/01.学习/10.搜索引擎使用技巧.html",redirect:"/pages/ce818a/"},{name:"v-3d06597e",path:"/advanced/4b2339/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-3d06597e").then(t)}},{path:"/advanced/4b2339/index.html",redirect:"/advanced/4b2339/"},{path:"/55.更多/02.进阶/01.JavaScript 的三座大山.html",redirect:"/advanced/4b2339/"},{name:"v-f6eeff0a",path:"/pages/9ba2b8fb13de1957/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-f6eeff0a").then(t)}},{path:"/pages/9ba2b8fb13de1957/index.html",redirect:"/pages/9ba2b8fb13de1957/"},{path:"/55.更多/01.学习/05.处理问题的思路.html",redirect:"/pages/9ba2b8fb13de1957/"},{name:"v-1641573c",path:"/pages/ed7042/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1641573c").then(t)}},{path:"/pages/ed7042/index.html",redirect:"/pages/ed7042/"},{path:"/55.更多/02.进阶/07.「硬核JS」垃圾回收机制.html",redirect:"/pages/ed7042/"},{name:"v-79fd1563",path:"/advanced/55c2e0/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-79fd1563").then(t)}},{path:"/advanced/55c2e0/index.html",redirect:"/advanced/55c2e0/"},{path:"/55.更多/02.进阶/10.Javascript 定时器应用技巧讲解.html",redirect:"/advanced/55c2e0/"},{name:"v-104cfd4b",path:"/advanced/0735ac/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-104cfd4b").then(t)}},{path:"/advanced/0735ac/index.html",redirect:"/advanced/0735ac/"},{path:"/55.更多/02.进阶/20.FormData 配合 ajax 异步无刷新上传表格数据.html",redirect:"/advanced/0735ac/"},{name:"v-499dee9f",path:"/advanced/39134a/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-499dee9f").then(t)}},{path:"/advanced/39134a/index.html",redirect:"/advanced/39134a/"},{path:"/55.更多/02.进阶/30.使用git命令行，删除远程分支上的文件or文件夹.html",redirect:"/advanced/39134a/"},{name:"v-c52e6f90",path:"/pages/3190e5/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-c52e6f90").then(t)}},{path:"/pages/3190e5/index.html",redirect:"/pages/3190e5/"},{path:"/55.更多/02.进阶/31.git push到远程指定分支(git拉取指定分支代码).html",redirect:"/pages/3190e5/"},{name:"v-f52fa3a8",path:"/pages/1130ec/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-f52fa3a8").then(t)}},{path:"/pages/1130ec/index.html",redirect:"/pages/1130ec/"},{path:"/55.更多/02.进阶/32.如何快速关联及修改Git远程仓库地址.html",redirect:"/pages/1130ec/"},{name:"v-2b3bacab",path:"/pages/77f5b4/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-2b3bacab").then(t)}},{path:"/pages/77f5b4/index.html",redirect:"/pages/77f5b4/"},{path:"/55.更多/02.进阶/41.后端一次性返回我10万条数据的8种解决方案.html",redirect:"/pages/77f5b4/"},{name:"v-28360899",path:"/advanced/6f6d13/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-28360899").then(t)}},{path:"/advanced/6f6d13/index.html",redirect:"/advanced/6f6d13/"},{path:"/55.更多/02.进阶/42.虚拟列表，我真的会了！！！.html",redirect:"/advanced/6f6d13/"},{name:"v-efaad25e",path:"/pages/39df27/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-efaad25e").then(t)}},{path:"/pages/39df27/index.html",redirect:"/pages/39df27/"},{path:"/55.更多/02.进阶/43.Vue中实现右键自定义菜单.html",redirect:"/pages/39df27/"},{name:"v-9bc8aa68",path:"/advanced/e561b0/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-9bc8aa68").then(t)}},{path:"/advanced/e561b0/index.html",redirect:"/advanced/e561b0/"},{path:"/55.更多/02.进阶/50.面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见.html",redirect:"/advanced/e561b0/"},{name:"v-21b79325",path:"/pages/08929e/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-21b79325").then(t)}},{path:"/pages/08929e/index.html",redirect:"/pages/08929e/"},{path:"/55.更多/02.进阶/44.大文件上传技术实现.html",redirect:"/pages/08929e/"},{name:"v-7be86aa5",path:"/pages/a7d5db/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-7be86aa5").then(t)}},{path:"/pages/a7d5db/index.html",redirect:"/pages/a7d5db/"},{path:"/55.更多/02.进阶/61.移动端H5-iPhone安全距离适配.html",redirect:"/pages/a7d5db/"},{name:"v-45374f90",path:"/pages/4546c7/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-45374f90").then(t)}},{path:"/pages/4546c7/index.html",redirect:"/pages/4546c7/"},{path:"/55.更多/02.进阶/60.移动端适配方案.html",redirect:"/pages/4546c7/"},{name:"v-63b092c7",path:"/pages/587043/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-63b092c7").then(t)}},{path:"/pages/587043/index.html",redirect:"/pages/587043/"},{path:"/55.更多/02.进阶/62.H5页面高德定位打卡功能.html",redirect:"/pages/587043/"},{name:"v-6369ee9a",path:"/pages/26cc37/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-6369ee9a").then(t)}},{path:"/pages/26cc37/index.html",redirect:"/pages/26cc37/"},{path:"/55.更多/05.技术面/02.CSS.html",redirect:"/pages/26cc37/"},{name:"v-5fb11738",path:"/pages/e4dc2c/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5fb11738").then(t)}},{path:"/pages/e4dc2c/index.html",redirect:"/pages/e4dc2c/"},{path:"/55.更多/05.技术面/01.JS.html",redirect:"/pages/e4dc2c/"},{name:"v-16dd473a",path:"/more/interview-vue/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-16dd473a").then(t)}},{path:"/more/interview-vue/index.html",redirect:"/more/interview-vue/"},{path:"/55.更多/05.技术面/04.Vue.html",redirect:"/more/interview-vue/"},{name:"v-6a2bce46",path:"/more/interview/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-6a2bce46").then(t)}},{path:"/more/interview/index.html",redirect:"/more/interview/"},{path:"/55.更多/04.面试/01.面试问题集锦.html",redirect:"/more/interview/"},{name:"v-c17e9308",path:"/pages/d178b0/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-c17e9308").then(t)}},{path:"/pages/d178b0/index.html",redirect:"/pages/d178b0/"},{path:"/55.更多/05.技术面/03.浏览器&http.html",redirect:"/pages/d178b0/"},{name:"v-4df113c3",path:"/pages/3d4029/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-4df113c3").then(t)}},{path:"/pages/3d4029/index.html",redirect:"/pages/3d4029/"},{path:"/55.更多/05.技术面/07.new vue主体流程.html",redirect:"/pages/3d4029/"},{name:"v-751178aa",path:"/navigation/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-751178aa").then(t)}},{path:"/navigation/index.html",redirect:"/navigation/"},{path:"/01.导航站.html",redirect:"/navigation/"},{name:"v-14bf4ff7",path:"/friends/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-14bf4ff7").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/55.更多/99.友情连接.html",redirect:"/friends/"},{name:"v-8efda230",path:"/pages/053424/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-8efda230").then(t)}},{path:"/pages/053424/index.html",redirect:"/pages/053424/"},{path:"/55.更多/05.技术面/08.Vue2响应式源码.html",redirect:"/pages/053424/"},{name:"v-82f6dcc4",path:"/pages/e1d719/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-82f6dcc4").then(t)}},{path:"/pages/e1d719/index.html",redirect:"/pages/e1d719/"},{path:"/55.更多/05.技术面/09.Vue2 Diff 算法.html",redirect:"/pages/e1d719/"},{name:"v-14211e26",path:"/whell/web/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-14211e26").then(t)}},{path:"/whell/web/index.html",redirect:"/whell/web/"},{path:"/75.收藏夹/01.网站轮子.html",redirect:"/whell/web/"},{name:"v-354f58fa",path:"/whell/front/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-354f58fa").then(t)}},{path:"/whell/front/index.html",redirect:"/whell/front/"},{path:"/75.收藏夹/02.前端轮子.html",redirect:"/whell/front/"},{name:"v-09f97d06",path:"/plugins/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-09f97d06").then(t)}},{path:"/plugins/index.html",redirect:"/plugins/"},{path:"/75.收藏夹/03.插件选择.html",redirect:"/plugins/"},{name:"v-5d5b1b5c",path:"/about/me/introduce/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5d5b1b5c").then(t)}},{path:"/about/me/introduce/index.html",redirect:"/about/me/introduce/"},{path:"/80.关于/03.关于 - 自我/02.自我 - 介绍.html",redirect:"/about/me/introduce/"},{name:"v-7f849213",path:"/about/learn-line/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-7f849213").then(t)}},{path:"/about/learn-line/index.html",redirect:"/about/learn-line/"},{path:"/80.关于/03.关于 - 自我/07.自我 - 学习线.html",redirect:"/about/learn-line/"},{name:"v-7c7210d4",path:"/about/qin-yu/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-7c7210d4").then(t)}},{path:"/about/qin-yu/index.html",redirect:"/about/qin-yu/"},{path:"/80.关于/03.关于 - 自我/09.自我 - 尊贵公子.html",redirect:"/about/qin-yu/"},{name:"v-66b3d6ef",path:"/about/liang-shi-bo/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-66b3d6ef").then(t)}},{path:"/about/liang-shi-bo/index.html",redirect:"/about/liang-shi-bo/"},{path:"/80.关于/03.关于 - 自我/11.自我 - 温润少年.html",redirect:"/about/liang-shi-bo/"},{name:"v-5df3ba47",path:"/about/list/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5df3ba47").then(t)}},{path:"/about/list/index.html",redirect:"/about/list/"},{path:"/80.关于/03.关于 - 自我/05.自我 - 清单.html",redirect:"/about/list/"},{name:"v-5fd17c76",path:"/about/website/introduce/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5fd17c76").then(t)}},{path:"/about/website/introduce/index.html",redirect:"/about/website/introduce/"},{path:"/80.关于/06.关于 - 本站/01.本站 - 介绍.html",redirect:"/about/website/introduce/"},{name:"v-597ab59a",path:"/about/me/explain/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-597ab59a").then(t)}},{path:"/about/me/explain/index.html",redirect:"/about/me/explain/"},{path:"/80.关于/03.关于 - 自我/13.自我 - 说明.html",redirect:"/about/me/explain/"},{name:"v-6566d8f7",path:"/about/website/plan/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-6566d8f7").then(t)}},{path:"/about/website/plan/index.html",redirect:"/about/website/plan/"},{path:"/80.关于/06.关于 - 本站/02.本站 - 规划.html",redirect:"/about/website/plan/"},{name:"v-50562c58",path:"/about/website/build/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-50562c58").then(t)}},{path:"/about/website/build/index.html",redirect:"/about/website/build/"},{path:"/80.关于/06.关于 - 本站/05.本站 - 搭建.html",redirect:"/about/website/build/"},{name:"v-1effc226",path:"/about/website/theme/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1effc226").then(t)}},{path:"/about/website/theme/index.html",redirect:"/about/website/theme/"},{path:"/80.关于/06.关于 - 本站/07.本站 - 主题.html",redirect:"/about/website/theme/"},{name:"v-3fcbe812",path:"/about/website/deploy/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-3fcbe812").then(t)}},{path:"/about/website/deploy/index.html",redirect:"/about/website/deploy/"},{path:"/80.关于/06.关于 - 本站/10.本站 - 网站部署.html",redirect:"/about/website/deploy/"},{name:"v-1980a5d5",path:"/about/website/server/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1980a5d5").then(t)}},{path:"/about/website/server/index.html",redirect:"/about/website/server/"},{path:"/80.关于/06.关于 - 本站/12.本站 - 服务器部署.html",redirect:"/about/website/server/"},{name:"v-fe63d31a",path:"/about/website/style/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-fe63d31a").then(t)}},{path:"/about/website/style/index.html",redirect:"/about/website/style/"},{path:"/80.关于/06.关于 - 本站/18.本站 - 自定义样式模块.html",redirect:"/about/website/style/"},{name:"v-1ecc7688",path:"/about/website/comment/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1ecc7688").then(t)}},{path:"/about/website/comment/index.html",redirect:"/about/website/comment/"},{path:"/80.关于/06.关于 - 本站/14.本站 - 评论模块.html",redirect:"/about/website/comment/"},{name:"v-0367b534",path:"/about/website/lastReading/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-0367b534").then(t)}},{path:"/about/website/lastReading/index.html",redirect:"/about/website/lastReading/"},{path:"/80.关于/06.关于 - 本站/20.本站 - 记录阅读文章模块.html",redirect:"/about/website/lastReading/"},{name:"v-60ac27e4",path:"/about/website/info/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-60ac27e4").then(t)}},{path:"/about/website/info/index.html",redirect:"/about/website/info/"},{path:"/80.关于/06.关于 - 本站/16.本站 - 站点信息模块.html",redirect:"/about/website/info/"},{name:"v-798ab013",path:"/about/website/private/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-798ab013").then(t)}},{path:"/about/website/private/index.html",redirect:"/about/website/private/"},{path:"/80.关于/06.关于 - 本站/22.本站 - 私密文章模块.html",redirect:"/about/website/private/"},{name:"v-11e8e024",path:"/about/website/tools/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-11e8e024").then(t)}},{path:"/about/website/tools/index.html",redirect:"/about/website/tools/"},{path:"/80.关于/06.关于 - 本站/24.本站 - 导航站模块.html",redirect:"/about/website/tools/"},{name:"v-27fb31be",path:"/about/website/code-block-hidden/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-27fb31be").then(t)}},{path:"/about/website/code-block-hidden/index.html",redirect:"/about/website/code-block-hidden/"},{path:"/80.关于/06.关于 - 本站/28.本站 - 代码块隐藏模块.html",redirect:"/about/website/code-block-hidden/"},{name:"v-98bdb7cc",path:"/about/website/index-big-img/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-98bdb7cc").then(t)}},{path:"/about/website/index-big-img/index.html",redirect:"/about/website/index-big-img/"},{path:"/80.关于/06.关于 - 本站/26.本站 - 首页大图模块.html",redirect:"/about/website/index-big-img/"},{name:"v-50e5c0bc",path:"/about/website/global-tip/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-50e5c0bc").then(t)}},{path:"/about/website/global-tip/index.html",redirect:"/about/website/global-tip/"},{path:"/80.关于/06.关于 - 本站/30.本站 - 全局时间提示模块.html",redirect:"/about/website/global-tip/"},{name:"v-1bce0795",path:"/about/index/younngkbt/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1bce0795").then(t)}},{path:"/about/index/younngkbt/index.html",redirect:"/about/index/younngkbt/"},{path:"/80.关于/08.关于 - 首页/02.首页 - 部署.html",redirect:"/about/index/younngkbt/"},{name:"v-222a195f",path:"/about/index/download/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-222a195f").then(t)}},{path:"/about/index/download/index.html",redirect:"/about/index/download/"},{path:"/80.关于/08.关于 - 首页/04.首页 - 下载站点.html",redirect:"/about/index/download/"},{name:"v-004ed419",path:"/about/typesetting/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-004ed419").then(t)}},{path:"/about/typesetting/index.html",redirect:"/about/typesetting/"},{path:"/80.关于/09.关于 - 技巧/04.技巧 - 排版.html",redirect:"/about/typesetting/"},{name:"v-c0cdc776",path:"/posts/category/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-c0cdc776").then(t)}},{path:"/posts/category/index.html",redirect:"/posts/category/"},{path:"/80.关于/12.关于 - 随笔/01.随笔 - 目录.html",redirect:"/posts/category/"},{name:"v-0843e2a1",path:"/about/mdskill/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-0843e2a1").then(t)}},{path:"/about/mdskill/index.html",redirect:"/about/mdskill/"},{path:"/80.关于/09.关于 - 技巧/02.技巧 - 笔记.html",redirect:"/about/mdskill/"},{name:"v-211f711c",path:"/private/test1/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-211f711c").then(t)}},{path:"/private/test1/index.html",redirect:"/private/test1/"},{path:"/90.私密文章测试/01.全局私密文章测试.html",redirect:"/private/test1/"},{name:"v-31fbd7e5",path:"/private/test2/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-31fbd7e5").then(t)}},{path:"/private/test2/index.html",redirect:"/private/test2/"},{path:"/90.私密文章测试/03.单个私密文章测试.html",redirect:"/private/test2/"},{name:"v-6ef34192",path:"/message-area/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-6ef34192").then(t)}},{path:"/message-area/index.html",redirect:"/message-area/"},{path:"/90.本站 - 留言区.html",redirect:"/message-area/"},{name:"v-528260fe",path:"/vdoing/login/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-528260fe").then(t)}},{path:"/vdoing/login/index.html",redirect:"/vdoing/login/"},{path:"/99.Vdoing私密文章登录.html",redirect:"/vdoing/login/"},{name:"v-1760b555",path:"/github/index/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1760b555").then(t)}},{path:"/github/index/index.html",redirect:"/github/index/"},{path:"/_posts/技术随笔/Github - 好看的主页.html",redirect:"/github/index/"},{name:"v-0574d59f",path:"/categories/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-0574d59f").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-7f6d28b2",path:"/360/system/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-7f6d28b2").then(t)}},{path:"/360/system/index.html",redirect:"/360/system/"},{path:"/_posts/技术随笔/技术随笔 - 360天擎关闭.html",redirect:"/360/system/"},{name:"v-57a8012f",path:"/right-click/idea-vscode/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-57a8012f").then(t)}},{path:"/right-click/idea-vscode/index.html",redirect:"/right-click/idea-vscode/"},{path:"/_posts/技术随笔/右键打开 IDEA 和 VSCode.html",redirect:"/right-click/idea-vscode/"},{name:"v-24efff4c",path:"/java/d/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-24efff4c").then(t)}},{path:"/java/d/index.html",redirect:"/java/d/"},{path:"/_posts/技术随笔/技术随笔 - Java启动的-D参数.html",redirect:"/java/d/"},{name:"v-78bd3772",path:"/domain/name/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-78bd3772").then(t)}},{path:"/domain/name/index.html",redirect:"/domain/name/"},{path:"/_posts/技术随笔/技术随笔 - 域名解析.html",redirect:"/domain/name/"},{name:"v-7c27afd4",path:"/live-posts/habit/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-7c27afd4").then(t)}},{path:"/live-posts/habit/index.html",redirect:"/live-posts/habit/"},{path:"/_posts/生活随笔/生活随笔 - 习惯.html",redirect:"/live-posts/habit/"},{name:"v-5f4699cc",path:"/live-posts/beautiful-words/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-5f4699cc").then(t)}},{path:"/live-posts/beautiful-words/index.html",redirect:"/live-posts/beautiful-words/"},{path:"/_posts/生活随笔/生活随笔 - 美词.html",redirect:"/live-posts/beautiful-words/"},{name:"v-1179473f",path:"/archives/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-1179473f").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-dfe9f282",path:"/tags/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-dfe9f282").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-543ef8d8",path:"/",component:sl,beforeEnter:(n,e,t)=>{us("Layout","v-543ef8d8").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:sl}],cl={title:"",description:"",base:"/",headTags:[["link",{rel:"shortcut icon",href:"/img/favicon.ico"}],["link",{rel:"stylesheet",href:"//at.alicdn.com/t/font_3114978_qe0b39no76.css"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["noscript",{},'<meta http-equiv="refresh" content="0; url=https://www.youngkbt.cn/noscript/"><style>.theme-vdoing-content { display:none }'],["meta",{name:"keywords",content:"Young Kbt个人博客, VuePress搭建, 学习Java、Web、框架、微服务、工具、前端等相关知识, 记录生活和技术路程。"}],["meta",{name:"theme-color",content:"#11a8cd"}],["script",{src:"https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js"}],["script",{},'var _hmt = _hmt || [];\n          (function() {\n            var hm = document.createElement("script");\n            hm.src = "https://hm.baidu.com/hm.js?267c5680c2ffb468ca29c45ffe6801da"; \n            var s = document.getElementsByTagName("script")[0];\n            s.parentNode.insertBefore(hm, s);\n          })();\n          ']],pages:[{title:"工具 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"40.工具",imgUrl:"/img/catalogue/default.png",description:"编程常用管理工具，包括部署工具等相关知识。"}},title:"工具 - 知识体系",date:"2021-10-21T16:48:47.000Z",permalink:"/tool/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/10.%E5%B7%A5%E5%85%B7%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/00.导航栏 - 目录页/10.工具 - 知识体系.md",key:"v-afcb83d6",path:"/tool/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"前端 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端基础",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"前端 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/basics/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/15.%E5%89%8D%E7%AB%AF%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/00.导航栏 - 目录页/15.前端 - 知识体系.md",key:"v-d24fe506",path:"/basics/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"前端 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.JS",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"前端 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/javascript/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/17.JS%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/00.导航栏 - 目录页/17.JS - 知识体系.md",key:"v-66492ece",path:"/javascript/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"更多 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"55.更多",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"更多 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/00.%E5%AF%BC%E8%88%AA%E6%A0%8F%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/88.%E6%9B%B4%E5%A4%9A%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/00.导航栏 - 目录页/88.更多 - 知识体系.md",key:"v-675813ce",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"JS基础 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"20.JS/10.基础",imgUrl:"/img/catalogue/default.png",description:"Maven 是最流行的 Java 项目构建系统JavaScript（简称“JS”）是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。"}},title:"JS基础 - 知识体系",date:"2021-11-25T18:49:44.000Z",permalink:"/JSbasics/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.JS%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%9F%BA%E7%A1%80%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/03.JS - 目录页/01.基础 - 知识体系.md",key:"v-478ae4fa",path:"/JSbasics/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/25, 01:19:49",lastUpdatedTimestamp:1682356789e3},{title:"ES6 - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"20.JS/20.ES6",imgUrl:"/img/catalogue/default.png",description:"ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。另外，一些情况下ES6也泛指ES2015及之后的新增特性，虽然之后的版本应当称为ES7、ES8等。"}},title:"ES6 - 知识体系",date:"2021-11-25T18:49:44.000Z",permalink:"/JS-ES6/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.JS%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/02.ES6%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/03.JS - 目录页/02.ES6 - 知识体系.md",key:"v-4c983d83",path:"/JS-ES6/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/25, 01:19:49",lastUpdatedTimestamp:1682356789e3},{title:"Webpack - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"40.工具/30.构建工具-webpack",imgUrl:"/img/catalogue/default.png",description:"webpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。"}},title:"Webpack - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/webpack/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/12.%E5%B7%A5%E5%85%B7%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/03.Webpack%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/12.工具 - 目录页/03.Webpack - 知识体系.md",key:"v-299b6b72",path:"/webpack/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/25, 01:19:49",lastUpdatedTimestamp:1682356789e3},{title:"Git - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"55.更多/02.进阶",imgUrl:"/img/catalogue/default.png",description:"Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。"}},title:"Git - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/more/advanced/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/17.%E6%9B%B4%E5%A4%9A%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E8%BF%9B%E9%98%B6%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/17.更多 - 目录页/03.进阶 - 知识体系.md",key:"v-190f784c",path:"/more/advanced/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/04, 20:43:29",lastUpdatedTimestamp:1680612209e3},{title:"HTML",frontmatter:{title:"HTML",date:"2020-04-04T15:15:03.000Z",permalink:"/basics/HTML/",categories:["前端基础","HTML"],tags:[null],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/01.HTML/01.HTML.html",relativePath:"01.前端基础/01.HTML/01.HTML.md",key:"v-891c8d58",path:"/basics/HTML/",headers:[{level:2,title:"1.1标题标签",slug:"_1-1标题标签",normalizedTitle:"1.1标题标签",charIndex:319},{level:2,title:"1.2段落和换行标签",slug:"_1-2段落和换行标签",normalizedTitle:"1.2段落和换行标签",charIndex:428},{level:2,title:"1.3文本格式化标签",slug:"_1-3文本格式化标签",normalizedTitle:"1.3文本格式化标签",charIndex:603},{level:2,title:"1.4 <div>和<span>标签(语义化标签)",slug:"_1-4-div-和-span-标签-语义化标签",normalizedTitle:"1.4 <div>和<span>标签(语义化标签)",charIndex:941},{level:2,title:"1.5图像、音视频标签、路径",slug:"_1-5图像、音视频标签、路径",normalizedTitle:"1.5图像、音视频标签、路径",charIndex:1460},{level:3,title:"图片标签",slug:"图片标签",normalizedTitle:"图片标签",charIndex:1492},{level:3,title:"音视频标签",slug:"音视频标签",normalizedTitle:"音视频标签",charIndex:1466},{level:2,title:"1.6 超链接",slug:"_1-6-超链接",normalizedTitle:"1.6 超链接",charIndex:1844},{level:2,title:"1.7锚点链接",slug:"_1-7锚点链接",normalizedTitle:"1.7锚点链接",charIndex:2186},{level:2,title:"3.1 无序列表",slug:"_3-1-无序列表",normalizedTitle:"3.1 无序列表",charIndex:2357},{level:2,title:"3.2 有序列表",slug:"_3-2-有序列表",normalizedTitle:"3.2 有序列表",charIndex:2810},{level:2,title:"2.7.3 自定义列表",slug:"_2-7-3-自定义列表",normalizedTitle:"2.7.3 自定义列表",charIndex:3227},{level:2,title:"4.1 表格的标题和表头单元格标签",slug:"_4-1-表格的标题和表头单元格标签",normalizedTitle:"4.1 表格的标题和表头单元格标签",charIndex:3562},{level:2,title:"4.2 表格的基本用法",slug:"_4-2-表格的基本用法",normalizedTitle:"4.2 表格的基本用法",charIndex:3762},{level:2,title:"4.3 表头单元格标签",slug:"_4-3-表头单元格标签",normalizedTitle:"4.3 表头单元格标签",charIndex:4061},{level:2,title:"4.4 表格属性",slug:"_4-4-表格属性",normalizedTitle:"4.4 表格属性",charIndex:4306},{level:2,title:"4.5 表格结构标签",slug:"_4-5-表格结构标签",normalizedTitle:"4.5 表格结构标签",charIndex:5127},{level:2,title:"4.6 合并单元格",slug:"_4-6-合并单元格",normalizedTitle:"4.6 合并单元格",charIndex:5817},{level:2,title:"5.1 表单的组成",slug:"_5-1-表单的组成",normalizedTitle:"5.1 表单的组成",charIndex:6584},{level:2,title:"*5.2 表单域",slug:"_5-2-表单域",normalizedTitle:"*5.2 表单域",charIndex:6652},{level:2,title:"5.3 input系列标签的基本介绍",slug:"_5-3-input系列标签的基本介绍",normalizedTitle:"5.3 input系列标签的基本介绍",charIndex:7642},{level:2,title:"5.4 input系列标签-文本框",slug:"_5-4-input系列标签-文本框",normalizedTitle:"5.4 input系列标签-文本框",charIndex:8027},{level:2,title:"5.5 input系列标签-单选框",slug:"_5-5-input系列标签-单选框",normalizedTitle:"5.5 input系列标签-单选框",charIndex:8316},{level:2,title:"5.6 input系列标签-文件选择",slug:"_5-6-input系列标签-文件选择",normalizedTitle:"5.6 input系列标签-文件选择",charIndex:8717},{level:2,title:"5.7 input系列标签-上传",slug:"_5-7-input系列标签-上传",normalizedTitle:"5.7 input系列标签-上传",charIndex:8813},{level:2,title:"5.8 button按钮标签",slug:"_5-8-button按钮标签",normalizedTitle:"5.8 button按钮标签",charIndex:9058},{level:2,title:"5.9 select下拉菜单",slug:"_5-9-select下拉菜单",normalizedTitle:"5.9 select下拉菜单",charIndex:9509},{level:2,title:"5.10 textarea文本标签",slug:"_5-10-textarea文本标签",normalizedTitle:"5.10 textarea文本标签",charIndex:9798},{level:2,title:"5.11 label标签",slug:"_5-11-label标签",normalizedTitle:"5.11 label标签",charIndex:9953}],headersStr:"1.1标题标签 1.2段落和换行标签 1.3文本格式化标签 1.4 <div>和<span>标签(语义化标签) 1.5图像、音视频标签、路径 图片标签 音视频标签 1.6 超链接 1.7锚点链接 3.1 无序列表 3.2 有序列表 2.7.3 自定义列表 4.1 表格的标题和表头单元格标签 4.2 表格的基本用法 4.3 表头单元格标签 4.4 表格属性 4.5 表格结构标签 4.6 合并单元格 5.1 表单的组成 *5.2 表单域 5.3 input系列标签的基本介绍 5.4 input系列标签-文本框 5.5 input系列标签-单选框 5.6 input系列标签-文件选择 5.7 input系列标签-上传 5.8 button按钮标签 5.9 select下拉菜单 5.10 textarea文本标签 5.11 label标签",content:'# 快捷键\n\n功能            按键\n向下复制          shift+alt>+↓\n单行注释          ctrl+/\n多行注释          alt+shift+A\n缩进            Tab\n回缩            shift+Tab\n移动行上下         Alt + ↑或 ↓\n删除行           Ctrl + Shift + K\n在当前行下插入新的一行   Ctrl + Enter\n在当前行上插入新的一行   Ctrl + Shift + Enter\n\n----------------------------------------\n\n\n# 一、HTML常用标签\n\n\n# 1.1标题标签\n\nHTML提供了6个等级的网页标题，即: <h1>到<h6>。\n\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n\n\n1\n2\n3\n\n\n> 单词head的缩写\n\n\n# 1.2段落和换行标签\n\n在网页中，要把文字有条理的展示出来，就需要用到分段。<p>用于将网页分为若干个段落。\n\n<p>这是一个段落</p>\n\n\n1\n\n\n> 单词pargraph的缩写\n\n强制某段文字换行使用<br>。\n\n<br>\n\n\n1\n\n\n> 单词break的缩写，以为：打断、换行\n\n注意：<br>是单标签。\n\n水平分割线：<hr>\n\n\n\n\n# 1.3文本格式化标签\n\n在网页中，有时会为文字设置粗体、斜体、下划线等标签，这时就需要文本格式化标签。是文字以特殊方式展示。\n\n语义    标签\n加粗    <strong> </strong>或<b> </b>\n倾斜    <em> </em>或<i> </i>\n删除线   <del> </del>或<s> </s>\n下划线   <ins> </ins>或<u> </u>\n\n注意：<em> 标签不只是单纯的用于倾斜文本，其核心的意义在于对元素进行强调！所以在后期的开发中可以把一些特殊性、强调性的元素放在 em 标签中，然后再对 em 这个盒子进行样式设置，这比把其放入其他盒子（如：span）中要更合理，同理<strong> 标签页适合放一些重点强调的元素。\n\n\n# 1.4 <div>和<span>标签(语义化标签)\n\n<div> 和 <span> 是没有语义的，它们就是两种盒子，用来对网页进行布局和装其他内容。\n\n<div>这是头部</div>\n<span>今日价格</span>\n\n\n1\n2\n\n\n> div 是 division 的缩写表示：分割、分区。\n\n> span 意为：跨度、跨距。\n\n特点：\n\n * <div> 标签用来布局，一行只能放一个 <div>，大盒子\n * <span> 标签用来布局，一行上可以放多个 <span>，小盒子\n\n**说明：**后期可以通过 CSS 将 div 与 span 之间的特性相互转换。\n\n拓展： span 标签不单单是用于布局，对于一些需要单独修饰和设置的元素，可以将其用 span 标签嵌套起来，然后就可以单独对其进行设置（比如：在一个 p 标签的段落中要对其中某一句话单独设置样式，那么就可以用 span 将这句话单独嵌套起来，这样就方便对其单独设置样式还不会影响段落中的其他内容，这其实也是利用了 span 一行可以放置多个盒子的特性），不过对于特殊且具有强调性的元素建议使用 em，对于重点强调但不特殊的的元素建议使用 strong。\n\n\n# 1.5图像、音视频标签、路径\n\n同级./ 上级 ../\n\n\n# 图片标签\n\nalt属性：图片无法读取时显示的提示性文本\n\ntitle属性：鼠标悬停时显示\n\n\n# 音视频标签\n\n音频 audio controls\n\n视频video controls\n\n属性名        功能\nsrc        路径\ncontrols   显示播放的控件\nautoplay   自动播放（高版本浏览器不可用）\nloop       循环播放\nmuted      视频静音播放，解决高版本浏览器自动播放失败\n\n\x3c!-- 谷歌浏览区可以让视频自动播放， 但是必须是静音状态muted --\x3e\n    <video src="./艳火 - 张悬 - 高清MV - 网易云音乐.mp4" controls autoplay muted loop></video>\n\n\n1\n2\n\n\n\n# 1.6 超链接\n\ntarget属性，默认值是_self,在当前窗口跳转，覆盖原网页；改为_blank后在新窗口跳转，保留原网页。\n\n \x3c!-- href：跳转地址   --\x3e\n    \n    <a href="https://www.baidu.com/" target="_blank">跳转到百度</a>\n    \n    <br>\n\n    <a href="./10.音频.html">跳转到音频</a>\n   \n    <br>\n    \n    <a href="#">空链接</a>\n   \n    \x3c!-- 当开发网站的初期，我们还不知道跳转地址的时候，href的值写为#（空链接） --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1.7锚点链接\n\n作用：实现页面内部的跳转，快速访问某一位置\n\n实现的步骤：\n\n01.找到要跳转的位置，用id标记；\n\n<a href="#mao1">跳转到基本信息</a>\n\n\n1\n\n\n02.设置超链接a的href的取值为#id;\n\n<h3 id="mao1">基本信息</h3>\n\n\n1\n\n\n\n# 二、注释\n\n\n# 三、列表标签\n\n\n# 3.1 无序列表\n\n<ul> 标签表示 HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <li> 标签定义（开发中经常使用）。\n\n无序列表的基本语法格式如下：\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n    ...\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n\n * 无序列表的各个列表项之间没有顺序级别之分，是并列的\n * <ul> </ul> 中只能嵌套 <li> </li>，直接在 <ul> </ul> 标签中输入其他标签或者文字的做法是不被允许的，列表中的任何内容都应该放在 li 中\n * <li> 与 </li> 之间相当于一个容器，可以容纳所有的元素\n * 无序列表会带有自己的样式属性（比如圆点），但在实际开发中，我们会使用 CSS 来设置\n * 实际使用中最好嵌套 div,方便控制样式\n\n> 附：去除 li 前符号的方法：style="list-style: none;"\n\n\n# 3.2 有序列表\n\n有序列表即为有序排列顺序的列表，其各个列表项会按照一定的顺序排列定义（开发中不太常用）。\n\n在 HTML 标签中，<ol> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <li> 标签来定义列表项。\n\n有序列表的基本语法格式如下：\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n    ...\n</ol>\n\n\n1\n2\n3\n4\n5\n6\n\n * <ol> </ol> 中只能嵌套 <li> </li>，直接在 <ol> </ol> 标签中输入其他标签或者文字的做法是不被允许的\n * <li> 与 </li> 之间相当于一个容器，可以容纳所有的元素\n * 有序列表会带有自己样式属性（比如序号），但在实际使用时，我们会使用 CSS 来设置\n\n> 附：去除 li 前符号的方法：style="list-style: none;"\n\n\n# 2.7.3 自定义列表\n\n自定义列表的使用场景：\n\n自定义列表常用于对术语或名词进行解释、描述和展开，定义列表的列表项前没有任何项目符号（开发中常用）。\n\n在 HTML 标签中，<dl> 标签用于定义描述列表（或定义列表），该标签会与 <dt>（定义项目/名字）和 <dd>（描述每一个项目/名字）一起使用。\n\n其基本语法如下：\n\n<dl>\n    <dt>名词1</dt>\n    <dd>名词1解释1</dd>\n    <dd>名词1解释2</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n\n * <dl> </dl> 里面只包含 <dt>、<dd>\n * <dt> 和 <dd> 个数没有限制，经常是一个 <dt> 对应多个 <dd>\n\n\n# 四、表格标签\n\n\n# 4.1 表格的标题和表头单元格标签\n\n场景： 在表格中展示整体大标题和一列小标题\n\n标签：\n\n标签名       名称      说明\ncaption   表格大标题   默认在表格整体顶部居中展示\nth        表头单元格   常用于表格第一格，默认文字加粗居中展示\n\n注意点：\n\n * caption标签书写在table标签内部\n * th书签写在tr标签内部（用于替换td标签）\n\n\n# 4.2 表格的基本用法\n\n<table>\n    <tr>\n        <td>单元格</td>\n        ...\n    </tr>\n    ...\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * <table> </table> 是用于定义表格的标签\n * <tr> </tr> 用于定义表格中的行，必须嵌套在 <table> </table> 标签中\n * <td> </td> 用于定义表格中的单元格，必须嵌套在 <tr> </tr> 标签中\n * 字母 td 指表格数据（table data），即：数据单元格的内容\n * 单元格 td 里面可以放任何的元素\n\n\n# 4.3 表头单元格标签\n\n一般表头单元格位于表格的第一行或第一列，作用是：突出重要性，表头单元格里面的文本内容默认加粗居中显示。\n\n<th> 标签表示 HTML 表格的表头部分（table head 的缩写）。\n\n<table>\n    <tr>\n    \t<th>姓名</th>\n        <th>性别</th>\n        <th>年龄</th>\n        ...\n    </tr>\n    ...\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.4 表格属性\n\n**注意：**表格标签的属性在实际开发中并不常用，而是通过后面的 CSS 来设置，这里了解即可。\n\n以下属性都写在 table 开始标签内，多个属性之间用空格隔开。\n\n<table align="center" border="1" cellpadding="0" cellspacing="0" width="500" height="240">\n    ...\n</table>\n\n\n1\n2\n3\n\n\n属性名           属性值                 描述\nalign         left、center、right   规定表格相对周围元素的对齐方式（默认\n                                  left），注意指的是整个表格的对齐方式（表格是在父盒子中默认往左靠，还是居中或是往右靠），而不是指单元格内容的对齐方式（单元格内容对齐可以通过：style="text-align:\n                                  center;" 设置）（了解）\nborder        1 或 ""              规定表格单元是否拥有边框，默认为 ""，表示没有边框（了解）\ncellpadding   像素值                 规定单元边沿与其内容之间的空白，默认 1 像素（了解）\ncellspacing   像素值                 规定单元格之间的空白，默认 2 像素（了解）\nwidth         像素值 或 百分比           规定表格的宽度（了解）\nheight        像素值 或 百分比           规定表格的高度（了解）\nRules         All                 取值为all，就可以实现细线表格样式，后期用css实现\n\n\n# 4.5 表格结构标签\n\n**使用场景：**因为表格可能很长，为了更好的表示表格的语义，可以将表格分割成：表格头部 和 表格主体 两大部分。\n\n在表格标签中，分别用：<thead> 标签表示表格的头部区域，<tbody> 标签表示表格的主体区域，这样可以更好的分清表格结构。\n\n * <thead> </thead>：用于定义表格的头部，<thead> 内部必须拥有 <tr> 标签，一般是位于第一行，且一般 <tr> 标签中推荐放置 <th> 标签\n * <tbody> </tbody>：用于定义表格的主体，主要用于放数据本体\n * 以上标签都是放在 <table> </table> 标签中\n\n<table>\n    \x3c!-- 头部区域 --\x3e\n    <thead>\n    \t<tr>\n    \t\t<th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n        \t...\n    \t</tr>\n    </thead>\n    \x3c!-- 主体区域 --\x3e\n    <tbody>\n        <tr>\n            <td>周吉瑞</td>\n            <td>男</td>\n            <td>18</td>\n            ...\n        </tr>\n        ...\n    </tbody>\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.6 合并单元格\n\n特殊情况下，可以把多个单元格合并为一个单元格，这里会最简单的合并单元格即可。\n\n合并单元格的方式：\n\n * 跨行合并（上下合并）：rowspan="合并单元格的个数"\n * 跨列合并（左右合并）：colspan="合并单元格的个数"\n\n目标单元格：（写合并代码）\n\n * 跨行：最上侧单元格为目标单元格，写合并代码\n * 跨列：最左侧单元格为目标单元格，写合并代码\n\n合并单元格三步曲：\n\n * 先确定是跨行还是跨列合并\n * 找到目标单元格，写上 合并方式=合并的单元格数量，比如：<td colspan="2"> </td>\n * 删除多余单元格\n\n<body>\n    <table width="500" height="249" border="1" cellspacing="0">\n        <tr>\n            <td></td>\n            <td colspan="2"></td>\n            \x3c!-- <td></td> --\x3e\n        </tr>\n        <tr>\n            <td rowspan="2"></td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            \x3c!-- <td></td> --\x3e\n            <td></td>\n            <td></td>\n        </tr>\n    </table>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、表单标签\n\n\n# 5.1 表单的组成\n\n在 HTML 中，一个完整的表单通常由 表单域、表单控件（也称为表单元素）和 提示信息 3 个部分构成。\n\n\n# *5.2 表单域\n\n表单域是一个包含表单元素的区域。\n\n在 HTML 标签中，<form> 标签用于定义表单域，以实现用户信息的收集和传递。\n\n<form> 会把它范围内的表单元素信息提交给服务器。\n\n<form action="url地址" method="提交方式" name="表单域名称">\n    \x3c!-- 各种表单元素控件 --\x3e\n</form>\n\n\n1\n2\n3\n\n\n常用属性：\n\n属性名      属性值          作用\naction   url 地址       用于指定接收并处理表单数据的服务器程序的 url 地址\nmethod   get / post   用于设置表单数据的提交方式，其取值为 get 或 post\nname     名称           用于指定表单的名称，以区分同一个页面中的多个表单域\n\n注意：对于 HTML 基础的学习来说，暂时不用考虑提交数据，只需写上 form 标签即可，后面学习服务端编程阶段会重新讲解。\n\nform 表单中 method 的 get 和 post 区别：\n\n> method 方法规定如何发送表单数据（form-data）（表单数据会被发送到在 action 属性中规定的页面中）。\n> \n> 表单数据可被作为 URL 变量的形式来发送（method="get"）或者作为 HTTP post 事务的形式来发送（method="post"）。\n> \n> 关于 GET 的注释：\n> \n>  * 将表单数据以名/值对的形式附加到 URL 中\n>  * URL 的长度是有限的（大约 3000 字符）\n>  * 绝不要使用 GET 来发送敏感数据！（在 URL 中是可见的，且浏览器会缓存 URL）\n>  * 对于用户希望加入浏览器书签的表单很有用（因为信息记录在 URL 中，直接保存 URL 即可）\n>  * GET 更适用于非安全数据，比如在 Google 中查询字符串\n> \n> 关于 POST 的注释：\n> \n>  * 将表单数据附加到 HTTP 请求的 body 内（数据不显示在 URL 中）\n>  * 没有长度限制\n>  * 通过 POST 提交的表单不能加入书签\n>  * POST 数据也是不安全的，但起码不会明目张胆的直接把数据显示在地址栏 URL 上，且不会缓存数据\n\n\n# 5.3 input系列标签的基本介绍\n\n场景： 在网页中收集用户信息的表单效果，如：登录页、注册页\n\n标签名： input\n\n * input标签可以通过type属性值的不同，展示不同的效果\n\ntype属性值：\n\n标签名     TYPE属性值    说明\ninput   txet       文本框，用于输入单行文本\ninput   password   密码框，用于输入密码\ninput   radio      单选框，用于单选一\ninput   checkbox   多选多，用于多选多\ninput   file       文件选择，用以之后上传文件\ninput   submit     提交按钮，用于提交\ninput   reset      重置按钮，用于重置\ninput   butten     普通按钮，默认无功能，之后配合js添加功能\n\n\n# 5.4 input系列标签-文本框\n\n场景： 在网页中输入单行文本表单控件\n\ntype属性值： text\n\n常用属性：\n\n属性名           说明\nplaceholder   占位符，提示用户输入内容的文本\nvalue         控件的初始或值，一般设置为空，后期用户输入后可以获取\nmaxlength     显示输入文字的最大长度，取值为数字\n\n    <input type="text" placeholder="请输入用户名">\n\n    <input type="password" placeholder="请输入密码">\n\n\n1\n2\n3\n\n\n\n# 5.5 input系列标签-单选框\n\n场景： 在网页中显示多选一的单选表单控件\n\ntype属性值： radio\n\n常用属性：\n\n属性名       说明\nname      分组，有相同name属性值的单选框为一组，一组中同时只有一个被选中\nchecked   默认选中\n\n    \x3c!-- name未分组，checked设置默认 --\x3e\n    性别：<input type="radio" name="sex" checked>男\n         <input type="radio" name="sex">女<br><br>\n    <input type="checkbox" name="" id=""checked>我同意注册条款\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * name属性对于单选框有分组功能\n * 有相同name属性值的单选框为一组，一组中只能同时有一个被选中\n\n\n# 5.6 input系列标签-文件选择\n\n场景： 在网页中显示选择的表单控件\n\ntype属性值： file\n\n常用属性：\n\n属性名        说明\nmultiple   多文件选择\n\n\n# 5.7 input系列标签-上传\n\n场景： 在网页中显示用户点击的按钮\n\ntype属性值：\n\n标签名     TYPE属性值   说明\ninput   submit    提交按钮。之后点击数据提交给后台服务器\ninput   reset     重置按钮。点击之后恢复表单默认值\ninput   button    普通按钮。默认无功能，之后配合js添加功能\ninput   Image     图片按钮，提交功能\n\n注意点：\n\n * 实现上述按钮功能，需要配合form标签使用\n\n\n# 5.8 button按钮标签\n\n场景： 在网页中显示用户点击的按钮\n\ntype属性值（同input按钮）：\n\n标签名      TYPE属性值   说明\nbutton   submit    提交按钮。之后点击数据提交给后台服务器\nbutton   reset     重置按钮。点击之后恢复表单默认值\nbutton   button    普通按钮。默认无功能，之后配合js添加功能\n\n    昵称：<input type="text" placeholder="昵称">\n    <br>\n    <button>我是按钮</button>\n    <br>\n    <button type="submit">提交按钮</button>\n    <br>\n    <button type="reset">重置按钮</button>\n    <br>\n    <button type="button">普通按钮，没有任何功能</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.9 select下拉菜单\n\n场景： 在网页中提供多个下拉菜单的表单控件\n\n标签组成：\n\n * select标签：下拉菜单的整体\n * option标签：下拉菜单的每一项\n\n常见属性：\n\n * selected：下拉菜单的默认选中\n\n    <select>\n        <option>北京</option> \n        <option>上海</option> \n        <option selected>广州</option> \n        <option>深圳</option> \n    </select>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.10 textarea文本标签\n\n场景： 在网页中提供可输入多行文本的表单控件\n\n标签名： textarea\n\n常见属性：\n\n * cols：规定了文本域内可见宽度\n * rows：规定了文本域内可见行数\n\n注意点：\n\n * 右下角可以拖拽改变大小\n * 实际开发时针对于样式效果推荐用CSS样式\n\n\n# 5.11 label标签\n\n场景： 常用于绑定内容与表单内的关系\n\n标签名： label\n\n常用方法①：\n\n1.使用label标签把内容（如：文本）包裹起来\n\n2.在表单标签上添加id属性\n\n3.在label标签的for属性中设置对应的id属性值\n\n    性别：\n    <input type="radio" name="sex" id="1"> <label for="1">男</label> \n    <input type="radio" name="sex" id="2"> <label for="2">女</label>\n\n\n1\n2\n3\n\n\n使用方法②：\n\n1.使用label标签把内容和表单标签包裹起来\n\n2.需要把label标签的for属性删除即可\n\n    性别：\n    <label><input type="radio" name="sex">男</label>\n    <label><input type="radio" name="sex">女</label>\n\n\n1\n2\n3\n',normalizedContent:'# 快捷键\n\n功能            按键\n向下复制          shift+alt>+↓\n单行注释          ctrl+/\n多行注释          alt+shift+a\n缩进            tab\n回缩            shift+tab\n移动行上下         alt + ↑或 ↓\n删除行           ctrl + shift + k\n在当前行下插入新的一行   ctrl + enter\n在当前行上插入新的一行   ctrl + shift + enter\n\n----------------------------------------\n\n\n# 一、html常用标签\n\n\n# 1.1标题标签\n\nhtml提供了6个等级的网页标题，即: <h1>到<h6>。\n\n<h1>一级标题</h1>\n<h2>二级标题</h2>\n<h3>三级标题</h3>\n\n\n1\n2\n3\n\n\n> 单词head的缩写\n\n\n# 1.2段落和换行标签\n\n在网页中，要把文字有条理的展示出来，就需要用到分段。<p>用于将网页分为若干个段落。\n\n<p>这是一个段落</p>\n\n\n1\n\n\n> 单词pargraph的缩写\n\n强制某段文字换行使用<br>。\n\n<br>\n\n\n1\n\n\n> 单词break的缩写，以为：打断、换行\n\n注意：<br>是单标签。\n\n水平分割线：<hr>\n\n\n\n\n# 1.3文本格式化标签\n\n在网页中，有时会为文字设置粗体、斜体、下划线等标签，这时就需要文本格式化标签。是文字以特殊方式展示。\n\n语义    标签\n加粗    <strong> </strong>或<b> </b>\n倾斜    <em> </em>或<i> </i>\n删除线   <del> </del>或<s> </s>\n下划线   <ins> </ins>或<u> </u>\n\n注意：<em> 标签不只是单纯的用于倾斜文本，其核心的意义在于对元素进行强调！所以在后期的开发中可以把一些特殊性、强调性的元素放在 em 标签中，然后再对 em 这个盒子进行样式设置，这比把其放入其他盒子（如：span）中要更合理，同理<strong> 标签页适合放一些重点强调的元素。\n\n\n# 1.4 <div>和<span>标签(语义化标签)\n\n<div> 和 <span> 是没有语义的，它们就是两种盒子，用来对网页进行布局和装其他内容。\n\n<div>这是头部</div>\n<span>今日价格</span>\n\n\n1\n2\n\n\n> div 是 division 的缩写表示：分割、分区。\n\n> span 意为：跨度、跨距。\n\n特点：\n\n * <div> 标签用来布局，一行只能放一个 <div>，大盒子\n * <span> 标签用来布局，一行上可以放多个 <span>，小盒子\n\n**说明：**后期可以通过 css 将 div 与 span 之间的特性相互转换。\n\n拓展： span 标签不单单是用于布局，对于一些需要单独修饰和设置的元素，可以将其用 span 标签嵌套起来，然后就可以单独对其进行设置（比如：在一个 p 标签的段落中要对其中某一句话单独设置样式，那么就可以用 span 将这句话单独嵌套起来，这样就方便对其单独设置样式还不会影响段落中的其他内容，这其实也是利用了 span 一行可以放置多个盒子的特性），不过对于特殊且具有强调性的元素建议使用 em，对于重点强调但不特殊的的元素建议使用 strong。\n\n\n# 1.5图像、音视频标签、路径\n\n同级./ 上级 ../\n\n\n# 图片标签\n\nalt属性：图片无法读取时显示的提示性文本\n\ntitle属性：鼠标悬停时显示\n\n\n# 音视频标签\n\n音频 audio controls\n\n视频video controls\n\n属性名        功能\nsrc        路径\ncontrols   显示播放的控件\nautoplay   自动播放（高版本浏览器不可用）\nloop       循环播放\nmuted      视频静音播放，解决高版本浏览器自动播放失败\n\n\x3c!-- 谷歌浏览区可以让视频自动播放， 但是必须是静音状态muted --\x3e\n    <video src="./艳火 - 张悬 - 高清mv - 网易云音乐.mp4" controls autoplay muted loop></video>\n\n\n1\n2\n\n\n\n# 1.6 超链接\n\ntarget属性，默认值是_self,在当前窗口跳转，覆盖原网页；改为_blank后在新窗口跳转，保留原网页。\n\n \x3c!-- href：跳转地址   --\x3e\n    \n    <a href="https://www.baidu.com/" target="_blank">跳转到百度</a>\n    \n    <br>\n\n    <a href="./10.音频.html">跳转到音频</a>\n   \n    <br>\n    \n    <a href="#">空链接</a>\n   \n    \x3c!-- 当开发网站的初期，我们还不知道跳转地址的时候，href的值写为#（空链接） --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1.7锚点链接\n\n作用：实现页面内部的跳转，快速访问某一位置\n\n实现的步骤：\n\n01.找到要跳转的位置，用id标记；\n\n<a href="#mao1">跳转到基本信息</a>\n\n\n1\n\n\n02.设置超链接a的href的取值为#id;\n\n<h3 id="mao1">基本信息</h3>\n\n\n1\n\n\n\n# 二、注释\n\n\n# 三、列表标签\n\n\n# 3.1 无序列表\n\n<ul> 标签表示 html 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用 <li> 标签定义（开发中经常使用）。\n\n无序列表的基本语法格式如下：\n\n<ul>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n    ...\n</ul>\n\n\n1\n2\n3\n4\n5\n6\n\n * 无序列表的各个列表项之间没有顺序级别之分，是并列的\n * <ul> </ul> 中只能嵌套 <li> </li>，直接在 <ul> </ul> 标签中输入其他标签或者文字的做法是不被允许的，列表中的任何内容都应该放在 li 中\n * <li> 与 </li> 之间相当于一个容器，可以容纳所有的元素\n * 无序列表会带有自己的样式属性（比如圆点），但在实际开发中，我们会使用 css 来设置\n * 实际使用中最好嵌套 div,方便控制样式\n\n> 附：去除 li 前符号的方法：style="list-style: none;"\n\n\n# 3.2 有序列表\n\n有序列表即为有序排列顺序的列表，其各个列表项会按照一定的顺序排列定义（开发中不太常用）。\n\n在 html 标签中，<ol> 标签用于定义有序列表，列表排序以数字来显示，并且使用 <li> 标签来定义列表项。\n\n有序列表的基本语法格式如下：\n\n<ol>\n    <li>列表项1</li>\n    <li>列表项2</li>\n    <li>列表项3</li>\n    ...\n</ol>\n\n\n1\n2\n3\n4\n5\n6\n\n * <ol> </ol> 中只能嵌套 <li> </li>，直接在 <ol> </ol> 标签中输入其他标签或者文字的做法是不被允许的\n * <li> 与 </li> 之间相当于一个容器，可以容纳所有的元素\n * 有序列表会带有自己样式属性（比如序号），但在实际使用时，我们会使用 css 来设置\n\n> 附：去除 li 前符号的方法：style="list-style: none;"\n\n\n# 2.7.3 自定义列表\n\n自定义列表的使用场景：\n\n自定义列表常用于对术语或名词进行解释、描述和展开，定义列表的列表项前没有任何项目符号（开发中常用）。\n\n在 html 标签中，<dl> 标签用于定义描述列表（或定义列表），该标签会与 <dt>（定义项目/名字）和 <dd>（描述每一个项目/名字）一起使用。\n\n其基本语法如下：\n\n<dl>\n    <dt>名词1</dt>\n    <dd>名词1解释1</dd>\n    <dd>名词1解释2</dd>\n</dl>\n\n\n1\n2\n3\n4\n5\n\n * <dl> </dl> 里面只包含 <dt>、<dd>\n * <dt> 和 <dd> 个数没有限制，经常是一个 <dt> 对应多个 <dd>\n\n\n# 四、表格标签\n\n\n# 4.1 表格的标题和表头单元格标签\n\n场景： 在表格中展示整体大标题和一列小标题\n\n标签：\n\n标签名       名称      说明\ncaption   表格大标题   默认在表格整体顶部居中展示\nth        表头单元格   常用于表格第一格，默认文字加粗居中展示\n\n注意点：\n\n * caption标签书写在table标签内部\n * th书签写在tr标签内部（用于替换td标签）\n\n\n# 4.2 表格的基本用法\n\n<table>\n    <tr>\n        <td>单元格</td>\n        ...\n    </tr>\n    ...\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * <table> </table> 是用于定义表格的标签\n * <tr> </tr> 用于定义表格中的行，必须嵌套在 <table> </table> 标签中\n * <td> </td> 用于定义表格中的单元格，必须嵌套在 <tr> </tr> 标签中\n * 字母 td 指表格数据（table data），即：数据单元格的内容\n * 单元格 td 里面可以放任何的元素\n\n\n# 4.3 表头单元格标签\n\n一般表头单元格位于表格的第一行或第一列，作用是：突出重要性，表头单元格里面的文本内容默认加粗居中显示。\n\n<th> 标签表示 html 表格的表头部分（table head 的缩写）。\n\n<table>\n    <tr>\n    \t<th>姓名</th>\n        <th>性别</th>\n        <th>年龄</th>\n        ...\n    </tr>\n    ...\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.4 表格属性\n\n**注意：**表格标签的属性在实际开发中并不常用，而是通过后面的 css 来设置，这里了解即可。\n\n以下属性都写在 table 开始标签内，多个属性之间用空格隔开。\n\n<table align="center" border="1" cellpadding="0" cellspacing="0" width="500" height="240">\n    ...\n</table>\n\n\n1\n2\n3\n\n\n属性名           属性值                 描述\nalign         left、center、right   规定表格相对周围元素的对齐方式（默认\n                                  left），注意指的是整个表格的对齐方式（表格是在父盒子中默认往左靠，还是居中或是往右靠），而不是指单元格内容的对齐方式（单元格内容对齐可以通过：style="text-align:\n                                  center;" 设置）（了解）\nborder        1 或 ""              规定表格单元是否拥有边框，默认为 ""，表示没有边框（了解）\ncellpadding   像素值                 规定单元边沿与其内容之间的空白，默认 1 像素（了解）\ncellspacing   像素值                 规定单元格之间的空白，默认 2 像素（了解）\nwidth         像素值 或 百分比           规定表格的宽度（了解）\nheight        像素值 或 百分比           规定表格的高度（了解）\nrules         all                 取值为all，就可以实现细线表格样式，后期用css实现\n\n\n# 4.5 表格结构标签\n\n**使用场景：**因为表格可能很长，为了更好的表示表格的语义，可以将表格分割成：表格头部 和 表格主体 两大部分。\n\n在表格标签中，分别用：<thead> 标签表示表格的头部区域，<tbody> 标签表示表格的主体区域，这样可以更好的分清表格结构。\n\n * <thead> </thead>：用于定义表格的头部，<thead> 内部必须拥有 <tr> 标签，一般是位于第一行，且一般 <tr> 标签中推荐放置 <th> 标签\n * <tbody> </tbody>：用于定义表格的主体，主要用于放数据本体\n * 以上标签都是放在 <table> </table> 标签中\n\n<table>\n    \x3c!-- 头部区域 --\x3e\n    <thead>\n    \t<tr>\n    \t\t<th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n        \t...\n    \t</tr>\n    </thead>\n    \x3c!-- 主体区域 --\x3e\n    <tbody>\n        <tr>\n            <td>周吉瑞</td>\n            <td>男</td>\n            <td>18</td>\n            ...\n        </tr>\n        ...\n    </tbody>\n</table>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.6 合并单元格\n\n特殊情况下，可以把多个单元格合并为一个单元格，这里会最简单的合并单元格即可。\n\n合并单元格的方式：\n\n * 跨行合并（上下合并）：rowspan="合并单元格的个数"\n * 跨列合并（左右合并）：colspan="合并单元格的个数"\n\n目标单元格：（写合并代码）\n\n * 跨行：最上侧单元格为目标单元格，写合并代码\n * 跨列：最左侧单元格为目标单元格，写合并代码\n\n合并单元格三步曲：\n\n * 先确定是跨行还是跨列合并\n * 找到目标单元格，写上 合并方式=合并的单元格数量，比如：<td colspan="2"> </td>\n * 删除多余单元格\n\n<body>\n    <table width="500" height="249" border="1" cellspacing="0">\n        <tr>\n            <td></td>\n            <td colspan="2"></td>\n            \x3c!-- <td></td> --\x3e\n        </tr>\n        <tr>\n            <td rowspan="2"></td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            \x3c!-- <td></td> --\x3e\n            <td></td>\n            <td></td>\n        </tr>\n    </table>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 五、表单标签\n\n\n# 5.1 表单的组成\n\n在 html 中，一个完整的表单通常由 表单域、表单控件（也称为表单元素）和 提示信息 3 个部分构成。\n\n\n# *5.2 表单域\n\n表单域是一个包含表单元素的区域。\n\n在 html 标签中，<form> 标签用于定义表单域，以实现用户信息的收集和传递。\n\n<form> 会把它范围内的表单元素信息提交给服务器。\n\n<form action="url地址" method="提交方式" name="表单域名称">\n    \x3c!-- 各种表单元素控件 --\x3e\n</form>\n\n\n1\n2\n3\n\n\n常用属性：\n\n属性名      属性值          作用\naction   url 地址       用于指定接收并处理表单数据的服务器程序的 url 地址\nmethod   get / post   用于设置表单数据的提交方式，其取值为 get 或 post\nname     名称           用于指定表单的名称，以区分同一个页面中的多个表单域\n\n注意：对于 html 基础的学习来说，暂时不用考虑提交数据，只需写上 form 标签即可，后面学习服务端编程阶段会重新讲解。\n\nform 表单中 method 的 get 和 post 区别：\n\n> method 方法规定如何发送表单数据（form-data）（表单数据会被发送到在 action 属性中规定的页面中）。\n> \n> 表单数据可被作为 url 变量的形式来发送（method="get"）或者作为 http post 事务的形式来发送（method="post"）。\n> \n> 关于 get 的注释：\n> \n>  * 将表单数据以名/值对的形式附加到 url 中\n>  * url 的长度是有限的（大约 3000 字符）\n>  * 绝不要使用 get 来发送敏感数据！（在 url 中是可见的，且浏览器会缓存 url）\n>  * 对于用户希望加入浏览器书签的表单很有用（因为信息记录在 url 中，直接保存 url 即可）\n>  * get 更适用于非安全数据，比如在 google 中查询字符串\n> \n> 关于 post 的注释：\n> \n>  * 将表单数据附加到 http 请求的 body 内（数据不显示在 url 中）\n>  * 没有长度限制\n>  * 通过 post 提交的表单不能加入书签\n>  * post 数据也是不安全的，但起码不会明目张胆的直接把数据显示在地址栏 url 上，且不会缓存数据\n\n\n# 5.3 input系列标签的基本介绍\n\n场景： 在网页中收集用户信息的表单效果，如：登录页、注册页\n\n标签名： input\n\n * input标签可以通过type属性值的不同，展示不同的效果\n\ntype属性值：\n\n标签名     type属性值    说明\ninput   txet       文本框，用于输入单行文本\ninput   password   密码框，用于输入密码\ninput   radio      单选框，用于单选一\ninput   checkbox   多选多，用于多选多\ninput   file       文件选择，用以之后上传文件\ninput   submit     提交按钮，用于提交\ninput   reset      重置按钮，用于重置\ninput   butten     普通按钮，默认无功能，之后配合js添加功能\n\n\n# 5.4 input系列标签-文本框\n\n场景： 在网页中输入单行文本表单控件\n\ntype属性值： text\n\n常用属性：\n\n属性名           说明\nplaceholder   占位符，提示用户输入内容的文本\nvalue         控件的初始或值，一般设置为空，后期用户输入后可以获取\nmaxlength     显示输入文字的最大长度，取值为数字\n\n    <input type="text" placeholder="请输入用户名">\n\n    <input type="password" placeholder="请输入密码">\n\n\n1\n2\n3\n\n\n\n# 5.5 input系列标签-单选框\n\n场景： 在网页中显示多选一的单选表单控件\n\ntype属性值： radio\n\n常用属性：\n\n属性名       说明\nname      分组，有相同name属性值的单选框为一组，一组中同时只有一个被选中\nchecked   默认选中\n\n    \x3c!-- name未分组，checked设置默认 --\x3e\n    性别：<input type="radio" name="sex" checked>男\n         <input type="radio" name="sex">女<br><br>\n    <input type="checkbox" name="" id=""checked>我同意注册条款\n\n\n1\n2\n3\n4\n\n\n注意点：\n\n * name属性对于单选框有分组功能\n * 有相同name属性值的单选框为一组，一组中只能同时有一个被选中\n\n\n# 5.6 input系列标签-文件选择\n\n场景： 在网页中显示选择的表单控件\n\ntype属性值： file\n\n常用属性：\n\n属性名        说明\nmultiple   多文件选择\n\n\n# 5.7 input系列标签-上传\n\n场景： 在网页中显示用户点击的按钮\n\ntype属性值：\n\n标签名     type属性值   说明\ninput   submit    提交按钮。之后点击数据提交给后台服务器\ninput   reset     重置按钮。点击之后恢复表单默认值\ninput   button    普通按钮。默认无功能，之后配合js添加功能\ninput   image     图片按钮，提交功能\n\n注意点：\n\n * 实现上述按钮功能，需要配合form标签使用\n\n\n# 5.8 button按钮标签\n\n场景： 在网页中显示用户点击的按钮\n\ntype属性值（同input按钮）：\n\n标签名      type属性值   说明\nbutton   submit    提交按钮。之后点击数据提交给后台服务器\nbutton   reset     重置按钮。点击之后恢复表单默认值\nbutton   button    普通按钮。默认无功能，之后配合js添加功能\n\n    昵称：<input type="text" placeholder="昵称">\n    <br>\n    <button>我是按钮</button>\n    <br>\n    <button type="submit">提交按钮</button>\n    <br>\n    <button type="reset">重置按钮</button>\n    <br>\n    <button type="button">普通按钮，没有任何功能</button>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5.9 select下拉菜单\n\n场景： 在网页中提供多个下拉菜单的表单控件\n\n标签组成：\n\n * select标签：下拉菜单的整体\n * option标签：下拉菜单的每一项\n\n常见属性：\n\n * selected：下拉菜单的默认选中\n\n    <select>\n        <option>北京</option> \n        <option>上海</option> \n        <option selected>广州</option> \n        <option>深圳</option> \n    </select>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.10 textarea文本标签\n\n场景： 在网页中提供可输入多行文本的表单控件\n\n标签名： textarea\n\n常见属性：\n\n * cols：规定了文本域内可见宽度\n * rows：规定了文本域内可见行数\n\n注意点：\n\n * 右下角可以拖拽改变大小\n * 实际开发时针对于样式效果推荐用css样式\n\n\n# 5.11 label标签\n\n场景： 常用于绑定内容与表单内的关系\n\n标签名： label\n\n常用方法①：\n\n1.使用label标签把内容（如：文本）包裹起来\n\n2.在表单标签上添加id属性\n\n3.在label标签的for属性中设置对应的id属性值\n\n    性别：\n    <input type="radio" name="sex" id="1"> <label for="1">男</label> \n    <input type="radio" name="sex" id="2"> <label for="2">女</label>\n\n\n1\n2\n3\n\n\n使用方法②：\n\n1.使用label标签把内容和表单标签包裹起来\n\n2.需要把label标签的for属性删除即可\n\n    性别：\n    <label><input type="radio" name="sex">男</label>\n    <label><input type="radio" name="sex">女</label>\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"Git - 知识体系",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"40.工具/20.开发管理 - Git",imgUrl:"/img/catalogue/default.png",description:"Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。"}},title:"Git - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/git/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/12.%E5%B7%A5%E5%85%B7%20-%20%E7%9B%AE%E5%BD%95%E9%A1%B5/02.Git%20-%20%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html",relativePath:"00.目录页/12.工具 - 目录页/02.Git - 知识体系.md",key:"v-c56c268c",path:"/git/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/04, 20:43:29",lastUpdatedTimestamp:1680612209e3},{title:"CSS基础",frontmatter:{title:"CSS基础",date:"2020-04-05T20:07:40.000Z",permalink:"/basics/CSS2/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/02.CSS%E5%9F%BA%E7%A1%80.html",relativePath:"01.前端基础/02.CSS/02.CSS基础.md",key:"v-3f70b542",path:"/basics/CSS2/",headers:[{level:2,title:"1.3 CSS语法规范",slug:"_1-3-css语法规范",normalizedTitle:"1.3 css语法规范",charIndex:2},{level:2,title:"1.1 CSS的三种引入方式",slug:"_1-1-css的三种引入方式",normalizedTitle:"1.1 css的三种引入方式",charIndex:602},{level:2,title:"1.2 行内样式表",slug:"_1-2-行内样式表",normalizedTitle:"1.2 行内样式表",charIndex:705},{level:2,title:"1.3 内部样式表",slug:"_1-3-内部样式表",normalizedTitle:"1.3 内部样式表",charIndex:1e3},{level:2,title:"1.4 外部样式表",slug:"_1-4-外部样式表",normalizedTitle:"1.4 外部样式表",charIndex:1371},{level:2,title:"5.5 CSS引入方式总结",slug:"_5-5-css引入方式总结",normalizedTitle:"5.5 css引入方式总结",charIndex:1869},{level:2,title:"2.1 CSS选择器的作用",slug:"_2-1-css选择器的作用",normalizedTitle:"2.1 css选择器的作用",charIndex:2117},{level:2,title:"2.2 选择器的分类",slug:"_2-2-选择器的分类",normalizedTitle:"2.2 选择器的分类",charIndex:2308},{level:2,title:"2.3 标签选择器",slug:"_2-3-标签选择器",normalizedTitle:"2.3 标签选择器",charIndex:2423},{level:2,title:"2.4 类选择器",slug:"_2-4-类选择器",normalizedTitle:"2.4 类选择器",charIndex:3047},{level:2,title:"2.5 id选择器",slug:"_2-5-id选择器",normalizedTitle:"2.5 id选择器",charIndex:4539},{level:2,title:"2.6 通配符选择器",slug:"_2-6-通配符选择器",normalizedTitle:"2.6 通配符选择器",charIndex:5548},{level:2,title:"2.7 基础选择器总结",slug:"_2-7-基础选择器总结",normalizedTitle:"2.7 基础选择器总结",charIndex:6327},{level:2,title:"3.1 字体系列(略读)",slug:"_3-1-字体系列-略读",normalizedTitle:"3.1 字体系列(略读)",charIndex:6893},{level:2,title:"3.2 字体大小（fs）",slug:"_3-2-字体大小-fs",normalizedTitle:"3.2 字体大小（fs）",charIndex:7370},{level:2,title:"3.3 字体粗细(fw)",slug:"_3-3-字体粗细-fw",normalizedTitle:"3.3 字体粗细(fw)",charIndex:7562},{level:2,title:"3.4 文字样式（斜体）(fs)",slug:"_3-4-文字样式-斜体-fs",normalizedTitle:"3.4 文字样式（斜体）(fs)",charIndex:7860},{level:2,title:"3.5 字体复合属性",slug:"_3-5-字体复合属性",normalizedTitle:"3.5 字体复合属性",charIndex:8339},{level:2,title:"3.6 字体属性总结",slug:"_3-6-字体属性总结",normalizedTitle:"3.6 字体属性总结",charIndex:9362},{level:2,title:"4.1 文本缩进(ti)",slug:"_4-1-文本缩进-ti",normalizedTitle:"4.1 文本缩进(ti)",charIndex:9683},{level:2,title:"4.2 文本水平对齐方式(ta)",slug:"_4-2-文本水平对齐方式-ta",normalizedTitle:"4.2 文本水平对齐方式(ta)",charIndex:10113},{level:2,title:"4.3 文本修饰属性",slug:"_4-3-文本修饰属性",normalizedTitle:"4.3 文本修饰属性",charIndex:10288},{level:2,title:"4.4行间距（行高）",slug:"_4-4行间距-行高",normalizedTitle:"4.4行间距（行高）",charIndex:10989},{level:2,title:"4.5 文本属性总结",slug:"_4-5-文本属性总结",normalizedTitle:"4.5 文本属性总结",charIndex:11287}],headersStr:"1.3 CSS语法规范 1.1 CSS的三种引入方式 1.2 行内样式表 1.3 内部样式表 1.4 外部样式表 5.5 CSS引入方式总结 2.1 CSS选择器的作用 2.2 选择器的分类 2.3 标签选择器 2.4 类选择器 2.5 id选择器 2.6 通配符选择器 2.7 基础选择器总结 3.1 字体系列(略读) 3.2 字体大小（fs） 3.3 字体粗细(fw) 3.4 文字样式（斜体）(fs) 3.5 字体复合属性 3.6 字体属性总结 4.1 文本缩进(ti) 4.2 文本水平对齐方式(ta) 4.3 文本修饰属性 4.4行间距（行高） 4.5 文本属性总结",content:'# 1.3 CSS语法规范\n\n使用 HTML 时，需要遵从一定的规范，CSS 也是如此，要想熟练地使用 CSS 对网页进行修饰，首先需要了解 CSS 样式规则。\n\nCSS 规则由两个主要的部分构成：选择器 以及 一条或多条声明。\n\n * 选择器 是用于选出需要设置 CSS 样式的 HTML 标签，选择器后跟的花括号内是对该对象设置的具体样式\n * 属性 和 属性值 以 “键值对” 的形式出现 属性: 属性值;\n * 属性是对指定的对象设置的样式属性，例如：字体大小、文本颜色等\n * 属性和属性值之间用英文 : 分开\n * 多个 “键值对” 之间用英文 ; 进行区分（末尾的键值对可以不加 ;）\n\n所有的样式，都包含在 <style> 标签内，表示是样式表。\n\n<style> 一般写到 </head> 里。\n\n<head>\n    <style type="text/css">\n        h4 {\n            color: bule;\n            font-size: 100px;\n        }\n    </style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：<style> 标签可以写到其他标签内部并作用与该标签区域内，但是强烈不推荐这种写法！\n\n> type="text/css" 可以省略。\n\n\n# 一、CSS引入方式\n\n\n# 1.1 CSS的三种引入方式\n\n按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：\n\n * 行内样式表（行内式）\n * 内部样式表（嵌入式）\n * 外部样式表（外链式）\n\n\n# 1.2 行内样式表\n\n行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式，适合于修改简单样式。\n\n<div style="color: red; font-size: 12px;">\n    青春不常在，抓紧谈恋爱\n</div>\n\n\n1\n2\n3\n\n * style 其实就是标签的属性\n * 在双引号中间，写法要符合 CSS 规范\n * 可以控制当前的标签设置样式\n * 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\n * 使用行内样式表设定 CSS，通常也被称为 行内式引入\n\n\n# 1.3 内部样式表\n\n内部样式表（嵌入样式表）时写到 HTML 页面内部，是将所有的 CSS 代码抽取出来，单独放到一个 <style> 标签中。\n\n<style type="text/css">\n    div {\n        color: red;\n        font-size: 12px;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n * <style> 标签理论上可以放在 HTML 文档的任何地方，但一般会放到文档的 <head> 标签中\n * 目前的浏览器已经支持省略 type 属性\n * 通过此种方式，可以方便控制当前整个页面中的元素样式设置\n * 代码结构清晰，但是并没有实现结构与样式完全分离\n * 使用内部样式表设定 CSS，通常也被称为 嵌入式引入，这种方式是我们练习时常用的方式\n\n\n# 1.4 外部样式表\n\n实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到 CSS 文件中，之后把 CSS 文件引入到 HTML 页面中使用。\n\n引入外部样式表分为两步：\n\n * 新建一个后缀名为：.css 的样式文件，把所有的 CSS 代码都放入此文件中\n * 在 HTML 页面中，使用 <link> 标签引入这个文件\n\n<link rel="stylesheet" type="text/css" href="css文件路径">\n\n\n1\n\n\n属性     作用\nrel    定义当前文档与被链接文档之间的关系，在这里需要指定为 "stylesheet"，表示被链接的文档是一个样式表文件\ntype   定被链接文档的 MIME 类型，该属性最常见的 MIME 类型是\n       "text/css"，该类型描述样式表，目前的浏览器已经支持省略 "type" 属性\nhref   定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径\n\n**注意：**使用外部样式表设定 CSS，通常也被称为 外链式 或 链接式引入，这种方式是开发中常用的方式。\n\n\n# 5.5 CSS引入方式总结\n\n样式表          优点             缺点       使用情况      控制范围\n行内样式表（行内式）   书写方便，权重高       结构样式混写   较少        控制一个标签\n内部样式表（嵌入式）   部分结构和样式分离      没有彻底分离   较多        控制一个页面\n外部样式表（外链式）   完全实现结构和样式相分离   需要引入     最多，吐血推荐   控制多个页面\n\n\n# 二、CSS基础选择器\n\n\n# 2.1 CSS选择器的作用\n\n选择器就是根据不同的需求把不同的标签选出来，这就是选择器的作用，简单来说，就是：选择标签用的。\n\nh1 {\n\tcolor: red;\n\tfont-size: 25px;\n}\n\n\n1\n2\n3\n4\n\n\n以上 CSS 做了两件事：\n\n * 找到所有的 h1 标签。（选对人）\n * 设置这些标签的样式：颜色为红色、字体大小为 25 像素。（做对事）\n\n\n# 2.2 选择器的分类\n\n选择器分为 基础选择器 和 复合选择器 两个大类，本文首先介绍一下基础选择器。\n\n * 基础选择器是由 单个 选择器组成的\n * 基础选择器又包括：标签选择器、类选择器、id 选择器、通配符选择器\n\n\n# 2.3 标签选择器\n\n标签选择器（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。\n\n语法：\n\n标签名 {\n\t属性1: 属性值1;\n\t属性2: 属性值2;\n\t属性3: 属性值3;\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n作用：\n\n标签选择器可以把某一类标签全部选择出来，比如所有的 <div> 标签和所有的 <span> 标签。\n\n优点：\n\n能快速为页面中同类型的标签统一设置样式。\n\n缺点：\n\n不能设计差异化样式，只能选择全部的当前标签。\n\n<head>\n\n    <style type="text/css">\n        /* 会对所有的该标签元素运用样式，优点：快速统一，缺点：无法差异化设置 */\n        p {\n            color: green;\n        }\n        div {\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <p>男</p>\n    <p>男</p>\n    <p>男</p>\n    <div>女生</div>\n    <div>女生</div>\n    <div>女生</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.4 类选择器\n\n如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用 类选择器 。\n\nCSS 语法：\n\n.类名 {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n\n例如：将所有拥有 red 类的 HTML 元素均设置为红色。\n\n.red {\n\tcolor: red;\n}\n\n\n1\n2\n3\n\n\nHTML 语法：\n\n<div class="red">变红色</div>\n\n\n1\n\n\n类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个 . 号显示。\n\n注意：\n\n * 类选择器使用 .（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）\n * 可以理解为给这个标签起了一个别名来表示\n * 类名可以由数字、字母、下划线、中划线-组成，但不能以数字、中划线开头、\n * 一个标签可以有多个类名，类名之间以中括号隔开\n * 长名称或词组可以使用中横线 - 来为类命名\n * 不能使用已有的关键字作为类名\n * 命名要有意义，尽量使别人一眼就知道这个类名的目的（可读性第一，长度第二，推荐使用英语，如果是使用拼音请使用全拼）\n * 命名规范：见附件（CSS 命名规范.md）\n\n记忆口诀：样式点定义，结构类调用，一个或多个，开发最常用。\n\n<head>\n    <style type="text/css">\n        /* 类选择器口诀：样式 . 定义，结构 class 调用，一个或多个，开发最常用 */\n        .red {\n            width: 100px;\n            height: 100px;\n            background-color: red;\n        }\n\n        .green {\n            width: 100px;\n            height: 100px;\n            background-color: green;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="red"></div>\n    <div class="green"></div>\n    <div class="red"></div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n类选择器——多类名\n\n我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。\n\n * 在标签 class 属性中写多个类名\n * 多个类名中间必须用 空格 分开\n * 这个标签就可以分别具有这些类名的样式\n\n<head>\n    <style type="text/css">\n        /* 一个标签可以运用多个类选择器，之间用空格隔开 */\n        .red {\n            color: red;\n        }\n\n        .font35 {\n            font-size: 35px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="red font35">zhoujirui</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.5 id选择器\n\nid 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。\n\nHTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以 # 来定义。\n\n语法：\n\n#id名 {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n\n**例如：**将 id 为 nav 元素中的内容设置为红色。\n\n#nav {\n\tcolor: red;\n}\n\n\n1\n2\n3\n\n\n**注意：**id 属性只能在每个 HTML 文档中出现一次。\n\n**口诀：**样式 # 定义，结构 id 调用，只能调用一次，别人切勿使用。\n\nid 选择器和类选择器的区别：\n\n * 类选择器 (class) 好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用\n * id 选择器好比人的身份证号码，全中国是唯一的，不可重复（同一个 id 选择器只能调用一次）\n * id 选择器和类选择器最大的不同在于使用次数上\n * 类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>基础选择器之id选择器</title>\n    <style type="text/css">\n        /* id 选择器口诀：样式 # 定义，结构 id 调用，只能调用一次，别人切勿使用 */\n        #pink {\n            color: pink;\n        }\n    </style>\n</head>\n\n<body>\n    <div id="pink">zhoujirui</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再次强调：同一 id 只能定义一次，同一 id 选择器也只能调用一次！（对于 CSS 修改样式来说，最好使用类选择器，id 选择器主要与后面的 JS 搭配使用）。\n\n\n# 2.6 通配符选择器\n\n在 CSS 中，通配符选择器使用 * 定义，它表示选取页面中所有元素（标签）。\n\n语法：\n\n* {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n * 通配符选择器不需要调用，自动就给所有的元素使用样式\n * 特殊情况才使用，后面讲解使用场景\n\n// 利用通配符选择器清除所有的元素标签的内外边距，后期讲\n* {\n\tmargin: 0;\n\tpadding: 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>基础选择器之通配符选择器</title>\n    <style type="text/css">\n        /* * 给 html 标签所有的元素都使用样式，并且这个过程是自动完成的，不需要手动调用 */\n        * {\n            color: red;\n        }\n    </style>\n</head>\n\n<body>\n    <div>我的</div>\n    <span>我的</span>\n    <ul>\n        <li>还是我的</li>\n    </ul>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.7 基础选择器总结\n\n基础选择器    作用                 特点                                使用情况        用法\n标签选择器    可以选出所有相同的标签，比如：p   不能差异化选择                           较多          p {color: red;}\n类选择器     可以选出 1 个或者 多个 标签   可以根据需求选择                          非常多         .nav {color: red;}\nid 选择器   一次只能选择 1 个标签       ID 属性只能在每个 HTML 文档中出现一次，也只能调用一次   一般和 js 搭配   #nav {color: red;}\n通配符选择器   选择所有的标签            选择的太多，有部分不需要                      特殊情况使用      * {color: red;}\n\n * 每个基础选择器都有使用场景，都需要掌握\n * 如果是修改样式，类选择器是使用最多的\n\n\n# 三、CSS字体属性\n\nCSS Fonts（字体）属性用于定义：字体系列、大小、粗细、和 文字样式（如：斜体）。\n\n\n# 3.1 字体系列(略读)\n\nCSS 使用 font-family 属性定义文本的字体系列。\n\np {\n\tfont-family: "Microsoft YaHei";\n}\n\ndiv {\n\tfont-family: Arial, "Microsoft YaHei";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 各种字体之间必须使用英文状态下的逗号隔开\n * 一般情况下，如果有空格隔开的多个单词组成的字体，加引号\n * 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\n * 最常用的字体：body {font-family: "Microsoft YaHei", tahoma, arial, sans-serif, "Hiragino Sans GB";}\n\n![](/Volumes/独立数据/MAC桌面/I-love-you-3-thousand-master/我爱你，不止三千遍/HTML CSS/02【CSS简介、基础选择器、字体属性、文本属性、引入方式】/mark-img/2021041511462678.png)\n\n\n# 3.2 字体大小（fs）\n\nCSS 使用 font-size 属性定义字体大小。\n\np {\n\tfont-size: 20px;\n}\n\n\n1\n2\n3\n\n * px（像素）大小是我们网页的最常用的单位\n * 谷歌浏览器默认的文字大小为：16px\n * 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\n * 可以给 body 指定整个页面文字的大小\n\n\n# 3.3 字体粗细(fw)\n\nCSS 使用 font-weight 属性设置文本字体的粗细。\n\np {\n\tfont-weight: bold;\n}\n\n\n1\n2\n3\n\n\n属性值       描述\nnormal    默认值（不加粗的）\nbold      定义粗体（加粗的）\n100-900   400 等同于 normal，而 700 等同于 bold，其它值一般不使用，注意这个数字后面不跟单位\n\n * 学会让加粗标签（比如 h 和 strong 等）变为不加粗，或者让其他标签加粗\n * 实际开发时，我们更喜欢用数字表示粗细\n * 不是所有字体都提供了九种粗细，因此部分取值页面中无效\n\n\n# 3.4 文字样式（斜体）(fs)\n\nCSS 使用 font-style 属性设置文本的风格。\n\np {\n\tfont-style: normal;\n}\n\n\n1\n2\n3\n\n\n属性值      作用\nnormal   默认值，浏览器会显示标准的字体样式 font-style: normal;\nitalic   浏览器会显示斜体的字体样式\n\n**注意：**平时我们很少给文字加斜体，反而要给斜体标签 (em、i) 改为不倾斜字体。\n\n    <style>\n        div{\n            font-style: italic;\n        }\n        em{\n            /* 斜体改为不倾斜 */\n            font-style: normal;\n        }\n    </style>\n</head>\n<body>\n    <div>2313213</div>\n    <em>42342</em>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3.5 字体复合属性\n\n字体属性可以把以上文字样式综合来写，这样可以更节约代码。\n\nbody {\n\tfont: font-style font-weight font-size/line-height font-family;\n}\n\nbody {\n\tfont: normal 400 font-size/line-height "Microsoft YaHei", Arial, sans-serif;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开\n * 倾斜和加粗可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用\n\n    <style>\n        /* 想要 div 文字变倾斜、加粗、字号设置为 16 像素，并且是微软雅黑 */\n        div {\n            /* font-style: italic;\n               font-weight: 700;\n               font-size: 16px;\n               font-family: \'Microsoft YaHei\'; */\n\n            /* 复合属性：简写的方式，里面的顺序不能打乱 以空格隔开 */\n            /* font: font-style font-weight font-size/line-height font-family; */\n            font: italic 700 16px \'Microsoft YaHei\';\n            /* 注意：不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 */\n            /* font: 20px \'Microsoft YaHei\'； */\n        }\n    </style>\n</head>\n\n<body>\n    <div>三生三世十里桃花，一心一意百行代码</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.6 字体属性总结\n\n属性            表示     注意点\nfont-size     字号     我们通常用的单位是 px 像素，一定要跟上单位\nfont-family   字体     实际工作中按照团队约定来写字体\nfont-weight   字体属性   记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位\nfont-style    字体样式   记住倾斜是 italic 不倾斜是 normal 工作中我们最常用 normal\nfont          字体连写   1、字体连写是有顺序的不能随意换位置，2、其中字号和字体必须同时出现\n\n\n# 四、文本样式\n\n\n# 4.1 文本缩进(ti)\n\n属性名： text-indent\n\n取值：\n\n * 数字+px\n * 数字+em（推荐：em 是一个相对单位，就是当前元素 (font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。）\n\n通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。\n\n    <style>\n        div{\n            text-indent: 20px;\n        }\n        p{\n            font-size: 30px;\n            text-indent: 2em;\n        }\n    </style>\n</head>\n<body>\n    <div>这是示例</div>\n    <p>这是示例</p>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4.2 文本水平对齐方式(ta)\n\n属性名： text-align\n\n取值：\n\n属性值           效果\nleft          左对齐(默认)\ncenter(tac)   居中对齐\nright         右对齐\n\n注意点：\n\n * 如果需要让文字水平居中，text-align属性需要给文字所在的标签（文字的父元素）设置\n\n\n# 4.3 文本修饰属性\n\n属性名： text-decoration\n\n取值：\n\n属性值                 效果\nunberline(tdu)      下划线（常用）\nline-through(tdl)   删除线（不常用）\noverline(tdo)       上划线（几乎不用）\nnone(tdn)           无装饰线（常用）\n\n注意点：\n\n * 开发中会使用text-decoration：none清除a标签（超链接）默认的下划线\n\n<style>\n        p{\n            text-decoration: line-through;\n        }\n        div{\n            text-decoration: underline;\n        }\n        h2{\n            text-decoration: overline;\n        }\n        a{\n            text-decoration: none;\n        }\n    </style>\n</head>\n<body>\n    <p>ppppp</p>\n    <div>divdivdiv</div>\n    <h2>h2h2h2</h2>\n    <a href="../13.路径/06.路径.html">../13.路径/06.路径.html</a>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.4行间距（行高）\n\n作用： 控制文字行与行之间的距离\n\n属性名： line-height\n\n取值：\n\n * 数字+px\n * 倍数（当前标签font-size的倍数）\n\n应用：\n\n1.让单行文本居中可以设置line-height：文字父元素高度\n\n2.网页精准布局时，会设置line-height：取消上下行间距\n\n行高： 行高与font连写的注意点：\n\n * 如果同时设置了行高和font连写，注意覆盖问题\n * font：style weight size/line-height family;\n\n**行间距测量技巧：**上一行文字的底部与本行文字的底部之间的距离就是行间距。\n\n\n# 4.5 文本属性总结\n\n属性                表示     注意点\ntext-align        文本对齐   可以设定文字水平的对齐方式\ntext-indent       文本缩进   通常我们用于段落首行缩进2个字的距离 text-indent: 2em;\ntext-decoration   文本修饰   牢记 添加下划线 underline 取消下划线 none\nline-height       行高     控制行与行之间的距离\n\n\n# 拓展\n\n通过margin：0 auto；实现标签水平居中',normalizedContent:'# 1.3 css语法规范\n\n使用 html 时，需要遵从一定的规范，css 也是如此，要想熟练地使用 css 对网页进行修饰，首先需要了解 css 样式规则。\n\ncss 规则由两个主要的部分构成：选择器 以及 一条或多条声明。\n\n * 选择器 是用于选出需要设置 css 样式的 html 标签，选择器后跟的花括号内是对该对象设置的具体样式\n * 属性 和 属性值 以 “键值对” 的形式出现 属性: 属性值;\n * 属性是对指定的对象设置的样式属性，例如：字体大小、文本颜色等\n * 属性和属性值之间用英文 : 分开\n * 多个 “键值对” 之间用英文 ; 进行区分（末尾的键值对可以不加 ;）\n\n所有的样式，都包含在 <style> 标签内，表示是样式表。\n\n<style> 一般写到 </head> 里。\n\n<head>\n    <style type="text/css">\n        h4 {\n            color: bule;\n            font-size: 100px;\n        }\n    </style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n注意：<style> 标签可以写到其他标签内部并作用与该标签区域内，但是强烈不推荐这种写法！\n\n> type="text/css" 可以省略。\n\n\n# 一、css引入方式\n\n\n# 1.1 css的三种引入方式\n\n按照 css 样式书写的位置（或者引入的方式），css 样式表可以分为三大类：\n\n * 行内样式表（行内式）\n * 内部样式表（嵌入式）\n * 外部样式表（外链式）\n\n\n# 1.2 行内样式表\n\n行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 css 样式，适合于修改简单样式。\n\n<div style="color: red; font-size: 12px;">\n    青春不常在，抓紧谈恋爱\n</div>\n\n\n1\n2\n3\n\n * style 其实就是标签的属性\n * 在双引号中间，写法要符合 css 规范\n * 可以控制当前的标签设置样式\n * 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用\n * 使用行内样式表设定 css，通常也被称为 行内式引入\n\n\n# 1.3 内部样式表\n\n内部样式表（嵌入样式表）时写到 html 页面内部，是将所有的 css 代码抽取出来，单独放到一个 <style> 标签中。\n\n<style type="text/css">\n    div {\n        color: red;\n        font-size: 12px;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n * <style> 标签理论上可以放在 html 文档的任何地方，但一般会放到文档的 <head> 标签中\n * 目前的浏览器已经支持省略 type 属性\n * 通过此种方式，可以方便控制当前整个页面中的元素样式设置\n * 代码结构清晰，但是并没有实现结构与样式完全分离\n * 使用内部样式表设定 css，通常也被称为 嵌入式引入，这种方式是我们练习时常用的方式\n\n\n# 1.4 外部样式表\n\n实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到 css 文件中，之后把 css 文件引入到 html 页面中使用。\n\n引入外部样式表分为两步：\n\n * 新建一个后缀名为：.css 的样式文件，把所有的 css 代码都放入此文件中\n * 在 html 页面中，使用 <link> 标签引入这个文件\n\n<link rel="stylesheet" type="text/css" href="css文件路径">\n\n\n1\n\n\n属性     作用\nrel    定义当前文档与被链接文档之间的关系，在这里需要指定为 "stylesheet"，表示被链接的文档是一个样式表文件\ntype   定被链接文档的 mime 类型，该属性最常见的 mime 类型是\n       "text/css"，该类型描述样式表，目前的浏览器已经支持省略 "type" 属性\nhref   定义所链接外部样式表文件的 url，可以是相对路径，也可以是绝对路径\n\n**注意：**使用外部样式表设定 css，通常也被称为 外链式 或 链接式引入，这种方式是开发中常用的方式。\n\n\n# 5.5 css引入方式总结\n\n样式表          优点             缺点       使用情况      控制范围\n行内样式表（行内式）   书写方便，权重高       结构样式混写   较少        控制一个标签\n内部样式表（嵌入式）   部分结构和样式分离      没有彻底分离   较多        控制一个页面\n外部样式表（外链式）   完全实现结构和样式相分离   需要引入     最多，吐血推荐   控制多个页面\n\n\n# 二、css基础选择器\n\n\n# 2.1 css选择器的作用\n\n选择器就是根据不同的需求把不同的标签选出来，这就是选择器的作用，简单来说，就是：选择标签用的。\n\nh1 {\n\tcolor: red;\n\tfont-size: 25px;\n}\n\n\n1\n2\n3\n4\n\n\n以上 css 做了两件事：\n\n * 找到所有的 h1 标签。（选对人）\n * 设置这些标签的样式：颜色为红色、字体大小为 25 像素。（做对事）\n\n\n# 2.2 选择器的分类\n\n选择器分为 基础选择器 和 复合选择器 两个大类，本文首先介绍一下基础选择器。\n\n * 基础选择器是由 单个 选择器组成的\n * 基础选择器又包括：标签选择器、类选择器、id 选择器、通配符选择器\n\n\n# 2.3 标签选择器\n\n标签选择器（元素选择器）是指用 html 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 css 样式。\n\n语法：\n\n标签名 {\n\t属性1: 属性值1;\n\t属性2: 属性值2;\n\t属性3: 属性值3;\n\t...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n作用：\n\n标签选择器可以把某一类标签全部选择出来，比如所有的 <div> 标签和所有的 <span> 标签。\n\n优点：\n\n能快速为页面中同类型的标签统一设置样式。\n\n缺点：\n\n不能设计差异化样式，只能选择全部的当前标签。\n\n<head>\n\n    <style type="text/css">\n        /* 会对所有的该标签元素运用样式，优点：快速统一，缺点：无法差异化设置 */\n        p {\n            color: green;\n        }\n        div {\n            color: pink;\n        }\n    </style>\n</head>\n<body>\n    <p>男</p>\n    <p>男</p>\n    <p>男</p>\n    <div>女生</div>\n    <div>女生</div>\n    <div>女生</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.4 类选择器\n\n如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用 类选择器 。\n\ncss 语法：\n\n.类名 {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n\n例如：将所有拥有 red 类的 html 元素均设置为红色。\n\n.red {\n\tcolor: red;\n}\n\n\n1\n2\n3\n\n\nhtml 语法：\n\n<div class="red">变红色</div>\n\n\n1\n\n\n类选择器在 html 中以 class 属性表示，在 css 中，类选择器以一个 . 号显示。\n\n注意：\n\n * 类选择器使用 .（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）\n * 可以理解为给这个标签起了一个别名来表示\n * 类名可以由数字、字母、下划线、中划线-组成，但不能以数字、中划线开头、\n * 一个标签可以有多个类名，类名之间以中括号隔开\n * 长名称或词组可以使用中横线 - 来为类命名\n * 不能使用已有的关键字作为类名\n * 命名要有意义，尽量使别人一眼就知道这个类名的目的（可读性第一，长度第二，推荐使用英语，如果是使用拼音请使用全拼）\n * 命名规范：见附件（css 命名规范.md）\n\n记忆口诀：样式点定义，结构类调用，一个或多个，开发最常用。\n\n<head>\n    <style type="text/css">\n        /* 类选择器口诀：样式 . 定义，结构 class 调用，一个或多个，开发最常用 */\n        .red {\n            width: 100px;\n            height: 100px;\n            background-color: red;\n        }\n\n        .green {\n            width: 100px;\n            height: 100px;\n            background-color: green;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="red"></div>\n    <div class="green"></div>\n    <div class="red"></div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n类选择器——多类名\n\n我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。\n\n * 在标签 class 属性中写多个类名\n * 多个类名中间必须用 空格 分开\n * 这个标签就可以分别具有这些类名的样式\n\n<head>\n    <style type="text/css">\n        /* 一个标签可以运用多个类选择器，之间用空格隔开 */\n        .red {\n            color: red;\n        }\n\n        .font35 {\n            font-size: 35px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="red font35">zhoujirui</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.5 id选择器\n\nid 选择器可以为标有特定 id 的 html 元素指定特定的样式。\n\nhtml 元素以 id 属性来设置 id 选择器，css 中 id 选择器以 # 来定义。\n\n语法：\n\n#id名 {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n\n**例如：**将 id 为 nav 元素中的内容设置为红色。\n\n#nav {\n\tcolor: red;\n}\n\n\n1\n2\n3\n\n\n**注意：**id 属性只能在每个 html 文档中出现一次。\n\n**口诀：**样式 # 定义，结构 id 调用，只能调用一次，别人切勿使用。\n\nid 选择器和类选择器的区别：\n\n * 类选择器 (class) 好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用\n * id 选择器好比人的身份证号码，全中国是唯一的，不可重复（同一个 id 选择器只能调用一次）\n * id 选择器和类选择器最大的不同在于使用次数上\n * 类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 javascript 搭配使用\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>基础选择器之id选择器</title>\n    <style type="text/css">\n        /* id 选择器口诀：样式 # 定义，结构 id 调用，只能调用一次，别人切勿使用 */\n        #pink {\n            color: pink;\n        }\n    </style>\n</head>\n\n<body>\n    <div id="pink">zhoujirui</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n再次强调：同一 id 只能定义一次，同一 id 选择器也只能调用一次！（对于 css 修改样式来说，最好使用类选择器，id 选择器主要与后面的 js 搭配使用）。\n\n\n# 2.6 通配符选择器\n\n在 css 中，通配符选择器使用 * 定义，它表示选取页面中所有元素（标签）。\n\n语法：\n\n* {\n\t属性1: 属性值1;\n\t...\n}\n\n\n1\n2\n3\n4\n\n * 通配符选择器不需要调用，自动就给所有的元素使用样式\n * 特殊情况才使用，后面讲解使用场景\n\n// 利用通配符选择器清除所有的元素标签的内外边距，后期讲\n* {\n\tmargin: 0;\n\tpadding: 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>基础选择器之通配符选择器</title>\n    <style type="text/css">\n        /* * 给 html 标签所有的元素都使用样式，并且这个过程是自动完成的，不需要手动调用 */\n        * {\n            color: red;\n        }\n    </style>\n</head>\n\n<body>\n    <div>我的</div>\n    <span>我的</span>\n    <ul>\n        <li>还是我的</li>\n    </ul>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.7 基础选择器总结\n\n基础选择器    作用                 特点                                使用情况        用法\n标签选择器    可以选出所有相同的标签，比如：p   不能差异化选择                           较多          p {color: red;}\n类选择器     可以选出 1 个或者 多个 标签   可以根据需求选择                          非常多         .nav {color: red;}\nid 选择器   一次只能选择 1 个标签       id 属性只能在每个 html 文档中出现一次，也只能调用一次   一般和 js 搭配   #nav {color: red;}\n通配符选择器   选择所有的标签            选择的太多，有部分不需要                      特殊情况使用      * {color: red;}\n\n * 每个基础选择器都有使用场景，都需要掌握\n * 如果是修改样式，类选择器是使用最多的\n\n\n# 三、css字体属性\n\ncss fonts（字体）属性用于定义：字体系列、大小、粗细、和 文字样式（如：斜体）。\n\n\n# 3.1 字体系列(略读)\n\ncss 使用 font-family 属性定义文本的字体系列。\n\np {\n\tfont-family: "microsoft yahei";\n}\n\ndiv {\n\tfont-family: arial, "microsoft yahei";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 各种字体之间必须使用英文状态下的逗号隔开\n * 一般情况下，如果有空格隔开的多个单词组成的字体，加引号\n * 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\n * 最常用的字体：body {font-family: "microsoft yahei", tahoma, arial, sans-serif, "hiragino sans gb";}\n\n![](/volumes/独立数据/mac桌面/i-love-you-3-thousand-master/我爱你，不止三千遍/html css/02【css简介、基础选择器、字体属性、文本属性、引入方式】/mark-img/2021041511462678.png)\n\n\n# 3.2 字体大小（fs）\n\ncss 使用 font-size 属性定义字体大小。\n\np {\n\tfont-size: 20px;\n}\n\n\n1\n2\n3\n\n * px（像素）大小是我们网页的最常用的单位\n * 谷歌浏览器默认的文字大小为：16px\n * 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小\n * 可以给 body 指定整个页面文字的大小\n\n\n# 3.3 字体粗细(fw)\n\ncss 使用 font-weight 属性设置文本字体的粗细。\n\np {\n\tfont-weight: bold;\n}\n\n\n1\n2\n3\n\n\n属性值       描述\nnormal    默认值（不加粗的）\nbold      定义粗体（加粗的）\n100-900   400 等同于 normal，而 700 等同于 bold，其它值一般不使用，注意这个数字后面不跟单位\n\n * 学会让加粗标签（比如 h 和 strong 等）变为不加粗，或者让其他标签加粗\n * 实际开发时，我们更喜欢用数字表示粗细\n * 不是所有字体都提供了九种粗细，因此部分取值页面中无效\n\n\n# 3.4 文字样式（斜体）(fs)\n\ncss 使用 font-style 属性设置文本的风格。\n\np {\n\tfont-style: normal;\n}\n\n\n1\n2\n3\n\n\n属性值      作用\nnormal   默认值，浏览器会显示标准的字体样式 font-style: normal;\nitalic   浏览器会显示斜体的字体样式\n\n**注意：**平时我们很少给文字加斜体，反而要给斜体标签 (em、i) 改为不倾斜字体。\n\n    <style>\n        div{\n            font-style: italic;\n        }\n        em{\n            /* 斜体改为不倾斜 */\n            font-style: normal;\n        }\n    </style>\n</head>\n<body>\n    <div>2313213</div>\n    <em>42342</em>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3.5 字体复合属性\n\n字体属性可以把以上文字样式综合来写，这样可以更节约代码。\n\nbody {\n\tfont: font-style font-weight font-size/line-height font-family;\n}\n\nbody {\n\tfont: normal 400 font-size/line-height "microsoft yahei", arial, sans-serif;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开\n * 倾斜和加粗可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用\n\n    <style>\n        /* 想要 div 文字变倾斜、加粗、字号设置为 16 像素，并且是微软雅黑 */\n        div {\n            /* font-style: italic;\n               font-weight: 700;\n               font-size: 16px;\n               font-family: \'microsoft yahei\'; */\n\n            /* 复合属性：简写的方式，里面的顺序不能打乱 以空格隔开 */\n            /* font: font-style font-weight font-size/line-height font-family; */\n            font: italic 700 16px \'microsoft yahei\';\n            /* 注意：不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 */\n            /* font: 20px \'microsoft yahei\'； */\n        }\n    </style>\n</head>\n\n<body>\n    <div>三生三世十里桃花，一心一意百行代码</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.6 字体属性总结\n\n属性            表示     注意点\nfont-size     字号     我们通常用的单位是 px 像素，一定要跟上单位\nfont-family   字体     实际工作中按照团队约定来写字体\nfont-weight   字体属性   记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位\nfont-style    字体样式   记住倾斜是 italic 不倾斜是 normal 工作中我们最常用 normal\nfont          字体连写   1、字体连写是有顺序的不能随意换位置，2、其中字号和字体必须同时出现\n\n\n# 四、文本样式\n\n\n# 4.1 文本缩进(ti)\n\n属性名： text-indent\n\n取值：\n\n * 数字+px\n * 数字+em（推荐：em 是一个相对单位，就是当前元素 (font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。）\n\n通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。\n\n    <style>\n        div{\n            text-indent: 20px;\n        }\n        p{\n            font-size: 30px;\n            text-indent: 2em;\n        }\n    </style>\n</head>\n<body>\n    <div>这是示例</div>\n    <p>这是示例</p>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 4.2 文本水平对齐方式(ta)\n\n属性名： text-align\n\n取值：\n\n属性值           效果\nleft          左对齐(默认)\ncenter(tac)   居中对齐\nright         右对齐\n\n注意点：\n\n * 如果需要让文字水平居中，text-align属性需要给文字所在的标签（文字的父元素）设置\n\n\n# 4.3 文本修饰属性\n\n属性名： text-decoration\n\n取值：\n\n属性值                 效果\nunberline(tdu)      下划线（常用）\nline-through(tdl)   删除线（不常用）\noverline(tdo)       上划线（几乎不用）\nnone(tdn)           无装饰线（常用）\n\n注意点：\n\n * 开发中会使用text-decoration：none清除a标签（超链接）默认的下划线\n\n<style>\n        p{\n            text-decoration: line-through;\n        }\n        div{\n            text-decoration: underline;\n        }\n        h2{\n            text-decoration: overline;\n        }\n        a{\n            text-decoration: none;\n        }\n    </style>\n</head>\n<body>\n    <p>ppppp</p>\n    <div>divdivdiv</div>\n    <h2>h2h2h2</h2>\n    <a href="../13.路径/06.路径.html">../13.路径/06.路径.html</a>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.4行间距（行高）\n\n作用： 控制文字行与行之间的距离\n\n属性名： line-height\n\n取值：\n\n * 数字+px\n * 倍数（当前标签font-size的倍数）\n\n应用：\n\n1.让单行文本居中可以设置line-height：文字父元素高度\n\n2.网页精准布局时，会设置line-height：取消上下行间距\n\n行高： 行高与font连写的注意点：\n\n * 如果同时设置了行高和font连写，注意覆盖问题\n * font：style weight size/line-height family;\n\n**行间距测量技巧：**上一行文字的底部与本行文字的底部之间的距离就是行间距。\n\n\n# 4.5 文本属性总结\n\n属性                表示     注意点\ntext-align        文本对齐   可以设定文字水平的对齐方式\ntext-indent       文本缩进   通常我们用于段落首行缩进2个字的距离 text-indent: 2em;\ntext-decoration   文本修饰   牢记 添加下划线 underline 取消下划线 none\nline-height       行高     控制行与行之间的距离\n\n\n# 拓展\n\n通过margin：0 auto；实现标签水平居中',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"CSS复合选择器、背景盒子透明、三大元素、圆角、阴影",frontmatter:{title:"CSS复合选择器、背景盒子透明、三大元素、圆角、阴影",date:"2020-04-06T01:28:54.000Z",permalink:"/pages/c7b8e9/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/03.CSS%E5%A4%8D%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E8%83%8C%E6%99%AF%E7%9B%92%E5%AD%90%E9%80%8F%E6%98%8E%E3%80%81%E4%B8%89%E5%A4%A7%E5%85%83%E7%B4%A0%E3%80%81%E5%9C%86%E8%A7%92%E3%80%81%E9%98%B4%E5%BD%B1.html",relativePath:"01.前端基础/02.CSS/03.CSS复合选择器、背景盒子透明、三大元素、圆角、阴影.md",key:"v-ca1a868a",path:"/pages/c7b8e9/",headers:[{level:2,title:"1.1 什么是复合选择器",slug:"_1-1-什么是复合选择器",normalizedTitle:"1.1 什么是复合选择器",charIndex:18},{level:2,title:"1.2 后代选择器",slug:"_1-2-后代选择器",normalizedTitle:"1.2 后代选择器",charIndex:209},{level:2,title:"1.3 子选择器",slug:"_1-3-子选择器",normalizedTitle:"1.3 子选择器",charIndex:555},{level:2,title:"1.4 交集选择器",slug:"_1-4-交集选择器",normalizedTitle:"1.4 交集选择器",charIndex:858},{level:2,title:"1.5 并集选择器",slug:"_1-5-并集选择器",normalizedTitle:"1.5 并集选择器",charIndex:1736},{level:2,title:"1.6 伪类选择器",slug:"_1-6-伪类选择器",normalizedTitle:"1.6 伪类选择器",charIndex:2690},{level:3,title:"1.6.1 常见伪类状态（了解）",slug:"_1-6-1-常见伪类状态-了解",normalizedTitle:"1.6.1 常见伪类状态（了解）",charIndex:2893},{level:3,title:"1.6.2 伪类选择器实际工作的用法（死了都要记）",slug:"_1-6-2-伪类选择器实际工作的用法-死了都要记",normalizedTitle:"1.6.2 伪类选择器实际工作的用法（死了都要记）",charIndex:3484},{level:3,title:"1.6.3 focus伪类选择器",slug:"_1-6-3-focus伪类选择器",normalizedTitle:"1.6.3 focus伪类选择器",charIndex:4131},{level:3,title:"1.6.4 ::placeholder占位符的颜色修改（死了都要记）",slug:"_1-6-4-placeholder占位符的颜色修改-死了都要记",normalizedTitle:"1.6.4 ::placeholder占位符的颜色修改（死了都要记）",charIndex:4468},{level:2,title:"1.7 复合选择器总结",slug:"_1-7-复合选择器总结",normalizedTitle:"1.7 复合选择器总结",charIndex:4613},{level:2,title:"3.1 背景颜色(bgc) background-color",slug:"_3-1-背景颜色-bgc-background-color",normalizedTitle:"3.1 背景颜色(bgc) background-color",charIndex:5164},{level:2,title:"3.2 背景图片(bgi)  background-image",slug:"_3-2-背景图片-bgi-background-image",normalizedTitle:"3.2 背景图片(bgi)  background-image",charIndex:null},{level:2,title:"3.3 背景平铺(bgr) background-repeat",slug:"_3-3-背景平铺-bgr-background-repeat",normalizedTitle:"3.3 背景平铺(bgr) background-repeat",charIndex:6400},{level:2,title:"3.4 背景图片位置(bgp) background-position",slug:"_3-4-背景图片位置-bgp-background-position",normalizedTitle:"3.4 背景图片位置(bgp) background-position",charIndex:6667},{level:2,title:"3.5 背景图像固定(bga)background-attachment",slug:"_3-5-背景图像固定-bga-background-attachment",normalizedTitle:"3.5 背景图像固定(bga)background-attachment",charIndex:7317},{level:2,title:"3.6 背景复合写法",slug:"_3-6-背景复合写法",normalizedTitle:"3.6 背景复合写法",charIndex:7561},{level:2,title:"3.7背景尺寸设置（bgs）background-size",slug:"_3-7背景尺寸设置-bgs-background-size",normalizedTitle:"3.7背景尺寸设置（bgs）background-size",charIndex:7793},{level:2,title:"3.8 背景颜色透明rgba（死了都要会）",slug:"_3-8-背景颜色透明rgba-死了都要会",normalizedTitle:"3.8 背景颜色透明rgba（死了都要会）",charIndex:8196},{level:2,title:"3.10 背景总结",slug:"_3-10-背景总结",normalizedTitle:"3.10 背景总结",charIndex:8402},{level:2,title:"2.1 什么是元素显示模式",slug:"_2-1-什么是元素显示模式",normalizedTitle:"2.1 什么是元素显示模式",charIndex:9088},{level:2,title:"2.2 块元素",slug:"_2-2-块元素",normalizedTitle:"2.2 块元素",charIndex:9249},{level:2,title:"2.3 行内元素",slug:"_2-3-行内元素",normalizedTitle:"2.3 行内元素",charIndex:9544},{level:2,title:"2.4 行内块元素",slug:"_2-4-行内块元素",normalizedTitle:"2.4 行内块元素",charIndex:9830},{level:2,title:"2.5 元素显示模式总结",slug:"_2-5-元素显示模式总结",normalizedTitle:"2.5 元素显示模式总结",charIndex:10048},{level:2,title:"2.6 元素显示模式转换display（死了都要记）",slug:"_2-6-元素显示模式转换display-死了都要记",normalizedTitle:"2.6 元素显示模式转换display（死了都要记）",charIndex:10338},{level:2,title:"5.1 圆角border-radius",slug:"_5-1-圆角border-radius",normalizedTitle:"5.1 圆角border-radius",charIndex:11682},{level:2,title:"5.2 盒子阴影",slug:"_5-2-盒子阴影",normalizedTitle:"5.2 盒子阴影",charIndex:13374},{level:2,title:"5.3 文字阴影",slug:"_5-3-文字阴影",normalizedTitle:"5.3 文字阴影",charIndex:15443}],headersStr:"1.1 什么是复合选择器 1.2 后代选择器 1.3 子选择器 1.4 交集选择器 1.5 并集选择器 1.6 伪类选择器 1.6.1 常见伪类状态（了解） 1.6.2 伪类选择器实际工作的用法（死了都要记） 1.6.3 focus伪类选择器 1.6.4 ::placeholder占位符的颜色修改（死了都要记） 1.7 复合选择器总结 3.1 背景颜色(bgc) background-color 3.2 背景图片(bgi)  background-image 3.3 背景平铺(bgr) background-repeat 3.4 背景图片位置(bgp) background-position 3.5 背景图像固定(bga)background-attachment 3.6 背景复合写法 3.7背景尺寸设置（bgs）background-size 3.8 背景颜色透明rgba（死了都要会） 3.10 背景总结 2.1 什么是元素显示模式 2.2 块元素 2.3 行内元素 2.4 行内块元素 2.5 元素显示模式总结 2.6 元素显示模式转换display（死了都要记） 5.1 圆角border-radius 5.2 盒子阴影 5.3 文字阴影",content:'# 一、CSS的复合选择器\n\n\n# 1.1 什么是复合选择器\n\n在 CSS 中，可以根据选择器的类型把选择器分为：基础选择器 和 复合选择器，复合选择器是建立在基础选择器之上，对基础选择器进行组合形成的。\n\n * 复合选择器可以更准确、更高效的选择目标元素（标签）\n * 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的\n * 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等\n\n\n# 1.2 后代选择器\n\n后代选择器 又称为 包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n语法：\n\n元素1 元素2 { 样式声明 }\n\n\n1\n\n\n上述语法表示选择 元素 1 里面的所有元素 2 （后代元素）。\n\n例如：\n\ndiv p {\n            color: red;\n        }\n\n\n1\n2\n3\n\n * 元素1 和 元素2 中间用 空格 隔开\n * 元素1 是父级，元素2 是子级，最终选择的是 元素2，即：元素1 是不会生效样式的\n * 元素2 可以是儿子，也可以是孙子等，只要是 元素1 的后代即可\n * 元素1 和 元素2 可以是任意基础选择器\n\n\n# 1.3 子选择器\n\n子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。\n\n注意：是最近一级而并非最近一个！\n\n语法：\n\n元素1>元素2 { 样式声明 }\n\n\n1\n\n\n上述语法表示选择元素1 里面的所有直接后代（子元素）元素2。\n\n例如：\n\ndiv>p { 样式声明 } \t/* 选择 div 里面所有最近一级 p 标签元素 */\n\n\n1\n\n\n * 元素1 和 元素2 中间用 大于号 隔开\n\n * 元素1 是父级，元素2 是子级，最终选择的是元素2，即元素1 是不会生效样式的\n\n * 元素2 必须是亲儿子，其孙子、重孙之类都不归他管，你也可以叫：亲儿子选择器\n\n\n# 1.4 交集选择器\n\n选中页面中 同时满足 多个选择器的标签，满足即又的关系，主要是可以提高被选择元素的权重；\n\n基本语法\n\n选择器1选择器2 { css样式 }\n\n01、交集选择器可以更加精准的选择某一个元素，相当于即又关系，也就是两个需求都要满足（比如：我要找一个人，这个人是男生并且有个名字叫老王 ---- 男生老王）；\n\n02、最常用的还是标签选择器和类选择器的搭配使用,选择器2也可以是id选择器；\n\n03、交集选择器两个选择器之间是绝对不能书写空格，有了空格就会变成后代选择器；\n\n    <style>\n        div {\n            width: 200px;\n            height: 100px;\n            background-color: aquamarine;\n        }\n\n        /*  选择器1选择器2 {  css样式 } */\n        div.box {\n            background-color: green;\n        }\n        /* 交集选择器的选择权重会大于直接类选择器 */\n        .box {\n            background-color: red;\n        }\n    </style>\n    <div>1</div>\n    <div class="box">2</div>\n    <div>3</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意：交集选择器后期经常用来提升元素的选择权重，以下的代码会选择第二个样式；\n\n        .list .san {\n            color: green;\n        }\n\n        .list li.san {\n            color: gold;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.5 并集选择器\n\n并集选择器 可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。 并集选择器 是各选择器通过英文逗号 , 连接而成，任何形式的选择器都可以作为并集选择器的一部分。\n\n语法：\n\n元素1, 元素2, 元素3 { 样式声明 }\n\n\n1\n\n\n元素1,\n元素2,\n元素3 {\n    样式声明\n}\n/* 推荐写法，编码风格 */\n\n\n1\n2\n3\n4\n5\n6\n\n\n上述语法表示选择元素1、元素2 和 元素3。\n\n例如：\n\nul, div { 样式声明 }\t\t /* 选择 ul 和 div标签元素 */\n\n\n1\n\n * 元素1 和 元素2 中间用逗号隔开（最后一个不加逗号）\n * 逗号可以理解为和的意思\n * 并集选择器通常用于集体声明\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <title>复合选择器之并集选择器</title>\n    <style>\n        /* 要求1：请把熊大和熊二改为粉色 */\n        /* div,\n        p {\n            color: pink;\n        } */\n\n        /* 要求2：请把熊大和熊二改为红色，还有小猪一家改为粉色 */\n        div,\n        p,\n        .pig li {\n            color: pink;\n        }\n        /* 语法规范：并集选择器通常竖着写 */\n    </style>\n</head>\n\n<body>\n    <div>熊大</div>\n    <p>熊二</p>\n    <span>光头强</span>\n    <ul class="pig">\n        <li>小猪佩奇</li>\n        <li>猪爸爸</li>\n        <li>猪妈妈</li>\n    </ul>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 1.6 伪类选择器\n\n伪类选择器 用于向某些选择器添加特殊的效果，比如：给链接添加特殊效果（链接伪类），或选择第 n 个元素（结构伪类）。 伪类选择器 书写最大的特点是用冒号 : 表示，比如：:hover、:first-child。 因为伪类选择器很多，比如：链接伪类、结构伪类 等，所以这里先讲解常用的链接伪类选择器。\n\n> 伪类的由来：因为在页面中并没有这个真实存在的类，所以称为 “伪类”。\n\n\n# 1.6.1 常见伪类状态（了解）\n\n选择器:link 鼠标未访问的链接（访问前） 选择器:visited 鼠标已访问的链接（访问后） 选择器:hover 鼠标移动到连接上（鼠标经过） 选择器:active 鼠标选定的链接（按下鼠标的时候）\n\n**注意：**如果以上四个状态都要书写必须按照L~V~H~A的顺序来书写，否则就会失去效果；\n\n    <style>\n        /* 鼠标访问前 */\n        a:link {\n            color: red;\n        }\n\n        /* 鼠标访问后 */\n        a:visited {\n            color: green;\n        }\n\n        /* 鼠标访问的时候 */\n        a:hover {\n            color: royalblue;\n        }\n\n        /* 鼠标按下的时候 */\n        a:active {\n            color: tomato;\n        }\n    </style>\n\n    <a href="#"></a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.6.2 伪类选择器实际工作的用法（死了都要记）\n\n实际开发中我们不会将伪类的四个状态都书写，我们只需要设置鼠标访问状态:hover即可；\n\n01、统一设置一个超链接a的样式，表示我们四个状态的样式都一致；\n\n02、然后通过样式覆盖的原理，设置鼠标访问:hover的样式即可；\n\n    <style>\n        /*01、设置a的四个状态link、visited、hover、active的样式都一致 */\n        .nav li a {\n            font-style: 18px;\n            color: #333;\n        }\n\n        /* 02、单独设置鼠标访问经过的样式覆盖前面的样式即可 */\n        .nav li a:hover {\n            color: red;\n        }\n    </style>\n    <div class="nav">\n        <ul>\n            <li><a href="#">首页</a></li>\n            <li><a href="#">产品分类</a></li>\n            <li><a href="#">联系我们</a></li>\n        </ul>\n    </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 1.6.3 focus伪类选择器\n\n用于选取获表单元素的焦点，一般input表单或者文本域textarea才能获取该焦点；\n\n    <style>\n        input:focus {\n            background: springgreen;\n        }\n\n        textarea:focus {\n            background-color: thistle;\n        }\n    </style>\n\n    <input type="text">\n    <textarea cols="30" rows="10"></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1.6.4 ::placeholder占位符的颜色修改（死了都要记）\n\n我们只能用这样方法修改占位符的颜色，其他样是不能 在这里修改；\n\n        input::placeholder {\n            color: red;\n        }\n\n\n1\n2\n3\n\n\n\n# 1.7 复合选择器总结\n\n选择器          作用            特征         使用情况   隔开符号及用法\n后代选择器        用来选择后代元素      可以是子孙后代    较多     符号是空格 .nav a\n子代选择器        选择最近一级元素      只选亲儿子      较少     符号是大于 .nav>p\n并集选择器        选择某些相同样式的元素   可以用于集体声明   较多     符号是逗号 .nav, .header\n链接伪类选择器      选择不同状态的链接     跟链接相关      较多     重点记住 a{} 和 a:hover 实际开发的写法\n:focus 选择器   选择获得光标的表单     跟表单相关      较少     input:focus 记住这个写法\n\n强调：复合选择器的层级写得越细越好（可读性，可维护性，安全性），同时将复合选择器的层级写得越细，可以提前避免大部分的选择器优先级混乱！\n\n\n# 二、CSS 的背景（background）\n\n通过 CSS 背景属性，可以给页面元素添加背景样式。 背景属性可以设置 背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定 等。\n\n\n# 3.1 背景颜色(bgc) background-color\n\nbackground-color 属性定义了元素的背景颜色。\n\nbackground-color: 颜色值;\n\n\n1\n\n\n一般情况下元素背景颜色默认值是 transparent（透明），我们也可以手动指定背景颜色为透明色。\n\nbackground-color: transparent;\n\n\n1\n\n\n目前 CSS 还支持丰富的渐变色，但是某些浏览器不支持，这里了解即可，具体内容请查阅资料。\n\n    <title>渐变</title>\n    <style>\n        #grad1 {\n            height: 200px;\n            /* 浏览器不支持时显示 */\n            background-color: red;\n            /* 线性渐变 - 从上到下（默认情况下）*/\n            background-image: linear-gradient(#e66465, #9198e5);\n        }\n    </style>\n</head>\n\n<body>\n    <h3>线性渐变 - 从上到下</h3>\n    <p>从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色：</p>\n\n    <div id="grad1"></div>\n\n    <p><strong>注意：</strong> Internet Explorer 9 及之前的版本不支持渐变。</p>\n</body>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 3.2 背景图片(bgi) background-image\n\nbackground-image 属性描述了元素的背景图像，实际开发常用于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置（精灵图也是一种运用场景）。\n\nbackground-image : none | url(url)\n\n\n1\n\n\n参数值    作用\nnone   无背景图（默认的）\nurl    使用绝对或相对地址指定背景图像\n\n注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。\n\nbackground-color: pink;\nbackground-image: url(../images/logo.png);\n/* 1、背景图片不平铺 */\n/* background-repeat: no-repeat; */\n/* 2、默认情况下，背景图片是平铺的 */\n/* background-repeat: repeat; */ /* 页面元素既可以添加背景颜色也可以添加背景图片，只不过背景图片区域会覆盖背景颜色 */\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 背景平铺(bgr) background-repeat\n\n如果需要在 HTML 页面上对背景图像进行平铺，可以使用 background-repeat 属性。\n\nbackground-repeat: repeat | no-repeat | repeat-x | repeat-y\n\n\n1\n\n\n参数值         作用\nrepeat      背景图像在纵向和横向上平铺（默认的）\nno-repeat   背景图像不平铺\nrepeat-x    背景图像在横向上平铺\nrepeat-y    背景图像在纵向上平铺\n\n\n# 3.4 背景图片位置(bgp) background-position\n\n利用 background-position 属性可以改变图片在背景中的位置。\n\nbackground-position: x y;\n\n\n1\n\n\n参数代表的意思是：x 坐标 和 y 坐标，可以使用 方位名词 或者 精确单位。\n\n参数值        说明\nlength     百分数 | 由浮点数字和单位标识符组成的长度值\nposition   top | center | bottom | left | rigth 方位名词\n\n * 参数是方位名词\n   \n   * 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致\n   * 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐\n\n * 参数是精确单位\n   \n   * 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标\n   * 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中\n\n * 参数是百分比\n   \n   * 取值为百分计算的值是按照父级盒子宽高计算的\n   * 如果取值为一个值，那么这个值是表示左右的水平位置，垂直方向的位置默认居中显示；\n\nbackground-position: 50% 50%;\n\n\n1\n\n * 参数是混合单位\n   * 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标\n\n\n# 3.5 背景图像固定(bga)background-attachment\n\nbackground-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。\n\nbackground-attachment 后期可以制作 视差滚动 的效果。\n\nbackground-attachment : scroll | fixed\n\n\n1\n\n\n参数       作用\nscroll   背景图像是随对象内容滚动的（可见区域取决于背景图像的高度）\nfixed    背景图像固定\n\n\n# 3.6 背景复合写法\n\n为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性 background 中，从而节约代码量。 当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为： background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置\n\n\n\nbackground: magenta url(./img/icon.png) no-repeat 5px center;\n\n\n1\n\n\n这是实际开发中，我们更提倡的写法。\n\n\n# 3.7背景尺寸设置（bgs）background-size\n\n如果背景图片小于当前的盒子或者大于当前的盒子，设置背景图的尺寸大小；\n\n * 取值为cover（常用）\n\n背景图等比缩放，一直到铺满整个盒子\n\nbackground-size: cover;\n\n\n1\n\n\n注意：该属性取值如果背景图和盒子比例不一致。可能会导致背景图过大超出盒子显示不全，溢出隐藏；\n\n * 取值为contain\n\n背景图等比缩放，直到背景图的宽或者高和盒子一致就停止缩放\n\nbackground-size: contain;\n\n\n1\n\n\n**注意：**该属性取值如果背景图和盒子比例不一致可能会导致背景图不会完全铺满盒子；\n\n * 取值为实际像素大小（移动端小图标常用）\n\n设置背景图大小固定，一般我们可以让宽设置固定的值，然后让高为auto自动计算\n\nbackground-size: 45px auto;\n\n\n1\n\n\n\n# 3.8 背景颜色透明rgba（死了都要会）\n\n我们可以设置背景颜色的透明度从而实现透明效果；\n\n语法： rgba(red, green, blue, alpha)\n\nalpha取值为0-1之间，0表示完全透明，1表示不透明，之间的数字表示透明的程度\n\nbackground-color: rgba(0,0,0,.5);\n\n\n1\n\n\n**注意：**rgba只能设置背景颜色透明不会影响盒子里面的内容透明；\n\n\n# 3.10 背景总结\n\n属性                     作用        值\nbackgroud-color        背景颜色      预定义的颜色值 / 十六进制 / RGB代码\nbackgroud-image        背景图片      url（图片路径）\nbackgroud-repeat       是否平铺      repeat / no-repeat / repeat-x / repeat-y\nbackgroud-position     背景位置      length / position 分别是 x 和 y 坐标\nbackgroud-attachment   背景附着      scroll（背景滚动）/ fixed（背景固定）\n背景简写                   书写更简单     背景颜色 背景图片地址 背景平铺 背景滚动 背景位置\n背景色半透明                 背景颜色半透明   background: rgba(0, 0, 0, 0.3); 后面必须是4个值\n\n\n# 三、盒子透明opacity\n\n语法： opacity: 透明值；\n\nopacity 设置盒子的透明，取值为0-1之间，0表示完全透明，1表示不透明，之间的小数表示透明的程度\n\n opacity: .5;\n\n\n1\n\n\n**注意：**用opacity 设置透明，不仅让背景颜色透明，也会影响盒子里面的内容也跟着透明，所以我们不建议使用，后期在制作css3的动画时会用到；\n\n\n# 四、CSS 的元素显示模式\n\n\n# 2.1 什么是元素显示模式\n\n**作用：**网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。\n\n元素显示模式 就是元素（标签）以什么方式进行显示，比如 <div> 自己占一行，比如一行可以放多个 <span>。\n\nHTML 元素一般分为 块元素 和 行内元素 两种类型。\n\n\n# 2.2 块元素\n\n常见的块元素有 <h1> ~ <h6>、<p>、<div>、<ul>、<ol>、<li>、<dl>、<dt>、<dd>、<table>、<tr>、<form> 等，其中 <div> 标签是最典型的块元素。\n\n块级元素的特点：\n\n * 比较霸道，自己独占一行\n * 高度，宽度、外边距以及内边距都可以控制\n * 宽度默认是容器（父级宽度）的 100%\n * 是一个容器及盒子，里面可以放行内或者块级元素\n\n注意：\n\n * 块元素里面可以嵌套任何元素，但是段落标签p里面不能嵌套div标签，因为浏览器解析的时候会将p 嵌套div解析成两个p标签，一个div标签显示；\n\n\n# 2.3 行内元素\n\n常见的行内元素有 <a>、<span>、<em>、<strong> 等，其中 <span> 标签是最典型的行内元素，有的地方也将行内元素称为内联元素。\n\n行内元素的特点：\n\n * 相邻行内元素在一行上，一行可以显示多个\n\n * 高、宽直接设置是无效的\n\n * 默认的宽是由内容多少撑开的\n\n * 设置内外边距上下不生效，左右生效\n\n * 行内元素中只能嵌套文本图片或者其他行内元素，但是超链接a里面可以嵌套块级元素\n\n注意：\n\n * 链接里面不能再放链接\n * 特殊情况链接 <a> 里面可以放块级元素，但是给 <a> 转换一下块级模式最安全\n\n\n# 2.4 行内块元素\n\n在行内元素中有几个特殊的标签：<img>、<input>、<th>、<td>、button，它们同时具有 块元素 和 行内元素 的特点，有些资料称它们为 行内块元素。\n\n行内块元素的特点：\n\n * 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）\n * 默认宽度就是它本身内容的宽度（行内元素特点）\n * 高度，行高、外边距以及内边距都可以控制（块级元素特点）\n\n\n# 2.5 元素显示模式总结\n\n元素模式    元素排列          设置样式           默认宽度       包含\n块级元素    一行只能放一个块级元素   可以设置宽度和高度      容器的 100%   容量级可以包含任何标签\n行内元素    一行可以放多个行内元素   不可以直接设置宽度和高度   它本身内容的宽度   容纳文本或其他行内元素\n行内块元素   一行放多个行内块元素    可以设置宽度和高度      它本身内容的宽度   \n\n学习元素显示模式的主要目的是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。\n\n\n# 2.6 元素显示模式转换display（死了都要记）\n\n实际开发中各个元素的显示模式是可以通过display设置不同的属性值实现的；\n\n * 将元素转化为块元素（重点） display:block;\n * 将元素转化为行内元素 display:inline;\n * 将元素转化为行内块元素 display:inline-block;\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>元素显示模式之显示模式的转换</title>\n    <style>\n        a {\n            width: 150px;\n            height: 50px;\n            background-color: orange;\n            /* 把行内元素 a 转换为 块级元素 */\n            display: block;\n        }\n\n        div {\n            width: 300px;\n            height: 100px;\n            background-color: black;\n            color: white;\n            /* 把 div 块级元素转化为行内元素 */\n            display: inline;\n        }\n\n        span {\n            width: 300px;\n            height: 30px;\n            background-color: skyblue;\n            /* 行内元素转化为行内块元素 */\n            display: inline-block;\n        }\n    </style>\n</head>\n\n<body>\n    <a href="#">我是行内元素</a>\n    <a href="#">我是行内元素</a>\n    <div>我是块级元素</div>\n    <div>我是块级元素</div>\n    <span>行内元素转化为行内块元素</span>\n    <span>行内元素转化为行内块元素</span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n\n# 五、css3常用新属性（死了都要会）\n\n\n# 5.1 圆角border-radius\n\nCSS 3 新增了圆角边框样式。\n\nborder-radius 属性用于设置元素的外边框圆角。\n\nborder-radius 顾名思义：边框半径。\n\n（椭）圆与边框的交集形成圆角效果。\n\n        div {\n            width: 300px;\n            height: 150px;\n            background-color: pink;\n            border-radius: 24px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 圆角矩形\n\nborder-radius取值为一个实际像素\n\n        .box {\n            width: 300px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 15px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 圆形\n\n矩形必须是正方形，设置border-radius取值大于等于高度一半或者直接设置50%\n\n        .box {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            /* border-radius: 50px; */\n            border-radius: 50%;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n * 胶囊形状\n\n矩形必须是长方形，设置border-radius取值大于等于高度一半；\n\n\n\n        .box {\n            width: 300px;\n            height: 50px;\n            background-color: #f00;\n            border-radius: 25px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n * 椭圆\n\n如果设置border-radius取值为50%，会绘制椭圆\n\n\n\n        .box {\n            width: 300px;\n            height: 50px;\n            background-color: #f00;\n            border-radius: 50%;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n * 半圆\n\n设置border-radius取值个数为4个值：分别是：左上角 右上角 右下角 左下角\n\n语法：border-radius：左上角 右上角 右下角 左下角；\n\n        .box {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 0 50px 50px 0;\n        }\n\n        .box1 {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 50px 0 0 50px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n注意：\n\n * 参数值可以为数值或百分比的形式\n * 如果是正方形，想要设置为圆形，那么只需要把数值修改为高度或者宽度的一半即可，或者直接写为 50%\n * 如果是个矩形，设置为高度的一半就可以做 “胶囊” 效果了\n\n\n# 5.2 盒子阴影\n\nCSS 3 新增了盒子阴影。\n\nbox-shadow 属性用于为盒子添加阴影。\n\n语法：\n\nbox-shadow: h-shadow v-shadow blur spread color inset;\nbox-shadow:水平阴影   垂直阴影   模糊距离   阴影大小   阴影颜色  内/外阴影；\n\n\n1\n2\n\n\n值          描述\nh-shadow   必须。水平阴影的位置，允许负值。\nv-shadow   必须。垂直阴影的位置，允许负值。\nblur       可选。模糊距离（虚实程度）。\nspread     可选。阴影的尺寸（大小）。\ncolor      可选。阴影的颜色，请参阅 CSS 颜色值（阴影多为半透明颜色）。\ninset      可选。将外部阴影（outset）改为内部阴影（outset 不能指定，默认为空即可）。\n\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: salmon;\n            margin: 100px auto;\n            /* box-shadow: 10px 10px; */\n        }\n\n        /* 伪类不仅仅可以用于 a 链接，还能用于其他标签 */\n        /* 原先盒子没有影子,当我们鼠标经过盒子就添加阴影效果 */\n        div:hover {\n            box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3);\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n三边阴影、双边阴影、单边阴影的设置方法：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>盒子阴影 三边阴影、双边阴影、单边阴影</title>\n    <style>\n        div {\n            width: 100px;\n            height: 100px;\n            background-color: #000;\n            margin: 25px auto;\n            color: white;\n        }\n\n        .a {\n            box-shadow: 0 0 25px 5px red;\n        }\n\n        /* 三边阴影就是直接把整个阴影部分往下边移 */\n        .b {\n            box-shadow: 0 6px 10px 0 red;\n        }\n\n        /* 两边阴影要用盒子嵌套来解决 */\n        .c1 {\n            box-shadow: 0 10px 10px -5px red;\n        }\n\n        .c2 {\n            width: 100%;\n            box-shadow: 0 -10px 10px -5px red;\n        }\n\n        /* 单边阴影就是直接把整个阴影部分往下边移，并且减小阴影大小 */\n        .d {\n            box-shadow: 0 10px 10px -5px red;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="a">四边阴影</div>\n    <div class="b">三边阴影</div>\n    <div class="c1">\n        <div class="c2">两边阴影</div>\n    </div>\n    <div class="d">一边阴影</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n\n# 5.3 文字阴影\n\nCSS 3 新增了文字阴影。\n\ntext-shadow 属性用于为文本添加阴影。\n\n语法：\n\ntext-shadow: h-shadow v-shadow blur color;\ntext-shadow:水平阴影   垂直阴影   模糊距离   阴影颜色 ；\n\n\n1\n2\n\n\n值          描述\nh-shadow   必须。水平阴影的位置。允许负值。\nv-shadow   必须。垂直阴影的位置。允许负值。\nblur       可选。模糊的距离（虚实程度）。\ncolor      可选。阴影的颜色。参阅 CSS 颜色值。\n\ndiv {\n            font-size: 50px;\n            color: salmon;\n            font-weight: 700;\n            text-shadow: 5px 5px 6px rgba(0, 0, 0, .3);\n        }\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# 一、css的复合选择器\n\n\n# 1.1 什么是复合选择器\n\n在 css 中，可以根据选择器的类型把选择器分为：基础选择器 和 复合选择器，复合选择器是建立在基础选择器之上，对基础选择器进行组合形成的。\n\n * 复合选择器可以更准确、更高效的选择目标元素（标签）\n * 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的\n * 常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等\n\n\n# 1.2 后代选择器\n\n后代选择器 又称为 包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n语法：\n\n元素1 元素2 { 样式声明 }\n\n\n1\n\n\n上述语法表示选择 元素 1 里面的所有元素 2 （后代元素）。\n\n例如：\n\ndiv p {\n            color: red;\n        }\n\n\n1\n2\n3\n\n * 元素1 和 元素2 中间用 空格 隔开\n * 元素1 是父级，元素2 是子级，最终选择的是 元素2，即：元素1 是不会生效样式的\n * 元素2 可以是儿子，也可以是孙子等，只要是 元素1 的后代即可\n * 元素1 和 元素2 可以是任意基础选择器\n\n\n# 1.3 子选择器\n\n子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。\n\n注意：是最近一级而并非最近一个！\n\n语法：\n\n元素1>元素2 { 样式声明 }\n\n\n1\n\n\n上述语法表示选择元素1 里面的所有直接后代（子元素）元素2。\n\n例如：\n\ndiv>p { 样式声明 } \t/* 选择 div 里面所有最近一级 p 标签元素 */\n\n\n1\n\n\n * 元素1 和 元素2 中间用 大于号 隔开\n\n * 元素1 是父级，元素2 是子级，最终选择的是元素2，即元素1 是不会生效样式的\n\n * 元素2 必须是亲儿子，其孙子、重孙之类都不归他管，你也可以叫：亲儿子选择器\n\n\n# 1.4 交集选择器\n\n选中页面中 同时满足 多个选择器的标签，满足即又的关系，主要是可以提高被选择元素的权重；\n\n基本语法\n\n选择器1选择器2 { css样式 }\n\n01、交集选择器可以更加精准的选择某一个元素，相当于即又关系，也就是两个需求都要满足（比如：我要找一个人，这个人是男生并且有个名字叫老王 ---- 男生老王）；\n\n02、最常用的还是标签选择器和类选择器的搭配使用,选择器2也可以是id选择器；\n\n03、交集选择器两个选择器之间是绝对不能书写空格，有了空格就会变成后代选择器；\n\n    <style>\n        div {\n            width: 200px;\n            height: 100px;\n            background-color: aquamarine;\n        }\n\n        /*  选择器1选择器2 {  css样式 } */\n        div.box {\n            background-color: green;\n        }\n        /* 交集选择器的选择权重会大于直接类选择器 */\n        .box {\n            background-color: red;\n        }\n    </style>\n    <div>1</div>\n    <div class="box">2</div>\n    <div>3</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意：交集选择器后期经常用来提升元素的选择权重，以下的代码会选择第二个样式；\n\n        .list .san {\n            color: green;\n        }\n\n        .list li.san {\n            color: gold;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.5 并集选择器\n\n并集选择器 可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。 并集选择器 是各选择器通过英文逗号 , 连接而成，任何形式的选择器都可以作为并集选择器的一部分。\n\n语法：\n\n元素1, 元素2, 元素3 { 样式声明 }\n\n\n1\n\n\n元素1,\n元素2,\n元素3 {\n    样式声明\n}\n/* 推荐写法，编码风格 */\n\n\n1\n2\n3\n4\n5\n6\n\n\n上述语法表示选择元素1、元素2 和 元素3。\n\n例如：\n\nul, div { 样式声明 }\t\t /* 选择 ul 和 div标签元素 */\n\n\n1\n\n * 元素1 和 元素2 中间用逗号隔开（最后一个不加逗号）\n * 逗号可以理解为和的意思\n * 并集选择器通常用于集体声明\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <title>复合选择器之并集选择器</title>\n    <style>\n        /* 要求1：请把熊大和熊二改为粉色 */\n        /* div,\n        p {\n            color: pink;\n        } */\n\n        /* 要求2：请把熊大和熊二改为红色，还有小猪一家改为粉色 */\n        div,\n        p,\n        .pig li {\n            color: pink;\n        }\n        /* 语法规范：并集选择器通常竖着写 */\n    </style>\n</head>\n\n<body>\n    <div>熊大</div>\n    <p>熊二</p>\n    <span>光头强</span>\n    <ul class="pig">\n        <li>小猪佩奇</li>\n        <li>猪爸爸</li>\n        <li>猪妈妈</li>\n    </ul>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 1.6 伪类选择器\n\n伪类选择器 用于向某些选择器添加特殊的效果，比如：给链接添加特殊效果（链接伪类），或选择第 n 个元素（结构伪类）。 伪类选择器 书写最大的特点是用冒号 : 表示，比如：:hover、:first-child。 因为伪类选择器很多，比如：链接伪类、结构伪类 等，所以这里先讲解常用的链接伪类选择器。\n\n> 伪类的由来：因为在页面中并没有这个真实存在的类，所以称为 “伪类”。\n\n\n# 1.6.1 常见伪类状态（了解）\n\n选择器:link 鼠标未访问的链接（访问前） 选择器:visited 鼠标已访问的链接（访问后） 选择器:hover 鼠标移动到连接上（鼠标经过） 选择器:active 鼠标选定的链接（按下鼠标的时候）\n\n**注意：**如果以上四个状态都要书写必须按照l~v~h~a的顺序来书写，否则就会失去效果；\n\n    <style>\n        /* 鼠标访问前 */\n        a:link {\n            color: red;\n        }\n\n        /* 鼠标访问后 */\n        a:visited {\n            color: green;\n        }\n\n        /* 鼠标访问的时候 */\n        a:hover {\n            color: royalblue;\n        }\n\n        /* 鼠标按下的时候 */\n        a:active {\n            color: tomato;\n        }\n    </style>\n\n    <a href="#"></a>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.6.2 伪类选择器实际工作的用法（死了都要记）\n\n实际开发中我们不会将伪类的四个状态都书写，我们只需要设置鼠标访问状态:hover即可；\n\n01、统一设置一个超链接a的样式，表示我们四个状态的样式都一致；\n\n02、然后通过样式覆盖的原理，设置鼠标访问:hover的样式即可；\n\n    <style>\n        /*01、设置a的四个状态link、visited、hover、active的样式都一致 */\n        .nav li a {\n            font-style: 18px;\n            color: #333;\n        }\n\n        /* 02、单独设置鼠标访问经过的样式覆盖前面的样式即可 */\n        .nav li a:hover {\n            color: red;\n        }\n    </style>\n    <div class="nav">\n        <ul>\n            <li><a href="#">首页</a></li>\n            <li><a href="#">产品分类</a></li>\n            <li><a href="#">联系我们</a></li>\n        </ul>\n    </div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 1.6.3 focus伪类选择器\n\n用于选取获表单元素的焦点，一般input表单或者文本域textarea才能获取该焦点；\n\n    <style>\n        input:focus {\n            background: springgreen;\n        }\n\n        textarea:focus {\n            background-color: thistle;\n        }\n    </style>\n\n    <input type="text">\n    <textarea cols="30" rows="10"></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 1.6.4 ::placeholder占位符的颜色修改（死了都要记）\n\n我们只能用这样方法修改占位符的颜色，其他样是不能 在这里修改；\n\n        input::placeholder {\n            color: red;\n        }\n\n\n1\n2\n3\n\n\n\n# 1.7 复合选择器总结\n\n选择器          作用            特征         使用情况   隔开符号及用法\n后代选择器        用来选择后代元素      可以是子孙后代    较多     符号是空格 .nav a\n子代选择器        选择最近一级元素      只选亲儿子      较少     符号是大于 .nav>p\n并集选择器        选择某些相同样式的元素   可以用于集体声明   较多     符号是逗号 .nav, .header\n链接伪类选择器      选择不同状态的链接     跟链接相关      较多     重点记住 a{} 和 a:hover 实际开发的写法\n:focus 选择器   选择获得光标的表单     跟表单相关      较少     input:focus 记住这个写法\n\n强调：复合选择器的层级写得越细越好（可读性，可维护性，安全性），同时将复合选择器的层级写得越细，可以提前避免大部分的选择器优先级混乱！\n\n\n# 二、css 的背景（background）\n\n通过 css 背景属性，可以给页面元素添加背景样式。 背景属性可以设置 背景颜色、背景图片、背景平铺、背景图片位置、背景图像固定 等。\n\n\n# 3.1 背景颜色(bgc) background-color\n\nbackground-color 属性定义了元素的背景颜色。\n\nbackground-color: 颜色值;\n\n\n1\n\n\n一般情况下元素背景颜色默认值是 transparent（透明），我们也可以手动指定背景颜色为透明色。\n\nbackground-color: transparent;\n\n\n1\n\n\n目前 css 还支持丰富的渐变色，但是某些浏览器不支持，这里了解即可，具体内容请查阅资料。\n\n    <title>渐变</title>\n    <style>\n        #grad1 {\n            height: 200px;\n            /* 浏览器不支持时显示 */\n            background-color: red;\n            /* 线性渐变 - 从上到下（默认情况下）*/\n            background-image: linear-gradient(#e66465, #9198e5);\n        }\n    </style>\n</head>\n\n<body>\n    <h3>线性渐变 - 从上到下</h3>\n    <p>从顶部开始的线性渐变。起点是红色，慢慢过渡到蓝色：</p>\n\n    <div id="grad1"></div>\n\n    <p><strong>注意：</strong> internet explorer 9 及之前的版本不支持渐变。</p>\n</body>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n\n# 3.2 背景图片(bgi) background-image\n\nbackground-image 属性描述了元素的背景图像，实际开发常用于 logo 或者一些装饰性的小图片或者是超大的背景图片, 优点是非常便于控制位置（精灵图也是一种运用场景）。\n\nbackground-image : none | url(url)\n\n\n1\n\n\n参数值    作用\nnone   无背景图（默认的）\nurl    使用绝对或相对地址指定背景图像\n\n注意：背景图片后面的地址，千万不要忘记加 url， 同时里面的路径不要加引号。\n\nbackground-color: pink;\nbackground-image: url(../images/logo.png);\n/* 1、背景图片不平铺 */\n/* background-repeat: no-repeat; */\n/* 2、默认情况下，背景图片是平铺的 */\n/* background-repeat: repeat; */ /* 页面元素既可以添加背景颜色也可以添加背景图片，只不过背景图片区域会覆盖背景颜色 */\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 背景平铺(bgr) background-repeat\n\n如果需要在 html 页面上对背景图像进行平铺，可以使用 background-repeat 属性。\n\nbackground-repeat: repeat | no-repeat | repeat-x | repeat-y\n\n\n1\n\n\n参数值         作用\nrepeat      背景图像在纵向和横向上平铺（默认的）\nno-repeat   背景图像不平铺\nrepeat-x    背景图像在横向上平铺\nrepeat-y    背景图像在纵向上平铺\n\n\n# 3.4 背景图片位置(bgp) background-position\n\n利用 background-position 属性可以改变图片在背景中的位置。\n\nbackground-position: x y;\n\n\n1\n\n\n参数代表的意思是：x 坐标 和 y 坐标，可以使用 方位名词 或者 精确单位。\n\n参数值        说明\nlength     百分数 | 由浮点数字和单位标识符组成的长度值\nposition   top | center | bottom | left | rigth 方位名词\n\n * 参数是方位名词\n   \n   * 如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致\n   * 如果只指定了一个方位名词，另一个值省略，则第二个值默认居中对齐\n\n * 参数是精确单位\n   \n   * 如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标\n   * 如果只指定一个数值，那该数值一定是 x 坐标，另一个默认垂直居中\n\n * 参数是百分比\n   \n   * 取值为百分计算的值是按照父级盒子宽高计算的\n   * 如果取值为一个值，那么这个值是表示左右的水平位置，垂直方向的位置默认居中显示；\n\nbackground-position: 50% 50%;\n\n\n1\n\n * 参数是混合单位\n   * 如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标\n\n\n# 3.5 背景图像固定(bga)background-attachment\n\nbackground-attachment 属性设置背景图像是否固定或者随着页面的其余部分滚动。\n\nbackground-attachment 后期可以制作 视差滚动 的效果。\n\nbackground-attachment : scroll | fixed\n\n\n1\n\n\n参数       作用\nscroll   背景图像是随对象内容滚动的（可见区域取决于背景图像的高度）\nfixed    背景图像固定\n\n\n# 3.6 背景复合写法\n\n为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性 background 中，从而节约代码量。 当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为： background: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置\n\n\n\nbackground: magenta url(./img/icon.png) no-repeat 5px center;\n\n\n1\n\n\n这是实际开发中，我们更提倡的写法。\n\n\n# 3.7背景尺寸设置（bgs）background-size\n\n如果背景图片小于当前的盒子或者大于当前的盒子，设置背景图的尺寸大小；\n\n * 取值为cover（常用）\n\n背景图等比缩放，一直到铺满整个盒子\n\nbackground-size: cover;\n\n\n1\n\n\n注意：该属性取值如果背景图和盒子比例不一致。可能会导致背景图过大超出盒子显示不全，溢出隐藏；\n\n * 取值为contain\n\n背景图等比缩放，直到背景图的宽或者高和盒子一致就停止缩放\n\nbackground-size: contain;\n\n\n1\n\n\n**注意：**该属性取值如果背景图和盒子比例不一致可能会导致背景图不会完全铺满盒子；\n\n * 取值为实际像素大小（移动端小图标常用）\n\n设置背景图大小固定，一般我们可以让宽设置固定的值，然后让高为auto自动计算\n\nbackground-size: 45px auto;\n\n\n1\n\n\n\n# 3.8 背景颜色透明rgba（死了都要会）\n\n我们可以设置背景颜色的透明度从而实现透明效果；\n\n语法： rgba(red, green, blue, alpha)\n\nalpha取值为0-1之间，0表示完全透明，1表示不透明，之间的数字表示透明的程度\n\nbackground-color: rgba(0,0,0,.5);\n\n\n1\n\n\n**注意：**rgba只能设置背景颜色透明不会影响盒子里面的内容透明；\n\n\n# 3.10 背景总结\n\n属性                     作用        值\nbackgroud-color        背景颜色      预定义的颜色值 / 十六进制 / rgb代码\nbackgroud-image        背景图片      url（图片路径）\nbackgroud-repeat       是否平铺      repeat / no-repeat / repeat-x / repeat-y\nbackgroud-position     背景位置      length / position 分别是 x 和 y 坐标\nbackgroud-attachment   背景附着      scroll（背景滚动）/ fixed（背景固定）\n背景简写                   书写更简单     背景颜色 背景图片地址 背景平铺 背景滚动 背景位置\n背景色半透明                 背景颜色半透明   background: rgba(0, 0, 0, 0.3); 后面必须是4个值\n\n\n# 三、盒子透明opacity\n\n语法： opacity: 透明值；\n\nopacity 设置盒子的透明，取值为0-1之间，0表示完全透明，1表示不透明，之间的小数表示透明的程度\n\n opacity: .5;\n\n\n1\n\n\n**注意：**用opacity 设置透明，不仅让背景颜色透明，也会影响盒子里面的内容也跟着透明，所以我们不建议使用，后期在制作css3的动画时会用到；\n\n\n# 四、css 的元素显示模式\n\n\n# 2.1 什么是元素显示模式\n\n**作用：**网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。\n\n元素显示模式 就是元素（标签）以什么方式进行显示，比如 <div> 自己占一行，比如一行可以放多个 <span>。\n\nhtml 元素一般分为 块元素 和 行内元素 两种类型。\n\n\n# 2.2 块元素\n\n常见的块元素有 <h1> ~ <h6>、<p>、<div>、<ul>、<ol>、<li>、<dl>、<dt>、<dd>、<table>、<tr>、<form> 等，其中 <div> 标签是最典型的块元素。\n\n块级元素的特点：\n\n * 比较霸道，自己独占一行\n * 高度，宽度、外边距以及内边距都可以控制\n * 宽度默认是容器（父级宽度）的 100%\n * 是一个容器及盒子，里面可以放行内或者块级元素\n\n注意：\n\n * 块元素里面可以嵌套任何元素，但是段落标签p里面不能嵌套div标签，因为浏览器解析的时候会将p 嵌套div解析成两个p标签，一个div标签显示；\n\n\n# 2.3 行内元素\n\n常见的行内元素有 <a>、<span>、<em>、<strong> 等，其中 <span> 标签是最典型的行内元素，有的地方也将行内元素称为内联元素。\n\n行内元素的特点：\n\n * 相邻行内元素在一行上，一行可以显示多个\n\n * 高、宽直接设置是无效的\n\n * 默认的宽是由内容多少撑开的\n\n * 设置内外边距上下不生效，左右生效\n\n * 行内元素中只能嵌套文本图片或者其他行内元素，但是超链接a里面可以嵌套块级元素\n\n注意：\n\n * 链接里面不能再放链接\n * 特殊情况链接 <a> 里面可以放块级元素，但是给 <a> 转换一下块级模式最安全\n\n\n# 2.4 行内块元素\n\n在行内元素中有几个特殊的标签：<img>、<input>、<th>、<td>、button，它们同时具有 块元素 和 行内元素 的特点，有些资料称它们为 行内块元素。\n\n行内块元素的特点：\n\n * 和相邻行内元素（行内块）在一行上，但是他们之间会有空白缝隙。一行可以显示多个（行内元素特点）\n * 默认宽度就是它本身内容的宽度（行内元素特点）\n * 高度，行高、外边距以及内边距都可以控制（块级元素特点）\n\n\n# 2.5 元素显示模式总结\n\n元素模式    元素排列          设置样式           默认宽度       包含\n块级元素    一行只能放一个块级元素   可以设置宽度和高度      容器的 100%   容量级可以包含任何标签\n行内元素    一行可以放多个行内元素   不可以直接设置宽度和高度   它本身内容的宽度   容纳文本或其他行内元素\n行内块元素   一行放多个行内块元素    可以设置宽度和高度      它本身内容的宽度   \n\n学习元素显示模式的主要目的是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。\n\n\n# 2.6 元素显示模式转换display（死了都要记）\n\n实际开发中各个元素的显示模式是可以通过display设置不同的属性值实现的；\n\n * 将元素转化为块元素（重点） display:block;\n * 将元素转化为行内元素 display:inline;\n * 将元素转化为行内块元素 display:inline-block;\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>元素显示模式之显示模式的转换</title>\n    <style>\n        a {\n            width: 150px;\n            height: 50px;\n            background-color: orange;\n            /* 把行内元素 a 转换为 块级元素 */\n            display: block;\n        }\n\n        div {\n            width: 300px;\n            height: 100px;\n            background-color: black;\n            color: white;\n            /* 把 div 块级元素转化为行内元素 */\n            display: inline;\n        }\n\n        span {\n            width: 300px;\n            height: 30px;\n            background-color: skyblue;\n            /* 行内元素转化为行内块元素 */\n            display: inline-block;\n        }\n    </style>\n</head>\n\n<body>\n    <a href="#">我是行内元素</a>\n    <a href="#">我是行内元素</a>\n    <div>我是块级元素</div>\n    <div>我是块级元素</div>\n    <span>行内元素转化为行内块元素</span>\n    <span>行内元素转化为行内块元素</span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n\n# 五、css3常用新属性（死了都要会）\n\n\n# 5.1 圆角border-radius\n\ncss 3 新增了圆角边框样式。\n\nborder-radius 属性用于设置元素的外边框圆角。\n\nborder-radius 顾名思义：边框半径。\n\n（椭）圆与边框的交集形成圆角效果。\n\n        div {\n            width: 300px;\n            height: 150px;\n            background-color: pink;\n            border-radius: 24px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 圆角矩形\n\nborder-radius取值为一个实际像素\n\n        .box {\n            width: 300px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 15px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n * 圆形\n\n矩形必须是正方形，设置border-radius取值大于等于高度一半或者直接设置50%\n\n        .box {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            /* border-radius: 50px; */\n            border-radius: 50%;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n * 胶囊形状\n\n矩形必须是长方形，设置border-radius取值大于等于高度一半；\n\n\n\n        .box {\n            width: 300px;\n            height: 50px;\n            background-color: #f00;\n            border-radius: 25px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n * 椭圆\n\n如果设置border-radius取值为50%，会绘制椭圆\n\n\n\n        .box {\n            width: 300px;\n            height: 50px;\n            background-color: #f00;\n            border-radius: 50%;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n * 半圆\n\n设置border-radius取值个数为4个值：分别是：左上角 右上角 右下角 左下角\n\n语法：border-radius：左上角 右上角 右下角 左下角；\n\n        .box {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 0 50px 50px 0;\n        }\n\n        .box1 {\n            width: 100px;\n            height: 100px;\n            background-color: #f00;\n            border-radius: 50px 0 0 50px;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n注意：\n\n * 参数值可以为数值或百分比的形式\n * 如果是正方形，想要设置为圆形，那么只需要把数值修改为高度或者宽度的一半即可，或者直接写为 50%\n * 如果是个矩形，设置为高度的一半就可以做 “胶囊” 效果了\n\n\n# 5.2 盒子阴影\n\ncss 3 新增了盒子阴影。\n\nbox-shadow 属性用于为盒子添加阴影。\n\n语法：\n\nbox-shadow: h-shadow v-shadow blur spread color inset;\nbox-shadow:水平阴影   垂直阴影   模糊距离   阴影大小   阴影颜色  内/外阴影；\n\n\n1\n2\n\n\n值          描述\nh-shadow   必须。水平阴影的位置，允许负值。\nv-shadow   必须。垂直阴影的位置，允许负值。\nblur       可选。模糊距离（虚实程度）。\nspread     可选。阴影的尺寸（大小）。\ncolor      可选。阴影的颜色，请参阅 css 颜色值（阴影多为半透明颜色）。\ninset      可选。将外部阴影（outset）改为内部阴影（outset 不能指定，默认为空即可）。\n\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: salmon;\n            margin: 100px auto;\n            /* box-shadow: 10px 10px; */\n        }\n\n        /* 伪类不仅仅可以用于 a 链接，还能用于其他标签 */\n        /* 原先盒子没有影子,当我们鼠标经过盒子就添加阴影效果 */\n        div:hover {\n            box-shadow: 10px 10px 10px -4px rgba(0, 0, 0, .3);\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n三边阴影、双边阴影、单边阴影的设置方法：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>盒子阴影 三边阴影、双边阴影、单边阴影</title>\n    <style>\n        div {\n            width: 100px;\n            height: 100px;\n            background-color: #000;\n            margin: 25px auto;\n            color: white;\n        }\n\n        .a {\n            box-shadow: 0 0 25px 5px red;\n        }\n\n        /* 三边阴影就是直接把整个阴影部分往下边移 */\n        .b {\n            box-shadow: 0 6px 10px 0 red;\n        }\n\n        /* 两边阴影要用盒子嵌套来解决 */\n        .c1 {\n            box-shadow: 0 10px 10px -5px red;\n        }\n\n        .c2 {\n            width: 100%;\n            box-shadow: 0 -10px 10px -5px red;\n        }\n\n        /* 单边阴影就是直接把整个阴影部分往下边移，并且减小阴影大小 */\n        .d {\n            box-shadow: 0 10px 10px -5px red;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="a">四边阴影</div>\n    <div class="b">三边阴影</div>\n    <div class="c1">\n        <div class="c2">两边阴影</div>\n    </div>\n    <div class="d">一边阴影</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n\n# 5.3 文字阴影\n\ncss 3 新增了文字阴影。\n\ntext-shadow 属性用于为文本添加阴影。\n\n语法：\n\ntext-shadow: h-shadow v-shadow blur color;\ntext-shadow:水平阴影   垂直阴影   模糊距离   阴影颜色 ；\n\n\n1\n2\n\n\n值          描述\nh-shadow   必须。水平阴影的位置。允许负值。\nv-shadow   必须。垂直阴影的位置。允许负值。\nblur       可选。模糊的距离（虚实程度）。\ncolor      可选。阴影的颜色。参阅 css 颜色值。\n\ndiv {\n            font-size: 50px;\n            color: salmon;\n            font-weight: 700;\n            text-shadow: 5px 5px 6px rgba(0, 0, 0, .3);\n        }\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"CSS三大特性、盒子模型、边距、过渡动画",frontmatter:{title:"CSS三大特性、盒子模型、边距、过渡动画",date:"2020-04-07T23:27:29.000Z",permalink:"/pages/33f061/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/04.CSS%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E3%80%81%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E3%80%81%E8%BE%B9%E8%B7%9D%E3%80%81%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB.html",relativePath:"01.前端基础/02.CSS/04.CSS三大特性、盒子模型、边距、过渡动画.md",key:"v-930608a0",path:"/pages/33f061/",headers:[{level:2,title:"1.1 层叠性（覆盖性）",slug:"_1-1-层叠性-覆盖性",normalizedTitle:"1.1 层叠性（覆盖性）",charIndex:45},{level:2,title:"1.2继承性",slug:"_1-2继承性",normalizedTitle:"1.2继承性",charIndex:194},{level:2,title:"1.3 优先级（权重）",slug:"_1-3-优先级-权重",normalizedTitle:"1.3 优先级（权重）",charIndex:736},{level:2,title:"2.1 看透网页布局的本质",slug:"_2-1-看透网页布局的本质",normalizedTitle:"2.1 看透网页布局的本质",charIndex:2565},{level:2,title:"2.2 盒子模型（Box Model）组成",slug:"_2-2-盒子模型-box-model-组成",normalizedTitle:"2.2 盒子模型（box model）组成",charIndex:2687},{level:2,title:"2.3 边框（border）",slug:"_2-3-边框-border",normalizedTitle:"2.3 边框（border）",charIndex:2819},{level:3,title:"2.3.1 表格的细线边框（边框合并）",slug:"_2-3-1-表格的细线边框-边框合并",normalizedTitle:"2.3.1 表格的细线边框（边框合并）",charIndex:3489},{level:3,title:"2.3.2 边框会影响盒子实际大小",slug:"_2-3-2-边框会影响盒子实际大小",normalizedTitle:"2.3.2 边框会影响盒子实际大小",charIndex:3866},{level:2,title:"2.4 内边距（padding）",slug:"_2-4-内边距-padding",normalizedTitle:"2.4 内边距（padding）",charIndex:4620},{level:2,title:"2.5 外边距（margin）",slug:"_2-5-外边距-margin",normalizedTitle:"2.5 外边距（margin）",charIndex:5355},{level:3,title:"2.1 外边距合并",slug:"_2-1-外边距合并",normalizedTitle:"2.1 外边距合并",charIndex:7998},{level:4,title:"2.1.1 相邻块元素垂直外边距的合并",slug:"_2-1-1-相邻块元素垂直外边距的合并",normalizedTitle:"2.1.1 相邻块元素垂直外边距的合并",charIndex:8123},{level:4,title:"2.1.2 嵌套块元素垂直外边距的塌陷",slug:"_2-1-2-嵌套块元素垂直外边距的塌陷",normalizedTitle:"2.1.2 嵌套块元素垂直外边距的塌陷",charIndex:9092},{level:2,title:"2.6 清除内外边距",slug:"_2-6-清除内外边距",normalizedTitle:"2.6 清除内外边距",charIndex:10983},{level:2,title:"3.1 盒子的实际占位大小计算",slug:"_3-1-盒子的实际占位大小计算",normalizedTitle:"3.1 盒子的实际占位大小计算",charIndex:11228},{level:2,title:"3.2 padding和border撑大盒子问题",slug:"_3-2-padding和border撑大盒子问题",normalizedTitle:"3.2 padding和border撑大盒子问题",charIndex:11382},{level:3,title:"解决方案1：人为手动加多少减多少：",slug:"解决方案1-人为手动加多少减多少",normalizedTitle:"解决方案1：人为手动加多少减多少：",charIndex:11457},{level:3,title:"解决方案2：开启css3的盒子内减模式",slug:"解决方案2-开启css3的盒子内减模式",normalizedTitle:"解决方案2：开启css3的盒子内减模式",charIndex:11522},{level:2,title:"3.3 外边距塌陷问题（了解）",slug:"_3-3-外边距塌陷问题-了解",normalizedTitle:"3.3 外边距塌陷问题（了解）",charIndex:11647},{level:3,title:"情况1：上下排列的盒子外边距合并",slug:"情况1-上下排列的盒子外边距合并",normalizedTitle:"情况1：上下排列的盒子外边距合并",charIndex:11667},{level:3,title:"情况2：嵌套盒子外边塌陷（外边距穿透）",slug:"情况2-嵌套盒子外边塌陷-外边距穿透",normalizedTitle:"情况2：嵌套盒子外边塌陷（外边距穿透）",charIndex:11796},{level:2,title:"3.4 外边距的经典应用：设置盒子水平居中",slug:"_3-4-外边距的经典应用-设置盒子水平居中",normalizedTitle:"3.4 外边距的经典应用：设置盒子水平居中",charIndex:12124},{level:2,title:"3.4.1 行内元素和行内块元素居中text-align：center；",slug:"_3-4-1-行内元素和行内块元素居中text-align-center",normalizedTitle:"3.4.1 行内元素和行内块元素居中text-align：center；",charIndex:12532},{level:2,title:"3.5 清除内外边距",slug:"_3-5-清除内外边距",normalizedTitle:"3.5 清除内外边距",charIndex:12629},{level:2,title:"3.6 细线表格（边框合并）--- 死了都要记",slug:"_3-6-细线表格-边框合并-死了都要记",normalizedTitle:"3.6 细线表格（边框合并）--- 死了都要记",charIndex:12846},{level:2,title:"3.7 border书写三角形效果（了解）",slug:"_3-7-border书写三角形效果-了解",normalizedTitle:"3.7 border书写三角形效果（了解）",charIndex:13122}],headersStr:"1.1 层叠性（覆盖性） 1.2继承性 1.3 优先级（权重） 2.1 看透网页布局的本质 2.2 盒子模型（Box Model）组成 2.3 边框（border） 2.3.1 表格的细线边框（边框合并） 2.3.2 边框会影响盒子实际大小 2.4 内边距（padding） 2.5 外边距（margin） 2.1 外边距合并 2.1.1 相邻块元素垂直外边距的合并 2.1.2 嵌套块元素垂直外边距的塌陷 2.6 清除内外边距 3.1 盒子的实际占位大小计算 3.2 padding和border撑大盒子问题 解决方案1：人为手动加多少减多少： 解决方案2：开启css3的盒子内减模式 3.3 外边距塌陷问题（了解） 情况1：上下排列的盒子外边距合并 情况2：嵌套盒子外边塌陷（外边距穿透） 3.4 外边距的经典应用：设置盒子水平居中 3.4.1 行内元素和行内块元素居中text-align：center； 3.5 清除内外边距 3.6 细线表格（边框合并）--- 死了都要记 3.7 border书写三角形效果（了解）",content:'# 一、CSS三大特性\n\nCSS 有三个非常重要的特性：层叠性、继承性、优先级。\n\n\n# 1.1 层叠性（覆盖性）\n\n给同一个选择器设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突的问题。\n\n层叠性原则：\n\n * 样式冲突，遵循的原则是 就近原则，哪个样式距离结构近，就执行哪个样式\n * 样式不冲突，不会层叠\n\n注：就近的标准是：后 > 前\n\n\n# 1.2继承性\n\n现实中的继承：我们继承了父亲的姓。\n\nCSS 中的继承：子标签会继承父标签的某些样式，如：文本颜色和字号，简单的理解就是：子承父业。\n\n * 恰当地使用继承可以简化代码，降低 CSS 样式的复杂性\n * 子元素可以继承父元素的样式（ text-、font-、line-、color ） 文本、字体、段落、颜色\n\n行高的继承\n\nbody {\n    font: 12px/1.5 \'Microsoft YaHei\';\n}\n\n\n1\n2\n3\n\n * 行高可以跟单位也可以不跟单位\n * 如果子元素没有设置行高，则会继承父元素的行高为 1.5\n * 此时子元素的行高是：当前元素的文字大小 * 1.5\n * body 行高 1.5 这样写法最大的优势就是里面的子元素可以根据自己文字的大小自动调整行高\n\n注意： 01、超链接a元素不会继承父级盒子的color颜色，因为浏览器默认给a设置默认的颜色样式，我们需要单独设置a的color颜色；\n\n\n\n02、标题标签h1,h2,h3,h5,h6不会直接继承父级盒子的文字大小font-size，因为他们本身自己有默认的文字大小并且是em相对单位，我们得到的结果是我们设置父级文字大小乘以这个倍数；所以我们需要单独设置；\n\n\n\n\n# 1.3 优先级（权重）\n\n * 选择器相同，则执行层叠性\n * 选择器不同，则根据选择器权重执行\n\n选择器权重如下表所示：\n\n选择器              选择器权重\n继承 或 *           0,0,0,0\n元素选择器            0,0,0,1\n类选择器、伪类选择器       0,0,1,0\nID 选择器           0,1,0,0\n行内样式 style=""    1,0,0,0\n!important 重要的   ∞ 无穷大\n\n**规则：**比较位级别，位级别相同时比较位大小。\n\n优先级注意问题：\n\n * 权重是由 4 组数字组成的，但是不会有进位！\n * 可以理解为：类选择器 永远大于 元素选择器，ID 选择器 永远大于 类选择器，以此类推！\n * 等级判断 从左到右，如果某一位数值相同，则判断下一位数值\n * 可以简单的记忆：通配符 和 继承 权重为 0，标签选择器 为 1，类（伪类）选择器为 10，ID 选择器为 100，行内样式表 为 1000，!important 无穷大\n * 继承的权重是 0，不管父元素权重多高，子元素得到的权重都是 0 ！\n * a 链接浏览器默认指定了一个样式，所以它不参与继承，所以设置样式需要选中单独设置\n\n<head>\n\n    <title>CSS三大特性之优先级——注意问题</title>\n    <style>\n        /* 父亲的权重是 100 */\n        #father {\n            color: red !important;\n        }\n\n        /* p 继承的权重为 0 */\n        /* 所以以后我们看标签到底执行哪一个样式，就先看这个标签有没有直接被选出来\n           如果直接被选择出来了，那么就与父亲无关了！*/\n        p {\n            color: pink;\n        }\n    </style>\n</head>\n\n<body>\n    \x3c!-- 继承的权重是 0，不管父元素权重多高，子元素得到的权重都是 0 --\x3e\n    <div id="father">\n        <p>你还是很好看</p> \x3c!-- pink --\x3e\n    </div>\n    \x3c!-- a 链接浏览器默认指定了一个样式，所以它不参与继承，所以给 a 改样式必须直接把 a 选出来 --\x3e\n    <a href="#">我是单独的样式</a>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n权重的叠加：\n\n如果是复合选择器，则会有权重叠加，需要计算权重。\n\n注意：再次强调！权重虽然会叠加，但一定不会进位！（1万个元素选择器也比不过一个类选择器）。\n\n从左到右逐位比较，只有左一位同样大，才比较右边一位！\n\n例如：\n\n * div ul li ——> 0,0,0,3\n * .nav ul li ——> 0,0,1,2\n * a:hover ——> 0,0,1,1\n * .nav a ——> 0,0,1,1\n\n如果要对某一元素设置样式，那么就必须给它足够高的权重（注意：是给他，而不是他的父亲！）。\n\n> 提高选择器权重的技巧之一：\n\n        /* ul li 权重 0,0,0,1 + 0,0,0,1 = 0,0,0,2 */\n        ul li {\n            color: green;\n        }\n\n        /* li 的权重是 0,0,0,1 */\n        li {\n            color: red;\n        }\n\n        /* .nav li 权重 0,0,1,0 + 0,0,0,1 = 0,0,1,1 */\n        .nav li {\n            color: pink;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 二、CSS盒子模型（重点）\n\n页面布局要学习三大核心：盒子模型、浮动和定位。\n\n学习好盒子模型能非常好的帮助我们布局页面。\n\n\n# 2.1 看透网页布局的本质\n\n网页布局过程：\n\n * 先准备好相关的网页元素，网页元素基本都是盒子\n\n * 利用 CSS 设置好盒子样式，然后摆放到相应位置\n\n * 往盒子里面装内容\n\n网页布局的核心本质： 就是利用 CSS 摆盒子！\n\n\n# 2.2 盒子模型（Box Model）组成\n\n所谓盒子模型：就是把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：边框、外边距、内边距、和 内容。\n\n\n\n\n\n\n# 2.3 边框（border）\n\nborder 可以设置元素的边框。\n\n边框有三部分组成：边框宽度（粗细）、边框样式、边框颜色。\n\n语法：\n\nborder: border-width || border-style || border-color\n\n\n1\n\n\n属性             作用\nborder-width   定义边框粗细，单位是 px\nborder-style   边框的样式\nborder-color   边框颜色\n\n边框样式 border-style 可以设置如下值：\n\n * none：没有边框，即忽略所有边框的宽度（默认值）\n * solid：边框为单实线（最为常用的）\n * dashed：边框为虚线\n * dotted：边框为点线\n\n边框简写：\n\nborder: 1px solid red; \t/* 没有顺序 */\n\n\n1\n\n\n边框四边写法：\n\n    border-top: solid 2px red;\n    border-bottom: solid 2px red;\n    border-left: solid 2px red;\n    border-right: solid 2px red;\n\n\n1\n2\n3\n4\n\n\n# 设置单独某个方向的某个属性\n\n语法：border-方位名词-属性：属性值；\n\n    border-left-color: red;\n    border-right-style: solid;\n    border-top-width: 3px;\n\n\n1\n2\n3\n\n\n\n# 2.3.1 表格的细线边框（边框合并）\n\n表格中两个单元格相邻的边框会重叠在一起，呈现出加粗的效果。\n\nborder-collapse 属性控制浏览器绘制表格边框的方式。\n\n它控制相邻单元格的边框。\n\n语法：\n\nborder-collapse: collapse;\n\n\n1\n\n * collapse 单词是合并的意思\n * border-collapse: collapse; 表示相邻边框合并在一起\n\n\ttable,\n\ttd,\n\tth {\n\t    border: 1px solid black;\n\t    /* 合并相邻的边框 */\n\t    border-collapse: collapse;\n\t    font-size: 14px;\n\t    text-align: center;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.3.2 边框会影响盒子实际大小\n\n边框会额外增加盒子的实际区域大小。因此我们有两种方案解决：\n\n * 测量盒子大小的时候，不量边框\n * 如果测量的时候包含了边框，则需要 width、height 减去边框宽度（注意减单边还是双边）\n\n> 注意：盒子实际区域大小 = 内容区大小 + 内边距大小 + 边框大小 + 外边距大小\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>边框会影响盒子的实际大小</title>\n    <style>\n        /* 我们需要一个 200*200 的盒子, 但是这个盒子有 10 像素的红色边框 */\n        div {\n            width: 180px;\n            height: 180px;\n            background-color: pink;\n            border: 10px solid black;\n        }\n    </style>\n</head>\n\n<body>\n    <div></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n\n# 2.4 内边距（padding）\n\npadding 属性用于设置内边距，即边框与内容之间的距离。\n\n属性               作用\npadding-left     左内边距\npadding-rigth    右内边距\npadding-top      上内边距\npadding-bottom   下内边距\n\npadding 属性（简写属性）可以有一到四个值。\n\n值的个数                           表达意思\npadding: 5px;                  1 个值，代表上下左右都有 5 像素内边距\npadding: 5px 10px;             2 个值，代表上下内边距是 5 像素，左右内边距是 10 像素\npadding: 5px 10px 20px;        3 个值，代码上内边距 5 像素，左右内边距 10 像素，下内边距 20 像素\npadding: 5px 10px 20px 30px;   4 个值，上是 5 像素，右 10 像素，下 20 像素，左是 30 像素（顺时针）\n\n以上 4 种情况，我们实际开发都会遇到。\n\n当我们给盒子指定 padding 值之后，发生了 2 件事情：\n\n * 内容和边框有了距离，添加了内边距\n * padding 影响了盒子实际区域大小\n\n也就是说，如果盒子已经有了宽度和高度，此时再指定内边距，会撑大盒子区域！\n\n解决方案：\n\n * 如果保证盒子跟效果图大小保持一致，则让 width、height 减去多出来的内边距大小即可\n * 如果盒子本身没有指定 width、height 属性，则此时 padding 不会撑开盒子区域大小\n\n\n# 2.5 外边距（margin）\n\nmargin 属性用于设置外边距，即控制盒子和盒子之间的距离。\n\n属性              作用\nmargin-left     左外边距\nmargin-right    右外边距\nmargin-top      上外边距\nmargin-bottom   下外边距\n\nmargin 简写方式代表的意义跟 padding 完全一致。\n\n外边距典型应用：\n\n外边距可以让块级盒子水平居中，但是必须满足两个条件：\n\n * 盒子必须指定了宽度 width\n * 盒子左右的外边距都设置为 auto\n\n.header { width: 960px; margin: 0 auto;}\n\n\n1\n\n\n常见的写法，以下三种都可以：\n\n * margin-left: auto; margin-right: auto;\n * margin: auto;\n * margin: 0 auto;\n\n注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>盒子模型之外边距margin</title>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n\n        /* \n        .one {\n            margin-bottom: 20px;\n        } \n        */\n\n        .two {\n            margin-top: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="one">1</div>\n    <div class="two">2</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>块级盒子水平居中对齐</title>\n    <style>\n        .header {\n            width: 900px;\n            height: 200px;\n            background-color: pink;\n            /* 上下 100 左右 auto */\n            margin: 100px auto;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="header"></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>行内元素、行内块元素水平居中对齐</title>\n    <style>\n        .header {\n            width: 900px;\n            height: 200px;\n            background-color: pink;\n            margin: 100px auto;\n            /* 行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可 */\n            text-align: center;\n        }\n\n        /* 这样是不起作用的 */\n        /* \n        span {\n            margin: 0 auto;\n        } \n        */\n    </style>\n</head>\n\n<body>\n    <div class="header">\n        <span>里面的文字</span>\n    </div>\n    <div class="header">\n        <img src="../image/icon.png" alt="">\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n\n# 2.1 外边距合并\n\n使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。\n\n注意：内边距没有合并一说！浮动的盒子不会发生外边距合并！\n\n主要有两种情况:\n\n * 相邻块元素垂直外边距的合并\n * 嵌套块元素垂直外边距的塌陷\n\n# 2.1.1 相邻块元素垂直外边距的合并\n\n当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。而是取两个值中的较大者，这种现象被称为相邻块元素垂直外边距的合并（准确的描述应该是：大的外边距覆盖小的）。\n\n\n\n\n\n解决方案：\n\n尽量只给一个盒子添加 margin 值。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>相邻块元素垂直外边距的合并</title>\n    <style>\n        .one {\n            width: 200px;\n            height: 200px;\n            background-color: hotpink;\n            margin-bottom: 100px;\n        }\n\n        .two {\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="one">one</div>\n    <div class="two">two</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n# 2.1.2 嵌套块元素垂直外边距的塌陷\n\n对于两个嵌套关系（父子关系）的块元素，当子元素有上外边距，此时父元素会塌陷较大的外边距值（外边距效果显示在父元素之上）。\n\n\n\n\n\n解决方案：\n\n * 可以为父元素定义上边框（比如：可以给一个透明 transparent 边框）\n * 可以为父元素定义上内边距\n * 可以为父元素添加 overflow: hidden\n\n还有其他方法，比如浮动、固定，绝对定位的盒子不会有塌陷问题，后面咱们再总结。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>外边距合并-嵌套块级元素垂直外边距塌陷</title>\n    <style>\n        .father {\n            width: 400px;\n            height: 400px;\n            background-color: black;\n            margin-top: 50px;\n        }\n\n        .son {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="father">\n        <div class="son"></div>\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>外边距合并-嵌套块级元素垂直外边距塌陷</title>\n    <style>\n        .father {\n            width: 400px;\n            height: 400px;\n            background-color: black;\n            margin-top: 50px;\n            /* border: 1px solid transparent; */\n            overflow: hidden;\n        }\n\n        .son {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="father">\n        <div class="son"></div>\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n注意：外边距的合并在利用盒子布局页面的时候是经常发生的！\n\n\n# 2.6 清除内外边距\n\n网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。\n\n* {\n\tpadding:0; \t/* 清除内边距 */\n\tmargin:0; \t/* 清除外边距 */\n}\n\n\n1\n2\n3\n4\n\n\n注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距（某些时候，行内元素对上下内外边距不生效）。但是转换为块级和行内块元素就可以了。\n\n\n# 三、盒子模型相关布局问题以及技巧（重点）\n\n\n# 3.1 盒子的实际占位大小计算\n\n盒子的实际占位大小指的就是我们设置好宽高的基础上累加padding和border的大小；\n\n盒子的实际宽度 = width + 左右的padding + 左右的border；\n\n盒子的实际高度 = height+ 上下的padding + 上下的border；\n\n\n\n\n# 3.2 padding和border撑大盒子问题\n\n如果盒子宽高设置固定了，再去给盒子添加padding和border就会将盒子的大小撑大；\n\n\n# 解决方案1：人为手动加多少减多少：\n\n加多少减多少，将我们自己设置的宽高减去对应的padding和border即可；\n\n\n\n\n# 解决方案2：开启css3的盒子内减模式\n\n直接给盒子设置css3的内减模式 box-sizing: border-box;\n\n浏览器在解析的时候就会自己算我们的尺寸，会将设置的padding和border全部减去然后重新计算盒子的大小；\n\n\n\n\n# 3.3 外边距塌陷问题（了解）\n\n\n# 情况1：上下排列的盒子外边距合并\n\n上下排列的两个盒子，上面的盒子设置了marin-bottom,下面的盒子设置了margin-top，最终显示的样式两个值谁大就显示谁，小的值被大的值合并了；\n\n解决方案：单独设置给其中某一个盒子，不要两者都设置；\n\n\n# 情况2：嵌套盒子外边塌陷（外边距穿透）\n\n如果两个盒子有嵌套包含的父子级关系，如果给子级盒子设置了margin-top，效果显示父级盒子也会跟着掉下来；\n\n\n\n**解决方案1：**给父级盒子设置边框border，只能设置border-top，如果父盒子本身就有border就不会出现塌陷问题；\n\n**解决方案2：**给父级盒子设置内边距padding，只能设置padding-top，如果父盒子本身就有padding就不会出现塌陷问题；\n\n**解决方案3：**给父级盒子设置overflow:hidden；、display:flow-root；利用盒子的BFC模式；\n\n**解决方案4：**如果父级盒子或者子级盒子有了浮动或者定位就不会出现塌陷；\n\n\n# 3.4 外边距的经典应用：设置盒子水平居中\n\n想要使用**margin:0 auto;**设置一个盒子居中必须满足两个条件：\n\n> 01、盒子必须是块元素，独自占一行；\n> \n> 02、盒子必须要有固定的宽度；\n\n注意：实际开发中最常用就是设置版心盒子居中；\n\n**版心：**网页的主体内容显示的区域，一般是一个固定宽度的盒子，在浏览器的中心显示；版心的类名一般用w或者container表示；目前市场的版心一般都在1200左右（传智1200，京东1190、小米1226）；\n\n\n\n实际的开发中版心是不需要固定的高度的，因为每一个模块的高度不一样；\n\n        .w {\n            width: 1200px;\n            margin: 0 auto;\n            background-color: red;\n        }\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 3.4.1 行内元素和行内块元素居中text-align：center；\n\n将行内元素和行内块元素放在一个父级盒子中，设置父级盒子tac即text-align：center；就可以居中\n\n\n# 3.5 清除内外边距\n\n有些html标签浏览器在解析的时候有默认的内边距padding或者外边居marign，我们需要将默认的样式清除，再去设置自己的样式；\n\n比如：body有8px的默认外边距，ul有默认的内边距等\n\n我们只需在css的最前面将所有标签的margin和padding清0即可；\n\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n\n1\n2\n3\n4\n\n\n\n# 3.6 细线表格（边框合并）--- 死了都要记\n\n实际工作我们经常使用表格展示数据，我们用css设置细线表格，我们只需要给table、th、td标签同时设置边框border，然后设置边框合并属性border-collapse: collapse;即可实现；\n\n        table,\n        th,\n        td {\n            border: 1px solid #ccc;\n            border-collapse: collapse;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 3.7 border书写三角形效果（了解）\n\n\n\n盒子宽高必须都是0，然后设置盒子四条边都是透明，最后单独设置一个方向的边的颜色即可；\n\n    width: 0;\n    height: 0;\n    border: 20px solid transparent;\n    border-top-color: red;\n\n\n1\n2\n3\n4\n\n\n\n# 四、css3过渡动画（死了都要记）\n\n语法：transition: 属性 时间 运动曲线 延时;\n\n> 属性：需要改变过渡的属性\n> 时间：整个过度动画需要多长时间完成\n> 运动曲线 ：动画运动形式默认取值为ease。匀速运动linear；\n> 延时：鼠标移入需要等待一段时间再去加载过渡动画；\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n实际开发中一般只会调用属性和时间\n\ntransition: 属性   时间；\n\n\n1\n\n\n> 注意： 01、同时修改多个属性，需要用英文逗号隔开 transition: width 1s, background-color 1s, height 1s; 02，用逗号隔开书写多个属性过渡太麻烦，我们只需要用一个all表示所有的属性即可 transition: all 1s ； 03、过渡加在本身上，谁做动画给谁加；',normalizedContent:'# 一、css三大特性\n\ncss 有三个非常重要的特性：层叠性、继承性、优先级。\n\n\n# 1.1 层叠性（覆盖性）\n\n给同一个选择器设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式，层叠性主要解决样式冲突的问题。\n\n层叠性原则：\n\n * 样式冲突，遵循的原则是 就近原则，哪个样式距离结构近，就执行哪个样式\n * 样式不冲突，不会层叠\n\n注：就近的标准是：后 > 前\n\n\n# 1.2继承性\n\n现实中的继承：我们继承了父亲的姓。\n\ncss 中的继承：子标签会继承父标签的某些样式，如：文本颜色和字号，简单的理解就是：子承父业。\n\n * 恰当地使用继承可以简化代码，降低 css 样式的复杂性\n * 子元素可以继承父元素的样式（ text-、font-、line-、color ） 文本、字体、段落、颜色\n\n行高的继承\n\nbody {\n    font: 12px/1.5 \'microsoft yahei\';\n}\n\n\n1\n2\n3\n\n * 行高可以跟单位也可以不跟单位\n * 如果子元素没有设置行高，则会继承父元素的行高为 1.5\n * 此时子元素的行高是：当前元素的文字大小 * 1.5\n * body 行高 1.5 这样写法最大的优势就是里面的子元素可以根据自己文字的大小自动调整行高\n\n注意： 01、超链接a元素不会继承父级盒子的color颜色，因为浏览器默认给a设置默认的颜色样式，我们需要单独设置a的color颜色；\n\n\n\n02、标题标签h1,h2,h3,h5,h6不会直接继承父级盒子的文字大小font-size，因为他们本身自己有默认的文字大小并且是em相对单位，我们得到的结果是我们设置父级文字大小乘以这个倍数；所以我们需要单独设置；\n\n\n\n\n# 1.3 优先级（权重）\n\n * 选择器相同，则执行层叠性\n * 选择器不同，则根据选择器权重执行\n\n选择器权重如下表所示：\n\n选择器              选择器权重\n继承 或 *           0,0,0,0\n元素选择器            0,0,0,1\n类选择器、伪类选择器       0,0,1,0\nid 选择器           0,1,0,0\n行内样式 style=""    1,0,0,0\n!important 重要的   ∞ 无穷大\n\n**规则：**比较位级别，位级别相同时比较位大小。\n\n优先级注意问题：\n\n * 权重是由 4 组数字组成的，但是不会有进位！\n * 可以理解为：类选择器 永远大于 元素选择器，id 选择器 永远大于 类选择器，以此类推！\n * 等级判断 从左到右，如果某一位数值相同，则判断下一位数值\n * 可以简单的记忆：通配符 和 继承 权重为 0，标签选择器 为 1，类（伪类）选择器为 10，id 选择器为 100，行内样式表 为 1000，!important 无穷大\n * 继承的权重是 0，不管父元素权重多高，子元素得到的权重都是 0 ！\n * a 链接浏览器默认指定了一个样式，所以它不参与继承，所以设置样式需要选中单独设置\n\n<head>\n\n    <title>css三大特性之优先级——注意问题</title>\n    <style>\n        /* 父亲的权重是 100 */\n        #father {\n            color: red !important;\n        }\n\n        /* p 继承的权重为 0 */\n        /* 所以以后我们看标签到底执行哪一个样式，就先看这个标签有没有直接被选出来\n           如果直接被选择出来了，那么就与父亲无关了！*/\n        p {\n            color: pink;\n        }\n    </style>\n</head>\n\n<body>\n    \x3c!-- 继承的权重是 0，不管父元素权重多高，子元素得到的权重都是 0 --\x3e\n    <div id="father">\n        <p>你还是很好看</p> \x3c!-- pink --\x3e\n    </div>\n    \x3c!-- a 链接浏览器默认指定了一个样式，所以它不参与继承，所以给 a 改样式必须直接把 a 选出来 --\x3e\n    <a href="#">我是单独的样式</a>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n权重的叠加：\n\n如果是复合选择器，则会有权重叠加，需要计算权重。\n\n注意：再次强调！权重虽然会叠加，但一定不会进位！（1万个元素选择器也比不过一个类选择器）。\n\n从左到右逐位比较，只有左一位同样大，才比较右边一位！\n\n例如：\n\n * div ul li ——> 0,0,0,3\n * .nav ul li ——> 0,0,1,2\n * a:hover ——> 0,0,1,1\n * .nav a ——> 0,0,1,1\n\n如果要对某一元素设置样式，那么就必须给它足够高的权重（注意：是给他，而不是他的父亲！）。\n\n> 提高选择器权重的技巧之一：\n\n        /* ul li 权重 0,0,0,1 + 0,0,0,1 = 0,0,0,2 */\n        ul li {\n            color: green;\n        }\n\n        /* li 的权重是 0,0,0,1 */\n        li {\n            color: red;\n        }\n\n        /* .nav li 权重 0,0,1,0 + 0,0,0,1 = 0,0,1,1 */\n        .nav li {\n            color: pink;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 二、css盒子模型（重点）\n\n页面布局要学习三大核心：盒子模型、浮动和定位。\n\n学习好盒子模型能非常好的帮助我们布局页面。\n\n\n# 2.1 看透网页布局的本质\n\n网页布局过程：\n\n * 先准备好相关的网页元素，网页元素基本都是盒子\n\n * 利用 css 设置好盒子样式，然后摆放到相应位置\n\n * 往盒子里面装内容\n\n网页布局的核心本质： 就是利用 css 摆盒子！\n\n\n# 2.2 盒子模型（box model）组成\n\n所谓盒子模型：就是把 html 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。 css 盒子模型本质上是一个盒子，封装周围的 html 元素，它包括：边框、外边距、内边距、和 内容。\n\n\n\n\n\n\n# 2.3 边框（border）\n\nborder 可以设置元素的边框。\n\n边框有三部分组成：边框宽度（粗细）、边框样式、边框颜色。\n\n语法：\n\nborder: border-width || border-style || border-color\n\n\n1\n\n\n属性             作用\nborder-width   定义边框粗细，单位是 px\nborder-style   边框的样式\nborder-color   边框颜色\n\n边框样式 border-style 可以设置如下值：\n\n * none：没有边框，即忽略所有边框的宽度（默认值）\n * solid：边框为单实线（最为常用的）\n * dashed：边框为虚线\n * dotted：边框为点线\n\n边框简写：\n\nborder: 1px solid red; \t/* 没有顺序 */\n\n\n1\n\n\n边框四边写法：\n\n    border-top: solid 2px red;\n    border-bottom: solid 2px red;\n    border-left: solid 2px red;\n    border-right: solid 2px red;\n\n\n1\n2\n3\n4\n\n\n# 设置单独某个方向的某个属性\n\n语法：border-方位名词-属性：属性值；\n\n    border-left-color: red;\n    border-right-style: solid;\n    border-top-width: 3px;\n\n\n1\n2\n3\n\n\n\n# 2.3.1 表格的细线边框（边框合并）\n\n表格中两个单元格相邻的边框会重叠在一起，呈现出加粗的效果。\n\nborder-collapse 属性控制浏览器绘制表格边框的方式。\n\n它控制相邻单元格的边框。\n\n语法：\n\nborder-collapse: collapse;\n\n\n1\n\n * collapse 单词是合并的意思\n * border-collapse: collapse; 表示相邻边框合并在一起\n\n\ttable,\n\ttd,\n\tth {\n\t    border: 1px solid black;\n\t    /* 合并相邻的边框 */\n\t    border-collapse: collapse;\n\t    font-size: 14px;\n\t    text-align: center;\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2.3.2 边框会影响盒子实际大小\n\n边框会额外增加盒子的实际区域大小。因此我们有两种方案解决：\n\n * 测量盒子大小的时候，不量边框\n * 如果测量的时候包含了边框，则需要 width、height 减去边框宽度（注意减单边还是双边）\n\n> 注意：盒子实际区域大小 = 内容区大小 + 内边距大小 + 边框大小 + 外边距大小\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>边框会影响盒子的实际大小</title>\n    <style>\n        /* 我们需要一个 200*200 的盒子, 但是这个盒子有 10 像素的红色边框 */\n        div {\n            width: 180px;\n            height: 180px;\n            background-color: pink;\n            border: 10px solid black;\n        }\n    </style>\n</head>\n\n<body>\n    <div></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n\n# 2.4 内边距（padding）\n\npadding 属性用于设置内边距，即边框与内容之间的距离。\n\n属性               作用\npadding-left     左内边距\npadding-rigth    右内边距\npadding-top      上内边距\npadding-bottom   下内边距\n\npadding 属性（简写属性）可以有一到四个值。\n\n值的个数                           表达意思\npadding: 5px;                  1 个值，代表上下左右都有 5 像素内边距\npadding: 5px 10px;             2 个值，代表上下内边距是 5 像素，左右内边距是 10 像素\npadding: 5px 10px 20px;        3 个值，代码上内边距 5 像素，左右内边距 10 像素，下内边距 20 像素\npadding: 5px 10px 20px 30px;   4 个值，上是 5 像素，右 10 像素，下 20 像素，左是 30 像素（顺时针）\n\n以上 4 种情况，我们实际开发都会遇到。\n\n当我们给盒子指定 padding 值之后，发生了 2 件事情：\n\n * 内容和边框有了距离，添加了内边距\n * padding 影响了盒子实际区域大小\n\n也就是说，如果盒子已经有了宽度和高度，此时再指定内边距，会撑大盒子区域！\n\n解决方案：\n\n * 如果保证盒子跟效果图大小保持一致，则让 width、height 减去多出来的内边距大小即可\n * 如果盒子本身没有指定 width、height 属性，则此时 padding 不会撑开盒子区域大小\n\n\n# 2.5 外边距（margin）\n\nmargin 属性用于设置外边距，即控制盒子和盒子之间的距离。\n\n属性              作用\nmargin-left     左外边距\nmargin-right    右外边距\nmargin-top      上外边距\nmargin-bottom   下外边距\n\nmargin 简写方式代表的意义跟 padding 完全一致。\n\n外边距典型应用：\n\n外边距可以让块级盒子水平居中，但是必须满足两个条件：\n\n * 盒子必须指定了宽度 width\n * 盒子左右的外边距都设置为 auto\n\n.header { width: 960px; margin: 0 auto;}\n\n\n1\n\n\n常见的写法，以下三种都可以：\n\n * margin-left: auto; margin-right: auto;\n * margin: auto;\n * margin: 0 auto;\n\n注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>盒子模型之外边距margin</title>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n\n        /* \n        .one {\n            margin-bottom: 20px;\n        } \n        */\n\n        .two {\n            margin-top: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="one">1</div>\n    <div class="two">2</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>块级盒子水平居中对齐</title>\n    <style>\n        .header {\n            width: 900px;\n            height: 200px;\n            background-color: pink;\n            /* 上下 100 左右 auto */\n            margin: 100px auto;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="header"></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>行内元素、行内块元素水平居中对齐</title>\n    <style>\n        .header {\n            width: 900px;\n            height: 200px;\n            background-color: pink;\n            margin: 100px auto;\n            /* 行内元素或者行内块元素水平居中给其父元素添加 text-align: center 即可 */\n            text-align: center;\n        }\n\n        /* 这样是不起作用的 */\n        /* \n        span {\n            margin: 0 auto;\n        } \n        */\n    </style>\n</head>\n\n<body>\n    <div class="header">\n        <span>里面的文字</span>\n    </div>\n    <div class="header">\n        <img src="../image/icon.png" alt="">\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n\n# 2.1 外边距合并\n\n使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。\n\n注意：内边距没有合并一说！浮动的盒子不会发生外边距合并！\n\n主要有两种情况:\n\n * 相邻块元素垂直外边距的合并\n * 嵌套块元素垂直外边距的塌陷\n\n# 2.1.1 相邻块元素垂直外边距的合并\n\n当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。而是取两个值中的较大者，这种现象被称为相邻块元素垂直外边距的合并（准确的描述应该是：大的外边距覆盖小的）。\n\n\n\n\n\n解决方案：\n\n尽量只给一个盒子添加 margin 值。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>相邻块元素垂直外边距的合并</title>\n    <style>\n        .one {\n            width: 200px;\n            height: 200px;\n            background-color: hotpink;\n            margin-bottom: 100px;\n        }\n\n        .two {\n            width: 200px;\n            height: 200px;\n            background-color: skyblue;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="one">one</div>\n    <div class="two">two</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n\n# 2.1.2 嵌套块元素垂直外边距的塌陷\n\n对于两个嵌套关系（父子关系）的块元素，当子元素有上外边距，此时父元素会塌陷较大的外边距值（外边距效果显示在父元素之上）。\n\n\n\n\n\n解决方案：\n\n * 可以为父元素定义上边框（比如：可以给一个透明 transparent 边框）\n * 可以为父元素定义上内边距\n * 可以为父元素添加 overflow: hidden\n\n还有其他方法，比如浮动、固定，绝对定位的盒子不会有塌陷问题，后面咱们再总结。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>外边距合并-嵌套块级元素垂直外边距塌陷</title>\n    <style>\n        .father {\n            width: 400px;\n            height: 400px;\n            background-color: black;\n            margin-top: 50px;\n        }\n\n        .son {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="father">\n        <div class="son"></div>\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>外边距合并-嵌套块级元素垂直外边距塌陷</title>\n    <style>\n        .father {\n            width: 400px;\n            height: 400px;\n            background-color: black;\n            margin-top: 50px;\n            /* border: 1px solid transparent; */\n            overflow: hidden;\n        }\n\n        .son {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            margin-top: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="father">\n        <div class="son"></div>\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n注意：外边距的合并在利用盒子布局页面的时候是经常发生的！\n\n\n# 2.6 清除内外边距\n\n网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。\n\n* {\n\tpadding:0; \t/* 清除内边距 */\n\tmargin:0; \t/* 清除外边距 */\n}\n\n\n1\n2\n3\n4\n\n\n注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距（某些时候，行内元素对上下内外边距不生效）。但是转换为块级和行内块元素就可以了。\n\n\n# 三、盒子模型相关布局问题以及技巧（重点）\n\n\n# 3.1 盒子的实际占位大小计算\n\n盒子的实际占位大小指的就是我们设置好宽高的基础上累加padding和border的大小；\n\n盒子的实际宽度 = width + 左右的padding + 左右的border；\n\n盒子的实际高度 = height+ 上下的padding + 上下的border；\n\n\n\n\n# 3.2 padding和border撑大盒子问题\n\n如果盒子宽高设置固定了，再去给盒子添加padding和border就会将盒子的大小撑大；\n\n\n# 解决方案1：人为手动加多少减多少：\n\n加多少减多少，将我们自己设置的宽高减去对应的padding和border即可；\n\n\n\n\n# 解决方案2：开启css3的盒子内减模式\n\n直接给盒子设置css3的内减模式 box-sizing: border-box;\n\n浏览器在解析的时候就会自己算我们的尺寸，会将设置的padding和border全部减去然后重新计算盒子的大小；\n\n\n\n\n# 3.3 外边距塌陷问题（了解）\n\n\n# 情况1：上下排列的盒子外边距合并\n\n上下排列的两个盒子，上面的盒子设置了marin-bottom,下面的盒子设置了margin-top，最终显示的样式两个值谁大就显示谁，小的值被大的值合并了；\n\n解决方案：单独设置给其中某一个盒子，不要两者都设置；\n\n\n# 情况2：嵌套盒子外边塌陷（外边距穿透）\n\n如果两个盒子有嵌套包含的父子级关系，如果给子级盒子设置了margin-top，效果显示父级盒子也会跟着掉下来；\n\n\n\n**解决方案1：**给父级盒子设置边框border，只能设置border-top，如果父盒子本身就有border就不会出现塌陷问题；\n\n**解决方案2：**给父级盒子设置内边距padding，只能设置padding-top，如果父盒子本身就有padding就不会出现塌陷问题；\n\n**解决方案3：**给父级盒子设置overflow:hidden；、display:flow-root；利用盒子的bfc模式；\n\n**解决方案4：**如果父级盒子或者子级盒子有了浮动或者定位就不会出现塌陷；\n\n\n# 3.4 外边距的经典应用：设置盒子水平居中\n\n想要使用**margin:0 auto;**设置一个盒子居中必须满足两个条件：\n\n> 01、盒子必须是块元素，独自占一行；\n> \n> 02、盒子必须要有固定的宽度；\n\n注意：实际开发中最常用就是设置版心盒子居中；\n\n**版心：**网页的主体内容显示的区域，一般是一个固定宽度的盒子，在浏览器的中心显示；版心的类名一般用w或者container表示；目前市场的版心一般都在1200左右（传智1200，京东1190、小米1226）；\n\n\n\n实际的开发中版心是不需要固定的高度的，因为每一个模块的高度不一样；\n\n        .w {\n            width: 1200px;\n            margin: 0 auto;\n            background-color: red;\n        }\n\n\n1\n2\n3\n4\n5\n\n\n\n\n\n# 3.4.1 行内元素和行内块元素居中text-align：center；\n\n将行内元素和行内块元素放在一个父级盒子中，设置父级盒子tac即text-align：center；就可以居中\n\n\n# 3.5 清除内外边距\n\n有些html标签浏览器在解析的时候有默认的内边距padding或者外边居marign，我们需要将默认的样式清除，再去设置自己的样式；\n\n比如：body有8px的默认外边距，ul有默认的内边距等\n\n我们只需在css的最前面将所有标签的margin和padding清0即可；\n\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n\n1\n2\n3\n4\n\n\n\n# 3.6 细线表格（边框合并）--- 死了都要记\n\n实际工作我们经常使用表格展示数据，我们用css设置细线表格，我们只需要给table、th、td标签同时设置边框border，然后设置边框合并属性border-collapse: collapse;即可实现；\n\n        table,\n        th,\n        td {\n            border: 1px solid #ccc;\n            border-collapse: collapse;\n        }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n\n# 3.7 border书写三角形效果（了解）\n\n\n\n盒子宽高必须都是0，然后设置盒子四条边都是透明，最后单独设置一个方向的边的颜色即可；\n\n    width: 0;\n    height: 0;\n    border: 20px solid transparent;\n    border-top-color: red;\n\n\n1\n2\n3\n4\n\n\n\n# 四、css3过渡动画（死了都要记）\n\n语法：transition: 属性 时间 运动曲线 延时;\n\n> 属性：需要改变过渡的属性\n> 时间：整个过度动画需要多长时间完成\n> 运动曲线 ：动画运动形式默认取值为ease。匀速运动linear；\n> 延时：鼠标移入需要等待一段时间再去加载过渡动画；\n> \n> \n> 1\n> 2\n> 3\n> 4\n\n实际开发中一般只会调用属性和时间\n\ntransition: 属性   时间；\n\n\n1\n\n\n> 注意： 01、同时修改多个属性，需要用英文逗号隔开 transition: width 1s, background-color 1s, height 1s; 02，用逗号隔开书写多个属性过渡太麻烦，我们只需要用一个all表示所有的属性即可 transition: all 1s ； 03、过渡加在本身上，谁做动画给谁加；',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"CSS3选择器、伪元素、光标类型、浮动",frontmatter:{title:"CSS3选择器、伪元素、光标类型、浮动",date:"2020-04-08T15:05:14.000Z",permalink:"/pages/64cb20/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/05.CSS3%E9%80%89%E6%8B%A9%E5%99%A8%E3%80%81%E4%BC%AA%E5%85%83%E7%B4%A0%E3%80%81%E5%85%89%E6%A0%87%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B5%AE%E5%8A%A8.html",relativePath:"01.前端基础/02.CSS/05.CSS3选择器、伪元素、光标类型、浮动.md",key:"v-1a4c07c0",path:"/pages/64cb20/",headers:[{level:2,title:"1.1 HTML5新增的语义化标签",slug:"_1-1-html5新增的语义化标签",normalizedTitle:"1.1 html5新增的语义化标签",charIndex:340},{level:2,title:"1.2 HTML5新增的多媒体标签",slug:"_1-2-html5新增的多媒体标签",normalizedTitle:"1.2 html5新增的多媒体标签",charIndex:1495},{level:3,title:"1.2.1 视频",slug:"_1-2-1-视频",normalizedTitle:"1.2.1 视频",charIndex:1611},{level:3,title:"1.2.2 音频",slug:"_1-2-2-音频",normalizedTitle:"1.2.2 音频",charIndex:2468},{level:3,title:"1.2.3 多媒体标签总结",slug:"_1-2-3-多媒体标签总结",normalizedTitle:"1.2.3 多媒体标签总结",charIndex:3170},{level:2,title:"1.3 HTML5新增的input类型",slug:"_1-3-html5新增的input类型",normalizedTitle:"1.3 html5新增的input类型",charIndex:3350},{level:2,title:"1.4 HTML5新增的表单属性",slug:"_1-4-html5新增的表单属性",normalizedTitle:"1.4 html5新增的表单属性",charIndex:4282},{level:2,title:"2.1 CSS3的现状",slug:"_2-1-css3的现状",normalizedTitle:"2.1 css3的现状",charIndex:6311},{level:2,title:"2.2 CSS3新增选择器",slug:"_2-2-css3新增选择器",normalizedTitle:"2.2 css3新增选择器",charIndex:6423},{level:3,title:"2.2.1 属性选择器",slug:"_2-2-1-属性选择器",normalizedTitle:"2.2.1 属性选择器",charIndex:6511},{level:4,title:"属性名称选择元素",slug:"属性名称选择元素",normalizedTitle:"属性名称选择元素",charIndex:6570},{level:4,title:"属性值选择元素",slug:"属性值选择元素",normalizedTitle:"属性值选择元素",charIndex:6738},{level:4,title:"属性值以某一个字符开头",slug:"属性值以某一个字符开头",normalizedTitle:"属性值以某一个字符开头",charIndex:6941},{level:4,title:"属性值以某一个字符结尾",slug:"属性值以某一个字符结尾",normalizedTitle:"属性值以某一个字符结尾",charIndex:7184},{level:4,title:"属性值包含某一个字符",slug:"属性值包含某一个字符",normalizedTitle:"属性值包含某一个字符",charIndex:7432},{level:3,title:"2.2.2 结构伪类选择器",slug:"_2-2-2-结构伪类选择器",normalizedTitle:"2.2.2 结构伪类选择器",charIndex:7700},{level:4,title:":nth-child 选择器（重点）",slug:"nth-child-选择器-重点",normalizedTitle:":nth-child 选择器（重点）",charIndex:7717},{level:4,title:"伪类选择器n的取值(重点)",slug:"伪类选择器n的取值-重点",normalizedTitle:"伪类选择器n的取值(重点)",charIndex:9086},{level:3,title:":nth-of-type选择器（了解）",slug:"nth-of-type选择器-了解",normalizedTitle:":nth-of-type选择器（了解）",charIndex:9426},{level:4,title:"第一个元素:first-of-type",slug:"第一个元素-first-of-type",normalizedTitle:"第一个元素:first-of-type",charIndex:9506},{level:4,title:"最后一个元素:last-of-type",slug:"最后一个元素-last-of-type",normalizedTitle:"最后一个元素:last-of-type",charIndex:9630},{level:4,title:"某一个元素:nth-of-type(n)",slug:"某一个元素-nth-of-type-n",normalizedTitle:"某一个元素:nth-of-type(n)",charIndex:9755},{level:3,title:"2.2.3 伪元素选择器（重点）",slug:"_2-2-3-伪元素选择器-重点",normalizedTitle:"2.2.3 伪元素选择器（重点）",charIndex:10295},{level:4,title:"::before",slug:"before",normalizedTitle:"::before",charIndex:10382},{level:4,title:"::after",slug:"after",normalizedTitle:"::after",charIndex:10406},{level:2,title:"2.3 CSS3盒子模型",slug:"_2-3-css3盒子模型",normalizedTitle:"2.3 css3盒子模型",charIndex:15095},{level:2,title:"2.4 CSS3其他特性（了解）",slug:"_2-4-css3其他特性-了解",normalizedTitle:"2.4 css3其他特性（了解）",charIndex:16451},{level:3,title:"2.4.1 CSS3滤镜 filter",slug:"_2-4-1-css3滤镜-filter",normalizedTitle:"2.4.1 css3滤镜 filter",charIndex:17858},{level:3,title:"2.4.2 CSS3 calc 函数",slug:"_2-4-2-css3-calc-函数",normalizedTitle:"2.4.2 css3 calc 函数",charIndex:17978},{level:2,title:"2.5 CSS3过渡（重点）",slug:"_2-5-css3过渡-重点",normalizedTitle:"2.5 css3过渡（重点）",charIndex:18096},{level:3,title:"2.5.1 过渡",slug:"_2-5-1-过渡",normalizedTitle:"2.5.1 过渡",charIndex:18115},{level:3,title:"2.5.2 进度条案例",slug:"_2-5-2-进度条案例",normalizedTitle:"2.5.2 进度条案例",charIndex:19543},{level:2,title:"2.6 CSS3 变量",slug:"_2-6-css3-变量",normalizedTitle:"2.6 css3 变量",charIndex:20448},{level:2,title:"1.1 传统网页布局的三种方式",slug:"_1-1-传统网页布局的三种方式",normalizedTitle:"1.1 传统网页布局的三种方式",charIndex:23477},{level:2,title:"1.2 标准流（普通流/文档流）",slug:"_1-2-标准流-普通流-文档流",normalizedTitle:"1.2 标准流（普通流/文档流）",charIndex:23619},{level:2,title:"1.3 为什么需要浮动？",slug:"_1-3-为什么需要浮动",normalizedTitle:"1.3 为什么需要浮动？",charIndex:23853},{level:2,title:"1.4 什么是浮动？",slug:"_1-4-什么是浮动",normalizedTitle:"1.4 什么是浮动？",charIndex:24145},{level:2,title:"1.5 浮动特性（重难点）",slug:"_1-5-浮动特性-重难点",normalizedTitle:"1.5 浮动特性（重难点）",charIndex:24385},{level:2,title:"1.6 使用浮动布局需要注意事项（死了都要记）",slug:"_1-6-使用浮动布局需要注意事项-死了都要记",normalizedTitle:"1.6 使用浮动布局需要注意事项（死了都要记）",charIndex:25466},{level:2,title:"1.7 浮动元素经常和标准流父级搭配使用",slug:"_1-7-浮动元素经常和标准流父级搭配使用",normalizedTitle:"1.7 浮动元素经常和标准流父级搭配使用",charIndex:26e3},{level:2,title:"3.1 思考题",slug:"_3-1-思考题",normalizedTitle:"3.1 思考题",charIndex:26113},{level:2,title:"3.2 为什么需要清除浮动？",slug:"_3-2-为什么需要清除浮动",normalizedTitle:"3.2 为什么需要清除浮动？",charIndex:26364},{level:2,title:"3.3 清除浮动本质",slug:"_3-3-清除浮动本质",normalizedTitle:"3.3 清除浮动本质",charIndex:26518},{level:2,title:"3.4 清除浮动属性clear",slug:"_3-4-清除浮动属性clear",normalizedTitle:"3.4 清除浮动属性clear",charIndex:26629},{level:2,title:"3.5 清除浮动方法",slug:"_3-5-清除浮动方法",normalizedTitle:"3.5 清除浮动方法",charIndex:26817},{level:3,title:"3.5.1 清除浮动 —— 额外标签法",slug:"_3-5-1-清除浮动-额外标签法",normalizedTitle:"3.5.1 清除浮动 —— 额外标签法",charIndex:26925},{level:3,title:"3.5.2 清除浮动 —— 父级添加 overflow",slug:"_3-5-2-清除浮动-父级添加-overflow",normalizedTitle:"3.5.2 清除浮动 —— 父级添加 overflow",charIndex:27285},{level:3,title:"3.5.3 清除浮动 —— :after 伪元素法（重要）",slug:"_3-5-3-清除浮动-after-伪元素法-重要",normalizedTitle:"3.5.3 清除浮动 —— :after 伪元素法（重要）",charIndex:27426},{level:3,title:"3.5.4 清除浮动 —— 双伪元素清除浮动",slug:"_3-5-4-清除浮动-双伪元素清除浮动",normalizedTitle:"3.5.4 清除浮动 —— 双伪元素清除浮动",charIndex:28079},{level:2,title:"3.6 清除浮动总结",slug:"_3-6-清除浮动总结",normalizedTitle:"3.6 清除浮动总结",charIndex:28451},{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:585},{level:2,title:"触发 BFC",slug:"触发-bfc",normalizedTitle:"触发 bfc",charIndex:29005},{level:2,title:"display:flow-root",slug:"display-flow-root",normalizedTitle:"display:flow-root",charIndex:29282},{level:2,title:"五、css书写顺序（了解）",slug:"五、css书写顺序-了解",normalizedTitle:"五、css书写顺序（了解）",charIndex:29395},{level:2,title:"2.1 初识常见网页布局",slug:"_2-1-初识常见网页布局",normalizedTitle:"2.1 初识常见网页布局",charIndex:30125},{level:2,title:"2.2 浮动布局注意点",slug:"_2-2-浮动布局注意点",normalizedTitle:"2.2 浮动布局注意点",charIndex:31817}],headersStr:"1.1 HTML5新增的语义化标签 1.2 HTML5新增的多媒体标签 1.2.1 视频 1.2.2 音频 1.2.3 多媒体标签总结 1.3 HTML5新增的input类型 1.4 HTML5新增的表单属性 2.1 CSS3的现状 2.2 CSS3新增选择器 2.2.1 属性选择器 属性名称选择元素 属性值选择元素 属性值以某一个字符开头 属性值以某一个字符结尾 属性值包含某一个字符 2.2.2 结构伪类选择器 :nth-child 选择器（重点） 伪类选择器n的取值(重点) :nth-of-type选择器（了解） 第一个元素:first-of-type 最后一个元素:last-of-type 某一个元素:nth-of-type(n) 2.2.3 伪元素选择器（重点） ::before ::after 2.3 CSS3盒子模型 2.4 CSS3其他特性（了解） 2.4.1 CSS3滤镜 filter 2.4.2 CSS3 calc 函数 2.5 CSS3过渡（重点） 2.5.1 过渡 2.5.2 进度条案例 2.6 CSS3 变量 1.1 传统网页布局的三种方式 1.2 标准流（普通流/文档流） 1.3 为什么需要浮动？ 1.4 什么是浮动？ 1.5 浮动特性（重难点） 1.6 使用浮动布局需要注意事项（死了都要记） 1.7 浮动元素经常和标准流父级搭配使用 3.1 思考题 3.2 为什么需要清除浮动？ 3.3 清除浮动本质 3.4 清除浮动属性clear 3.5 清除浮动方法 3.5.1 清除浮动 —— 额外标签法 3.5.2 清除浮动 —— 父级添加 overflow 3.5.3 清除浮动 —— :after 伪元素法（重要） 3.5.4 清除浮动 —— 双伪元素清除浮动 3.6 清除浮动总结 定义 触发 BFC display:flow-root 五、css书写顺序（了解） 2.1 初识常见网页布局 2.2 浮动布局注意点",content:'# 五、光标类型/鼠标样式cursor（了解）\n\n默认的小箭头\n\ncursor: default;\n\n\n1\n\n\n小手形状\n\ncursor:pointer;\n\n\n1\n\n\n移动图标\n\ncursor:move;\n\n\n1\n\n\n文本图标\n\ncursor:text;\n\n\n1\n\n\n禁止点击图标\n\ncursor:not-allowed;\t\t\n\n\n1\n\n\n\n# 一、HTML5的新特性\n\nHTML5 的新增特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等。\n\n这些新特性都有兼容性问题，基本是 IE9+ 以上版本的浏览器才支持，如果不考虑兼容性问题（例如：移动端），便可以大量使用这些新特性。\n\n> 声明：新特性增加了很多，但是我们只需专注于开发常用的新特性即可\n\n\n# 1.1 HTML5新增的语义化标签\n\n以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。\n\n<div class=“header”> </div>\n<div class=“nav”> </div>\n<div class=“content”> </div>\n<div class=“footer”> </div>\n\n\n1\n2\n3\n4\n\n\n\n\n * <header>：头部标签\n * <nav>：导航标签\n * <article>：内容标签\n * <section>：定义文档的某个区域\n * <aside>：侧边栏标签\n * <footer>：尾部标签\n\n注意：\n\n * 这种语义化标准主要是针对搜索引擎的\n * 这些新标签页面中可以使用多次\n * 在 IE9 中，需要把这些元素转换为块级元素\n * 其实，我们移动端更喜欢使用这些标签\n * HTML5 还增加了很多其他标签，我们后面再慢慢学\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增语义化标签</title>\n    <style>\n        header, nav {\n            height: 120px;\n            background-color: pink;\n            border-radius: 15px;\n            width: 800px;\n            margin: 15px auto;\n        }\n\n        section {\n            width: 500px;\n            height: 300px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n<body>\n<header>头部标签</header>\n<nav>导航栏标签</nav>\n<section>某个区域</section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n\n# 1.2 HTML5新增的多媒体标签\n\n新增的多媒体标签主要包含两个：\n\n 1. 音频：<audio>\n 2. 视频：<video>\n\n使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用 flash 和其他浏览器插件。\n\n\n# 1.2.1 视频\n\nHTML5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放。当然，支持的格式是有限的。\n\n当前 <video> 元素支持三种视频格式：尽量使用 mp4 格式。\n\n\n\n语法：\n\n<video src="文件地址" controls="controls"></video>\n\n\n1\n\n\n<video controls="controls" width="300"> \n    <source src="move.ogg" type="video/ogg"> \n    <source src="move.mp4" type="video/mp4"> \n    您的浏览器暂不支持 <video> 标签播放视频\n</ video >\n\n\n1\n2\n3\n4\n5\n\n\n常见属性：\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增视频标签</title>\n    <style>\n        video {\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n<video src="media/mi.mp4" autoplay="autoplay" muted="muted" loop="loop" poster="media/mi9.jpg"></video>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n以上视频会自动播放。\n\n\n# 1.2.2 音频\n\nHTML5 在不使用插件的情况下，也可以原生的支持音频格式文件的播放。当然，支持的格式是有限的。\n\n当前 <audio> 元素支持三种音频格式：尽量使用 mp3 格式。\n\n\n\n语法：\n\n<audio src="文件地址" controls="controls"></audio>\n\n\n1\n\n\n<audio controls="controls">\n\t<source src="happy.mp3" type="audio/mpeg">\n\t<source src="happy.ogg" type="audio/ogg">\n\t您的浏览器暂不支持 <audio> 标签。\n</audio>\n\n\n1\n2\n3\n4\n5\n\n\n常见属性：\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增音频标签</title>\n</head>\n<body>\n<audio src="media/music.mp3" autoplay="autoplay" controls="controls"></audio>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n\n# 1.2.3 多媒体标签总结\n\n * 音频标签和视频标签使用方式基本一致\n * 浏览器支持情况不同\n * 谷歌浏览器把音频和视频自动播放禁止了\n * 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过 JavaScript 解决）\n * 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性\n\n\n# 1.3 HTML5新增的input类型\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>Document</title>\n</head>\n\n<body>\n\x3c!-- 我们验证的时候必须添加form表单域 --\x3e\n<form action="">\n    <ul>\n        <li>邮箱: <input type="email"/></li>\n        <li>网址: <input type="url"/></li>\n        <li>日期: <input type="date"/></li>\n        <li>时间: <input type="time"/></li>\n        <li>数量: <input type="number"/></li>\n        <li>手机号码: <input type="tel"/></li>\n        <li>搜索: <input type="search"/></li>\n        <li>颜色: <input type="color"/></li>\n        \x3c!-- 当我们点击提交按钮就可以验证表单了 --\x3e\n        <li><input type="submit" value="提交"></li>\n    </ul>\n</form>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n注意：HTML5 所提供的 input 类型可以依据具体的系统环境适配界面样式。\n\n当为数值框时，输入法自动打开数字键盘！\n\n\n# 1.4 HTML5新增的表单属性\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n<body>\n<form action="">\n    <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n           autocomplete="off">\n    <input type="file" name="" id="two" multiple="multiple">\n    <input type="submit" value="提交">\n</form>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n\n<body>\n    <form action="">\n        <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n            autocomplete="on">\n        <input type="submit" value="提交">\n    </form>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>HTML5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n\n<body>\n    <form action="">\n        <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n            autofocus="autofocus">\n        <input type="submit" value="提交">\n    </form>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n自动聚焦：\n\n\n\n\n# 二、CSS3的新特性\n\n\n# 2.1 CSS3的现状\n\n * 新增的 CSS3 特性有兼容性问题，IE9+ 才支持\n * 移动端支持优于 PC 端\n * 不断改进中\n * 应用相对广泛\n * 现阶段主要学习：新增选择器、盒子模型 以及 其他特性\n\n\n# 2.2 CSS3新增选择器\n\nCSS3 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。\n\n 1. 属性选择器\n 2. 结构伪类选择器\n 3. 伪元素选择器\n\n\n# 2.2.1 属性选择器\n\n根据元素的属性及属性值来选择元素；\n\n语法：元素名称[相关属性] { css样式 }\n\n# 属性名称选择元素\n\n语法：标签选择器[属性] {}，通过某一个属性选择元素\n\n        /* 表示选中了input标签，而且标签有一个type属性 */\n        input[type] {\n            background-color: blueviolet;\n        }\n\n\n1\n2\n3\n4\n\n\n# 属性值选择元素\n\n语法：标签选择器[属性=属性值] {}，通过某一个属性和属性值选择元素；\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值为url */\n        input[type=url] {\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n\n\n注意：属性值的引号可以省略不写；\n\n# 属性值以某一个字符开头\n\n语法：标签选择器[属性^=属性值里面的字符]，\n\n通过某一个属性选择元素，但是属性值必须是以某一个字符开头的\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值必须是以t字符开头的 */\n        input[type^=t] {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n4\n\n\n注意： ^= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n# 属性值以某一个字符结尾\n\n语法：标签选择器[属性$=属性值里面的字符]，\n\n通过某一个属性选择元素，但是属性值必须是以某一个字符结尾的\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值必须是以h字符结尾的 */\n        input[type$=h] {\n            background-color: orangered;\n        }\n\n\n1\n2\n3\n4\n\n\n注意： $= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n# 属性值包含某一个字符\n\n语法：标签选择器[属性=属性值里面的字符]*，通过某一个属性选择元素，但是属性值不管在什么位置只要包含某一个字符即可选中；\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值不管什么位置只要包含r就会被选中 */\n        input[type*=r] {\n            background-color: rgb(255, 0, 106);\n        }\n\n\n1\n2\n3\n4\n\n\n注意： *= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n\n# 2.2.2 结构伪类选择器\n\n# :nth-child 选择器（重点）\n\n通过nth-child选择元素是将这个父级盒子中的所有子元素依次排序，然后按照对应的顺序选择元素，不会将元素分类（比如男生女生混合的排序）\n\n查找方法：先查看位置，然后再去匹配是不是对应的标签，如果选择的位置，元素不匹配则不会渲染样式；\n\n * n 可以是数字，关键字和公式\n * n 如果是数字，就是选择第 n 个子元素，里面数字从 1 开始……\n * n 可以是关键字：even 偶数，odd 奇数\n * n 可以是公式：常见的公式如下（如果 n 是公式，则从 n = 0 开始计算，但是第 0 个元素和超出了元素的个数会被忽略）\n\n公式     取值\n2n     偶数（2、4、6、……）\n2n+1   奇数（1、3、5、……）\n5n     5 10 15...\nn+5    从第 5 个开始（包含第 5 个）到最后\n-n+5   前 5 个（包含第 5 个）\n\n结构伪类选择器主要根据文档结构来选择元素，常用于根据父级来选择其子元素。\n\n选择器                简介\nE:first-child      匹配父元素中的第一个子元素 E\nE:last-child       匹配父元素中最后一个 E 元素\nE:nth-child(n)     匹配父元素中的第 n 个子元素 E\nE:first-of-type    指定类型 E 的第一个\nE:last-of-type     指定类型 E 的最后一个\nE:nth-of-type(n)   指定类型 E 的第 n 个\n\n# 第一个元素:first-child {}\n\n选择结构中指定的第一个元素；\n\n        /* 表示选中了box盒子里面所有的li中的第一个 */\n        .box li:first-child {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n\n\n# 最后一个元素:last-child {}\n\n选择结构中指定的最后一个元素；\n\n        /* 表示选中了box盒子里面所有的li中的最后一个 */\n        .box li:last-child {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n\n\n# 倒数第几个:nth-last-child(n)\n\n选择结构中指定的倒数第n个元素；\n\n        /* 表示选中了box盒子里面所有的li中的倒数第3个元素 */\n        .box li:nth-last-child(3) {\n            background-color: pink;\n        }\n\n\n1\n2\n3\n4\n\n\n# 某一个元素nth-child(n)\n\n选择结构中指定的第n个元素；\n\n        /* 表示选中了box盒子里面所有的li中的指定的位置的元素 */\n        .box li:nth-child(3) {\n            background-color: powderblue;\n        }\n\n\n1\n2\n3\n4\n\n\n# 伪类选择器n的取值(重点)\n\n# 01、直接取值为n\n\n表示选中所有的该标签\n\n# 02、取值为关键字odd或者even\n\nodd 表示取值为奇数\n\n\t .box li:nth-child(odd) {\n            background-color: pink;\n      }\n\n\n1\n2\n3\n\n\neven 表示取值为偶数\n\n\t.box li:nth-child(even) {\n            background-color: palegreen;\n     }\n\n\n1\n2\n3\n\n\n# 03、取值为数学公式\n\n2n表示偶数； 2n+1 表示奇数； 3n表示取值为3的倍数； n+3表示从第3个开始一直选择到最后一个； -n+3表示表示前3个；\n\n\n# :nth-of-type选择器（了解）\n\n**选择元素的规则：**先将父级里面元素分类（比如班级里的学生分为男生和女生）并且各自排序，然后再去匹配位置；\n\n# 第一个元素:first-of-type\n\n选择父元素下某一类元素的第一个元素\n\n\t.box div:first-of-type {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n\n\n# 最后一个元素:last-of-type\n\n选择父元素下某一类元素的最后一个元素\n\n\t .box div:last-of-type {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n\n\n# 某一个元素:nth-of-type(n)\n\n选择器父元素下某一类标签中的第n个元素\n\n        .box p:nth-of-type(2) {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n\n\n注意：:nth-of-type(n) 中 n的取值个nth-child是一样的； 区别：\n\n 1. nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第 n 个孩子，然后看看是否和 E 匹配\n 2. nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配 E，然后再根据 E 找第 n 个孩子\n\n小结：\n\n * 结构伪类选择器一般用于选择父级里面的第几个孩子\n * nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第 n 个孩子，然后看看是否和 E 匹配\n * nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配 E，然后再根据 E 找第 n 个孩子\n * 若父元素内都是同一种标签（如：列表），优先用 nth-child，否则就只能使用 nth-of-type\n * 类选择器、属性选择器、伪类选择器，权重为 10\n\n\n# 2.2.3 伪元素选择器（重点）\n\n伪元素选择器可以帮助我们利用 CSS 创建新标签元素，而不需要 HTML 标签，从而简化 HTML 结构。\n\n选择器        简介\n::before   在元素内容的前面插入内容\n::after    在元素内容的后面插入内容\n\n# ::before\n\n在元素内容前面插入一个伪盒子\n\n    .box::before {\n        content: \'\';\n    }\n\n\n1\n2\n3\n\n\n# ::after\n\n在元素内容后面插入一个伪盒子\n\n    .box::after {\n        content: \'\';\n    }\n\n\n1\n2\n3\n\n\n注意：\n\n * 伪元素的显示模式默认是行内元素的特点，before 和 after 创建一个元素，属于行内元素,直接设置宽高是无效的，我们需要转化\n * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n * 语法：element::before{}\n * 伪元素设置的时候必须添加content属性，否则不生效，哪怕是空的也要设置空的引号\n * before 在父元素内容的前面创建元素，after 在父元素内容的后面创建元素\n * 伪元素选择器和标签选择器一样，权重为 1\n\n（1）伪元素选择器使用场景1：伪元素字体图标\n\np::before {\n\tposition: absolute;\n\tright: 20px;\n\ttop: 10px;\n\tcontent: \'\\e91e\';\n\tfont-size: 20px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（2）伪元素选择器使用场景2：仿土豆效果\n\n/* 当我们鼠标经过了 土豆这个盒子，就让里面 before 遮罩层显示出来 */\n.tudou:hover::before {\n\t/* 而是显示元素 */\n    display: block;\n}\n\n\n1\n2\n3\n4\n5\n\n\n（3）伪元素选择器使用场景3：伪元素清除浮动\n\n 1. 额外标签法也称为隔墙法，是 W3C 推荐的做法\n 2. 父级添加 overflow 属性\n 3. 父级添加 after 伪元素\n 4. 父级添加双伪元素\n\n额外标签法也称为隔墙法，是 W3C 推荐的做法。\n\n\n\n注意：要求这个新的空标签必须是块级元素。\n\n后面两种伪元素清除浮动算是第一种额外标签法的一个升级和优化。\n\n.clearfix:after {\n\tcontent: "";\t\t\t/* 伪元素必须写的属性 */\n\tdisplay: block;\t\t\t/* 插入的元素必须是块级 */\n\theight: 0;\t\t\t\t/* 不要看见这个元素 */\n\tclear: both;\t\t\t/* 核心代码清除浮动 */\n\tvisibility: hidden;\t\t/* 不要看见这个元素 */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n.clearfix:before,\n.clearfix:after {\n\tcontent: "";\n\tdisplay: table;\t\t\t/* 转换为块级元素并且一行显示 */\n}\n\n.clearfix:after {\n\tclear: both;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n案例：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>伪元素选择器before和after</title>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: salmon;\n        }\n\n        /* div::before 权重是 2 */\n        div::before {\n            /* 这个 content 是必须要写的 */\n            /* display: inline-block; */\n            content: \'我\';\n            /* width: 30px;\n            height: 40px;\n            background-color: purple; */\n        }\n\n        div::after {\n            content: \'小猪佩奇\';\n        }\n    </style>\n</head>\n<body>\n<div>\n    是\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>伪元素选择器使用场景-字体图标</title>\n    <style>\n        @font-face {\n            font-family: \'icomoon\';\n            src: url(\'fonts/icomoon.eot?1lv3na\');\n            src: url(\'fonts/icomoon.eot?1lv3na#iefix\') format(\'embedded-opentype\'),\n            url(\'fonts/icomoon.ttf?1lv3na\') format(\'truetype\'),\n            url(\'fonts/icomoon.woff?1lv3na\') format(\'woff\'),\n            url(\'fonts/icomoon.svg?1lv3na#icomoon\') format(\'svg\');\n            font-weight: normal;\n            font-style: normal;\n            font-display: block;\n        }\n\n        div {\n            position: relative;\n            width: 200px;\n            height: 35px;\n            border: 1px solid red;\n        }\n\n        div::after {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            font-family: \'icomoon\';\n            /* content: \'\'; */\n            content: \'\\e91e\';\n            color: red;\n            font-size: 18px;\n        }\n    </style>\n</head>\n\n<body>\n<div></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>伪元素选择器使用场景2-仿土豆网显示隐藏遮罩案例</title>\n    <style>\n        .tudou {\n            position: relative;\n            width: 444px;\n            height: 320px;\n            background-color: pink;\n            margin: 30px auto;\n        }\n\n        .tudou img {\n            width: 100%;\n            height: 100%;\n        }\n\n        .tudou::before {\n            content: \'\';\n            /* 隐藏遮罩层 */\n            display: none;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center;\n        }\n\n        /* 当我们鼠标经过了土豆这个盒子，就让里面 before 遮罩层显示出来 */\n        .tudou:hover::before {\n            /* 而是显示元素 */\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n<div class="tudou">\n    <img src="images/tudou.jpg" alt="">\n</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n\n# 2.3 CSS3盒子模型\n\nCSS3 中可以通过 box-sizing 来指定盒模型，有 2 个值：即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变。\n\n可以分成两种情况：\n\n 1. box-sizing: content-box 盒子大小为 width + padding + border （以前默认的）\n 2. box-sizing: border-box 盒子大小为 width\n\n如果盒子模型我们改为了 box-sizing: border-box， 那 padding 和 border 就不会撑大盒子了（前提 padding 和 border 不会超过 width 宽度）\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS3盒子模型</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            border: 20px solid red;\n            padding: 15px;\n            box-sizing: content-box;\n        }\n\n        p {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            border: 20px solid red;\n            padding: 15px;\n            /* css3 盒子模型 盒子最终的大小就是 width 200 的大小 */\n            box-sizing: border-box;\n        }\n    </style>\n</head>\n<body>\n<div>\n    小猪乔治\n</div>\n<p>\n    小猪佩奇\n</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n\n\n\n\n# 2.4 CSS3其他特性（了解）\n\n 1. 图片变模糊\n 2. 计算盒子宽度 width:calc 函数\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>图片模糊处理filter</title>\n    <style>\n        img {\n            /* blur 是一个函数 小括号里面数值越大，图片越模糊 注意数值要加 px 单位 */\n            filter: blur(15px);\n        }\n\n        img:hover {\n            filter: blur(0);\n        }\n    </style>\n</head>\n<body>\n<img src="images/pink.jpg" alt="">\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS3属性calc函数</title>\n    <style>\n        .father {\n            width: 500px;\n            height: 500px;\n            background-color: black;\n        }\n\n        .son {\n            /* width: 300px; */\n            /* width: calc(500px - 100px); */\n            width: calc(100% - 100px);\n            height: 200px;\n            background-color: salmon;\n        }\n    </style>\n</head>\n<body>\n\x3c!-- 需求：我们的子盒子宽度永远比父盒子小 100 像素 --\x3e\n<div class="father">\n    <div class="son"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 2.4.1 CSS3滤镜 filter\n\nfilter CSS 属性将模糊或颜色偏移等图形效果应用于元素。\n\nfilter: 函数(); 例如：filter: blur(5px); blur 模糊处理，数值越大越模糊\n\n\n1\n\n\n\n\n\n# 2.4.2 CSS3 calc 函数\n\ncalc() 此 CSS 函数让你在声明 CSS 属性值时执行一些计算。\n\nwidth: calc(100% - 80px);\n\n\n1\n\n\n括号里面可以使用 + - * / 来进行计算。\n\n\n# 2.5 CSS3过渡（重点）\n\n\n# 2.5.1 过渡\n\n过渡（transition）是 CSS3 中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。\n\n过渡动画：是从一个状态渐渐的过渡到另外一个状态。\n\n可以让我们页面更好看，更动感十足，虽然低版本浏览器不支持（IE9 以下版本） 但是不会影响页面布局。\n\n我们现在经常和 :hover 一起搭配使用。\n\n语法：\n\ntransition: 要过渡的属性 花费时间 运动曲线 何时开始;\n\n\n1\n\n 1. 属性：想要变化的 css 属性，宽度高度、背景颜色、内外边距都可以 。如果想要所有的属性都变化过渡，写一个 all 就可以\n 2. 花费时间：单位是秒（必须写单位）比如 0.5s\n 3. 运动曲线：默认是 ease（可以省略）\n 4. 何时开始：单位是秒（必须写单位）可以设置延迟触发时间默认是 0s（可以省略）\n\n记住过渡的使用口诀：谁做过渡给谁加！\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS3过渡效果</title>\n    <style>\n        div {\n            width: 200px;\n            height: 100px;\n            background-color: black;\n            /* transition: 变化的属性 花费时间 运动曲线 何时开始; */\n            /* transition: width .5s ease 0s, height .5s ease 1s; */\n            /* 如果想要写多个属性，利用逗号进行分割 */\n            /* transition: width .5s, height .5s; */\n            /* 如果想要多个属性都变化，属性写 all 就可以了 */\n            /* transition: height .5s ease 1s; */\n            /* 谁做过渡，给谁加 */\n            transition: all 0.5s;\n        }\n\n        div:hover {\n            width: 400px;\n            height: 200px;\n            background-color: gray;\n        }\n    </style>\n</head>\n<body>\n<div></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n\n# 2.5.2 进度条案例\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS3过渡练习-进度条</title>\n    <style>\n        .bar {\n            width: 150px;\n            height: 15px;\n            border: 1px solid red;\n            border-radius: 7px;\n            padding: 1px;\n        }\n\n        .bar_in {\n            width: 50%;\n            height: 100%;\n            border-radius: 7px;\n            background-color: red;\n            /* 谁做过渡给谁加 */\n            transition: all .7s;\n        }\n\n        .bar:hover .bar_in {\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class="bar">\n    <div class="bar_in"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# 2.6 CSS3 变量\n\nvar() 函数用于插入 CSS 变量的值。\n\n使用 CSS 变量的一种好方法涉及设计的颜色。您可以将它们放在变量中，而不必一遍又一遍地复制和粘贴相同的颜色。\n\n【传统方式】\n\n以下例子显示了在样式表中定义一些颜色的传统方式（通过为每个特定元素定义要使用的颜色）：\n\n<!DOCTYPE html>\n<html>\n<head>\n<style>\nbody {\n  background-color: #1e90ff;\n}\n\nh2 {\n  border-bottom: 2px solid #1e90ff;\n}\n\n.container {\n  color: #1e90ff;\n  background-color: #ffffff;\n  padding: 15px;\n}\n\nbutton {\n  background-color: #ffffff;\n  color: #1e90ff;\n  border: 1px solid #1e90ff;\n  padding: 5px;\n}\n</style>\n</head>\n<body>\n\n<h1>传统方式</h1>\n\n<div class="container">\n  <h2>Welcome to Shanghai!</h2>\n  <p>Shanghai is one of the four direct-administered municipalities of the People\'s Republic of China.</p>\n  <p>Shanghai is one of the four direct-administered municipalities of the People\'s Republic of China.</p>\n  <p>\n    <button>Yes</button>\n    <button>No</button>\n  </p>\n</div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n【var() 函数的语法】\n\nvar() 函数用于插入 CSS 变量的值。\n\nvar() 函数的语法如下：\n\nvar(name, value)\n\n\n1\n\n\n值       描述\nname    必需。变量名（以两条破折号 -- 开头）。\nvalue   可选。回退值（在未找到变量时使用）。\n\n**注释：**变量名称必须以两个破折号 -- 开头，且区分大小写！\n\n【var() 如何工作】\n\n首先：CSS 变量可以有全局或局部作用域。\n\n全局变量可以在整个文档中进行访问/使用，而局部变量只能在声明它的选择器内部使用。\n\n如需创建具有全局作用域的变量，请在 :root 选择器中声明它，:root 选择器匹配文档的根元素。\n\n如需创建具有局部作用域的变量，请在将要使用它的选择器中声明它。\n\n下面的例子与上面的例子相同，但是在这里我们使用 var() 函数。\n\n首先，我们声明两个全局变量（--blue 和 --white）。然后，我们使用 var() 函数稍后在样式表中插入变量的值：\n\n<!DOCTYPE html>\n<html>\n<head>\n<style>\n:root {\n  --blue: #1e90ff;\n  --white: #ffffff; \n}\n\nbody {\n  background-color: var(--blue);\n}\n\nh2 {\n  border-bottom: 2px solid var(--blue);\n}\n\n.container {\n  color: var(--blue);\n  background-color: var(--white);\n  padding: 15px;\n}\n\nbutton {\n  background-color: var(--white);\n  color: var(--blue);\n  border: 1px solid var(--blue);\n  padding: 5px;\n}\n</style>\n</head>\n<body>\n\n<h1>使用 var() 函数</h1>\n\n<div class="container">\n  <h2>Welcome to Shanghai!</h2>\n  <p>Shanghai is one of the four direct-administered municipalities of the People\'s Republic of China.</p>\n  <p>Shanghai is one of the four direct-administered municipalities of the People\'s Republic of China.</p>\n  <p>\n    <button>Yes</button>\n    <button>No</button>\n  </p>\n</div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n使用 var() 有如下优势：\n\n * 使代码更易于阅读（更容易理解）\n * 使修改颜色值更加容易\n\n如需将蓝色和白色改为较柔和的蓝色和白色，您只需要修改两个变量值：\n\n:root {\n  --blue: #6495ed;\n  --white: #faf0e6;\n}\n\nbody { background-color: var(--blue); }\n\nh2 { border-bottom: 2px solid var(--blue); }\n\n.container {\n  color: var(--blue);\n  background-color: var(--white);\n  padding: 15px;\n}\n\nbutton {\n  background-color: var(--white);\n  color: var(--blue);\n  border: 1px solid var(--blue);\n  padding: 5px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 三、狭义的 HTML5 CSS3\n\n 1. HTML5 结构本身\n    \n    \n\n 2. CSS3 相关样式\n    \n    \n\n\n# 四、广义的 HTML5\n\n 1. 广义的 HTML5 是 HTML5 + CSS3 + JavaScript\n 2. 这个集合有时称为 H5\n 3. 虽然 HTML5 的一些特性仍然不被某些浏览器支持，但是它是一种发展趋势\n\n\n# 一、浮动（float）\n\n\n# 1.1 传统网页布局的三种方式\n\n网页布局的本质：用 CSS 来摆放盒子，把盒子摆放到相应位置。\n\nCSS 提供了三种传统布局方式（简单说就是盒子如何进行排列）。\n\n * 普通流（标准流）\n * 浮动\n * 定位\n\n> 这里指的只是传统布局，其实还有一些特殊高级的布局方式。\n\n\n# 1.2 标准流（普通流/文档流）\n\n所谓的标准流：就是标签按照规定好的默认方式排列。\n\n 1. 块级元素会独占一行，从上向下顺序排列。\n 2. 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。\n\n以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。\n\n这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。\n\n**注意：**实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。\n\n\n# 1.3 为什么需要浮动？\n\n提问：我们用标准流能很方便的实现如下效果吗？\n\n 1. 如何让多个块级盒子（div）水平排列成一行？\n\n\n\n比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。\n\n\n\n 2. 如何实现两个盒子的左右对齐？\n\n\n\n总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式。\n\n浮动最典型的应用：可以让多个块级元素一行内排列显示。\n\n网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动！\n\n**拓展：**浮动的盒子不会发生外边距合并！\n\n\n# 1.4 什么是浮动？\n\nfloat 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。\n\n语法：\n\n选择器 { float: 属性值;}\n\n\n1\n\n\n属性      描述\nnone    元素不浮动（默认值）\nleft    元素向左浮动\nright   元素向右浮动\n\n左浮动 fll\n\n float: left;\n\n\n1\n\n\n右浮动 flr\n\nfloat: right;\n\n\n1\n\n\n不浮动\n\n float: none;\n\n\n1\n\n\n\n# 1.5 浮动特性（重难点）\n\n加了浮动之后的元素，会具有很多特性，需要我们掌握。\n\n 1. 浮动元素会脱离标准流（脱标）\n 2. 浮动的元素会一行内显示并且元素顶部对齐\n 3. 浮动的元素会具有行内块元素的特性\n\n下面分别解释：\n\n（1）浮动元素会脱离标准流（脱标）\n\n * 脱离标准普通流的控制（浮） 移动到指定位置（动），（俗称脱标）\n * 浮动的盒子不再保留原先的位置\n\n\n\n<head>\n\n    <style>\n        /* 设置了浮动（float）的元素会：\n        1.脱离标准普通流的控制（浮）移动到指定位置（动）。\n        2.浮动的盒子不再保留原先的位置 */\n        .box1 {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n\n        .box2 {\n            width: 300px;\n            height: 300px;\n            background-color: gray;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box1">浮动的盒子</div>\n    <div class="box2">标准流的盒子</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n（2）浮动的元素会一行内显示并且元素顶部对齐\n\n * 如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。\n * 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。\n\n（3）浮动的元素会具有行内块元素的特性\n\n任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。\n\n * 块级盒子：没有设置宽度时默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\n * 行内盒子：宽度默认和内容一样宽，直接设置高宽无效，但是添加浮动后，它的大小可以直接设置\n * 浮动的盒子中间是没有缝隙的，是紧挨着一起的\n * 即：默认宽度由内容决定，同时支持指定高宽内外边距，盒子之间无空隙\n\n\n# 1.6 使用浮动布局需要注意事项（死了都要记）\n\n01、浮动布局的时候一定要配合一个标准流的父级盒子来限制浮动元素的位置； 02、如果父元素中的子元素布局的时候，一个浮动了其他的子元素也要浮动，否则会出现问题；\n\n03、如果父元素里面的子元素浮动以后，所有的宽度包括margin值加起来大于父盒子的宽度，子盒子会折行另起一行显示；\n\n解决方案1：使用css3的结构伪类选择器，选中每一行的最后一个设置某一个数的倍数，设置外边距为0即可；\n\n.list-box .pr li:nth-child(4n) {\n  margin-right: 0;\n}\n\n\n1\n2\n3\n\n\n以上的代码表示选中了4的倍数的盒子设置margin-right为0；\n\n**解决方案2：**列表的父级盒子默认和最外层的大盒子一样大，我们可以设置列表的父级盒子比外层的大盒子宽103%，这样就可以兼容任何浏览器；\n\n.list-box ul {\n  /* width: 992px; */\n  width: 103%;\n  /* height: 600px; */\n  /* background-color: rgba(0, 0, 0, 0.6); */\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.7 浮动元素经常和标准流父级搭配使用\n\n为了约束浮动元素位置，我们网页布局一般采取的策略是：\n\n先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准侧。\n\n\n\n\n# 三、清除浮动\n\n\n# 3.1 思考题\n\n我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点，都是有高度的。\n\n但是，所有的父盒子都必须有高度吗？\n\n答案：不一定！比如，一个产品列表，随着时期的不同，产品数量也不同，所需的盒子大小也会随之改变，那么直接固定盒子高度的形式显然就是不行的。再比如，文章之类的盒子，不同的文章字数是不相同的，那么显然盒子也不能直接固定高度。\n\n理想中的状态，让子盒子撑开父亲。有多少孩子，我父盒子就有多高。\n\n但是不给父盒子高度会有问题吗？\n\n答案：会！但有方法解决（清除浮动）。\n\n\n# 3.2 为什么需要清除浮动？\n\n由于父级盒子很多情况下不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。\n\n\n\n * 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响\n\n * 此时一但父盒子下面有其他盒子，那么布局就会发生严重混乱！\n\n\n# 3.3 清除浮动本质\n\n * 清除浮动的本质是清除浮动元素造成的影响\n * 如果父盒子本身有高度，则不需要清除浮动\n * 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了\n\n\n# 3.4 清除浮动属性clear\n\n语法：\n\n选择器 { clear: 属性值; }\n\n\n1\n\n\n属性值     描述\nleft    不允许左侧有浮动元素（清除左侧浮动的影响）\nright   不允许右侧有浮动元素（清除右侧浮动的影响）\nboth    同时清除左右两侧浮动的影响\n\n我们实际工作中，几乎只用 clear: both;\n\n清除浮动的策略是：闭合浮动。\n\n\n# 3.5 清除浮动方法\n\n 1. 额外标签法也称为隔墙法，是 W3C 推荐的做法。(实际开发不推荐)\n 2. 父级添加 overflow 属性\n 3. 父级添加 after 伪元素\n 4. 父级添加 双伪元素\n\n\n# 3.5.1 清除浮动 —— 额外标签法\n\n额外标签法也称为隔墙法，是 W3C 推荐的做法。\n\n额外标签法会在浮动元素末尾添加一个空的标签。例如 <div style="clear: both"></div>，或者其他标签（如 <br> 等）。\n\n * 优点： 通俗易懂，书写方便\n * 缺点： 添加许多无意义的标签，结构化较差\n\n注意： 要求这个新的空标签必须是块级元素。\n\n总结：\n\n * 清除浮动本质是？\n\n清除浮动的本质是清除浮动元素脱离标准流造成的影响。\n\n * 清除浮动策略是？\n\n闭合浮动。只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。\n\n * 额外标签法？\n\n隔墙法，就是在最后一个浮动的子元素后面添加一个额外空标签（块级标签），添加清除浮动样式。\n\n实际工作可能会遇到，但是不常用。\n\n\n\n\n# 3.5.2 清除浮动 —— 父级添加 overflow\n\n可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll。即开启BFC。 子不教，父之过，注意是给父元素添加代码。\n\n * 优点：代码简洁\n * 缺点：无法显示溢出的部分\n\n\n# 3.5.3 清除浮动 —— :after 伪元素法（重要）\n\n:after 方式是额外标签法的升级版，也是给父元素添加代码。\n\n原理：自动在父盒子里的末尾添加一个 行内盒子，我们将它转换为 块级盒子，就间接实现了额外标签法。\n\n.clearfix:after {\n\tcontent: "";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix { \n    /* IE6、7 专有清除浮动的样式 */\n\t*zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：类名不一定非要是 clearfix，但是还是推荐这么写以提高可读性。\n\n> 01、after表示在clearfix的双标签盒子的内容后面添加了一个伪元素盒子；\n> 02、content属性是伪元素必须要书写的属性，哪怕空着也有，空的就书写一个空的英文引号即可；\n> 03、伪元素默认的显示默认是为行内元素，所以要转化为块dispaly：block；\n> 04、visibility: hidden;占位隐藏；\n> 05、clear: both;清除浮动的影响；\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n * 优点：没有增加标签，结构更简单\n * 缺点：需要单独照顾低版本浏览器\n * 代表网站： 百度、淘宝网、网易等\n\n使用方法：谁的子级盒子浮动了，就用调用clearfix类名；\n\n\n\n\n# 3.5.4 清除浮动 —— 双伪元素清除浮动\n\n额外标签法的升级版，也是给给父元素添加代码。\n\n原理：自动在父盒子里的两端添加两个行内盒子，并把它们转换为 表格，间接实现了额外标签法。\n\n.clearfix:before,\n.clearfix:after {\n\tcontent: "";\n\tdisplay: table;\n}\n\n.clearfix:after {\n\tclear: both;\n}\n\n.clearfix {\n    /* IE6、7 专有 */\n\t*zoom:1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意：类名不一定非要是 clearfix，但是还是推荐这么写以提高可读性。\n\n * 优点：代码更简洁\n\n * 缺点：需要单独照顾低版本浏览器\n\n * 代表网站：小米、腾讯等\n\n\n\n\n# 3.6 清除浮动总结\n\n为什么需要清除浮动？\n\n * 父级没高度\n * 子盒子浮动了\n * 影响下面布局了，我们就应该清除浮动了\n\n清除浮动的方式                优点          缺点\n额外标签法（隔墙法）             通俗易懂，书写方便   添加许多无意义的标签，结构化较差\n父级 overflow: hidden;   书写简单        溢出隐藏\n父级 after 伪元素           结构语义化正确     由于 IE6~7 不支持 :after，兼容性问题\n父级双伪元素                 结构语义化正确     由于 IE6~7 不支持 :after，兼容性问题\n\n> after 伪元素、双伪元素 清除浮动的原理将在后面的 CSS3 中解释。\n\n\n# 六、css的BFC（面试必备）\n\n\n# 定义\n\n块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n通俗理解：BFC是一个独立的布局环境，BFC里面的子元素不会影响外界的元素，所以我们可以用BFC来解决外边距塌陷，外边距合并、清除浮动等问题；\n\n\n# 触发 BFC\n\n只要元素满足下面任一条件即可触发 BFC 特性：\n\n>  * html，body 根元素；\n>  * 浮动元素：float 除 none 以外的值；\n>  * 绝对定位元素：position (absolute、fixed)；\n>  * display 为 inline-block、table-cells、flex，flow-root，除了block其他基本都是可以触发BFC的；\n>  * overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n我们最常用的是：overflow:hidden; display:flow-root;\n\n\n# display:flow-root\n\n给元素设置display:flow-root，元素就会变成块级元素，同时这个元素会建立新的块级格式上下文（也就是触发了BFC模式）；\n\n\n# 五、css书写顺序（了解）\n\n建议遵循以下顺序：\n\n 1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）\n 2. 自身属性：width / height / margin / padding / border / background\n 3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n 4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …\n\n .jdc {\n    display: block;\n    position: relative;\n    float: left;\n    width: 100px;\n    height: 100px;\n    margin: 0 10px;\n    padding: 20px 0;\n    font-family: Arial, \'Helvetica Neue\', Helvetica, sans-serif;\n    color: #333;\n    background: rgba(0,0,0,.5);\n    border-radius: 10px;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 二、常见网页布局\n\n\n# 2.1 初识常见网页布局\n\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>常见网页布局</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        li {\n            list-style: none;\n        }\n\n        .top {\n            height: 50px;\n            background-color: gray;\n        }\n\n        .banner {\n            width: 980px;\n            height: 150px;\n            background-color: gray;\n            margin: 10px auto;\n        }\n\n        .box {\n            width: 980px;\n            margin: 0 auto;\n            height: 300px;\n            background-color: pink;\n        }\n\n        .box li {\n            float: left;\n            width: 237px;\n            height: 300px;\n            background-color: gray;\n            margin-right: 10px;\n        }\n\n        .box .last {\n            margin-right: 0;\n        }\n\n        /* 只要是通栏的盒子（和浏览器一样宽）不需要指定宽度 */\n        .footer {\n            height: 200px;\n            background-color: gray;\n            margin-top: 10px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="top">top</div>\n    <div class="banner">banner</div>\n    <div class="box">\n        <ul>\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n            <li class="last">4</li>\n        </ul>\n    </div>\n    <div class="footer">footer</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n\n\n# 2.2 浮动布局注意点\n\n（1）浮动和标准流的父盒子搭配\n\n先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。\n\n（2）一个元素浮动了，理论上其余的兄弟元素也要浮动\n\n一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。\n\n浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 如果一个子元素浮动了，尽量其他盒子也浮动，这样保证这些子元素一行显示 */\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            float: left;\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。 */\n        /* 大毛为标准流，所以大毛会占据其所在的一行，后面的二毛就算浮动也不会跑到大毛上方！*/\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            /* float: left; */\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            float: left;\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- 标准流 --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。 */\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            /* float: left; */\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- 标准流 --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n由于大毛是浮动的，所以原来大毛的位置会空出来，此时二毛就会向上补齐空位，由于二毛高度小于大毛，所以二毛被大毛挡住了，又因为二毛是标准流，所以二毛会占据所在的一行，所以后面浮动的三毛就只能在二毛的底部之下，又由于大毛也是浮动的，所以三毛就会紧贴在大毛右侧。\n\n',normalizedContent:'# 五、光标类型/鼠标样式cursor（了解）\n\n默认的小箭头\n\ncursor: default;\n\n\n1\n\n\n小手形状\n\ncursor:pointer;\n\n\n1\n\n\n移动图标\n\ncursor:move;\n\n\n1\n\n\n文本图标\n\ncursor:text;\n\n\n1\n\n\n禁止点击图标\n\ncursor:not-allowed;\t\t\n\n\n1\n\n\n\n# 一、html5的新特性\n\nhtml5 的新增特性主要是针对于以前的不足，增加了一些新的标签、新的表单和新的表单属性等。\n\n这些新特性都有兼容性问题，基本是 ie9+ 以上版本的浏览器才支持，如果不考虑兼容性问题（例如：移动端），便可以大量使用这些新特性。\n\n> 声明：新特性增加了很多，但是我们只需专注于开发常用的新特性即可\n\n\n# 1.1 html5新增的语义化标签\n\n以前布局，我们基本用 div 来做。div 对于搜索引擎来说，是没有语义的。\n\n<div class=“header”> </div>\n<div class=“nav”> </div>\n<div class=“content”> </div>\n<div class=“footer”> </div>\n\n\n1\n2\n3\n4\n\n\n\n\n * <header>：头部标签\n * <nav>：导航标签\n * <article>：内容标签\n * <section>：定义文档的某个区域\n * <aside>：侧边栏标签\n * <footer>：尾部标签\n\n注意：\n\n * 这种语义化标准主要是针对搜索引擎的\n * 这些新标签页面中可以使用多次\n * 在 ie9 中，需要把这些元素转换为块级元素\n * 其实，我们移动端更喜欢使用这些标签\n * html5 还增加了很多其他标签，我们后面再慢慢学\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增语义化标签</title>\n    <style>\n        header, nav {\n            height: 120px;\n            background-color: pink;\n            border-radius: 15px;\n            width: 800px;\n            margin: 15px auto;\n        }\n\n        section {\n            width: 500px;\n            height: 300px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n<body>\n<header>头部标签</header>\n<nav>导航栏标签</nav>\n<section>某个区域</section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n\n\n# 1.2 html5新增的多媒体标签\n\n新增的多媒体标签主要包含两个：\n\n 1. 音频：<audio>\n 2. 视频：<video>\n\n使用它们可以很方便的在页面中嵌入音频和视频，而不再去使用 flash 和其他浏览器插件。\n\n\n# 1.2.1 视频\n\nhtml5 在不使用插件的情况下，也可以原生的支持视频格式文件的播放。当然，支持的格式是有限的。\n\n当前 <video> 元素支持三种视频格式：尽量使用 mp4 格式。\n\n\n\n语法：\n\n<video src="文件地址" controls="controls"></video>\n\n\n1\n\n\n<video controls="controls" width="300"> \n    <source src="move.ogg" type="video/ogg"> \n    <source src="move.mp4" type="video/mp4"> \n    您的浏览器暂不支持 <video> 标签播放视频\n</ video >\n\n\n1\n2\n3\n4\n5\n\n\n常见属性：\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增视频标签</title>\n    <style>\n        video {\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n<video src="media/mi.mp4" autoplay="autoplay" muted="muted" loop="loop" poster="media/mi9.jpg"></video>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n以上视频会自动播放。\n\n\n# 1.2.2 音频\n\nhtml5 在不使用插件的情况下，也可以原生的支持音频格式文件的播放。当然，支持的格式是有限的。\n\n当前 <audio> 元素支持三种音频格式：尽量使用 mp3 格式。\n\n\n\n语法：\n\n<audio src="文件地址" controls="controls"></audio>\n\n\n1\n\n\n<audio controls="controls">\n\t<source src="happy.mp3" type="audio/mpeg">\n\t<source src="happy.ogg" type="audio/ogg">\n\t您的浏览器暂不支持 <audio> 标签。\n</audio>\n\n\n1\n2\n3\n4\n5\n\n\n常见属性：\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增音频标签</title>\n</head>\n<body>\n<audio src="media/music.mp3" autoplay="autoplay" controls="controls"></audio>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\n\n# 1.2.3 多媒体标签总结\n\n * 音频标签和视频标签使用方式基本一致\n * 浏览器支持情况不同\n * 谷歌浏览器把音频和视频自动播放禁止了\n * 我们可以给视频标签添加 muted 属性来静音播放视频，音频不可以（可以通过 javascript 解决）\n * 视频标签是重点，我们经常设置自动播放，不使用 controls 控件，循环和设置大小属性\n\n\n# 1.3 html5新增的input类型\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>document</title>\n</head>\n\n<body>\n\x3c!-- 我们验证的时候必须添加form表单域 --\x3e\n<form action="">\n    <ul>\n        <li>邮箱: <input type="email"/></li>\n        <li>网址: <input type="url"/></li>\n        <li>日期: <input type="date"/></li>\n        <li>时间: <input type="time"/></li>\n        <li>数量: <input type="number"/></li>\n        <li>手机号码: <input type="tel"/></li>\n        <li>搜索: <input type="search"/></li>\n        <li>颜色: <input type="color"/></li>\n        \x3c!-- 当我们点击提交按钮就可以验证表单了 --\x3e\n        <li><input type="submit" value="提交"></li>\n    </ul>\n</form>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n注意：html5 所提供的 input 类型可以依据具体的系统环境适配界面样式。\n\n当为数值框时，输入法自动打开数字键盘！\n\n\n# 1.4 html5新增的表单属性\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n<body>\n<form action="">\n    <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n           autocomplete="off">\n    <input type="file" name="" id="two" multiple="multiple">\n    <input type="submit" value="提交">\n</form>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n\n<body>\n    <form action="">\n        <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n            autocomplete="on">\n        <input type="submit" value="提交">\n    </form>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>html5新增表单属性</title>\n    <style>\n        input::placeholder {\n            color: hotpink;\n        }\n    </style>\n</head>\n\n<body>\n    <form action="">\n        <input type="search" name="sear" id="one" required="required" placeholder="pink老师" autofocus="autofocus"\n            autofocus="autofocus">\n        <input type="submit" value="提交">\n    </form>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n自动聚焦：\n\n\n\n\n# 二、css3的新特性\n\n\n# 2.1 css3的现状\n\n * 新增的 css3 特性有兼容性问题，ie9+ 才支持\n * 移动端支持优于 pc 端\n * 不断改进中\n * 应用相对广泛\n * 现阶段主要学习：新增选择器、盒子模型 以及 其他特性\n\n\n# 2.2 css3新增选择器\n\ncss3 给我们新增了选择器，可以更加便捷，更加自由的选择目标元素。\n\n 1. 属性选择器\n 2. 结构伪类选择器\n 3. 伪元素选择器\n\n\n# 2.2.1 属性选择器\n\n根据元素的属性及属性值来选择元素；\n\n语法：元素名称[相关属性] { css样式 }\n\n# 属性名称选择元素\n\n语法：标签选择器[属性] {}，通过某一个属性选择元素\n\n        /* 表示选中了input标签，而且标签有一个type属性 */\n        input[type] {\n            background-color: blueviolet;\n        }\n\n\n1\n2\n3\n4\n\n\n# 属性值选择元素\n\n语法：标签选择器[属性=属性值] {}，通过某一个属性和属性值选择元素；\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值为url */\n        input[type=url] {\n            background-color: green;\n        }\n\n\n1\n2\n3\n4\n\n\n注意：属性值的引号可以省略不写；\n\n# 属性值以某一个字符开头\n\n语法：标签选择器[属性^=属性值里面的字符]，\n\n通过某一个属性选择元素，但是属性值必须是以某一个字符开头的\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值必须是以t字符开头的 */\n        input[type^=t] {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n4\n\n\n注意： ^= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n# 属性值以某一个字符结尾\n\n语法：标签选择器[属性$=属性值里面的字符]，\n\n通过某一个属性选择元素，但是属性值必须是以某一个字符结尾的\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值必须是以h字符结尾的 */\n        input[type$=h] {\n            background-color: orangered;\n        }\n\n\n1\n2\n3\n4\n\n\n注意： $= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n# 属性值包含某一个字符\n\n语法：标签选择器[属性=属性值里面的字符]*，通过某一个属性选择元素，但是属性值不管在什么位置只要包含某一个字符即可选中；\n\n        /* 表示选中了input标签，而且标签有一个type属性,属性的取值不管什么位置只要包含r就会被选中 */\n        input[type*=r] {\n            background-color: rgb(255, 0, 106);\n        }\n\n\n1\n2\n3\n4\n\n\n注意： *= 后面的值不能是纯数字或者以数字开头，必须是字母\n\n\n# 2.2.2 结构伪类选择器\n\n# :nth-child 选择器（重点）\n\n通过nth-child选择元素是将这个父级盒子中的所有子元素依次排序，然后按照对应的顺序选择元素，不会将元素分类（比如男生女生混合的排序）\n\n查找方法：先查看位置，然后再去匹配是不是对应的标签，如果选择的位置，元素不匹配则不会渲染样式；\n\n * n 可以是数字，关键字和公式\n * n 如果是数字，就是选择第 n 个子元素，里面数字从 1 开始……\n * n 可以是关键字：even 偶数，odd 奇数\n * n 可以是公式：常见的公式如下（如果 n 是公式，则从 n = 0 开始计算，但是第 0 个元素和超出了元素的个数会被忽略）\n\n公式     取值\n2n     偶数（2、4、6、……）\n2n+1   奇数（1、3、5、……）\n5n     5 10 15...\nn+5    从第 5 个开始（包含第 5 个）到最后\n-n+5   前 5 个（包含第 5 个）\n\n结构伪类选择器主要根据文档结构来选择元素，常用于根据父级来选择其子元素。\n\n选择器                简介\ne:first-child      匹配父元素中的第一个子元素 e\ne:last-child       匹配父元素中最后一个 e 元素\ne:nth-child(n)     匹配父元素中的第 n 个子元素 e\ne:first-of-type    指定类型 e 的第一个\ne:last-of-type     指定类型 e 的最后一个\ne:nth-of-type(n)   指定类型 e 的第 n 个\n\n# 第一个元素:first-child {}\n\n选择结构中指定的第一个元素；\n\n        /* 表示选中了box盒子里面所有的li中的第一个 */\n        .box li:first-child {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n\n\n# 最后一个元素:last-child {}\n\n选择结构中指定的最后一个元素；\n\n        /* 表示选中了box盒子里面所有的li中的最后一个 */\n        .box li:last-child {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n\n\n# 倒数第几个:nth-last-child(n)\n\n选择结构中指定的倒数第n个元素；\n\n        /* 表示选中了box盒子里面所有的li中的倒数第3个元素 */\n        .box li:nth-last-child(3) {\n            background-color: pink;\n        }\n\n\n1\n2\n3\n4\n\n\n# 某一个元素nth-child(n)\n\n选择结构中指定的第n个元素；\n\n        /* 表示选中了box盒子里面所有的li中的指定的位置的元素 */\n        .box li:nth-child(3) {\n            background-color: powderblue;\n        }\n\n\n1\n2\n3\n4\n\n\n# 伪类选择器n的取值(重点)\n\n# 01、直接取值为n\n\n表示选中所有的该标签\n\n# 02、取值为关键字odd或者even\n\nodd 表示取值为奇数\n\n\t .box li:nth-child(odd) {\n            background-color: pink;\n      }\n\n\n1\n2\n3\n\n\neven 表示取值为偶数\n\n\t.box li:nth-child(even) {\n            background-color: palegreen;\n     }\n\n\n1\n2\n3\n\n\n# 03、取值为数学公式\n\n2n表示偶数； 2n+1 表示奇数； 3n表示取值为3的倍数； n+3表示从第3个开始一直选择到最后一个； -n+3表示表示前3个；\n\n\n# :nth-of-type选择器（了解）\n\n**选择元素的规则：**先将父级里面元素分类（比如班级里的学生分为男生和女生）并且各自排序，然后再去匹配位置；\n\n# 第一个元素:first-of-type\n\n选择父元素下某一类元素的第一个元素\n\n\t.box div:first-of-type {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n\n\n# 最后一个元素:last-of-type\n\n选择父元素下某一类元素的最后一个元素\n\n\t .box div:last-of-type {\n            background-color: gold;\n        }\n\n\n1\n2\n3\n\n\n# 某一个元素:nth-of-type(n)\n\n选择器父元素下某一类标签中的第n个元素\n\n        .box p:nth-of-type(2) {\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n\n\n注意：:nth-of-type(n) 中 n的取值个nth-child是一样的； 区别：\n\n 1. nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第 n 个孩子，然后看看是否和 e 匹配\n 2. nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配 e，然后再根据 e 找第 n 个孩子\n\n小结：\n\n * 结构伪类选择器一般用于选择父级里面的第几个孩子\n * nth-child 对父元素里面所有孩子排序选择（序号是固定的） 先找到第 n 个孩子，然后看看是否和 e 匹配\n * nth-of-type 对父元素里面指定子元素进行排序选择。 先去匹配 e，然后再根据 e 找第 n 个孩子\n * 若父元素内都是同一种标签（如：列表），优先用 nth-child，否则就只能使用 nth-of-type\n * 类选择器、属性选择器、伪类选择器，权重为 10\n\n\n# 2.2.3 伪元素选择器（重点）\n\n伪元素选择器可以帮助我们利用 css 创建新标签元素，而不需要 html 标签，从而简化 html 结构。\n\n选择器        简介\n::before   在元素内容的前面插入内容\n::after    在元素内容的后面插入内容\n\n# ::before\n\n在元素内容前面插入一个伪盒子\n\n    .box::before {\n        content: \'\';\n    }\n\n\n1\n2\n3\n\n\n# ::after\n\n在元素内容后面插入一个伪盒子\n\n    .box::after {\n        content: \'\';\n    }\n\n\n1\n2\n3\n\n\n注意：\n\n * 伪元素的显示模式默认是行内元素的特点，before 和 after 创建一个元素，属于行内元素,直接设置宽高是无效的，我们需要转化\n * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n * 语法：element::before{}\n * 伪元素设置的时候必须添加content属性，否则不生效，哪怕是空的也要设置空的引号\n * before 在父元素内容的前面创建元素，after 在父元素内容的后面创建元素\n * 伪元素选择器和标签选择器一样，权重为 1\n\n（1）伪元素选择器使用场景1：伪元素字体图标\n\np::before {\n\tposition: absolute;\n\tright: 20px;\n\ttop: 10px;\n\tcontent: \'\\e91e\';\n\tfont-size: 20px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（2）伪元素选择器使用场景2：仿土豆效果\n\n/* 当我们鼠标经过了 土豆这个盒子，就让里面 before 遮罩层显示出来 */\n.tudou:hover::before {\n\t/* 而是显示元素 */\n    display: block;\n}\n\n\n1\n2\n3\n4\n5\n\n\n（3）伪元素选择器使用场景3：伪元素清除浮动\n\n 1. 额外标签法也称为隔墙法，是 w3c 推荐的做法\n 2. 父级添加 overflow 属性\n 3. 父级添加 after 伪元素\n 4. 父级添加双伪元素\n\n额外标签法也称为隔墙法，是 w3c 推荐的做法。\n\n\n\n注意：要求这个新的空标签必须是块级元素。\n\n后面两种伪元素清除浮动算是第一种额外标签法的一个升级和优化。\n\n.clearfix:after {\n\tcontent: "";\t\t\t/* 伪元素必须写的属性 */\n\tdisplay: block;\t\t\t/* 插入的元素必须是块级 */\n\theight: 0;\t\t\t\t/* 不要看见这个元素 */\n\tclear: both;\t\t\t/* 核心代码清除浮动 */\n\tvisibility: hidden;\t\t/* 不要看见这个元素 */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n.clearfix:before,\n.clearfix:after {\n\tcontent: "";\n\tdisplay: table;\t\t\t/* 转换为块级元素并且一行显示 */\n}\n\n.clearfix:after {\n\tclear: both;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n案例：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>伪元素选择器before和after</title>\n    <style>\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: salmon;\n        }\n\n        /* div::before 权重是 2 */\n        div::before {\n            /* 这个 content 是必须要写的 */\n            /* display: inline-block; */\n            content: \'我\';\n            /* width: 30px;\n            height: 40px;\n            background-color: purple; */\n        }\n\n        div::after {\n            content: \'小猪佩奇\';\n        }\n    </style>\n</head>\n<body>\n<div>\n    是\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>伪元素选择器使用场景-字体图标</title>\n    <style>\n        @font-face {\n            font-family: \'icomoon\';\n            src: url(\'fonts/icomoon.eot?1lv3na\');\n            src: url(\'fonts/icomoon.eot?1lv3na#iefix\') format(\'embedded-opentype\'),\n            url(\'fonts/icomoon.ttf?1lv3na\') format(\'truetype\'),\n            url(\'fonts/icomoon.woff?1lv3na\') format(\'woff\'),\n            url(\'fonts/icomoon.svg?1lv3na#icomoon\') format(\'svg\');\n            font-weight: normal;\n            font-style: normal;\n            font-display: block;\n        }\n\n        div {\n            position: relative;\n            width: 200px;\n            height: 35px;\n            border: 1px solid red;\n        }\n\n        div::after {\n            position: absolute;\n            top: 10px;\n            right: 10px;\n            font-family: \'icomoon\';\n            /* content: \'\'; */\n            content: \'\\e91e\';\n            color: red;\n            font-size: 18px;\n        }\n    </style>\n</head>\n\n<body>\n<div></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>伪元素选择器使用场景2-仿土豆网显示隐藏遮罩案例</title>\n    <style>\n        .tudou {\n            position: relative;\n            width: 444px;\n            height: 320px;\n            background-color: pink;\n            margin: 30px auto;\n        }\n\n        .tudou img {\n            width: 100%;\n            height: 100%;\n        }\n\n        .tudou::before {\n            content: \'\';\n            /* 隐藏遮罩层 */\n            display: none;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, .4) url(images/arr.png) no-repeat center;\n        }\n\n        /* 当我们鼠标经过了土豆这个盒子，就让里面 before 遮罩层显示出来 */\n        .tudou:hover::before {\n            /* 而是显示元素 */\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n<div class="tudou">\n    <img src="images/tudou.jpg" alt="">\n</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n\n# 2.3 css3盒子模型\n\ncss3 中可以通过 box-sizing 来指定盒模型，有 2 个值：即可指定为 content-box、border-box，这样我们计算盒子大小的方式就发生了改变。\n\n可以分成两种情况：\n\n 1. box-sizing: content-box 盒子大小为 width + padding + border （以前默认的）\n 2. box-sizing: border-box 盒子大小为 width\n\n如果盒子模型我们改为了 box-sizing: border-box， 那 padding 和 border 就不会撑大盒子了（前提 padding 和 border 不会超过 width 宽度）\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css3盒子模型</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        div {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            border: 20px solid red;\n            padding: 15px;\n            box-sizing: content-box;\n        }\n\n        p {\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n            border: 20px solid red;\n            padding: 15px;\n            /* css3 盒子模型 盒子最终的大小就是 width 200 的大小 */\n            box-sizing: border-box;\n        }\n    </style>\n</head>\n<body>\n<div>\n    小猪乔治\n</div>\n<p>\n    小猪佩奇\n</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n\n\n\n\n# 2.4 css3其他特性（了解）\n\n 1. 图片变模糊\n 2. 计算盒子宽度 width:calc 函数\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>图片模糊处理filter</title>\n    <style>\n        img {\n            /* blur 是一个函数 小括号里面数值越大，图片越模糊 注意数值要加 px 单位 */\n            filter: blur(15px);\n        }\n\n        img:hover {\n            filter: blur(0);\n        }\n    </style>\n</head>\n<body>\n<img src="images/pink.jpg" alt="">\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css3属性calc函数</title>\n    <style>\n        .father {\n            width: 500px;\n            height: 500px;\n            background-color: black;\n        }\n\n        .son {\n            /* width: 300px; */\n            /* width: calc(500px - 100px); */\n            width: calc(100% - 100px);\n            height: 200px;\n            background-color: salmon;\n        }\n    </style>\n</head>\n<body>\n\x3c!-- 需求：我们的子盒子宽度永远比父盒子小 100 像素 --\x3e\n<div class="father">\n    <div class="son"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 2.4.1 css3滤镜 filter\n\nfilter css 属性将模糊或颜色偏移等图形效果应用于元素。\n\nfilter: 函数(); 例如：filter: blur(5px); blur 模糊处理，数值越大越模糊\n\n\n1\n\n\n\n\n\n# 2.4.2 css3 calc 函数\n\ncalc() 此 css 函数让你在声明 css 属性值时执行一些计算。\n\nwidth: calc(100% - 80px);\n\n\n1\n\n\n括号里面可以使用 + - * / 来进行计算。\n\n\n# 2.5 css3过渡（重点）\n\n\n# 2.5.1 过渡\n\n过渡（transition）是 css3 中具有颠覆性的特征之一，我们可以在不使用 flash 动画或 javascript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。\n\n过渡动画：是从一个状态渐渐的过渡到另外一个状态。\n\n可以让我们页面更好看，更动感十足，虽然低版本浏览器不支持（ie9 以下版本） 但是不会影响页面布局。\n\n我们现在经常和 :hover 一起搭配使用。\n\n语法：\n\ntransition: 要过渡的属性 花费时间 运动曲线 何时开始;\n\n\n1\n\n 1. 属性：想要变化的 css 属性，宽度高度、背景颜色、内外边距都可以 。如果想要所有的属性都变化过渡，写一个 all 就可以\n 2. 花费时间：单位是秒（必须写单位）比如 0.5s\n 3. 运动曲线：默认是 ease（可以省略）\n 4. 何时开始：单位是秒（必须写单位）可以设置延迟触发时间默认是 0s（可以省略）\n\n记住过渡的使用口诀：谁做过渡给谁加！\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css3过渡效果</title>\n    <style>\n        div {\n            width: 200px;\n            height: 100px;\n            background-color: black;\n            /* transition: 变化的属性 花费时间 运动曲线 何时开始; */\n            /* transition: width .5s ease 0s, height .5s ease 1s; */\n            /* 如果想要写多个属性，利用逗号进行分割 */\n            /* transition: width .5s, height .5s; */\n            /* 如果想要多个属性都变化，属性写 all 就可以了 */\n            /* transition: height .5s ease 1s; */\n            /* 谁做过渡，给谁加 */\n            transition: all 0.5s;\n        }\n\n        div:hover {\n            width: 400px;\n            height: 200px;\n            background-color: gray;\n        }\n    </style>\n</head>\n<body>\n<div></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n\n# 2.5.2 进度条案例\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css3过渡练习-进度条</title>\n    <style>\n        .bar {\n            width: 150px;\n            height: 15px;\n            border: 1px solid red;\n            border-radius: 7px;\n            padding: 1px;\n        }\n\n        .bar_in {\n            width: 50%;\n            height: 100%;\n            border-radius: 7px;\n            background-color: red;\n            /* 谁做过渡给谁加 */\n            transition: all .7s;\n        }\n\n        .bar:hover .bar_in {\n            width: 100%;\n        }\n    </style>\n</head>\n<body>\n<div class="bar">\n    <div class="bar_in"></div>\n</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# 2.6 css3 变量\n\nvar() 函数用于插入 css 变量的值。\n\n使用 css 变量的一种好方法涉及设计的颜色。您可以将它们放在变量中，而不必一遍又一遍地复制和粘贴相同的颜色。\n\n【传统方式】\n\n以下例子显示了在样式表中定义一些颜色的传统方式（通过为每个特定元素定义要使用的颜色）：\n\n<!doctype html>\n<html>\n<head>\n<style>\nbody {\n  background-color: #1e90ff;\n}\n\nh2 {\n  border-bottom: 2px solid #1e90ff;\n}\n\n.container {\n  color: #1e90ff;\n  background-color: #ffffff;\n  padding: 15px;\n}\n\nbutton {\n  background-color: #ffffff;\n  color: #1e90ff;\n  border: 1px solid #1e90ff;\n  padding: 5px;\n}\n</style>\n</head>\n<body>\n\n<h1>传统方式</h1>\n\n<div class="container">\n  <h2>welcome to shanghai!</h2>\n  <p>shanghai is one of the four direct-administered municipalities of the people\'s republic of china.</p>\n  <p>shanghai is one of the four direct-administered municipalities of the people\'s republic of china.</p>\n  <p>\n    <button>yes</button>\n    <button>no</button>\n  </p>\n</div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n【var() 函数的语法】\n\nvar() 函数用于插入 css 变量的值。\n\nvar() 函数的语法如下：\n\nvar(name, value)\n\n\n1\n\n\n值       描述\nname    必需。变量名（以两条破折号 -- 开头）。\nvalue   可选。回退值（在未找到变量时使用）。\n\n**注释：**变量名称必须以两个破折号 -- 开头，且区分大小写！\n\n【var() 如何工作】\n\n首先：css 变量可以有全局或局部作用域。\n\n全局变量可以在整个文档中进行访问/使用，而局部变量只能在声明它的选择器内部使用。\n\n如需创建具有全局作用域的变量，请在 :root 选择器中声明它，:root 选择器匹配文档的根元素。\n\n如需创建具有局部作用域的变量，请在将要使用它的选择器中声明它。\n\n下面的例子与上面的例子相同，但是在这里我们使用 var() 函数。\n\n首先，我们声明两个全局变量（--blue 和 --white）。然后，我们使用 var() 函数稍后在样式表中插入变量的值：\n\n<!doctype html>\n<html>\n<head>\n<style>\n:root {\n  --blue: #1e90ff;\n  --white: #ffffff; \n}\n\nbody {\n  background-color: var(--blue);\n}\n\nh2 {\n  border-bottom: 2px solid var(--blue);\n}\n\n.container {\n  color: var(--blue);\n  background-color: var(--white);\n  padding: 15px;\n}\n\nbutton {\n  background-color: var(--white);\n  color: var(--blue);\n  border: 1px solid var(--blue);\n  padding: 5px;\n}\n</style>\n</head>\n<body>\n\n<h1>使用 var() 函数</h1>\n\n<div class="container">\n  <h2>welcome to shanghai!</h2>\n  <p>shanghai is one of the four direct-administered municipalities of the people\'s republic of china.</p>\n  <p>shanghai is one of the four direct-administered municipalities of the people\'s republic of china.</p>\n  <p>\n    <button>yes</button>\n    <button>no</button>\n  </p>\n</div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n使用 var() 有如下优势：\n\n * 使代码更易于阅读（更容易理解）\n * 使修改颜色值更加容易\n\n如需将蓝色和白色改为较柔和的蓝色和白色，您只需要修改两个变量值：\n\n:root {\n  --blue: #6495ed;\n  --white: #faf0e6;\n}\n\nbody { background-color: var(--blue); }\n\nh2 { border-bottom: 2px solid var(--blue); }\n\n.container {\n  color: var(--blue);\n  background-color: var(--white);\n  padding: 15px;\n}\n\nbutton {\n  background-color: var(--white);\n  color: var(--blue);\n  border: 1px solid var(--blue);\n  padding: 5px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 三、狭义的 html5 css3\n\n 1. html5 结构本身\n    \n    \n\n 2. css3 相关样式\n    \n    \n\n\n# 四、广义的 html5\n\n 1. 广义的 html5 是 html5 + css3 + javascript\n 2. 这个集合有时称为 h5\n 3. 虽然 html5 的一些特性仍然不被某些浏览器支持，但是它是一种发展趋势\n\n\n# 一、浮动（float）\n\n\n# 1.1 传统网页布局的三种方式\n\n网页布局的本质：用 css 来摆放盒子，把盒子摆放到相应位置。\n\ncss 提供了三种传统布局方式（简单说就是盒子如何进行排列）。\n\n * 普通流（标准流）\n * 浮动\n * 定位\n\n> 这里指的只是传统布局，其实还有一些特殊高级的布局方式。\n\n\n# 1.2 标准流（普通流/文档流）\n\n所谓的标准流：就是标签按照规定好的默认方式排列。\n\n 1. 块级元素会独占一行，从上向下顺序排列。\n 2. 行内元素会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行。\n\n以上都是标准流布局，我们前面学习的就是标准流，标准流是最基本的布局方式。\n\n这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。\n\n**注意：**实际开发中，一个页面基本都包含了这三种布局方式（后面移动端学习新的布局方式） 。\n\n\n# 1.3 为什么需要浮动？\n\n提问：我们用标准流能很方便的实现如下效果吗？\n\n 1. 如何让多个块级盒子（div）水平排列成一行？\n\n\n\n比较难，虽然转换为行内块元素可以实现一行显示，但是他们之间会有大的空白缝隙，很难控制。\n\n\n\n 2. 如何实现两个盒子的左右对齐？\n\n\n\n总结： 有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式。\n\n浮动最典型的应用：可以让多个块级元素一行内排列显示。\n\n网页布局第一准则：多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动！\n\n**拓展：**浮动的盒子不会发生外边距合并！\n\n\n# 1.4 什么是浮动？\n\nfloat 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。\n\n语法：\n\n选择器 { float: 属性值;}\n\n\n1\n\n\n属性      描述\nnone    元素不浮动（默认值）\nleft    元素向左浮动\nright   元素向右浮动\n\n左浮动 fll\n\n float: left;\n\n\n1\n\n\n右浮动 flr\n\nfloat: right;\n\n\n1\n\n\n不浮动\n\n float: none;\n\n\n1\n\n\n\n# 1.5 浮动特性（重难点）\n\n加了浮动之后的元素，会具有很多特性，需要我们掌握。\n\n 1. 浮动元素会脱离标准流（脱标）\n 2. 浮动的元素会一行内显示并且元素顶部对齐\n 3. 浮动的元素会具有行内块元素的特性\n\n下面分别解释：\n\n（1）浮动元素会脱离标准流（脱标）\n\n * 脱离标准普通流的控制（浮） 移动到指定位置（动），（俗称脱标）\n * 浮动的盒子不再保留原先的位置\n\n\n\n<head>\n\n    <style>\n        /* 设置了浮动（float）的元素会：\n        1.脱离标准普通流的控制（浮）移动到指定位置（动）。\n        2.浮动的盒子不再保留原先的位置 */\n        .box1 {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        }\n\n        .box2 {\n            width: 300px;\n            height: 300px;\n            background-color: gray;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box1">浮动的盒子</div>\n    <div class="box2">标准流的盒子</div>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n（2）浮动的元素会一行内显示并且元素顶部对齐\n\n * 如果多个盒子都设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列。\n * 浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐。\n\n（3）浮动的元素会具有行内块元素的特性\n\n任何元素都可以浮动。不管原先是什么模式的元素，添加浮动之后具有行内块元素相似的特性。\n\n * 块级盒子：没有设置宽度时默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\n * 行内盒子：宽度默认和内容一样宽，直接设置高宽无效，但是添加浮动后，它的大小可以直接设置\n * 浮动的盒子中间是没有缝隙的，是紧挨着一起的\n * 即：默认宽度由内容决定，同时支持指定高宽内外边距，盒子之间无空隙\n\n\n# 1.6 使用浮动布局需要注意事项（死了都要记）\n\n01、浮动布局的时候一定要配合一个标准流的父级盒子来限制浮动元素的位置； 02、如果父元素中的子元素布局的时候，一个浮动了其他的子元素也要浮动，否则会出现问题；\n\n03、如果父元素里面的子元素浮动以后，所有的宽度包括margin值加起来大于父盒子的宽度，子盒子会折行另起一行显示；\n\n解决方案1：使用css3的结构伪类选择器，选中每一行的最后一个设置某一个数的倍数，设置外边距为0即可；\n\n.list-box .pr li:nth-child(4n) {\n  margin-right: 0;\n}\n\n\n1\n2\n3\n\n\n以上的代码表示选中了4的倍数的盒子设置margin-right为0；\n\n**解决方案2：**列表的父级盒子默认和最外层的大盒子一样大，我们可以设置列表的父级盒子比外层的大盒子宽103%，这样就可以兼容任何浏览器；\n\n.list-box ul {\n  /* width: 992px; */\n  width: 103%;\n  /* height: 600px; */\n  /* background-color: rgba(0, 0, 0, 0.6); */\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.7 浮动元素经常和标准流父级搭配使用\n\n为了约束浮动元素位置，我们网页布局一般采取的策略是：\n\n先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。符合网页布局第一准侧。\n\n\n\n\n# 三、清除浮动\n\n\n# 3.1 思考题\n\n我们前面浮动元素有一个标准流的父元素，他们有一个共同的特点，都是有高度的。\n\n但是，所有的父盒子都必须有高度吗？\n\n答案：不一定！比如，一个产品列表，随着时期的不同，产品数量也不同，所需的盒子大小也会随之改变，那么直接固定盒子高度的形式显然就是不行的。再比如，文章之类的盒子，不同的文章字数是不相同的，那么显然盒子也不能直接固定高度。\n\n理想中的状态，让子盒子撑开父亲。有多少孩子，我父盒子就有多高。\n\n但是不给父盒子高度会有问题吗？\n\n答案：会！但有方法解决（清除浮动）。\n\n\n# 3.2 为什么需要清除浮动？\n\n由于父级盒子很多情况下不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。\n\n\n\n * 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响\n\n * 此时一但父盒子下面有其他盒子，那么布局就会发生严重混乱！\n\n\n# 3.3 清除浮动本质\n\n * 清除浮动的本质是清除浮动元素造成的影响\n * 如果父盒子本身有高度，则不需要清除浮动\n * 清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了\n\n\n# 3.4 清除浮动属性clear\n\n语法：\n\n选择器 { clear: 属性值; }\n\n\n1\n\n\n属性值     描述\nleft    不允许左侧有浮动元素（清除左侧浮动的影响）\nright   不允许右侧有浮动元素（清除右侧浮动的影响）\nboth    同时清除左右两侧浮动的影响\n\n我们实际工作中，几乎只用 clear: both;\n\n清除浮动的策略是：闭合浮动。\n\n\n# 3.5 清除浮动方法\n\n 1. 额外标签法也称为隔墙法，是 w3c 推荐的做法。(实际开发不推荐)\n 2. 父级添加 overflow 属性\n 3. 父级添加 after 伪元素\n 4. 父级添加 双伪元素\n\n\n# 3.5.1 清除浮动 —— 额外标签法\n\n额外标签法也称为隔墙法，是 w3c 推荐的做法。\n\n额外标签法会在浮动元素末尾添加一个空的标签。例如 <div style="clear: both"></div>，或者其他标签（如 <br> 等）。\n\n * 优点： 通俗易懂，书写方便\n * 缺点： 添加许多无意义的标签，结构化较差\n\n注意： 要求这个新的空标签必须是块级元素。\n\n总结：\n\n * 清除浮动本质是？\n\n清除浮动的本质是清除浮动元素脱离标准流造成的影响。\n\n * 清除浮动策略是？\n\n闭合浮动。只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子。\n\n * 额外标签法？\n\n隔墙法，就是在最后一个浮动的子元素后面添加一个额外空标签（块级标签），添加清除浮动样式。\n\n实际工作可能会遇到，但是不常用。\n\n\n\n\n# 3.5.2 清除浮动 —— 父级添加 overflow\n\n可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll。即开启bfc。 子不教，父之过，注意是给父元素添加代码。\n\n * 优点：代码简洁\n * 缺点：无法显示溢出的部分\n\n\n# 3.5.3 清除浮动 —— :after 伪元素法（重要）\n\n:after 方式是额外标签法的升级版，也是给父元素添加代码。\n\n原理：自动在父盒子里的末尾添加一个 行内盒子，我们将它转换为 块级盒子，就间接实现了额外标签法。\n\n.clearfix:after {\n\tcontent: "";\n\tdisplay: block;\n\theight: 0;\n\tclear: both;\n\tvisibility: hidden;\n}\n\n.clearfix { \n    /* ie6、7 专有清除浮动的样式 */\n\t*zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n注意：类名不一定非要是 clearfix，但是还是推荐这么写以提高可读性。\n\n> 01、after表示在clearfix的双标签盒子的内容后面添加了一个伪元素盒子；\n> 02、content属性是伪元素必须要书写的属性，哪怕空着也有，空的就书写一个空的英文引号即可；\n> 03、伪元素默认的显示默认是为行内元素，所以要转化为块dispaly：block；\n> 04、visibility: hidden;占位隐藏；\n> 05、clear: both;清除浮动的影响；\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n * 优点：没有增加标签，结构更简单\n * 缺点：需要单独照顾低版本浏览器\n * 代表网站： 百度、淘宝网、网易等\n\n使用方法：谁的子级盒子浮动了，就用调用clearfix类名；\n\n\n\n\n# 3.5.4 清除浮动 —— 双伪元素清除浮动\n\n额外标签法的升级版，也是给给父元素添加代码。\n\n原理：自动在父盒子里的两端添加两个行内盒子，并把它们转换为 表格，间接实现了额外标签法。\n\n.clearfix:before,\n.clearfix:after {\n\tcontent: "";\n\tdisplay: table;\n}\n\n.clearfix:after {\n\tclear: both;\n}\n\n.clearfix {\n    /* ie6、7 专有 */\n\t*zoom:1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n注意：类名不一定非要是 clearfix，但是还是推荐这么写以提高可读性。\n\n * 优点：代码更简洁\n\n * 缺点：需要单独照顾低版本浏览器\n\n * 代表网站：小米、腾讯等\n\n\n\n\n# 3.6 清除浮动总结\n\n为什么需要清除浮动？\n\n * 父级没高度\n * 子盒子浮动了\n * 影响下面布局了，我们就应该清除浮动了\n\n清除浮动的方式                优点          缺点\n额外标签法（隔墙法）             通俗易懂，书写方便   添加许多无意义的标签，结构化较差\n父级 overflow: hidden;   书写简单        溢出隐藏\n父级 after 伪元素           结构语义化正确     由于 ie6~7 不支持 :after，兼容性问题\n父级双伪元素                 结构语义化正确     由于 ie6~7 不支持 :after，兼容性问题\n\n> after 伪元素、双伪元素 清除浮动的原理将在后面的 css3 中解释。\n\n\n# 六、css的bfc（面试必备）\n\n\n# 定义\n\n块格式化上下文（block formatting context，bfc） 是web页面的可视css渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。\n\n通俗理解：bfc是一个独立的布局环境，bfc里面的子元素不会影响外界的元素，所以我们可以用bfc来解决外边距塌陷，外边距合并、清除浮动等问题；\n\n\n# 触发 bfc\n\n只要元素满足下面任一条件即可触发 bfc 特性：\n\n>  * html，body 根元素；\n>  * 浮动元素：float 除 none 以外的值；\n>  * 绝对定位元素：position (absolute、fixed)；\n>  * display 为 inline-block、table-cells、flex，flow-root，除了block其他基本都是可以触发bfc的；\n>  * overflow 除了 visible 以外的值 (hidden、auto、scroll)\n\n我们最常用的是：overflow:hidden; display:flow-root;\n\n\n# display:flow-root\n\n给元素设置display:flow-root，元素就会变成块级元素，同时这个元素会建立新的块级格式上下文（也就是触发了bfc模式）；\n\n\n# 五、css书写顺序（了解）\n\n建议遵循以下顺序：\n\n 1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）\n 2. 自身属性：width / height / margin / padding / border / background\n 3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n 4. 其他属性（css3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …\n\n .jdc {\n    display: block;\n    position: relative;\n    float: left;\n    width: 100px;\n    height: 100px;\n    margin: 0 10px;\n    padding: 20px 0;\n    font-family: arial, \'helvetica neue\', helvetica, sans-serif;\n    color: #333;\n    background: rgba(0,0,0,.5);\n    border-radius: 10px;\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 二、常见网页布局\n\n\n# 2.1 初识常见网页布局\n\n\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>常见网页布局</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        li {\n            list-style: none;\n        }\n\n        .top {\n            height: 50px;\n            background-color: gray;\n        }\n\n        .banner {\n            width: 980px;\n            height: 150px;\n            background-color: gray;\n            margin: 10px auto;\n        }\n\n        .box {\n            width: 980px;\n            margin: 0 auto;\n            height: 300px;\n            background-color: pink;\n        }\n\n        .box li {\n            float: left;\n            width: 237px;\n            height: 300px;\n            background-color: gray;\n            margin-right: 10px;\n        }\n\n        .box .last {\n            margin-right: 0;\n        }\n\n        /* 只要是通栏的盒子（和浏览器一样宽）不需要指定宽度 */\n        .footer {\n            height: 200px;\n            background-color: gray;\n            margin-top: 10px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="top">top</div>\n    <div class="banner">banner</div>\n    <div class="box">\n        <ul>\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n            <li class="last">4</li>\n        </ul>\n    </div>\n    <div class="footer">footer</div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n\n\n# 2.2 浮动布局注意点\n\n（1）浮动和标准流的父盒子搭配\n\n先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置。\n\n（2）一个元素浮动了，理论上其余的兄弟元素也要浮动\n\n一个盒子里面有多个子盒子，如果其中一个盒子浮动了，那么其他兄弟也应该浮动，以防止引起问题。\n\n浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 如果一个子元素浮动了，尽量其他盒子也浮动，这样保证这些子元素一行显示 */\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            float: left;\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。 */\n        /* 大毛为标准流，所以大毛会占据其所在的一行，后面的二毛就算浮动也不会跑到大毛上方！*/\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            /* float: left; */\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            float: left;\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- 标准流 --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>浮动注意点</title>\n    <style>\n        /* 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流。 */\n        .box {\n            width: 900px;\n            height: 300px;\n            background-color: black;\n            margin: 0 auto;\n        }\n\n        .damao {\n            float: left;\n            width: 200px;\n            height: 200px;\n            background-color: palevioletred;\n        }\n\n        .ermao {\n            /* float: left; */\n            width: 200px;\n            height: 150px;\n            background-color: palegreen;\n        }\n\n        .sanmao {\n            float: left;\n            width: 300px;\n            height: 240px;\n            background-color: skyblue;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box">\n        <div class="damao">大毛</div>\t\t\x3c!-- float: left; --\x3e\n        <div class="ermao">二毛</div>\t\t\x3c!-- 标准流 --\x3e\n        <div class="sanmao">三毛</div>\t\x3c!-- float: left; --\x3e\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n\n由于大毛是浮动的，所以原来大毛的位置会空出来，此时二毛就会向上补齐空位，由于二毛高度小于大毛，所以二毛被大毛挡住了，又因为二毛是标准流，所以二毛会占据所在的一行，所以后面浮动的三毛就只能在二毛的底部之下，又由于大毛也是浮动的，所以三毛就会紧贴在大毛右侧。\n\n',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局",frontmatter:{title:"CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局",date:"2020-04-09T15:09:00.000Z",permalink:"/pages/915fc4/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/06.CSS%E9%9A%90%E8%97%8F%E3%80%81%E5%AF%B9%E9%BD%90%E5%B1%9E%E6%80%A7%E3%80%81%E7%B2%BE%E7%81%B5%E5%9B%BE%E3%80%81%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87%E3%80%81%E6%96%87%E5%AD%97%E6%BA%A2%E5%87%BA%E3%80%81%E5%B8%83%E5%B1%80.html",relativePath:"01.前端基础/02.CSS/06.CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局.md",key:"v-9b071a1c",path:"/pages/915fc4/",headers:[{level:2,title:"三、css显示隐藏",slug:"三、css显示隐藏",normalizedTitle:"三、css显示隐藏",charIndex:2},{level:3,title:"占位隐藏（了解）",slug:"占位隐藏-了解",normalizedTitle:"占位隐藏（了解）",charIndex:16},{level:3,title:"不占位隐藏（死了都要记）",slug:"不占位隐藏-死了都要记",normalizedTitle:"不占位隐藏（死了都要记）",charIndex:164},{level:2,title:"五、vertical-align属性（了解）",slug:"五、vertical-align属性-了解",normalizedTitle:"五、vertical-align属性（了解）",charIndex:289},{level:3,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:316},{level:2,title:"1.1 为什么需要精灵图？",slug:"_1-1-为什么需要精灵图",normalizedTitle:"1.1 为什么需要精灵图？",charIndex:940},{level:2,title:"1.2 精灵图（sprites）的使用",slug:"_1-2-精灵图-sprites-的使用",normalizedTitle:"1.2 精灵图（sprites）的使用",charIndex:1197},{level:2,title:"1.3 案例：拼单词",slug:"_1-3-案例-拼单词",normalizedTitle:"1.3 案例：拼单词",charIndex:2439},{level:2,title:"2.1 字体图标的产生",slug:"_2-1-字体图标的产生",normalizedTitle:"2.1 字体图标的产生",charIndex:3827},{level:2,title:"2.2 字体图标的优点",slug:"_2-2-字体图标的优点",normalizedTitle:"2.2 字体图标的优点",charIndex:4036},{level:2,title:"2.3 字体图标的下载",slug:"_2-3-字体图标的下载",normalizedTitle:"2.3 字体图标的下载",charIndex:4382},{level:2,title:"2.4 字体图标的引入",slug:"_2-4-字体图标的引入",normalizedTitle:"2.4 字体图标的引入",charIndex:4681},{level:2,title:"2.5 字体图标的追加",slug:"_2-5-字体图标的追加",normalizedTitle:"2.5 字体图标的追加",charIndex:5838},{level:2,title:"2.6 字体图标加载的原理",slug:"_2-6-字体图标加载的原理",normalizedTitle:"2.6 字体图标加载的原理",charIndex:5979},{level:2,title:"6.1 单行文本溢出省略号显示",slug:"_6-1-单行文本溢出省略号显示",normalizedTitle:"6.1 单行文本溢出省略号显示",charIndex:7054},{level:2,title:"6.2 多行文本溢出省略号显示",slug:"_6-2-多行文本溢出省略号显示",normalizedTitle:"6.2 多行文本溢出省略号显示",charIndex:8118},{level:2,title:"一、定位布局position",slug:"一、定位布局position",normalizedTitle:"一、定位布局position",charIndex:9336},{level:3,title:"概念作用",slug:"概念作用",normalizedTitle:"概念作用",charIndex:9355},{level:3,title:"边偏移量",slug:"边偏移量",normalizedTitle:"边偏移量",charIndex:9422},{level:3,title:"定位模式分类",slug:"定位模式分类",normalizedTitle:"定位模式分类",charIndex:9537},{level:4,title:"静态定位：position:static; （了解）",slug:"静态定位-position-static-了解",normalizedTitle:"静态定位：position:static; （了解）",charIndex:9547},{level:4,title:"相对定位：position:relative;",slug:"相对定位-position-relative",normalizedTitle:"相对定位：position:relative;",charIndex:9620},{level:4,title:"绝对定位：position:absolute;",slug:"绝对定位-position-absolute",normalizedTitle:"绝对定位：position:absolute;",charIndex:9784},{level:4,title:"固定定位：position: fixed;",slug:"固定定位-position-fixed",normalizedTitle:"固定定位：position: fixed;",charIndex:10112},{level:4,title:"粘性定位：position: sticky;",slug:"粘性定位-position-sticky",normalizedTitle:"粘性定位：position: sticky;",charIndex:10230},{level:2,title:"二、定位布局的一些技巧（死了都要记）",slug:"二、定位布局的一些技巧-死了都要记",normalizedTitle:"二、定位布局的一些技巧（死了都要记）",charIndex:10492},{level:3,title:"子绝父相",slug:"子绝父相",normalizedTitle:"子绝父相",charIndex:9762},{level:4,title:"原因",slug:"原因",normalizedTitle:"原因",charIndex:10523},{level:4,title:"基本规则",slug:"基本规则",normalizedTitle:"基本规则",charIndex:10646},{level:3,title:"固定定位的盒子跟随版心定位",slug:"固定定位的盒子跟随版心定位",normalizedTitle:"固定定位的盒子跟随版心定位",charIndex:10718},{level:3,title:"定位的盒子如何实现水平和垂直居中显示",slug:"定位的盒子如何实现水平和垂直居中显示",normalizedTitle:"定位的盒子如何实现水平和垂直居中显示",charIndex:11136},{level:3,title:"定位盒子的层叠位置",slug:"定位盒子的层叠位置",normalizedTitle:"定位盒子的层叠位置",charIndex:11695}],headersStr:"三、css显示隐藏 占位隐藏（了解） 不占位隐藏（死了都要记） 五、vertical-align属性（了解） 基本语法 1.1 为什么需要精灵图？ 1.2 精灵图（sprites）的使用 1.3 案例：拼单词 2.1 字体图标的产生 2.2 字体图标的优点 2.3 字体图标的下载 2.4 字体图标的引入 2.5 字体图标的追加 2.6 字体图标加载的原理 6.1 单行文本溢出省略号显示 6.2 多行文本溢出省略号显示 一、定位布局position 概念作用 边偏移量 定位模式分类 静态定位：position:static; （了解） 相对定位：position:relative; 绝对定位：position:absolute; 固定定位：position: fixed; 粘性定位：position: sticky; 二、定位布局的一些技巧（死了都要记） 子绝父相 原因 基本规则 固定定位的盒子跟随版心定位 定位的盒子如何实现水平和垂直居中显示 定位盒子的层叠位置",content:'# 三、css显示隐藏\n\n\n# 占位隐藏（了解）\n\n将盒子隐藏掉，然后盒子还是占有位置；\n\n注意：很少使用，在清除浮动的时候会搭配使用；\n\n    /* 占位隐藏 */\n    visibility: hidden;\n    /* 占位显示 */\n    visibility: visible;\n\n\n1\n2\n3\n4\n\n\n\n# 不占位隐藏（死了都要记）\n\n将盒子隐藏掉，然后盒子的位置同时被隐藏掉；\n\n    /* 不占位隐藏 */\n    display: none;\n    /* 显示隐藏的盒子 */\n    display: block;\n\n\n1\n2\n3\n4\n\n\n\n# 五、vertical-align属性（了解）\n\n\n# 基本语法\n\n行内和行内块元素默认的对齐方式是以基线对齐的，可能会导致元素和文字，元素和元素之间不能完全对齐； 通过给行内块元素或者行内元素vertical-align的不同取值设置对齐方式，该属性必须设置为当前的行内块元素或者行内元素：\n\n     /* bottom（底线对齐）  */\n     vertical-align: bottom;\n     /* top（顶线对齐）  */\n     vertical-align: top;\n     /* middle（中线对齐）  */\n     vertical-align: middle;\t\t\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 五、vertical-align 属性应用\n\nCSS 的 vertical-align 属性使用场景：经常用于设置图片或者表单（行内块元素）与文字垂直对齐。\n\n官方解释：用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。\n\n语法：\n\nvertical-align: baseline | top | middle | bottom\n\n\n1\n\n\n值          描述\nbaseline   默认。元素放置在父元素的基线上\ntop        把元素的顶端与行中最高元素的顶端对齐\nmiddle     把此元素放置在父元素的中部\nbottom     把元素的顶端与行中最低的元素的顶端对齐\n\n\n\n\n# 一、精灵图\n\n\n# 1.1 为什么需要精灵图？\n\n一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送 请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。\n\n因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。\n\n核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。\n\n精灵技术目的：为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度。\n\n\n# 1.2 精灵图（sprites）的使用\n\n使用精灵图核心：\n\n 1. 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中\n 2. 这个大图片也称为 sprites 精灵图 或者 雪碧图\n 3. 移动背景图片位置以控制显示区域， 此时可以使用 background-position\n 4. 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\n 5. 因为一般情况下都是将精灵图往上往左移动，所以两个坐标数值基本是负值\n 6. 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置\n\n使用精灵图核心总结：\n\n 1. 精灵图主要针对于小的背景图片使用\n 2. 主要借助于背景位置来实现 background-position\n 3. 一般情况下精灵图都是负值（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理）\n\n【王者荣耀案例】\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>精灵图使用</title>\n    <style>\n        .box1 {\n            width: 60px;\n            height: 60px;\n            margin: 100px auto;\n            background: url(images/sprites.png) no-repeat -182px 0;\n\n        }\n\n        .box2 {\n            width: 27px;\n            height: 25px;\n            /* background-color: pink; */\n            margin: 200px;\n            background: url(images/sprites.png) no-repeat -155px -106px;\n\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box1"></div>\n    <div class="box2"></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n\n# 1.3 案例：拼单词\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>利用精灵图拼出自己名字</title>\n    <style>\n        span {\n            display: inline-block;\n            background: url(images/abcd.jpg) no-repeat;\n        }\n\n        .p {\n            width: 100px;\n            height: 112px;\n            /* background-color: pink; */\n            background-position: -493px -276px;\n        }\n\n        .i {\n            width: 60px;\n            height: 108px;\n            /* background-color: pink; */\n            background-position: -327px -142px;\n        }\n\n        .n {\n            width: 115px;\n            height: 112px;\n            /* background-color: pink; */\n            background-position: -255px -275px;\n        }\n\n        .k {\n            width: 105px;\n            height: 114px;\n            /* background-color: pink; */\n            background-position: -495px -142px;\n        }\n    </style>\n</head>\n\n<body>\n    <span class="p">p</span>\n    <span class="i">i</span>\n    <span class="n">n</span>\n    <span class="k">k</span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n\n【PS 切片工具的使用】\n\n\n\n\n\n\n\n\n# 二、字体图标\n\n\n# 2.1 字体图标的产生\n\n字体图标使用场景：主要用于显示网页中通用、常用的一些小图标。\n\n精灵图是有诸多优点的，但是缺点很明显。\n\n 1. 图片文件还是比较大的\n 2. 图片本身放大和缩小会失真\n 3. 一旦图片制作完毕想要更换非常复杂\n\n此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。\n\n字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，但本质却属于字体。\n\n\n# 2.2 字体图标的优点\n\n * 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\n * 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\n * 兼容性：几乎支持所有的浏览器，请放心使用\n\n注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。\n\n总结：\n\n 1. 如果遇到一些结构和样式比较简单的小图标，就用字体图标\n 2. 如果遇到一些结构和样式复杂一点的小图片，就用精灵图\n\n字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为：\n\n 1. 字体图标的下载\n 2. 字体图标的引入（引入到我们 html 页面中）\n 3. 字体图标的追加（在原有的基础上添加新的小图标）\n\n\n# 2.3 字体图标的下载\n\n推荐下载网站：\n\n * icomoon 字库 https://icomoon.io/\n\nIcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n\n * 阿里 iconfont 字库 https://www.iconfont.cn/\n\n这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI 制作图标上传生成。 重点是，免费！\n\n> 以下内容以 icomoon 字库 为例。\n\n\n# 2.4 字体图标的引入\n\n下载完毕之后，注意原先的文件不要删，后面会用！\n\n 1. 把下载包里面的 fonts 文件夹放入页面根目录下\n\n不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。\n\n * TureType (.ttf) 格式 .ttf 字体是 Windows 和 Mac 的最常见的字体，支持这种字体的浏览器有 IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；\n * Web Open Font Format (.woff) 格式 woff 字体，支持这种字体的浏览器有 IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；\n * Embedded Open Type (.eot) 格式 .eot 字体是 IE 专用字体，支持这种字体的浏览器有 IE4+；\n * SVG (.svg) 格式 .svg 字体是基于 SVG 字体渲染的一种格式，支持这种字体的浏览器有 Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；\n\n 2. 在 CSS 样式中全局声明字体：简单理解把这些字体文件通过 css 引入到我们页面中\n\n一定注意字体文件路径的问题。\n\n@font-face {\n\tfont-family: \'icomoon\';\n\tsrc: url(\'fonts/icomoon.eot?7kkyc2\');\n\tsrc: url(\'fonts/icomoon.eot?7kkyc2#iefix\') format(\'embedded-opentype\'),\n\turl(\'fonts/icomoon.ttf?7kkyc2\') format(\'truetype\'),\n\turl(\'fonts/icomoon.woff?7kkyc2\') format(\'woff\'),\n\turl(\'fonts/icomoon.svg?7kkyc2#icomoon\') format(\'svg\');\n\tfont-weight: normal;\n\tfont-style: normal;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. html 标签内添加小图标\n\n复制小图标对应的字符（一个小方框）到 html 中，一般建议放在 <span></span> 标签里。\n\n 4. 给标签定义字体\n\nspan {\n\tfont-family: "icomoon";\n}\n\n\n1\n2\n3\n\n\n注意：务必保证这个字体和上面 @font-face 里面的字体保持一致（默认为：icomoon）。\n\n\n# 2.5 字体图标的追加\n\n如果工作中，原来的字体图标不够用了，我们便需要添加新的字体图标到原来的字体文件中。\n\n选择 Import Icons 按钮，把原压缩包里面的 selection.json 重新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。\n\n\n# 2.6 字体图标加载的原理\n\n服务器只需接受一次浏览器请求便可以将 fonts 文件一次性返回，如此而来网页中所有用到 fonts 字体图标的部分便一次性加载好了，大大减轻了服务器压力。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="X-UA-Compatible" content="ie=edge">\n  <title>字体图标的使用</title>\n  <style>\n    /* 字体声明 */\n    @font-face {\n    \tfont-family: \'icomoon\';\n      \tsrc: url(\'fonts/icomoon.eot?p4ssmb\');\n      \tsrc: url(\'fonts/icomoon.eot?p4ssmb#iefix\') format(\'embedded-opentype\'),\n        url(\'fonts/icomoon.ttf?p4ssmb\') format(\'truetype\'),\n        url(\'fonts/icomoon.woff?p4ssmb\') format(\'woff\'),\n        url(\'fonts/icomoon.svg?p4ssmb#icomoon\') format(\'svg\');\n      \tfont-weight: normal;\n      \tfont-style: normal;\n      \tfont-display: block;\n    }\n\n    span {\n      font-family: \'icomoon\';\n      font-size: 100px;\n      color: salmon;\n    }\n  </style>\n</head>\n\n<body>\n  <span></span>\n  <span></span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# 六、溢出的文字省略号显示\n\n\n# 6.1 单行文本溢出省略号显示\n\n三个必要条件：\n\n/* 1. 先强制一行内显示文本 */ \nwhite-space: nowrap; \t/*（ 默认 normal 自动换行）*/ \n/* 2. 超出的部分隐藏 */ \noverflow: hidden; \n/* 3. 文字用省略号替代超出的部分 */ \ntext-overflow: ellipsis;\n\n\n1\n2\n3\n4\n5\n6\n\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>单行文本溢出显示省略号</title>\n    <style>\n        div {\n            width: 150px;\n            height: 80px;\n            background-color: pink;\n            margin: 100px auto;\n            /* 这个单词的意思是如果文字显示不开自动换行 */\n            /* white-space: normal; */\n            /* 1.这个单词的意思是如果文字显示不开也必须强制一行内显示 */\n            white-space: nowrap;\n            /* 2.溢出的部分隐藏起来 */\n            overflow: hidden;\n            /* 3.文字溢出的时候用省略号来显示 */\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n\n<body>\n    <div>\n        啥也不说，此处省略一万字\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n\n# 6.2 多行文本溢出省略号显示\n\n多行文本溢出显示省略号，有较大兼容性问题， 适合于 webkit 浏览器或移动端（移动端大部分是 webkit 内核）。\n\noverflow: hidden;\ntext-overflow: ellipsis;\n/* 弹性伸缩盒子模型显示 */\ndisplay: -webkit-box;\n/* 限制在一个块元素显示的文本的行数 */\n-webkit-line-clamp: 2;\n/* 设置或检索伸缩盒对象的子元素的排列方式 */\n-webkit-box-orient: vertical;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>单行文本溢出显示省略号</title>\n    <style>\n        div {\n            width: 150px;\n            height: 65px;\n            background-color: pink;\n            margin: 100px auto;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            /* 弹性伸缩盒子模型显示 */\n            display: -webkit-box;\n            /* 限制在一个块元素显示的文本的行数 */\n            -webkit-line-clamp: 3;\n            /* 设置或检索伸缩盒对象的子元素的排列方式 */\n            -webkit-box-orient: vertical;\n        }\n    </style>\n</head>\n\n<body>\n    <div>\n        啥也不说，此处省略一万字,啥也不说，此处省略一万字此处省略一万字\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nChrome 浏览器效果：\n\n\n\n\n# 一、定位布局position\n\n\n# 概念作用\n\n定位布局可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子；\n\n一个完美的定位是由定位模式和边偏移量同时完成的：定位 = 定位模式 + 边偏移（方位名词更改）\n\n\n# 边偏移量\n\n指的就是top、bottom、left、right属性，left和right值控制左右位置偏移，top和bottom只控制上下偏移；\n\n\n# 定位模式分类\n\n# 静态定位：position:static; （了解）\n\n就是盒子默认的显示方式，相当于啥也没做 就算是给静态定位盒子设置了边偏移是无效的；\n\n# 相对定位：position:relative;\n\n参照对象（参照物）：根据自己原来的位置进行定位；\n\n特点：\n\n> 01、相对定位的盒子不会脱离标准流，设置边偏移后盒子原来的位置还存在； 02、相对定位不会改变盒子的默认显示模式； 03、相对定位很少单独使用，后期经常配合绝对定位完成子绝父相的效果，做绝对定位盒子父亲；\n\n# 绝对定位：position:absolute;\n\n参照对象（参照物）：\n\n> 01、默认的参照对象是父级盒子，如果没有父级盒子就以浏览器为参照定位；\n> \n> 02、如果有父级盒子并且父级盒子有定位属性，就以父级盒子为参照定位；\n> \n> 03、如果有父级盒子但是父级盒子没有定位属性，就会一级一级的往上找祖先盒子，就近的祖先盒子有定位 属性性就以当前的祖先盒子为参照，如果所有的祖先盒子都没有定位属性就以浏览器为参照；\n\n特点：\n\n> 01、绝对定位的盒子完全脱离了文档流，不会占有原来的位置，属于不占位的定位； 02、绝对定位会改变盒子的显示模式为行内块的元素的特点； 03、绝对定位一般会配合相对定位实现子绝父相的定位效果，很少自己单独使用；\n\n# 固定定位：position: fixed;\n\n**参照对象（参照物）：**是浏览器的可视窗口为参照定位；\n\n特点：\n\n> 01、固定定位的盒子完全脱离文档流，属于不占位定位； 02、固定定位会将盒子的显示模式更改为行内块的特点；\n\n# 粘性定位：position: sticky;\n\n参照对象（参照物）： 一开始条件没有满足的时候是相对定位，当条件满足以后马上更改为固定定位，所以可以理解为参照物没有满足条件的时候为自己本身，满足了条件后更改为浏览器的可视窗口；\n\n**注意：**粘性定位的盒子必须满足设置边偏移的四个值分别是top,right,bottom,left中的一个，比如上下滚动设置top值；以下代码必须满足元素的top值为0的时候就会执行粘性定位样式；\n\n    position: sticky;\n    top: 0;\n\n\n1\n2\n\n\n\n# 二、定位布局的一些技巧（死了都要记）\n\n\n# 子绝父相\n\n# 原因\n\n父级盒子是用来做布局占位用的，如果使用了绝对定位父级盒子就会完全脱离文档流，导致后面的盒子布局混乱；\n\n\n\n所以我们父级盒子有一般都用相对定位，这样父级盒子会占有原来的位置也不会改变盒子的显示模式，就不会影响后面盒子的布局了；\n\n\n\n# 基本规则\n\n> 01、子级绝对父级相对；\n> \n> 02、如果父级盒子有有对应的定位属性，也可以直接做父级定位子级，不一定是子绝父相；\n\n\n# 固定定位的盒子跟随版心定位\n\n如果想要固定定位的盒子跟随版心定位需要按照以下步骤设置：\n\n> 01、首先盒子必须是固定定位position: fixed;，然后设置left取值为50%；\n> \n> 02、然后设置盒子的margin-left取值为版心的一半加合适的距离；\n\n\n\n以下代码是将版心设置为1200的标准设置的：\n\n        .sub-nav {\n            position: fixed;\n            top: 300px;\n            left: 50%;\n            margin-left: 620px;\n            width: 60px;\n            height: 300px;\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 定位的盒子如何实现水平和垂直居中显示\n\n**情况1：**如果盒子是相对定位我们可以直接使用margin设置盒子居中显示；\n\n**情况2：**如果盒子是绝对定位或者固定定位，因为盒子完全脱离了标准流margin居中就会失效，我们需要按照以下的方法实现盒子的水平和垂直居中；\n\n> 01、设置定位盒子的left:50%;和top:50%;让盒子直接定位整个父级平分的右侧和下面；\n> \n> 02、设置margin-left：- 盒子宽度一半；和margin-top:-盒子高度一半；\n\n        .box {\n            position: absolute;\n            top: 300px;\n            left: 50%;\n            top: 50%;\n            margin-left: -150px;\n            margin-top: -150px;\n            width: 300px;\n            height: 300px;\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n\n# 定位盒子的层叠位置\n\n定位的元素，写在后面的盒子会将前面的盒子压住，如果想要调整盒子的先后顺序，就需要用z-index来设置：\n\nz-index的取值是任意的整数，可以是负数或者正数，默认的取值理解为0，值越大盒子越靠前；\n\n注意：z-index必须配合定位属性一起使用，取值不能带任何单位；',normalizedContent:'# 三、css显示隐藏\n\n\n# 占位隐藏（了解）\n\n将盒子隐藏掉，然后盒子还是占有位置；\n\n注意：很少使用，在清除浮动的时候会搭配使用；\n\n    /* 占位隐藏 */\n    visibility: hidden;\n    /* 占位显示 */\n    visibility: visible;\n\n\n1\n2\n3\n4\n\n\n\n# 不占位隐藏（死了都要记）\n\n将盒子隐藏掉，然后盒子的位置同时被隐藏掉；\n\n    /* 不占位隐藏 */\n    display: none;\n    /* 显示隐藏的盒子 */\n    display: block;\n\n\n1\n2\n3\n4\n\n\n\n# 五、vertical-align属性（了解）\n\n\n# 基本语法\n\n行内和行内块元素默认的对齐方式是以基线对齐的，可能会导致元素和文字，元素和元素之间不能完全对齐； 通过给行内块元素或者行内元素vertical-align的不同取值设置对齐方式，该属性必须设置为当前的行内块元素或者行内元素：\n\n     /* bottom（底线对齐）  */\n     vertical-align: bottom;\n     /* top（顶线对齐）  */\n     vertical-align: top;\n     /* middle（中线对齐）  */\n     vertical-align: middle;\t\t\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 五、vertical-align 属性应用\n\ncss 的 vertical-align 属性使用场景：经常用于设置图片或者表单（行内块元素）与文字垂直对齐。\n\n官方解释：用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。\n\n语法：\n\nvertical-align: baseline | top | middle | bottom\n\n\n1\n\n\n值          描述\nbaseline   默认。元素放置在父元素的基线上\ntop        把元素的顶端与行中最高元素的顶端对齐\nmiddle     把此元素放置在父元素的中部\nbottom     把元素的顶端与行中最低的元素的顶端对齐\n\n\n\n\n# 一、精灵图\n\n\n# 1.1 为什么需要精灵图？\n\n一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送 请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。\n\n因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 css 精灵技术（也称 css sprites、css 雪碧）。\n\n核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。\n\n精灵技术目的：为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度。\n\n\n# 1.2 精灵图（sprites）的使用\n\n使用精灵图核心：\n\n 1. 精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中\n 2. 这个大图片也称为 sprites 精灵图 或者 雪碧图\n 3. 移动背景图片位置以控制显示区域， 此时可以使用 background-position\n 4. 移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同\n 5. 因为一般情况下都是将精灵图往上往左移动，所以两个坐标数值基本是负值\n 6. 使用精灵图的时候需要精确测量，每个小背景图片的大小和位置\n\n使用精灵图核心总结：\n\n 1. 精灵图主要针对于小的背景图片使用\n 2. 主要借助于背景位置来实现 background-position\n 3. 一般情况下精灵图都是负值（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理）\n\n【王者荣耀案例】\n\n\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>精灵图使用</title>\n    <style>\n        .box1 {\n            width: 60px;\n            height: 60px;\n            margin: 100px auto;\n            background: url(images/sprites.png) no-repeat -182px 0;\n\n        }\n\n        .box2 {\n            width: 27px;\n            height: 25px;\n            /* background-color: pink; */\n            margin: 200px;\n            background: url(images/sprites.png) no-repeat -155px -106px;\n\n        }\n    </style>\n</head>\n\n<body>\n    <div class="box1"></div>\n    <div class="box2"></div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n\n# 1.3 案例：拼单词\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>利用精灵图拼出自己名字</title>\n    <style>\n        span {\n            display: inline-block;\n            background: url(images/abcd.jpg) no-repeat;\n        }\n\n        .p {\n            width: 100px;\n            height: 112px;\n            /* background-color: pink; */\n            background-position: -493px -276px;\n        }\n\n        .i {\n            width: 60px;\n            height: 108px;\n            /* background-color: pink; */\n            background-position: -327px -142px;\n        }\n\n        .n {\n            width: 115px;\n            height: 112px;\n            /* background-color: pink; */\n            background-position: -255px -275px;\n        }\n\n        .k {\n            width: 105px;\n            height: 114px;\n            /* background-color: pink; */\n            background-position: -495px -142px;\n        }\n    </style>\n</head>\n\n<body>\n    <span class="p">p</span>\n    <span class="i">i</span>\n    <span class="n">n</span>\n    <span class="k">k</span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n\n【ps 切片工具的使用】\n\n\n\n\n\n\n\n\n# 二、字体图标\n\n\n# 2.1 字体图标的产生\n\n字体图标使用场景：主要用于显示网页中通用、常用的一些小图标。\n\n精灵图是有诸多优点的，但是缺点很明显。\n\n 1. 图片文件还是比较大的\n 2. 图片本身放大和缩小会失真\n 3. 一旦图片制作完毕想要更换非常复杂\n\n此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。\n\n字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，但本质却属于字体。\n\n\n# 2.2 字体图标的优点\n\n * 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\n * 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\n * 兼容性：几乎支持所有的浏览器，请放心使用\n\n注意： 字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。\n\n总结：\n\n 1. 如果遇到一些结构和样式比较简单的小图标，就用字体图标\n 2. 如果遇到一些结构和样式复杂一点的小图片，就用精灵图\n\n字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为：\n\n 1. 字体图标的下载\n 2. 字体图标的引入（引入到我们 html 页面中）\n 3. 字体图标的追加（在原有的基础上添加新的小图标）\n\n\n# 2.3 字体图标的下载\n\n推荐下载网站：\n\n * icomoon 字库 https://icomoon.io/\n\nicomoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n\n * 阿里 iconfont 字库 https://www.iconfont.cn/\n\n这个是阿里妈妈 m2ux 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 ai 制作图标上传生成。 重点是，免费！\n\n> 以下内容以 icomoon 字库 为例。\n\n\n# 2.4 字体图标的引入\n\n下载完毕之后，注意原先的文件不要删，后面会用！\n\n 1. 把下载包里面的 fonts 文件夹放入页面根目录下\n\n不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容，就是因为包含了主流浏览器支持的字体文件。\n\n * turetype (.ttf) 格式 .ttf 字体是 windows 和 mac 的最常见的字体，支持这种字体的浏览器有 ie9+、firefox3.5+、chrome4+、safari3+、opera10+、ios mobile、safari4.2+；\n * web open font format (.woff) 格式 woff 字体，支持这种字体的浏览器有 ie9+、firefox3.5+、chrome6+、safari3.6+、opera11.1+；\n * embedded open type (.eot) 格式 .eot 字体是 ie 专用字体，支持这种字体的浏览器有 ie4+；\n * svg (.svg) 格式 .svg 字体是基于 svg 字体渲染的一种格式，支持这种字体的浏览器有 chrome4+、safari3.1+、opera10.0+、ios mobile safari3.2+；\n\n 2. 在 css 样式中全局声明字体：简单理解把这些字体文件通过 css 引入到我们页面中\n\n一定注意字体文件路径的问题。\n\n@font-face {\n\tfont-family: \'icomoon\';\n\tsrc: url(\'fonts/icomoon.eot?7kkyc2\');\n\tsrc: url(\'fonts/icomoon.eot?7kkyc2#iefix\') format(\'embedded-opentype\'),\n\turl(\'fonts/icomoon.ttf?7kkyc2\') format(\'truetype\'),\n\turl(\'fonts/icomoon.woff?7kkyc2\') format(\'woff\'),\n\turl(\'fonts/icomoon.svg?7kkyc2#icomoon\') format(\'svg\');\n\tfont-weight: normal;\n\tfont-style: normal;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n 3. html 标签内添加小图标\n\n复制小图标对应的字符（一个小方框）到 html 中，一般建议放在 <span></span> 标签里。\n\n 4. 给标签定义字体\n\nspan {\n\tfont-family: "icomoon";\n}\n\n\n1\n2\n3\n\n\n注意：务必保证这个字体和上面 @font-face 里面的字体保持一致（默认为：icomoon）。\n\n\n# 2.5 字体图标的追加\n\n如果工作中，原来的字体图标不够用了，我们便需要添加新的字体图标到原来的字体文件中。\n\n选择 import icons 按钮，把原压缩包里面的 selection.json 重新上传，然后选中自己想要新的图标，从新下载压缩包，并替换原来的文件即可。\n\n\n# 2.6 字体图标加载的原理\n\n服务器只需接受一次浏览器请求便可以将 fonts 文件一次性返回，如此而来网页中所有用到 fonts 字体图标的部分便一次性加载好了，大大减轻了服务器压力。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <title>字体图标的使用</title>\n  <style>\n    /* 字体声明 */\n    @font-face {\n    \tfont-family: \'icomoon\';\n      \tsrc: url(\'fonts/icomoon.eot?p4ssmb\');\n      \tsrc: url(\'fonts/icomoon.eot?p4ssmb#iefix\') format(\'embedded-opentype\'),\n        url(\'fonts/icomoon.ttf?p4ssmb\') format(\'truetype\'),\n        url(\'fonts/icomoon.woff?p4ssmb\') format(\'woff\'),\n        url(\'fonts/icomoon.svg?p4ssmb#icomoon\') format(\'svg\');\n      \tfont-weight: normal;\n      \tfont-style: normal;\n      \tfont-display: block;\n    }\n\n    span {\n      font-family: \'icomoon\';\n      font-size: 100px;\n      color: salmon;\n    }\n  </style>\n</head>\n\n<body>\n  <span></span>\n  <span></span>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n\n# 六、溢出的文字省略号显示\n\n\n# 6.1 单行文本溢出省略号显示\n\n三个必要条件：\n\n/* 1. 先强制一行内显示文本 */ \nwhite-space: nowrap; \t/*（ 默认 normal 自动换行）*/ \n/* 2. 超出的部分隐藏 */ \noverflow: hidden; \n/* 3. 文字用省略号替代超出的部分 */ \ntext-overflow: ellipsis;\n\n\n1\n2\n3\n4\n5\n6\n\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>单行文本溢出显示省略号</title>\n    <style>\n        div {\n            width: 150px;\n            height: 80px;\n            background-color: pink;\n            margin: 100px auto;\n            /* 这个单词的意思是如果文字显示不开自动换行 */\n            /* white-space: normal; */\n            /* 1.这个单词的意思是如果文字显示不开也必须强制一行内显示 */\n            white-space: nowrap;\n            /* 2.溢出的部分隐藏起来 */\n            overflow: hidden;\n            /* 3.文字溢出的时候用省略号来显示 */\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n\n<body>\n    <div>\n        啥也不说，此处省略一万字\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n\n\n# 6.2 多行文本溢出省略号显示\n\n多行文本溢出显示省略号，有较大兼容性问题， 适合于 webkit 浏览器或移动端（移动端大部分是 webkit 内核）。\n\noverflow: hidden;\ntext-overflow: ellipsis;\n/* 弹性伸缩盒子模型显示 */\ndisplay: -webkit-box;\n/* 限制在一个块元素显示的文本的行数 */\n-webkit-line-clamp: 2;\n/* 设置或检索伸缩盒对象的子元素的排列方式 */\n-webkit-box-orient: vertical;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。\n\n案例：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>单行文本溢出显示省略号</title>\n    <style>\n        div {\n            width: 150px;\n            height: 65px;\n            background-color: pink;\n            margin: 100px auto;\n            overflow: hidden;\n            text-overflow: ellipsis;\n            /* 弹性伸缩盒子模型显示 */\n            display: -webkit-box;\n            /* 限制在一个块元素显示的文本的行数 */\n            -webkit-line-clamp: 3;\n            /* 设置或检索伸缩盒对象的子元素的排列方式 */\n            -webkit-box-orient: vertical;\n        }\n    </style>\n</head>\n\n<body>\n    <div>\n        啥也不说，此处省略一万字,啥也不说，此处省略一万字此处省略一万字\n    </div>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nchrome 浏览器效果：\n\n\n\n\n# 一、定位布局position\n\n\n# 概念作用\n\n定位布局可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子；\n\n一个完美的定位是由定位模式和边偏移量同时完成的：定位 = 定位模式 + 边偏移（方位名词更改）\n\n\n# 边偏移量\n\n指的就是top、bottom、left、right属性，left和right值控制左右位置偏移，top和bottom只控制上下偏移；\n\n\n# 定位模式分类\n\n# 静态定位：position:static; （了解）\n\n就是盒子默认的显示方式，相当于啥也没做 就算是给静态定位盒子设置了边偏移是无效的；\n\n# 相对定位：position:relative;\n\n参照对象（参照物）：根据自己原来的位置进行定位；\n\n特点：\n\n> 01、相对定位的盒子不会脱离标准流，设置边偏移后盒子原来的位置还存在； 02、相对定位不会改变盒子的默认显示模式； 03、相对定位很少单独使用，后期经常配合绝对定位完成子绝父相的效果，做绝对定位盒子父亲；\n\n# 绝对定位：position:absolute;\n\n参照对象（参照物）：\n\n> 01、默认的参照对象是父级盒子，如果没有父级盒子就以浏览器为参照定位；\n> \n> 02、如果有父级盒子并且父级盒子有定位属性，就以父级盒子为参照定位；\n> \n> 03、如果有父级盒子但是父级盒子没有定位属性，就会一级一级的往上找祖先盒子，就近的祖先盒子有定位 属性性就以当前的祖先盒子为参照，如果所有的祖先盒子都没有定位属性就以浏览器为参照；\n\n特点：\n\n> 01、绝对定位的盒子完全脱离了文档流，不会占有原来的位置，属于不占位的定位； 02、绝对定位会改变盒子的显示模式为行内块的元素的特点； 03、绝对定位一般会配合相对定位实现子绝父相的定位效果，很少自己单独使用；\n\n# 固定定位：position: fixed;\n\n**参照对象（参照物）：**是浏览器的可视窗口为参照定位；\n\n特点：\n\n> 01、固定定位的盒子完全脱离文档流，属于不占位定位； 02、固定定位会将盒子的显示模式更改为行内块的特点；\n\n# 粘性定位：position: sticky;\n\n参照对象（参照物）： 一开始条件没有满足的时候是相对定位，当条件满足以后马上更改为固定定位，所以可以理解为参照物没有满足条件的时候为自己本身，满足了条件后更改为浏览器的可视窗口；\n\n**注意：**粘性定位的盒子必须满足设置边偏移的四个值分别是top,right,bottom,left中的一个，比如上下滚动设置top值；以下代码必须满足元素的top值为0的时候就会执行粘性定位样式；\n\n    position: sticky;\n    top: 0;\n\n\n1\n2\n\n\n\n# 二、定位布局的一些技巧（死了都要记）\n\n\n# 子绝父相\n\n# 原因\n\n父级盒子是用来做布局占位用的，如果使用了绝对定位父级盒子就会完全脱离文档流，导致后面的盒子布局混乱；\n\n\n\n所以我们父级盒子有一般都用相对定位，这样父级盒子会占有原来的位置也不会改变盒子的显示模式，就不会影响后面盒子的布局了；\n\n\n\n# 基本规则\n\n> 01、子级绝对父级相对；\n> \n> 02、如果父级盒子有有对应的定位属性，也可以直接做父级定位子级，不一定是子绝父相；\n\n\n# 固定定位的盒子跟随版心定位\n\n如果想要固定定位的盒子跟随版心定位需要按照以下步骤设置：\n\n> 01、首先盒子必须是固定定位position: fixed;，然后设置left取值为50%；\n> \n> 02、然后设置盒子的margin-left取值为版心的一半加合适的距离；\n\n\n\n以下代码是将版心设置为1200的标准设置的：\n\n        .sub-nav {\n            position: fixed;\n            top: 300px;\n            left: 50%;\n            margin-left: 620px;\n            width: 60px;\n            height: 300px;\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 定位的盒子如何实现水平和垂直居中显示\n\n**情况1：**如果盒子是相对定位我们可以直接使用margin设置盒子居中显示；\n\n**情况2：**如果盒子是绝对定位或者固定定位，因为盒子完全脱离了标准流margin居中就会失效，我们需要按照以下的方法实现盒子的水平和垂直居中；\n\n> 01、设置定位盒子的left:50%;和top:50%;让盒子直接定位整个父级平分的右侧和下面；\n> \n> 02、设置margin-left：- 盒子宽度一半；和margin-top:-盒子高度一半；\n\n        .box {\n            position: absolute;\n            top: 300px;\n            left: 50%;\n            top: 50%;\n            margin-left: -150px;\n            margin-top: -150px;\n            width: 300px;\n            height: 300px;\n            background-color: palegreen;\n        }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n\n# 定位盒子的层叠位置\n\n定位的元素，写在后面的盒子会将前面的盒子压住，如果想要调整盒子的先后顺序，就需要用z-index来设置：\n\nz-index的取值是任意的整数，可以是负数或者正数，默认的取值理解为0，值越大盒子越靠前；\n\n注意：z-index必须配合定位属性一起使用，取值不能带任何单位；',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"CSS进阶",frontmatter:{title:"CSS进阶",date:"2020-10-03T15:46:55.000Z",permalink:"/pages/602c76/",categories:["前端基础","CSS"],tags:["CSS"],readingShow:"top"},regularPath:"/01.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/02.CSS/20.CSS%E8%BF%9B%E9%98%B6.html",relativePath:"01.前端基础/02.CSS/20.CSS进阶.md",key:"v-d4457084",path:"/pages/602c76/",headers:[{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:2},{level:3,title:"flex布局",slug:"flex布局",normalizedTitle:"flex布局",charIndex:10},{level:4,title:"1.更换主轴方向",slug:"_1-更换主轴方向",normalizedTitle:"1.更换主轴方向",charIndex:20},{level:4,title:"2.flex-wrap实现多行排列",slug:"_2-flex-wrap实现多行排列",normalizedTitle:"2.flex-wrap实现多行排列",charIndex:297},{level:4,title:"3. flex属性",slug:"_3-flex属性",normalizedTitle:"3. flex属性",charIndex:565},{level:2,title:"flex缩写的等值",slug:"flex缩写的等值",normalizedTitle:"flex缩写的等值",charIndex:985},{level:3,title:"移动端适配",slug:"移动端适配",normalizedTitle:"移动端适配",charIndex:1268},{level:4,title:"1、rem",slug:"_1、rem",normalizedTitle:"1、rem",charIndex:1323},{level:4,title:"2、vw / vh",slug:"_2、vw-vh",normalizedTitle:"2、vw / vh",charIndex:1784}],headersStr:"CSS flex布局 1.更换主轴方向 2.flex-wrap实现多行排列 3. flex属性 flex缩写的等值 移动端适配 1、rem 2、vw / vh",content:"# CSS\n\n\n# flex布局\n\n# 1.更换主轴方向\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n> flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n# 2.flex-wrap实现多行排列\n\n弹性盒子换行显示：flex-wrap: wrap;\n\n调整行对齐方式：align-content，取值与justify-content基本相同\n\n> .box{\n> flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-wrap可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n# 3. flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n> flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-grow是如果有剩余空间，是否扩大，1为扩大 flex-shrink是如果剩余空间不够，是否缩小，1为缩小 flex-basis为项目本身的大小，默认值是auto\n\nflex-basis:0%;把子盒自身的width变成无效,所有的宽度只和flex-grow,flex-shrink有关系\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n# flex缩写的等值\n\n了解了三个属性各自的含义之后，可以看下三个属性对应的等值。\n\n语法              等值\nflex: initial   flex: 0 1 auto\nflex: 0         flex: 0 1 0%\nflex: none      flex: 0 0 auto\nflex: 1         flex: 1 1 0%\nflex: auto      flex: 1 1 auto\n\n你了解flex:1，flex:auto，flex:0，flex:none的区别吗？\n\n一文搞懂flex:0,1,auto,none\n\n\n# 移动端适配\n\n了解\n\npx是固定像素单位，百分比布局宽度自适应但高度需要固定，所以无法实现移动端适配。\n\n# 1、rem\n\nrem适配方案实际上是根据当前设备的屏幕大小动态地修改html根节点字体大小，来进行适配。\n\n原理是通过媒体查询判断当前屏幕的大小，并修改html根节点字体大小。但是不同的机型需要手写不同的方案，我们在项目中会引入lib-flexible.js文件，和px-to-rem包，就能自动实现px转rem进行动态适配了。\n\n代码如下：\n\n@media (width:375px) { //iphone6、7、8\n        html {\n          font-size: 37.5px;\n        }\n      }\n\n\n1\n2\n3\n4\n5\n\n\nbody {\n    height: (100 / 37.5rem);\n}\n\n\n1\n2\n3\n\n\n使用媒体查询需要单独设置机型，太过麻烦，建议配合flexible.js（手机淘宝团队出品）使用\n\n配合flexible.js文件使用\n\n引入js文件即可\n\n<script src=\"./js/flexible.js\"><\/script>\n\n\n1\n\n\n# 2、vw / vh\n\nvw 即 viewport width 视口宽度\n\nvh 即 viewport height 视口高度\n\n1vw = 视口宽度的1/100\n\n1vh = 视口高度的1/100\n\nbody {\n    height: (100 / 3.75vw);\n}\n\n\n1\n2\n3\n\n\nvw和vh使用时要注意只是用一种，同一个项目中不能混用，防止元素被拉伸变形\n\nvw和vh不需要媒体查询",normalizedContent:"# css\n\n\n# flex布局\n\n# 1.更换主轴方向\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n> flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n# 2.flex-wrap实现多行排列\n\n弹性盒子换行显示：flex-wrap: wrap;\n\n调整行对齐方式：align-content，取值与justify-content基本相同\n\n> .box{\n> flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-wrap可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n# 3. flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n> flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-grow是如果有剩余空间，是否扩大，1为扩大 flex-shrink是如果剩余空间不够，是否缩小，1为缩小 flex-basis为项目本身的大小，默认值是auto\n\nflex-basis:0%;把子盒自身的width变成无效,所有的宽度只和flex-grow,flex-shrink有关系\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n# flex缩写的等值\n\n了解了三个属性各自的含义之后，可以看下三个属性对应的等值。\n\n语法              等值\nflex: initial   flex: 0 1 auto\nflex: 0         flex: 0 1 0%\nflex: none      flex: 0 0 auto\nflex: 1         flex: 1 1 0%\nflex: auto      flex: 1 1 auto\n\n你了解flex:1，flex:auto，flex:0，flex:none的区别吗？\n\n一文搞懂flex:0,1,auto,none\n\n\n# 移动端适配\n\n了解\n\npx是固定像素单位，百分比布局宽度自适应但高度需要固定，所以无法实现移动端适配。\n\n# 1、rem\n\nrem适配方案实际上是根据当前设备的屏幕大小动态地修改html根节点字体大小，来进行适配。\n\n原理是通过媒体查询判断当前屏幕的大小，并修改html根节点字体大小。但是不同的机型需要手写不同的方案，我们在项目中会引入lib-flexible.js文件，和px-to-rem包，就能自动实现px转rem进行动态适配了。\n\n代码如下：\n\n@media (width:375px) { //iphone6、7、8\n        html {\n          font-size: 37.5px;\n        }\n      }\n\n\n1\n2\n3\n4\n5\n\n\nbody {\n    height: (100 / 37.5rem);\n}\n\n\n1\n2\n3\n\n\n使用媒体查询需要单独设置机型，太过麻烦，建议配合flexible.js（手机淘宝团队出品）使用\n\n配合flexible.js文件使用\n\n引入js文件即可\n\n<script src=\"./js/flexible.js\"><\/script>\n\n\n1\n\n\n# 2、vw / vh\n\nvw 即 viewport width 视口宽度\n\nvh 即 viewport height 视口高度\n\n1vw = 视口宽度的1/100\n\n1vh = 视口高度的1/100\n\nbody {\n    height: (100 / 3.75vw);\n}\n\n\n1\n2\n3\n\n\nvw和vh使用时要注意只是用一种，同一个项目中不能混用，防止元素被拉伸变形\n\nvw和vh不需要媒体查询",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS语法与变量",frontmatter:{title:"JS语法与变量",date:"2020-04-30T11:58:31.000Z",permalink:"/javascript/c8f971/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/01.JS%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%8F%98%E9%87%8F.html",relativePath:"20.JS/10.基础/01.JS语法与变量.md",key:"v-36e24b0a",path:"/javascript/c8f971/",headers:[{level:2,title:"1.1 前端三层",slug:"_1-1-前端三层",normalizedTitle:"1.1 前端三层",charIndex:52},{level:2,title:"1.2 JavaScript 历史",slug:"_1-2-javascript-历史",normalizedTitle:"1.2 javascript 历史",charIndex:188},{level:2,title:"1.3 什么是前端语言和后端语言",slug:"_1-3-什么是前端语言和后端语言",normalizedTitle:"1.3 什么是前端语言和后端语言",charIndex:407},{level:2,title:"1.4 ECMAScript 是 JavaScript 的标准",slug:"_1-4-ecmascript-是-javascript-的标准",normalizedTitle:"1.4 ecmascript 是 javascript 的标准",charIndex:765},{level:2,title:"1.5 JavaScript 体系",slug:"_1-5-javascript-体系",normalizedTitle:"1.5 javascript 体系",charIndex:958},{level:2,title:"1.6 JavaScript 的语言风格和特性",slug:"_1-6-javascript-的语言风格和特性",normalizedTitle:"1.6 javascript 的语言风格和特性",charIndex:1070},{level:2,title:"2.1 在 <body> 中书写 JS 代码",slug:"_2-1-在-body-中书写-js-代码",normalizedTitle:"2.1 在 <body> 中书写 js 代码",charIndex:1662},{level:2,title:"2.2 将 JS 代码单独保存为 \\.js 文件",slug:"_2-2-将-js-代码单独保存为-js-文件",normalizedTitle:"2.2 将 js 代码单独保存为 .js 文件",charIndex:2414},{level:2,title:"3.1 alert()",slug:"_3-1-alert",normalizedTitle:"3.1 alert()",charIndex:3116},{level:2,title:"3.2 console.log()",slug:"_3-2-console-log",normalizedTitle:"3.2 console.log()",charIndex:3582},{level:2,title:"5.1 定义变量",slug:"_5-1-定义变量",normalizedTitle:"5.1 定义变量",charIndex:4526},{level:2,title:"5.2 使用变量",slug:"_5-2-使用变量",normalizedTitle:"5.2 使用变量",charIndex:4643},{level:2,title:"5.3 改变变量的值",slug:"_5-3-改变变量的值",normalizedTitle:"5.3 改变变量的值",charIndex:4749},{level:2,title:"5.4 变量的合法命名",slug:"_5-4-变量的合法命名",normalizedTitle:"5.4 变量的合法命名",charIndex:4850},{level:2,title:"5.5 推荐的变量命名风格",slug:"_5-5-推荐的变量命名风格",normalizedTitle:"5.5 推荐的变量命名风格",charIndex:4987},{level:2,title:"5.6 变量的默认值",slug:"_5-6-变量的默认值",normalizedTitle:"5.6 变量的默认值",charIndex:5132},{level:2,title:"5.7 变量的常见错误",slug:"_5-7-变量的常见错误",normalizedTitle:"5.7 变量的常见错误",charIndex:5312},{level:2,title:"5.8 等号表示赋值",slug:"_5-8-等号表示赋值",normalizedTitle:"5.8 等号表示赋值",charIndex:6634},{level:2,title:"5.9 同时声明多个变量",slug:"_5-9-同时声明多个变量",normalizedTitle:"5.9 同时声明多个变量",charIndex:6741}],headersStr:"1.1 前端三层 1.2 JavaScript 历史 1.3 什么是前端语言和后端语言 1.4 ECMAScript 是 JavaScript 的标准 1.5 JavaScript 体系 1.6 JavaScript 的语言风格和特性 2.1 在 <body> 中书写 JS 代码 2.2 将 JS 代码单独保存为 \\.js 文件 3.1 alert() 3.2 console.log() 5.1 定义变量 5.2 使用变量 5.3 改变变量的值 5.4 变量的合法命名 5.5 推荐的变量命名风格 5.6 变量的默认值 5.7 变量的常见错误 5.8 等号表示赋值 5.9 同时声明多个变量",content:'# 【JS语法与变量】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、初识JavaScript\n\n\n# 1.1 前端三层\n\n      语言           功能\n结构层   HTML         搭建结构、放置部件、描述语义\n样式层   CSS          美化网页、实现布局\n行为层   JavaScript   实现交互效果、数据收发、表单验证等\n\n\n# 1.2 JavaScript 历史\n\n创始人：布兰登·艾奇\n\n * 1995 年艾奇在美国网景公司发明了 LiveScript\n * 网景公司与 Sun 公司合作，为了宣传改名为 JavaScript\n\n> JavaScript 与 Java 没有半毛钱关系！非要有关系，那就是都与 Sun 公司有关。\n\n目前 JavaScript 已经完全垄断了浏览器端脚本！\n\n如今 JavaScript 功能非常强大，未来还会越来越强大！\n\n\n# 1.3 什么是前端语言和后端语言\n\n前端语言：处理界面（HTML、CSS、JavaScript、……）\n\n后端语言：处理数据（Java、PHP、Python、Go、……）\n\n（浏览器）前端 <———— HTTP 协议 ————> 后端（服务器）\n\n> 传统的 JS 是一门前端语言，只能运行在浏览器端，不能在服务器端处理数据，且不能独立于浏览器存在，不能脱离 HTML！\n\n在 2009 年，诞生了 Node.js，这是一个 JavaScript 的服务端运行平台。\n\n> Node.js 出现后，JavaScript 可以独立于浏览器运行，可以用来写服务器端（后端）！\n\n所以，JavaScript 是一门可以 “上天入地” 的语言！\n\n可以说，JavaScript 是一门真正意义上的 “全栈” 语言！\n\n\n# 1.4 ECMAScript 是 JavaScript 的标准\n\n1997 年，欧洲计算机制造商协会（ECMA）颁布了 JavaScript 的标准，命名为 ECMAScript。\n\n> ECMAScript 简称 ES，JavaScript 简称 JS。\n\n * JavaScript 实现了 ECMAScript\n\n * ECMAScript 规范了 JavaScript\n\n\n# 1.5 JavaScript 体系\n\n * 语言核心\n   * ES5（现阶段学习目标）\n   * ES6（后期学习目标）、ES7、ES8、ES9、……\n * DOM（操纵 HTML）\n * BOM（操作 浏览器）\n\n\n# 1.6 JavaScript 的语言风格和特性\n\n * 类 C 语言风格，容易上手\n * 弱类型（动态类型），简单易学\n * 丰富的功能，无敌的生态，强大的性能\n\n> 弱类型既是 JS 的优点，也是 JS 的缺点！在 JS 诞生之初，JS 只是一个控制浏览器网页的小型脚本语言，所以最初设计 JS 时去掉了类型系统，因为类型系统需要涉及到复杂的语法校验和编译过程，得不偿失。后来随着前端的不断发展，JS 所开发的项目越来越复杂，JS 弱类型的特性反而变成了 JS 的劣势！所以最近几年微软出品的 TypeScript 越来越火，TS 就是一个 JS 的超集，在 JS 的基础上提供了类型系统的一门全新的语言，并且 TS 代码可以编译为纯 JS 代码运行到 JS 能运行的任何地方！所以 TypeScript 未来一定是前端开发的趋势……，我们在掌握好 JS 后，最好去学习一下 TS！\n\n\n# 二、JS的书写位置\n\n * 在 <body> 中的 <script> 标签中书写 JS 代码\n * 将 JS 代码单独保存为 .js 文件，然后在 HTML 文件中使用 <script src=""><\/script> 引入\n\n> JavaScript 不能脱离 HTML 网页运行！\n> \n> （当然，今后学习 Node.js 后，JavaScript 可以运行在独立的平台中）\n\n\n# 2.1 在 <body> 中书写 JS 代码\n\n在 <body> 中的 <script> 标签中书写 JS 代码\n\n * index.html\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n\n<body>\n    \x3c!-- 在 HTML5 之前，必须要加上 type 属性，并且里面的内容一定要正确！--\x3e\n    \x3c!-- \n    <script type="text/javascript">\n    <\/script> \n    --\x3e\n\n    \x3c!-- 目前都是使用 HTML5，所以不用写 type 属性，默认就是 JS --\x3e\n    \x3c!-- 推荐把 <script> 写到 body 的末尾（避免 JS 发生阻塞时页面受到牵连）--\x3e\n    <script>\n        // 弹窗输出一句话\n        // 每一句 JS 代码以分号结尾！\n        alert(\'你好，JavaScript！\');\n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 效果图\n\n\n# 2.2 将 JS 代码单独保存为 .js 文件\n\n将 JS 代码单独保存为 .js 文件，然后在 HTML 文件中使用 <script src=""><\/script> 引入\n\n * 文件结构\n\n\n\n * index.html\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    \x3c!--\n    <script src="./js/index.js"><\/script>\n\t--\x3e\n</head>\n\n<body>\n    \x3c!-- 也可以放在 body 末尾（推荐）--\x3e\n    <script src="./js/index.js"><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * index.js\n\nalert(\'你好，JavaScript！\');\n\n\n1\n\n * 效果图\n\n> 以上两种 JS 的书写方法，对于复杂的 js 代码，强烈推荐第二种！\n\n\n# 三、认识输出语句\n\n * alert()：弹出消息框\n * console.log()：控制台输出\n\n\n# 3.1 alert()\n\nalert(\'周吉瑞\');\n\n\n1\n\n\n> alert：消息、警报\n\n * alert 是 JS 的内置函数\n * 调用函数需要使用圆括号 ()\n * 周吉瑞 是函数的参数，此处的参数是一个字符串（JS 的字符串用 \'\' 或 "" 包裹）\n * JS 语句末尾需要以 ; 结尾\n\n> 注意事项：\n> \n>  * JS 字符串支持 \'\' 和 ""，但是目前实际开发中 \'\' 用的更多，原因在于输入时可以不用按下 shift 键！\n> \n>  * JS 语法规定是需要在句末加上 ; 表示结束的！但是即便你不加 ;，JS 解析引擎也会帮你自动加上，但还是推荐手动加上 ;，因为极少数情况下会出现意外！\n> \n>  * JS 语法中的任何符号都应该是英文状态下的符号！\n\n【效果】\n\n【功能】\n\n在浏览器（JavaScript 引擎 例如：Chrome V8）解析到 JS 文件中的 alert() 语句时，便会中断 JS 脚本的执行，同时弹出消息框，直到用户单击确定后，才继续执行后续的 JS 脚本。\n\n\n# 3.2 console.log()\n\nconsole.log(\'周吉瑞\');\n\n\n1\n\n\n> console：控制台\n> \n> log：记录、日志\n\n * console 是 JS 的内置对象\n * 通过对象 “打点” 可以调用其内部的 log 方法（所谓 “方法” 就是对象能够调用的函数）\n\n【效果】\n\n> F12 打开浏览器调试面板，点击 Console 控制台菜单。\n\n【功能】\n\n在浏览器（JavaScript 引擎 例如：Chrome V8）解析到 JS 文件中的 console.log() 语句时，会直接在浏览器控制台输出语句，并自动继续执行后续的 JS 脚本。\n\n\n# 四、学会处理报错\n\n> JS 一但发生语句错误，那么后续的语句也就不执行了！\n> \n> 浏览器控制台会检测错误的类型及行号（行号不一定正确，但可以确定范围）\n> \n> 现代 IDE 一般具备智能自动检查功能，目前最智能的 JavaScript IDE：WebStorm（收费），VSCode（需要插件配合，免费轻量）\n\n * Uncaught SyntaxError: Invalid or unexpected token\n\n未捕获的语法错误：不合法或错误的符号。\n\n（中文符号错误、……）\n\n * Uncaught ReferenceError: jerry is not defined\n\n未捕获的引用错误：jerry 没有被定义。\n\n（字符串没有加引号、名称拼写错误、……）\n\n【学会 debugger】\n\n当我们需要调试 JavaScript 代码时，我们可以在代码的任何行上写上 debugger;，那么当执行到此处时，代码执行就会自动停止（相当于 “打断点”），当然我们也可以不加 debugger;，在调试时用鼠标点击的方式来 “打断点”，反正怎么方便怎么来！\n\n> 注意：debugger; 被成功执行的前提是工具开启了调试功能，否则该语句不起任何作用！（Chrome Source 窗口可以开启调试；VSCode 也支持本地调试……）\n\n\n# 五、变量\n\n变量：计算机语言中能储存计算结果或能表示值的抽象概念。\n\n> 变量不是数值本身，它们仅仅是一个用于存储数值的容器！\n\n\n# 5.1 定义变量\n\n要想使用变量，第一步就是声明它，并给它赋值。\n\nvar a = 24;\nvar b = \'周吉瑞\';\n\n\n1\n2\n\n * var 定义变量的关键字\n * a 变量名\n * = 赋值符号\n * 24 变量值\n\n\n# 5.2 使用变量\n\n当变量被赋值后，就可以使用它了。\n\nconsole.log(a);\nconsole.log(b);\n\n\n1\n2\n\n\n> 注意：使用变量时，变量名不能用引号包裹，否则会被识别为字符串！\n\n\n# 5.3 改变变量的值\n\n变量的值可以通过再次赋值被改变，改变变量的值时不需要再书写 var 关键字。\n\nvar a = 54;\na = 24;\nconsole.log(a);\n\n\n1\n2\n3\n\n\n\n# 5.4 变量的合法命名\n\n * 只能由 字母、数字、_、$ 组成，但不能以数字开头（建议普通代码一律以字母开头）\n * 不能是 关键字 或 保留字\n * 变量名大小写敏感，a 和 A 是两个不同的变量\n\n> 函数、类名、对象的属性等也都要遵守这个标识符的命名规则！\n\n\n# 5.5 推荐的变量命名风格\n\n * 小驼峰命名法：mathTestScore（吐血推荐）\n * C 风格变量命名法：math_test_score\n\n>  * 驼峰命名法：Java、JavaScript\n> \n>  * 下划线命名法：C、C++、Python、Golang、SQL\n\n\n# 5.6 变量的默认值\n\n * 一个变量只定义，但没有赋初值，默认值是 undefined（未定义）\n * 一个变量只有被 var 定义，并赋初值之后，才算正式初始化完成\n\nvar a;\t// 只定义但没有赋初值\nconsole.log(a);\t// undefined\na = 24;\nconsole.log(a);\t// 24\n\n\n1\n2\n3\n4\n\n\n\n# 5.7 变量的常见错误\n\n * 不用 var 定义，而直接将值赋予它，虽然不引发报错，但会产生严重的作用域问题。\n\n> 请一律加上 var ！\n\na = 24; // 未使用 var 定义的变量默认为全局变量！成为 window 对象的属性。\nconsole.log(a);\t// 24\nconsole.log(window.a);\t// 24\nconsole.log(window.a === a);\t// true\n\n\n1\n2\n3\n4\n\n\n> 关于作用域的问题，后面会介绍。\n\n * 尝试使用一个既没有被 var 定义过，也没有赋过值的变量，就会产生引用错误。\n\nconsole.log(c);\n// index.js:1 Uncaught ReferenceError: c is not defined at index.js:1\n\n\n1\n2\n\n\n> 使用 strict 严格模式\n> \n> JavaScript 在设计之初，为了方便初学者学习，并不强制要求用 var 申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过 var 申明就被使用，那么该变量就自动被申明为全局变量：\n> \n> i = 10; // i 现在是全局变量\n> \n> \n> 1\n> \n> \n> 在同一个 HTML 页面的不同的 JavaScript 文件中，如果都不用 var 申明，恰好都使用了变量 i，将造成变量 i 互相影响，产生难以调试的错误结果。\n> \n> 使用 var 申明的变量则不是全局变量，它的范围被限制在该变量被申明的 JS 文件或函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。\n> \n> 为了修补 JavaScript 这一严重设计缺陷，ECMA 在后续规范中推出了 strict 模式，在 strict 模式下运行的 JavaScript 代码，强制通过 var 申明变量，未使用 var 申明变量就使用的，将导致运行错误。\n> \n> 启用 strict 模式的方法是在 JavaScript 代码的第一行写上：\n> \n> "use strict";\n> \n> \n> 1\n> \n> \n> 这是一个字符串，不支持 strict 模式的浏览器会把它当做一个字符串语句执行，支持 strict 模式的浏览器将开启 strict 模式运行 JavaScript。\n> \n> "use strict";\n> abc = "Hello, world";\n> console.log(abc);\n> // 如果浏览器支持 strict 模式，\n> // 下面的代码将报 ReferenceError 错误：Uncaught ReferenceError: abc is not defined\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 不用 var 申明的变量会被视为全局变量，为了避免这一缺陷，所有的 JavaScript 代码都推荐使用 strict 模式。\n> \n> 提示："use strict" 语句可以放在 JS 代码的任意一行上，并且它只对它所在作用域下方的代码起作用。\n\n\n# 5.8 等号表示赋值\n\nvar a = 10;\na = a + 1;\nconsole.log(a);\t// 11\na = a - 1;\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.9 同时声明多个变量\n\nvar a = 0, b = 1, c = 2;\t// 建议每行只声明一个变量\n\n\n1\n\n\n\n# 六、变量声明提升\n\n * 变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\n * 在执行所有代码前，JS 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\n\n// 先使用变量（不会报错）\nconsole.log(a);\t// undefined\n// 后定义变量\nvar a = 10;\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n\n\n实际的情况相当于：\n\n// 变量声明提升的只是定义，不提升赋值！！！\nvar a;\nconsole.log(a); // undefined\na = 10;\nconsole.log(a); // 10\n\n\n1\n2\n3\n4\n5\n\n\n【注意事项】\n\n * 变量声明提升是 JS 的独有特性！\n * 在实际开发中，不要刻意使用变量提升的特性，一定要先定义再使用！\n * 严格模式对变量提升没有约束作用，严格模式是不对变量提升进行报错的！',normalizedContent:'# 【js语法与变量】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、初识javascript\n\n\n# 1.1 前端三层\n\n      语言           功能\n结构层   html         搭建结构、放置部件、描述语义\n样式层   css          美化网页、实现布局\n行为层   javascript   实现交互效果、数据收发、表单验证等\n\n\n# 1.2 javascript 历史\n\n创始人：布兰登·艾奇\n\n * 1995 年艾奇在美国网景公司发明了 livescript\n * 网景公司与 sun 公司合作，为了宣传改名为 javascript\n\n> javascript 与 java 没有半毛钱关系！非要有关系，那就是都与 sun 公司有关。\n\n目前 javascript 已经完全垄断了浏览器端脚本！\n\n如今 javascript 功能非常强大，未来还会越来越强大！\n\n\n# 1.3 什么是前端语言和后端语言\n\n前端语言：处理界面（html、css、javascript、……）\n\n后端语言：处理数据（java、php、python、go、……）\n\n（浏览器）前端 <———— http 协议 ————> 后端（服务器）\n\n> 传统的 js 是一门前端语言，只能运行在浏览器端，不能在服务器端处理数据，且不能独立于浏览器存在，不能脱离 html！\n\n在 2009 年，诞生了 node.js，这是一个 javascript 的服务端运行平台。\n\n> node.js 出现后，javascript 可以独立于浏览器运行，可以用来写服务器端（后端）！\n\n所以，javascript 是一门可以 “上天入地” 的语言！\n\n可以说，javascript 是一门真正意义上的 “全栈” 语言！\n\n\n# 1.4 ecmascript 是 javascript 的标准\n\n1997 年，欧洲计算机制造商协会（ecma）颁布了 javascript 的标准，命名为 ecmascript。\n\n> ecmascript 简称 es，javascript 简称 js。\n\n * javascript 实现了 ecmascript\n\n * ecmascript 规范了 javascript\n\n\n# 1.5 javascript 体系\n\n * 语言核心\n   * es5（现阶段学习目标）\n   * es6（后期学习目标）、es7、es8、es9、……\n * dom（操纵 html）\n * bom（操作 浏览器）\n\n\n# 1.6 javascript 的语言风格和特性\n\n * 类 c 语言风格，容易上手\n * 弱类型（动态类型），简单易学\n * 丰富的功能，无敌的生态，强大的性能\n\n> 弱类型既是 js 的优点，也是 js 的缺点！在 js 诞生之初，js 只是一个控制浏览器网页的小型脚本语言，所以最初设计 js 时去掉了类型系统，因为类型系统需要涉及到复杂的语法校验和编译过程，得不偿失。后来随着前端的不断发展，js 所开发的项目越来越复杂，js 弱类型的特性反而变成了 js 的劣势！所以最近几年微软出品的 typescript 越来越火，ts 就是一个 js 的超集，在 js 的基础上提供了类型系统的一门全新的语言，并且 ts 代码可以编译为纯 js 代码运行到 js 能运行的任何地方！所以 typescript 未来一定是前端开发的趋势……，我们在掌握好 js 后，最好去学习一下 ts！\n\n\n# 二、js的书写位置\n\n * 在 <body> 中的 <script> 标签中书写 js 代码\n * 将 js 代码单独保存为 .js 文件，然后在 html 文件中使用 <script src=""><\/script> 引入\n\n> javascript 不能脱离 html 网页运行！\n> \n> （当然，今后学习 node.js 后，javascript 可以运行在独立的平台中）\n\n\n# 2.1 在 <body> 中书写 js 代码\n\n在 <body> 中的 <script> 标签中书写 js 代码\n\n * index.html\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>document</title>\n</head>\n\n<body>\n    \x3c!-- 在 html5 之前，必须要加上 type 属性，并且里面的内容一定要正确！--\x3e\n    \x3c!-- \n    <script type="text/javascript">\n    <\/script> \n    --\x3e\n\n    \x3c!-- 目前都是使用 html5，所以不用写 type 属性，默认就是 js --\x3e\n    \x3c!-- 推荐把 <script> 写到 body 的末尾（避免 js 发生阻塞时页面受到牵连）--\x3e\n    <script>\n        // 弹窗输出一句话\n        // 每一句 js 代码以分号结尾！\n        alert(\'你好，javascript！\');\n    <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 效果图\n\n\n# 2.2 将 js 代码单独保存为 .js 文件\n\n将 js 代码单独保存为 .js 文件，然后在 html 文件中使用 <script src=""><\/script> 引入\n\n * 文件结构\n\n\n\n * index.html\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>document</title>\n    \x3c!--\n    <script src="./js/index.js"><\/script>\n\t--\x3e\n</head>\n\n<body>\n    \x3c!-- 也可以放在 body 末尾（推荐）--\x3e\n    <script src="./js/index.js"><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * index.js\n\nalert(\'你好，javascript！\');\n\n\n1\n\n * 效果图\n\n> 以上两种 js 的书写方法，对于复杂的 js 代码，强烈推荐第二种！\n\n\n# 三、认识输出语句\n\n * alert()：弹出消息框\n * console.log()：控制台输出\n\n\n# 3.1 alert()\n\nalert(\'周吉瑞\');\n\n\n1\n\n\n> alert：消息、警报\n\n * alert 是 js 的内置函数\n * 调用函数需要使用圆括号 ()\n * 周吉瑞 是函数的参数，此处的参数是一个字符串（js 的字符串用 \'\' 或 "" 包裹）\n * js 语句末尾需要以 ; 结尾\n\n> 注意事项：\n> \n>  * js 字符串支持 \'\' 和 ""，但是目前实际开发中 \'\' 用的更多，原因在于输入时可以不用按下 shift 键！\n> \n>  * js 语法规定是需要在句末加上 ; 表示结束的！但是即便你不加 ;，js 解析引擎也会帮你自动加上，但还是推荐手动加上 ;，因为极少数情况下会出现意外！\n> \n>  * js 语法中的任何符号都应该是英文状态下的符号！\n\n【效果】\n\n【功能】\n\n在浏览器（javascript 引擎 例如：chrome v8）解析到 js 文件中的 alert() 语句时，便会中断 js 脚本的执行，同时弹出消息框，直到用户单击确定后，才继续执行后续的 js 脚本。\n\n\n# 3.2 console.log()\n\nconsole.log(\'周吉瑞\');\n\n\n1\n\n\n> console：控制台\n> \n> log：记录、日志\n\n * console 是 js 的内置对象\n * 通过对象 “打点” 可以调用其内部的 log 方法（所谓 “方法” 就是对象能够调用的函数）\n\n【效果】\n\n> f12 打开浏览器调试面板，点击 console 控制台菜单。\n\n【功能】\n\n在浏览器（javascript 引擎 例如：chrome v8）解析到 js 文件中的 console.log() 语句时，会直接在浏览器控制台输出语句，并自动继续执行后续的 js 脚本。\n\n\n# 四、学会处理报错\n\n> js 一但发生语句错误，那么后续的语句也就不执行了！\n> \n> 浏览器控制台会检测错误的类型及行号（行号不一定正确，但可以确定范围）\n> \n> 现代 ide 一般具备智能自动检查功能，目前最智能的 javascript ide：webstorm（收费），vscode（需要插件配合，免费轻量）\n\n * uncaught syntaxerror: invalid or unexpected token\n\n未捕获的语法错误：不合法或错误的符号。\n\n（中文符号错误、……）\n\n * uncaught referenceerror: jerry is not defined\n\n未捕获的引用错误：jerry 没有被定义。\n\n（字符串没有加引号、名称拼写错误、……）\n\n【学会 debugger】\n\n当我们需要调试 javascript 代码时，我们可以在代码的任何行上写上 debugger;，那么当执行到此处时，代码执行就会自动停止（相当于 “打断点”），当然我们也可以不加 debugger;，在调试时用鼠标点击的方式来 “打断点”，反正怎么方便怎么来！\n\n> 注意：debugger; 被成功执行的前提是工具开启了调试功能，否则该语句不起任何作用！（chrome source 窗口可以开启调试；vscode 也支持本地调试……）\n\n\n# 五、变量\n\n变量：计算机语言中能储存计算结果或能表示值的抽象概念。\n\n> 变量不是数值本身，它们仅仅是一个用于存储数值的容器！\n\n\n# 5.1 定义变量\n\n要想使用变量，第一步就是声明它，并给它赋值。\n\nvar a = 24;\nvar b = \'周吉瑞\';\n\n\n1\n2\n\n * var 定义变量的关键字\n * a 变量名\n * = 赋值符号\n * 24 变量值\n\n\n# 5.2 使用变量\n\n当变量被赋值后，就可以使用它了。\n\nconsole.log(a);\nconsole.log(b);\n\n\n1\n2\n\n\n> 注意：使用变量时，变量名不能用引号包裹，否则会被识别为字符串！\n\n\n# 5.3 改变变量的值\n\n变量的值可以通过再次赋值被改变，改变变量的值时不需要再书写 var 关键字。\n\nvar a = 54;\na = 24;\nconsole.log(a);\n\n\n1\n2\n3\n\n\n\n# 5.4 变量的合法命名\n\n * 只能由 字母、数字、_、$ 组成，但不能以数字开头（建议普通代码一律以字母开头）\n * 不能是 关键字 或 保留字\n * 变量名大小写敏感，a 和 a 是两个不同的变量\n\n> 函数、类名、对象的属性等也都要遵守这个标识符的命名规则！\n\n\n# 5.5 推荐的变量命名风格\n\n * 小驼峰命名法：mathtestscore（吐血推荐）\n * c 风格变量命名法：math_test_score\n\n>  * 驼峰命名法：java、javascript\n> \n>  * 下划线命名法：c、c++、python、golang、sql\n\n\n# 5.6 变量的默认值\n\n * 一个变量只定义，但没有赋初值，默认值是 undefined（未定义）\n * 一个变量只有被 var 定义，并赋初值之后，才算正式初始化完成\n\nvar a;\t// 只定义但没有赋初值\nconsole.log(a);\t// undefined\na = 24;\nconsole.log(a);\t// 24\n\n\n1\n2\n3\n4\n\n\n\n# 5.7 变量的常见错误\n\n * 不用 var 定义，而直接将值赋予它，虽然不引发报错，但会产生严重的作用域问题。\n\n> 请一律加上 var ！\n\na = 24; // 未使用 var 定义的变量默认为全局变量！成为 window 对象的属性。\nconsole.log(a);\t// 24\nconsole.log(window.a);\t// 24\nconsole.log(window.a === a);\t// true\n\n\n1\n2\n3\n4\n\n\n> 关于作用域的问题，后面会介绍。\n\n * 尝试使用一个既没有被 var 定义过，也没有赋过值的变量，就会产生引用错误。\n\nconsole.log(c);\n// index.js:1 uncaught referenceerror: c is not defined at index.js:1\n\n\n1\n2\n\n\n> 使用 strict 严格模式\n> \n> javascript 在设计之初，为了方便初学者学习，并不强制要求用 var 申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过 var 申明就被使用，那么该变量就自动被申明为全局变量：\n> \n> i = 10; // i 现在是全局变量\n> \n> \n> 1\n> \n> \n> 在同一个 html 页面的不同的 javascript 文件中，如果都不用 var 申明，恰好都使用了变量 i，将造成变量 i 互相影响，产生难以调试的错误结果。\n> \n> 使用 var 申明的变量则不是全局变量，它的范围被限制在该变量被申明的 js 文件或函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。\n> \n> 为了修补 javascript 这一严重设计缺陷，ecma 在后续规范中推出了 strict 模式，在 strict 模式下运行的 javascript 代码，强制通过 var 申明变量，未使用 var 申明变量就使用的，将导致运行错误。\n> \n> 启用 strict 模式的方法是在 javascript 代码的第一行写上：\n> \n> "use strict";\n> \n> \n> 1\n> \n> \n> 这是一个字符串，不支持 strict 模式的浏览器会把它当做一个字符串语句执行，支持 strict 模式的浏览器将开启 strict 模式运行 javascript。\n> \n> "use strict";\n> abc = "hello, world";\n> console.log(abc);\n> // 如果浏览器支持 strict 模式，\n> // 下面的代码将报 referenceerror 错误：uncaught referenceerror: abc is not defined\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> \n> \n> 不用 var 申明的变量会被视为全局变量，为了避免这一缺陷，所有的 javascript 代码都推荐使用 strict 模式。\n> \n> 提示："use strict" 语句可以放在 js 代码的任意一行上，并且它只对它所在作用域下方的代码起作用。\n\n\n# 5.8 等号表示赋值\n\nvar a = 10;\na = a + 1;\nconsole.log(a);\t// 11\na = a - 1;\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5.9 同时声明多个变量\n\nvar a = 0, b = 1, c = 2;\t// 建议每行只声明一个变量\n\n\n1\n\n\n\n# 六、变量声明提升\n\n * 变量声明的提升：可以提前使用一个稍后才声明的变量，而不会引发异常\n * 在执行所有代码前，js 有预解析阶段，会预读所有变量的声明（不会提升赋值，只会提升定义）\n\n// 先使用变量（不会报错）\nconsole.log(a);\t// undefined\n// 后定义变量\nvar a = 10;\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n\n\n实际的情况相当于：\n\n// 变量声明提升的只是定义，不提升赋值！！！\nvar a;\nconsole.log(a); // undefined\na = 10;\nconsole.log(a); // 10\n\n\n1\n2\n3\n4\n5\n\n\n【注意事项】\n\n * 变量声明提升是 js 的独有特性！\n * 在实际开发中，不要刻意使用变量提升的特性，一定要先定义再使用！\n * 严格模式对变量提升没有约束作用，严格模式是不对变量提升进行报错的！',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS基本数据类型",frontmatter:{title:"JS基本数据类型",date:"2020-04-30T12:00:27.000Z",permalink:"/pages/6f1d80/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/02.JS%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"20.JS/10.基础/02.JS基本数据类型.md",key:"v-72bd17b5",path:"/pages/6f1d80/",headers:[{level:2,title:"1.1 JavaScript 中两大数据类型",slug:"_1-1-javascript-中两大数据类型",normalizedTitle:"1.1 javascript 中两大数据类型",charIndex:50},{level:2,title:"1.2 typeof 运算符",slug:"_1-2-typeof-运算符",normalizedTitle:"1.2 typeof 运算符",charIndex:309},{level:2,title:"1.3 5种基本数据类型的 typeof 检测结果",slug:"_1-3-5种基本数据类型的-typeof-检测结果",normalizedTitle:"1.3 5种基本数据类型的 typeof 检测结果",charIndex:643},{level:2,title:"2.1 一切数都是数字类型",slug:"_2-1-一切数都是数字类型",normalizedTitle:"2.1 一切数都是数字类型",charIndex:955},{level:2,title:"2.2 小数中 0 可以省略",slug:"_2-2-小数中-0-可以省略",normalizedTitle:"2.2 小数中 0 可以省略",charIndex:1084},{level:2,title:"2.3 科学计数法",slug:"_2-3-科学计数法",normalizedTitle:"2.3 科学计数法",charIndex:1127},{level:2,title:"2.4 不同进制的数字",slug:"_2-4-不同进制的数字",normalizedTitle:"2.4 不同进制的数字",charIndex:1259},{level:2,title:"2.5 一个特殊的数字型值 NaN",slug:"_2-5-一个特殊的数字型值-nan",normalizedTitle:"2.5 一个特殊的数字型值 nan",charIndex:1393},{level:2,title:"3.1 字符串的表示",slug:"_3-1-字符串的表示",normalizedTitle:"3.1 字符串的表示",charIndex:1866},{level:2,title:"3.2 字符串的拼接",slug:"_3-2-字符串的拼接",normalizedTitle:"3.2 字符串的拼接",charIndex:2067},{level:2,title:"3.3 字符串和变量的拼接",slug:"_3-3-字符串和变量的拼接",normalizedTitle:"3.3 字符串和变量的拼接",charIndex:2159},{level:2,title:"3.4 空字符串",slug:"_3-4-空字符串",normalizedTitle:"3.4 空字符串",charIndex:2468},{level:2,title:"3.5 字符串的 length 属性",slug:"_3-5-字符串的-length-属性",normalizedTitle:"3.5 字符串的 length 属性",charIndex:2696},{level:2,title:"3.6 字符串的常用方法",slug:"_3-6-字符串的常用方法",normalizedTitle:"3.6 字符串的常用方法",charIndex:2952},{level:3,title:"3.6.1 charAt() 方法",slug:"_3-6-1-charat-方法",normalizedTitle:"3.6.1 charat() 方法",charIndex:3288},{level:3,title:"3.6.2 substring()、substr() 和 slice() 方法",slug:"_3-6-2-substring-、substr-和-slice-方法",normalizedTitle:"3.6.2 substring()、substr() 和 slice() 方法",charIndex:3704},{level:3,title:"3.6.3 toUpperCase() 和 toLowerCase() 方法",slug:"_3-6-3-touppercase-和-tolowercase-方法",normalizedTitle:"3.6.3 touppercase() 和 tolowercase() 方法",charIndex:4891},{level:3,title:"3.6.4 indexOf() 方法",slug:"_3-6-4-indexof-方法",normalizedTitle:"3.6.4 indexof() 方法",charIndex:5351},{level:3,title:"3.6.5 trim()、trimStart()、trimEnd() 方法",slug:"_3-6-5-trim-、trimstart-、trimend-方法",normalizedTitle:"3.6.5 trim()、trimstart()、trimend() 方法",charIndex:5562},{level:2,title:"7.1 其他值 ——> 数字",slug:"_7-1-其他值-数字",normalizedTitle:"7.1 其他值 ——&gt; 数字",charIndex:null},{level:3,title:"7.1.1 使用 Number() 函数",slug:"_7-1-1-使用-number-函数",normalizedTitle:"7.1.1 使用 number() 函数",charIndex:6726},{level:3,title:"7.1.2 使用 parseInt() 函数",slug:"_7-1-2-使用-parseint-函数",normalizedTitle:"7.1.2 使用 parseint() 函数",charIndex:7308},{level:3,title:"7.1.3 使用 parseFloat() 函数",slug:"_7-1-3-使用-parsefloat-函数",normalizedTitle:"7.1.3 使用 parsefloat() 函数",charIndex:8069},{level:2,title:"7.2 其他值 ——> 字符串",slug:"_7-2-其他值-字符串",normalizedTitle:"7.2 其他值 ——&gt; 字符串",charIndex:null},{level:3,title:"7.2.1 使用 String() 函数",slug:"_7-2-1-使用-string-函数",normalizedTitle:"7.2.1 使用 string() 函数",charIndex:8382},{level:3,title:"7.2.2 使用 toString() 方法",slug:"_7-2-2-使用-tostring-方法",normalizedTitle:"7.2.2 使用 tostring() 方法",charIndex:8914},{level:2,title:"7.3 其他值 ——> 布尔值",slug:"_7-3-其他值-布尔值",normalizedTitle:"7.3 其他值 ——&gt; 布尔值",charIndex:null}],headersStr:"1.1 JavaScript 中两大数据类型 1.2 typeof 运算符 1.3 5种基本数据类型的 typeof 检测结果 2.1 一切数都是数字类型 2.2 小数中 0 可以省略 2.3 科学计数法 2.4 不同进制的数字 2.5 一个特殊的数字型值 NaN 3.1 字符串的表示 3.2 字符串的拼接 3.3 字符串和变量的拼接 3.4 空字符串 3.5 字符串的 length 属性 3.6 字符串的常用方法 3.6.1 charAt() 方法 3.6.2 substring()、substr() 和 slice() 方法 3.6.3 toUpperCase() 和 toLowerCase() 方法 3.6.4 indexOf() 方法 3.6.5 trim()、trimStart()、trimEnd() 方法 7.1 其他值 ——> 数字 7.1.1 使用 Number() 函数 7.1.2 使用 parseInt() 函数 7.1.3 使用 parseFloat() 函数 7.2 其他值 ——> 字符串 7.2.1 使用 String() 函数 7.2.2 使用 toString() 方法 7.3 其他值 ——> 布尔值",content:"# 【JS基本数据类型】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、数据类型简介和检测\n\n\n# 1.1 JavaScript 中两大数据类型\n\n（1）基本数据类型\n\n> JS 没有字符型（char），JS 的 String 是基本类型！\n\n * Number（数字）\n * String（字符串）\n * Boolean（布尔）\n * Undefined（未定义）\n * Null（空）\n\n（2）复杂数据类型\n\n * Object（对象）\n * Array（数组）\n * Function（函数）\n * RegExp（正则表达式）\n * Date\n * Map\n * Set\n * Symbol\n * ……\n\n\n# 1.2 typeof 运算符\n\n使用 typeof 运算符可以检测值或者变量的类型。\n\n> typeof 是一个运算符，而不是内置函数，所以不用加 ()，如果加了也不会报错，但是并不推荐！\n\ntypeof 5;\t\t  // number\ntypeof '周吉瑞';\t// string\n\n\n1\n2\n\n\n> 利用浏览器控制台进行交互测试……\n\nconsole.log(typeof 5);\nconsole.log(typeof '周吉瑞');\nvar a = '5';\nconsole.log(typeof a);\n\n\n1\n2\n3\n4\n\n\n> 从以上测试也可以看出，JS 是一个弱类型的语言，变量值是什么类型，那么变量就是什么类型，而不用显式地指出变量的类型。\n\n\n# 1.3 5种基本数据类型的 typeof 检测结果\n\n类型名            TYPEOF 检测结果        值举例\n数字类型           number             5、2.5、-0.5\n字符串类型          string             '前端'、\"后端\"、'3.14'\n布尔类型           boolean            true、false\nundefined 类型   undefined          undefined\nnull 类型        object（可以理解为空对象）   null\n\n\n# 二、Number（数字）类型\n\n\n# 2.1 一切数都是数字类型\n\n在 JS 中，所有数字不分大小、不分整浮、不分正负，都是数字类型。\n\ntypeof 925; // number\ntypeof 0.5; // number\ntypeof -24; // number\n\n\n1\n2\n3\n\n\n\n# 2.2 小数中 0 可以省略\n\n在表达小数的时候，整数个位的 0 可以省略。\n\n\n# 2.3 科学计数法\n\n较大数或较小数可以写成科学计数法。\n\n3e8;\t\t\t// 300000000\ntypeof 3e8;\t\t// number\n\n3e-4;\t\t\t// 0.0003\ntypeof 3e-4;\t// number\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.4 不同进制的数字\n\n（1）二进制数值以 0b 开头\n\n0b10;\t// 2\n0b1111;\t// 15\n\n\n1\n2\n\n\n（2）八进制数值以 0 开头\n\n017;\t// 15\n\n\n1\n\n\n（3）十六进制数值以 0x 开头\n\n0xf;\t// 15\n\n\n1\n\n\n\n# 2.5 一个特殊的数字型值 NaN\n\nNaN 是 “not a number” 的意思，即 “不是一个数”，但它属于数字类型。\n\ntypeof NaN;\t// number\n\n\n1\n\n * 0 除以 0 的结果是 NaN，事实上，在 JS 数学运算中，若结果不能得到数字，其结果往往都是 NaN\n * NaN 有一个 “奇怪” 的性质：不自等（这个知识点将在后续课程中讲解）\n\n0 / 0;\t// NaN\n5 - 3;\t// 2\n'我' - '你';\t// NaN\n'我' * '你';\t// NaN\n'我' / '你';\t// NaN\n'我' + '你';\t// \"我你\"（字符串遇到加法是拼接功能）\nNaN == NaN;   // false（NaN 不自等）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 再次强调：NaN 是一个值（特殊的值），不是类型。\n> \n> 唯一能判断 NaN 的方法是通过 isNaN() 函数：\n> \n> isNaN(NaN); // true\n> \n> \n> 1\n\n\n# 三、String（字符串）类型\n\n\n# 3.1 字符串的表示\n\n字符串要用引号包裹，双引号或者单引号均可（无论用哪种，都应该保持风格统一）。\n\n注意：大部分 JS 项目习惯约定使用单引号（因为可以减少按下 shift 键）。\n\ntypeof \"周吉瑞\";\t// string\n或\ntypeof '周吉瑞';\t// string\n\n\n1\n2\n3\n\n\n数字 10 和字符串 '10' 在语义上是不同的，前者表示一个数量，后者是一个文本。\n\n\n# 3.2 字符串的拼接\n\n加号可以用来拼接多个字符串。\n\n'周' + '吉瑞';\t// \"周吉瑞\"\n'abc' + 'd' + 'ef';\t// \"abcdef\"\n\n\n1\n2\n\n\n\n# 3.3 字符串和变量的拼接\n\n要将一个变量的值 “插入” 到字符串中，要满足变量左右两边至少有一边 + 字符串。\n\nvar year = 2022;\nvar str = '北京冬奥会在' + year + '年召开';\t// \"北京冬奥会在2022年召开\"\n\nvar a = 24;\nvar str1 = 54 + a;\t\t// 78\nvar str2 = '54' + a;\t// \"5424\"\n\n1 + '10'; // \"110\"\n\n2 + '';\t// \"2\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> ES6 中增加了反引号 ( ` ) 表示法，可以更方便进行变量插值，后面会进行介绍。\n\n\n# 3.4 空字符串\n\n一些时候需要使用空字符串，直接书写闭合的引号对即可。\n\nvar str = \"\";\n或\nvar str = '';\n\n\n1\n2\n3\n\n\n空字符串可以用于将变量变为字符串！\n\nvar a = 24;\nconsole.log(typeof a);\t// number\na = a + '';\nconsole.log(a);\t// \"24\"\nconsole.log(typeof a);\t// string\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.5 字符串的 length 属性\n\n> 通过对 String 类型 “打点” 的方式，可以调用其内置属性。\n> \n> > 注意：在 JS 中，String 是基本类型，之所以 String 可以 “打点” 调用属性和方法，那是因为 JS 的解释器会自动将基本类型包装成对应的 Object 类型。\n\n字符串的 length 属性表示字符串的长度。\n\n'我喜欢JS'.length;\t// 5\n'我喜欢JS，我也喜欢TS'.length;\t// 12\n''.length;\t// 0\n\n\n1\n2\n3\n\n\n\n# 3.6 字符串的常用方法\n\n> 通过对 String 类型 “打点” 的方式，可以调用其内置方法。\n\n“方法” 就是能够打点调用的函数，字符串类型有丰富的内置方法。\n\n方法              功能\ncharAt()        得到指定位置字符\nsubstring()     提取子串\nsubstr()        提取子串\nslice()         提取子串\ntoUpperCase()   将字符串变为大写\ntoLowerCase()   将字符串变为小写\nindexOf()       检索字符串\ntrim()          删除首尾空格\ntrimStart()     删除首部空格\ntrimEnd()       删除尾部空格\n\n\n# 3.6.1 charAt() 方法\n\ncharAt() 方法可以得到指定位置的字符。\n\n字符串中的每个字符都按顺序编号，编号从 0 开始。\n\n'   我   喜   欢   J   S   ,   我   也   喜   欢   N    O    D    E    '\n    0   1   2   3   4   5   6   7   8   9   10   11   12   13   \n\n'我喜欢JS，我也喜欢NODE'.charAt(0);\t\t// \"我\"\n'我喜欢JS，我也喜欢NODE'.charAt(5);\t\t// \"，\"\n'我喜欢JS，我也喜欢NODE'.charAt(11);\t// \"O\"\n'我喜欢JS，我也喜欢NODE'.charAt(99);\t// \"\"\n'我喜欢JS，我也喜欢NODE'.charAt(-1);\t// \"\"\n\n\n1\n2\n3\n4\n5\n\n\n> 超出范围的输出空字符 \"\"。\n\n\n# 3.6.2 substring()、substr() 和 slice() 方法\n\n（1）substring(a, b) 方法得到从 a 开始到 b 结束（不包括 b 处）的子串 [a, b)\n\n> 编程语言的区间一般都是：左闭右开！\n\n'我喜欢JS，我也喜欢NODE'.substring(3, 5);\t\t// \"JS\"\n'我喜欢JS，我也喜欢NODE'.substring(10, 14);\t\t// \"NODE\"\n'我喜欢JS，我也喜欢NODE'.substring(10, 99);\t\t// \"NODE\"\n'我喜欢JS，我也喜欢NODE'.substring(-1, 4);\t\t// \"我喜欢J\"\n\n\n1\n2\n3\n4\n\n\n> 超出范围的部分，取到端点字符！\n\n * substring(a, b) 方法如果省略第二个参数，返回的子串会一直到字符串的结尾\n\n'我喜欢JS，我也喜欢NODE'.substring(6);\t\t// \"我也喜欢NODE\"\n\n\n1\n\n * substring(a, b) 中，a 可以大于 b，数字顺序将自动调整为小数在前\n\n> 应该没有人会这样用^^\n\n'我喜欢JS，我也喜欢NODE'.substring(3, 5);\t\t// \"JS\"\n'我喜欢JS，我也喜欢NODE'.substring(5, 3);\t\t// \"JS\"\n\n\n1\n2\n\n\n（2）substr(a, b) 中，将得到从 a 开始的长度为 b 的子串\n\n'我喜欢JS，我也喜欢NODE'.substr(3, 2);\t\t// \"JS\"\n\n\n1\n\n * substr(a, b) 中，b 可以省略，表示到字符串结尾\n\n'我喜欢JS，我也喜欢NODE'.substr(3);\t\t// \"JS，我也喜欢NODE\"\n\n\n1\n\n * substr(a, b) 中，a 可以是负数，表示倒数位置\n\n> 倒数第一位为 -1，而不是 -0\n\n'我喜欢JS，我也喜欢NODE'.substr(-4, 2);\t\t// \"NO\"\n\n\n1\n\n\n（3）slice(a, b) 方法得到从 a 开始到 b 结束（不包括 b 处）的子串\n\n> slice：切片\n\n'我喜欢JS，我也喜欢NODE'.slice(3, 5);\t\t// \"JS\"\n\n\n1\n\n * slice(a, b) 的参数 a 可以是负数（与 substring(a, b) 的区别）\n\n'我喜欢JS，我也喜欢NODE'.slice(-4, -1);\t\t// \"NOD\"\n// (-4, -1)：从 倒数第4位 到 倒数第1位，不包括 倒数第1位\n\n\n1\n2\n\n * slice(a, b) 中，参数 a 必须小于参数 b，否则便会返回一个空字符串\n\n'我喜欢JS，我也喜欢NODE'.slice(5, 2);\t\t// \"\"\n\n\n1\n\n\n\n# 3.6.3 toUpperCase() 和 toLowerCase() 方法\n\n * toUpperCase() 转为大写\n * toLowerCase() 转为小写\n\n'I Love You'.toUpperCase();\t\t// \"I LOVE YOU\"\n'IMooc'.toLowerCase();\t\t    // \"imooc\"\n\n\n1\n2\n\n\n> 注意：toUpperCase() 和 toLowerCase()，只是返回一个大小写格式，变量本身的值并没有改变。\n> \n> var str = \"I Love You\";\n> console.log(str.toUpperCase());\t\t// \"I LOVE YOU\"\n> console.log(str);\t\t\t\t    // \"I Love You\"\n> str = str.toUpperCase();\n> console.log(str);\t\t\t\t    // \"I LOVE YOU\"\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 3.6.4 indexOf() 方法\n\nindexOf() 方法返回某个指定的字符串值在字符串中首次出现的位置\n\n如果要检索的字符串没有出现，则返回 -1\n\n这个方法用于判断字符串是否包含目标子串时特别有用！\n\n'abcdebb'.indexOf('b');\t\t// 1\n'abcdebb'.indexOf('deb');\t// 3\n'abcdebb'.indexOf('m');\t\t// -1\n\n\n1\n2\n3\n\n\n\n# 3.6.5 trim()、trimStart()、trimEnd() 方法\n\n// 删除首尾空格\nconsole.log('---' + ' 123 '.trim() + '---');\n// 删除首部空格\nconsole.log('---' + ' 123 '.trimStart() + '---');\n// 删除尾部空格\nconsole.log('---' + ' 123 '.trimEnd() + '---');\n\n/*\n---123---\n---123 ---\n--- 123---\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、Boolean（布尔）类型\n\n在计算机领域，几乎所有的 “真” 和 “假” 都归为布尔类型值。\n\n布尔类型值只有两个：true 和 false，分别表示 真 和 假。\n\ntypeof true;\t// boolean\ntypeof false;\t// boolean\n\n\n1\n2\n\n\n> 布尔类型在 关系运算 和 逻辑运算 中广泛运用。\n\n3 < 5;\t  // true\n5 > 3; \t  // true \n5 >= 100; // false\n\n\n1\n2\n3\n\n\n> 注意：在 JS 中，1 可以 “代表” true，0 或 -0 可以 “代表” false，原理是类型的自动转换，但非常不建议以数字来代替布尔值！\n\n\n# 五、Undefined 类型\n\n一个没有赋值的变量的默认值是 undefined，而 undefined 的类型也是 undefined。\n\n即：undefined 既是类型，又是值（且这种类型只有一个唯一的值：就是它自身）。\n\ntypeof undefined;\t// undefined\n\n\n1\n\n\n> 实际开发中，一般不会给某个变量赋值为 undefined，但是我们会检查一个变量的值是否为 undefined。\n\n> 在变量声明提升的时候，会出现 undefined，要注意！\n\n\n# 六、Null 类型\n\nnull 表示 “空”，可以理解为它是 “空对象”。\n\n当我们需要将对象销毁、数组销毁或者删除事件监听时，通常将它们设置为 null。\n\nbox.onclick = null;\n// 删除点击事件\n\n\n1\n2\n\n\n用 typeof 检测 null 结果为 object。\n\ntypeof null;\t// object\n\n\n1\n\n\n> 狭义上，null 可以理解为 “空对象”，这样可以合理的解释为什么 null 的类型为 object。\n> \n> 但是准确的来说，null 不是一个 “对象”，它是一个独立的 “基本数据类型”。\n\n\n# 七、数据类型的转换\n\n\n# 7.1 其他值 ——> 数字\n\n\n# 7.1.1 使用 Number() 函数\n\nNumber() 函数是 JS 内置函数。\n\n> 由于 Number() 属于内置构造函数，所以 Number() 的首字母 N 要大写。\n\n（1）字符串 ——> 数字\n\nNumber('123');\t\t\t // 123\nNumber('123.45');\t\t // 123.45\nNumber('-123');\t\t\t // -123\nNumber('-123.45');\t\t // -123.45\n// 字符串中不支持有非数值字符\nNumber('123年');\t    \t// NaN\nNumber('2e3');\t\t\t// 2000\nNumber('');\t\t\t\t// 0\n\n// 字符串不支持是数学表达式\nNumber('1+1');\t\t\t// NaN\n// 除了字符串外，还可以直接放一个表达式\nNumber(1+1);\t\t\t// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n（2）布尔值 ——> 数字\n\nNumber(true);\t\t\t// 1\nNumber(false);\t\t\t// 0\n\n\n1\n2\n\n\n（3）undefined 和 null ——> 数字\n\nNumber(undefined);\t\t// NaN\nNumber(null);\t\t\t// 0\n\n\n1\n2\n\n\n\n# 7.1.2 使用 parseInt() 函数\n\nparseInt() 函数的功能是将 字符串 或 浮点数 转为 整数。\n\n * 自动截掉第一个非数字字符之后的所有字符\n\nparseInt('3.14');\t\t  // 3\nparseInt('-3.14');\t\t  // -3\nparseInt('3周吉瑞.14');\t// 3\nparseInt(3.14);\t\t  \t  // 3\nparseInt(-3.14);\t\t  // -3\n\n\n1\n2\n3\n4\n5\n\n * 所有文字都将被截掉\n\nparseInt('3.14是圆周率');\t// 3\n\n\n1\n\n * 如果字符串以非数字开头，则转为 NaN\n\nparseInt('圆周率是3.14');\t// NaN\nparseInt('一二三');\t\t // NaN\n\n\n1\n2\n\n * 不存在 “四舍五入”\n\nparseInt('3.99');\t\t  // 3\n\n\n1\n\n * true、false、undefined、null 转为 NaN\n\n> 之所以会出现这种情况的原因是，parseInt() 的原理是先将参数转换为字符串，再将字符串转为整数。\n> \n> 所以，true 会先被转为 'true'，null 会被转为 'null'，其它同理……\n\nparseInt(true);\t\t\t// NaN\nparseInt(false);\t\t// NaN\t\nparseInt(undefined);\t// NaN\nparseInt(null);\t\t\t// NaN\n\n\n1\n2\n3\n4\n\n\n> parseInt() 函数的特性会用于处理数字的净化。\n> \n> parseInt('24px');\t// 24\n> // 去除了单位，保留数值！\n> \n> \n> 1\n> 2\n\n\n# 7.1.3 使用 parseFloat() 函数\n\nparseFloat() 函数的功能是将字符串转为浮点数。\n\n> 绝大部分原理与 parseInt() 类似。\n\nparseFloat('3.14');\t\t// 3.14\nparseFloat(3.14);\t\t// 3.14\n\nparseFloat('3.14是圆周率');\t\t// 3.14\nparseFloat('3.14.15');\t\t   // 3.14\n\nparseFloat('3.99');\t\t\t// 3.99\nparseFloat('-3.99');\t\t// -3.99\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.2 其他值 ——> 字符串\n\n\n# 7.2.1 使用 String() 函数\n\nString() 函数是 JS 内置函数。\n\n> 由于 String() 属于内置构造函数，所以 String() 的首字母 S 要大写。\n\n（1）数字 ——> 字符串\n\n变为 “长得相同” 的字符串。\n\n科学计数法和非 10 进制数字会转为 10 进制的标准值。\n\nString(123);\t\t// '123'\nString(123.4);\t\t// '123.4'\nString(2e3);\t\t// '2000'\nStiing(NaN);\t\t// 'NaN'\nString(Infinity);\t// 'Infinity'\nString(0xf);\t\t// '15'\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）布尔值 ——> 字符串\n\n变为 “长得相同” 的字符串。\n\nString(true);\t\t// 'true'\nString(false);\t\t// 'false'\n\n\n1\n2\n\n\n（3）undefined 和 null ——> 字符串\n\n变为 “长得相同” 的字符串。\n\nString(undefined);\t// 'undefined'\nString(null);\t\t// 'null'\n\n\n1\n2\n\n\n\n# 7.2.2 使用 toString() 方法\n\ntoString() 是几乎所有基本类型都自带的方法，功能是将值转为字符串。\n\n> 纯数字不能直接 “打点” 调用 toString() 方法，要把纯数字用 () 包裹起来，此时 JS 会提升该数字为一个 Number 对象（包装对象）\n\n> toString() 方法依旧是返回一个字符串，并不改变变量原有的类型！\n\n\n# 7.3 其他值 ——> 布尔值\n\nBoolean() 函数是 JS 内置函数。\n\n> 由于 Boolean() 属于内置构造函数，所以 Boolean() 的首字母 B 要大写。\n\n（1）数字 ——> 布尔值\n\n0 和 NaN 转为 false，其他数字都转为 true。\n\nBoolean(123);\t\t\t// true\nBoolean(0);\t\t\t\t// false\nBoolean(NaN);\t\t\t// false\nBoolean(Infinity);\t\t// true\nBoolean(-Infinity);\t\t// true\n\n\n1\n2\n3\n4\n5\n\n\n> 全局属性 Infinity 是一个数值，表示无穷大。\n\n（2）字符串 ——> 布尔值\n\n空字符串 '' 转为 false，其他都转为 true。\n\nBoolean('');\t\t\t\t// false\nBoolean('abc');\t\t\t\t// true\nBoolean('false');\t\t\t// true\n\n\n1\n2\n3\n\n\n（3）undefined 和 null ——> 布尔值\n\n转为 false。\n\nBoolean(undefined);\t\t\t\t// false\nBoolean(null);\t\t\t\t\t// false\n\n\n1\n2\n\n\n\n# 八、加法器案例\n\n * 使用 prompt() 函数弹出浏览器输入框，让用户输入两个数字\n\n * 由于 prompt() 函数输入的任何值都将默认为字符串，所以我们要将其先转为数字类型\n\n * 对数字进行加法运算\n\n * 最后用 alert() 显示结果\n\n// 输入两个数字，并将他们转为数字类型\nvar a = Number(prompt('请输入第一个数字：'));\nvar b = Number(prompt('请输入第二个数字：'));\n// 计算两个数字的和\nvar sum = a + b;\n// 弹出结果\nalert(sum);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 九、复杂数据类型简介\n\n除基本类型值外，JS 的世界中还有复杂数据类型。\n\n举例：\n\n[1, 2, 3]\n\n{ a: 1, b: 2 }\n\nfunction() {\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 JS 中普通类型也可以包装为复杂类型（对象）\n> \n> str01 = 'zjr';\n> str02 = new String('zjr');\n> str03 = String('zjr');\n> console.log(typeof str01);\t\t// string\n> console.log(typeof str02);\t\t// object\n> console.log(typeof str03);\t\t// string\n> console.log(str01 === str02);\t// false\n> console.log(str02 === str03);\t// false\n> console.log(str01 === str03);\t// true\n> // Number、Boolean 同理\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n复杂数据类型都是 “引用类型”（type: object），将在后续介绍。",normalizedContent:"# 【js基本数据类型】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、数据类型简介和检测\n\n\n# 1.1 javascript 中两大数据类型\n\n（1）基本数据类型\n\n> js 没有字符型（char），js 的 string 是基本类型！\n\n * number（数字）\n * string（字符串）\n * boolean（布尔）\n * undefined（未定义）\n * null（空）\n\n（2）复杂数据类型\n\n * object（对象）\n * array（数组）\n * function（函数）\n * regexp（正则表达式）\n * date\n * map\n * set\n * symbol\n * ……\n\n\n# 1.2 typeof 运算符\n\n使用 typeof 运算符可以检测值或者变量的类型。\n\n> typeof 是一个运算符，而不是内置函数，所以不用加 ()，如果加了也不会报错，但是并不推荐！\n\ntypeof 5;\t\t  // number\ntypeof '周吉瑞';\t// string\n\n\n1\n2\n\n\n> 利用浏览器控制台进行交互测试……\n\nconsole.log(typeof 5);\nconsole.log(typeof '周吉瑞');\nvar a = '5';\nconsole.log(typeof a);\n\n\n1\n2\n3\n4\n\n\n> 从以上测试也可以看出，js 是一个弱类型的语言，变量值是什么类型，那么变量就是什么类型，而不用显式地指出变量的类型。\n\n\n# 1.3 5种基本数据类型的 typeof 检测结果\n\n类型名            typeof 检测结果        值举例\n数字类型           number             5、2.5、-0.5\n字符串类型          string             '前端'、\"后端\"、'3.14'\n布尔类型           boolean            true、false\nundefined 类型   undefined          undefined\nnull 类型        object（可以理解为空对象）   null\n\n\n# 二、number（数字）类型\n\n\n# 2.1 一切数都是数字类型\n\n在 js 中，所有数字不分大小、不分整浮、不分正负，都是数字类型。\n\ntypeof 925; // number\ntypeof 0.5; // number\ntypeof -24; // number\n\n\n1\n2\n3\n\n\n\n# 2.2 小数中 0 可以省略\n\n在表达小数的时候，整数个位的 0 可以省略。\n\n\n# 2.3 科学计数法\n\n较大数或较小数可以写成科学计数法。\n\n3e8;\t\t\t// 300000000\ntypeof 3e8;\t\t// number\n\n3e-4;\t\t\t// 0.0003\ntypeof 3e-4;\t// number\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.4 不同进制的数字\n\n（1）二进制数值以 0b 开头\n\n0b10;\t// 2\n0b1111;\t// 15\n\n\n1\n2\n\n\n（2）八进制数值以 0 开头\n\n017;\t// 15\n\n\n1\n\n\n（3）十六进制数值以 0x 开头\n\n0xf;\t// 15\n\n\n1\n\n\n\n# 2.5 一个特殊的数字型值 nan\n\nnan 是 “not a number” 的意思，即 “不是一个数”，但它属于数字类型。\n\ntypeof nan;\t// number\n\n\n1\n\n * 0 除以 0 的结果是 nan，事实上，在 js 数学运算中，若结果不能得到数字，其结果往往都是 nan\n * nan 有一个 “奇怪” 的性质：不自等（这个知识点将在后续课程中讲解）\n\n0 / 0;\t// nan\n5 - 3;\t// 2\n'我' - '你';\t// nan\n'我' * '你';\t// nan\n'我' / '你';\t// nan\n'我' + '你';\t// \"我你\"（字符串遇到加法是拼接功能）\nnan == nan;   // false（nan 不自等）\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 再次强调：nan 是一个值（特殊的值），不是类型。\n> \n> 唯一能判断 nan 的方法是通过 isnan() 函数：\n> \n> isnan(nan); // true\n> \n> \n> 1\n\n\n# 三、string（字符串）类型\n\n\n# 3.1 字符串的表示\n\n字符串要用引号包裹，双引号或者单引号均可（无论用哪种，都应该保持风格统一）。\n\n注意：大部分 js 项目习惯约定使用单引号（因为可以减少按下 shift 键）。\n\ntypeof \"周吉瑞\";\t// string\n或\ntypeof '周吉瑞';\t// string\n\n\n1\n2\n3\n\n\n数字 10 和字符串 '10' 在语义上是不同的，前者表示一个数量，后者是一个文本。\n\n\n# 3.2 字符串的拼接\n\n加号可以用来拼接多个字符串。\n\n'周' + '吉瑞';\t// \"周吉瑞\"\n'abc' + 'd' + 'ef';\t// \"abcdef\"\n\n\n1\n2\n\n\n\n# 3.3 字符串和变量的拼接\n\n要将一个变量的值 “插入” 到字符串中，要满足变量左右两边至少有一边 + 字符串。\n\nvar year = 2022;\nvar str = '北京冬奥会在' + year + '年召开';\t// \"北京冬奥会在2022年召开\"\n\nvar a = 24;\nvar str1 = 54 + a;\t\t// 78\nvar str2 = '54' + a;\t// \"5424\"\n\n1 + '10'; // \"110\"\n\n2 + '';\t// \"2\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> es6 中增加了反引号 ( ` ) 表示法，可以更方便进行变量插值，后面会进行介绍。\n\n\n# 3.4 空字符串\n\n一些时候需要使用空字符串，直接书写闭合的引号对即可。\n\nvar str = \"\";\n或\nvar str = '';\n\n\n1\n2\n3\n\n\n空字符串可以用于将变量变为字符串！\n\nvar a = 24;\nconsole.log(typeof a);\t// number\na = a + '';\nconsole.log(a);\t// \"24\"\nconsole.log(typeof a);\t// string\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.5 字符串的 length 属性\n\n> 通过对 string 类型 “打点” 的方式，可以调用其内置属性。\n> \n> > 注意：在 js 中，string 是基本类型，之所以 string 可以 “打点” 调用属性和方法，那是因为 js 的解释器会自动将基本类型包装成对应的 object 类型。\n\n字符串的 length 属性表示字符串的长度。\n\n'我喜欢js'.length;\t// 5\n'我喜欢js，我也喜欢ts'.length;\t// 12\n''.length;\t// 0\n\n\n1\n2\n3\n\n\n\n# 3.6 字符串的常用方法\n\n> 通过对 string 类型 “打点” 的方式，可以调用其内置方法。\n\n“方法” 就是能够打点调用的函数，字符串类型有丰富的内置方法。\n\n方法              功能\ncharat()        得到指定位置字符\nsubstring()     提取子串\nsubstr()        提取子串\nslice()         提取子串\ntouppercase()   将字符串变为大写\ntolowercase()   将字符串变为小写\nindexof()       检索字符串\ntrim()          删除首尾空格\ntrimstart()     删除首部空格\ntrimend()       删除尾部空格\n\n\n# 3.6.1 charat() 方法\n\ncharat() 方法可以得到指定位置的字符。\n\n字符串中的每个字符都按顺序编号，编号从 0 开始。\n\n'   我   喜   欢   j   s   ,   我   也   喜   欢   n    o    d    e    '\n    0   1   2   3   4   5   6   7   8   9   10   11   12   13   \n\n'我喜欢js，我也喜欢node'.charat(0);\t\t// \"我\"\n'我喜欢js，我也喜欢node'.charat(5);\t\t// \"，\"\n'我喜欢js，我也喜欢node'.charat(11);\t// \"o\"\n'我喜欢js，我也喜欢node'.charat(99);\t// \"\"\n'我喜欢js，我也喜欢node'.charat(-1);\t// \"\"\n\n\n1\n2\n3\n4\n5\n\n\n> 超出范围的输出空字符 \"\"。\n\n\n# 3.6.2 substring()、substr() 和 slice() 方法\n\n（1）substring(a, b) 方法得到从 a 开始到 b 结束（不包括 b 处）的子串 [a, b)\n\n> 编程语言的区间一般都是：左闭右开！\n\n'我喜欢js，我也喜欢node'.substring(3, 5);\t\t// \"js\"\n'我喜欢js，我也喜欢node'.substring(10, 14);\t\t// \"node\"\n'我喜欢js，我也喜欢node'.substring(10, 99);\t\t// \"node\"\n'我喜欢js，我也喜欢node'.substring(-1, 4);\t\t// \"我喜欢j\"\n\n\n1\n2\n3\n4\n\n\n> 超出范围的部分，取到端点字符！\n\n * substring(a, b) 方法如果省略第二个参数，返回的子串会一直到字符串的结尾\n\n'我喜欢js，我也喜欢node'.substring(6);\t\t// \"我也喜欢node\"\n\n\n1\n\n * substring(a, b) 中，a 可以大于 b，数字顺序将自动调整为小数在前\n\n> 应该没有人会这样用^^\n\n'我喜欢js，我也喜欢node'.substring(3, 5);\t\t// \"js\"\n'我喜欢js，我也喜欢node'.substring(5, 3);\t\t// \"js\"\n\n\n1\n2\n\n\n（2）substr(a, b) 中，将得到从 a 开始的长度为 b 的子串\n\n'我喜欢js，我也喜欢node'.substr(3, 2);\t\t// \"js\"\n\n\n1\n\n * substr(a, b) 中，b 可以省略，表示到字符串结尾\n\n'我喜欢js，我也喜欢node'.substr(3);\t\t// \"js，我也喜欢node\"\n\n\n1\n\n * substr(a, b) 中，a 可以是负数，表示倒数位置\n\n> 倒数第一位为 -1，而不是 -0\n\n'我喜欢js，我也喜欢node'.substr(-4, 2);\t\t// \"no\"\n\n\n1\n\n\n（3）slice(a, b) 方法得到从 a 开始到 b 结束（不包括 b 处）的子串\n\n> slice：切片\n\n'我喜欢js，我也喜欢node'.slice(3, 5);\t\t// \"js\"\n\n\n1\n\n * slice(a, b) 的参数 a 可以是负数（与 substring(a, b) 的区别）\n\n'我喜欢js，我也喜欢node'.slice(-4, -1);\t\t// \"nod\"\n// (-4, -1)：从 倒数第4位 到 倒数第1位，不包括 倒数第1位\n\n\n1\n2\n\n * slice(a, b) 中，参数 a 必须小于参数 b，否则便会返回一个空字符串\n\n'我喜欢js，我也喜欢node'.slice(5, 2);\t\t// \"\"\n\n\n1\n\n\n\n# 3.6.3 touppercase() 和 tolowercase() 方法\n\n * touppercase() 转为大写\n * tolowercase() 转为小写\n\n'i love you'.touppercase();\t\t// \"i love you\"\n'imooc'.tolowercase();\t\t    // \"imooc\"\n\n\n1\n2\n\n\n> 注意：touppercase() 和 tolowercase()，只是返回一个大小写格式，变量本身的值并没有改变。\n> \n> var str = \"i love you\";\n> console.log(str.touppercase());\t\t// \"i love you\"\n> console.log(str);\t\t\t\t    // \"i love you\"\n> str = str.touppercase();\n> console.log(str);\t\t\t\t    // \"i love you\"\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 3.6.4 indexof() 方法\n\nindexof() 方法返回某个指定的字符串值在字符串中首次出现的位置\n\n如果要检索的字符串没有出现，则返回 -1\n\n这个方法用于判断字符串是否包含目标子串时特别有用！\n\n'abcdebb'.indexof('b');\t\t// 1\n'abcdebb'.indexof('deb');\t// 3\n'abcdebb'.indexof('m');\t\t// -1\n\n\n1\n2\n3\n\n\n\n# 3.6.5 trim()、trimstart()、trimend() 方法\n\n// 删除首尾空格\nconsole.log('---' + ' 123 '.trim() + '---');\n// 删除首部空格\nconsole.log('---' + ' 123 '.trimstart() + '---');\n// 删除尾部空格\nconsole.log('---' + ' 123 '.trimend() + '---');\n\n/*\n---123---\n---123 ---\n--- 123---\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、boolean（布尔）类型\n\n在计算机领域，几乎所有的 “真” 和 “假” 都归为布尔类型值。\n\n布尔类型值只有两个：true 和 false，分别表示 真 和 假。\n\ntypeof true;\t// boolean\ntypeof false;\t// boolean\n\n\n1\n2\n\n\n> 布尔类型在 关系运算 和 逻辑运算 中广泛运用。\n\n3 < 5;\t  // true\n5 > 3; \t  // true \n5 >= 100; // false\n\n\n1\n2\n3\n\n\n> 注意：在 js 中，1 可以 “代表” true，0 或 -0 可以 “代表” false，原理是类型的自动转换，但非常不建议以数字来代替布尔值！\n\n\n# 五、undefined 类型\n\n一个没有赋值的变量的默认值是 undefined，而 undefined 的类型也是 undefined。\n\n即：undefined 既是类型，又是值（且这种类型只有一个唯一的值：就是它自身）。\n\ntypeof undefined;\t// undefined\n\n\n1\n\n\n> 实际开发中，一般不会给某个变量赋值为 undefined，但是我们会检查一个变量的值是否为 undefined。\n\n> 在变量声明提升的时候，会出现 undefined，要注意！\n\n\n# 六、null 类型\n\nnull 表示 “空”，可以理解为它是 “空对象”。\n\n当我们需要将对象销毁、数组销毁或者删除事件监听时，通常将它们设置为 null。\n\nbox.onclick = null;\n// 删除点击事件\n\n\n1\n2\n\n\n用 typeof 检测 null 结果为 object。\n\ntypeof null;\t// object\n\n\n1\n\n\n> 狭义上，null 可以理解为 “空对象”，这样可以合理的解释为什么 null 的类型为 object。\n> \n> 但是准确的来说，null 不是一个 “对象”，它是一个独立的 “基本数据类型”。\n\n\n# 七、数据类型的转换\n\n\n# 7.1 其他值 ——> 数字\n\n\n# 7.1.1 使用 number() 函数\n\nnumber() 函数是 js 内置函数。\n\n> 由于 number() 属于内置构造函数，所以 number() 的首字母 n 要大写。\n\n（1）字符串 ——> 数字\n\nnumber('123');\t\t\t // 123\nnumber('123.45');\t\t // 123.45\nnumber('-123');\t\t\t // -123\nnumber('-123.45');\t\t // -123.45\n// 字符串中不支持有非数值字符\nnumber('123年');\t    \t// nan\nnumber('2e3');\t\t\t// 2000\nnumber('');\t\t\t\t// 0\n\n// 字符串不支持是数学表达式\nnumber('1+1');\t\t\t// nan\n// 除了字符串外，还可以直接放一个表达式\nnumber(1+1);\t\t\t// 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n（2）布尔值 ——> 数字\n\nnumber(true);\t\t\t// 1\nnumber(false);\t\t\t// 0\n\n\n1\n2\n\n\n（3）undefined 和 null ——> 数字\n\nnumber(undefined);\t\t// nan\nnumber(null);\t\t\t// 0\n\n\n1\n2\n\n\n\n# 7.1.2 使用 parseint() 函数\n\nparseint() 函数的功能是将 字符串 或 浮点数 转为 整数。\n\n * 自动截掉第一个非数字字符之后的所有字符\n\nparseint('3.14');\t\t  // 3\nparseint('-3.14');\t\t  // -3\nparseint('3周吉瑞.14');\t// 3\nparseint(3.14);\t\t  \t  // 3\nparseint(-3.14);\t\t  // -3\n\n\n1\n2\n3\n4\n5\n\n * 所有文字都将被截掉\n\nparseint('3.14是圆周率');\t// 3\n\n\n1\n\n * 如果字符串以非数字开头，则转为 nan\n\nparseint('圆周率是3.14');\t// nan\nparseint('一二三');\t\t // nan\n\n\n1\n2\n\n * 不存在 “四舍五入”\n\nparseint('3.99');\t\t  // 3\n\n\n1\n\n * true、false、undefined、null 转为 nan\n\n> 之所以会出现这种情况的原因是，parseint() 的原理是先将参数转换为字符串，再将字符串转为整数。\n> \n> 所以，true 会先被转为 'true'，null 会被转为 'null'，其它同理……\n\nparseint(true);\t\t\t// nan\nparseint(false);\t\t// nan\t\nparseint(undefined);\t// nan\nparseint(null);\t\t\t// nan\n\n\n1\n2\n3\n4\n\n\n> parseint() 函数的特性会用于处理数字的净化。\n> \n> parseint('24px');\t// 24\n> // 去除了单位，保留数值！\n> \n> \n> 1\n> 2\n\n\n# 7.1.3 使用 parsefloat() 函数\n\nparsefloat() 函数的功能是将字符串转为浮点数。\n\n> 绝大部分原理与 parseint() 类似。\n\nparsefloat('3.14');\t\t// 3.14\nparsefloat(3.14);\t\t// 3.14\n\nparsefloat('3.14是圆周率');\t\t// 3.14\nparsefloat('3.14.15');\t\t   // 3.14\n\nparsefloat('3.99');\t\t\t// 3.99\nparsefloat('-3.99');\t\t// -3.99\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7.2 其他值 ——> 字符串\n\n\n# 7.2.1 使用 string() 函数\n\nstring() 函数是 js 内置函数。\n\n> 由于 string() 属于内置构造函数，所以 string() 的首字母 s 要大写。\n\n（1）数字 ——> 字符串\n\n变为 “长得相同” 的字符串。\n\n科学计数法和非 10 进制数字会转为 10 进制的标准值。\n\nstring(123);\t\t// '123'\nstring(123.4);\t\t// '123.4'\nstring(2e3);\t\t// '2000'\nstiing(nan);\t\t// 'nan'\nstring(infinity);\t// 'infinity'\nstring(0xf);\t\t// '15'\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）布尔值 ——> 字符串\n\n变为 “长得相同” 的字符串。\n\nstring(true);\t\t// 'true'\nstring(false);\t\t// 'false'\n\n\n1\n2\n\n\n（3）undefined 和 null ——> 字符串\n\n变为 “长得相同” 的字符串。\n\nstring(undefined);\t// 'undefined'\nstring(null);\t\t// 'null'\n\n\n1\n2\n\n\n\n# 7.2.2 使用 tostring() 方法\n\ntostring() 是几乎所有基本类型都自带的方法，功能是将值转为字符串。\n\n> 纯数字不能直接 “打点” 调用 tostring() 方法，要把纯数字用 () 包裹起来，此时 js 会提升该数字为一个 number 对象（包装对象）\n\n> tostring() 方法依旧是返回一个字符串，并不改变变量原有的类型！\n\n\n# 7.3 其他值 ——> 布尔值\n\nboolean() 函数是 js 内置函数。\n\n> 由于 boolean() 属于内置构造函数，所以 boolean() 的首字母 b 要大写。\n\n（1）数字 ——> 布尔值\n\n0 和 nan 转为 false，其他数字都转为 true。\n\nboolean(123);\t\t\t// true\nboolean(0);\t\t\t\t// false\nboolean(nan);\t\t\t// false\nboolean(infinity);\t\t// true\nboolean(-infinity);\t\t// true\n\n\n1\n2\n3\n4\n5\n\n\n> 全局属性 infinity 是一个数值，表示无穷大。\n\n（2）字符串 ——> 布尔值\n\n空字符串 '' 转为 false，其他都转为 true。\n\nboolean('');\t\t\t\t// false\nboolean('abc');\t\t\t\t// true\nboolean('false');\t\t\t// true\n\n\n1\n2\n3\n\n\n（3）undefined 和 null ——> 布尔值\n\n转为 false。\n\nboolean(undefined);\t\t\t\t// false\nboolean(null);\t\t\t\t\t// false\n\n\n1\n2\n\n\n\n# 八、加法器案例\n\n * 使用 prompt() 函数弹出浏览器输入框，让用户输入两个数字\n\n * 由于 prompt() 函数输入的任何值都将默认为字符串，所以我们要将其先转为数字类型\n\n * 对数字进行加法运算\n\n * 最后用 alert() 显示结果\n\n// 输入两个数字，并将他们转为数字类型\nvar a = number(prompt('请输入第一个数字：'));\nvar b = number(prompt('请输入第二个数字：'));\n// 计算两个数字的和\nvar sum = a + b;\n// 弹出结果\nalert(sum);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 九、复杂数据类型简介\n\n除基本类型值外，js 的世界中还有复杂数据类型。\n\n举例：\n\n[1, 2, 3]\n\n{ a: 1, b: 2 }\n\nfunction() {\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 在 js 中普通类型也可以包装为复杂类型（对象）\n> \n> str01 = 'zjr';\n> str02 = new string('zjr');\n> str03 = string('zjr');\n> console.log(typeof str01);\t\t// string\n> console.log(typeof str02);\t\t// object\n> console.log(typeof str03);\t\t// string\n> console.log(str01 === str02);\t// false\n> console.log(str02 === str03);\t// false\n> console.log(str01 === str03);\t// true\n> // number、boolean 同理\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n复杂数据类型都是 “引用类型”（type: object），将在后续介绍。",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS表达式与操作符",frontmatter:{title:"JS表达式与操作符",date:"2020-04-30T11:11:33.000Z",permalink:"/pages/5c5ad9/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/03.JS%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6.html",relativePath:"20.JS/10.基础/03.JS表达式与操作符.md",key:"v-45001122",path:"/pages/5c5ad9/",headers:[{level:2,title:"2.1 算术运算符",slug:"_2-1-算术运算符",normalizedTitle:"2.1 算术运算符",charIndex:112},{level:2,title:"2.2 隐式类型转换",slug:"_2-2-隐式类型转换",normalizedTitle:"2.2 隐式类型转换",charIndex:251},{level:2,title:"2.3 有关IEEE754",slug:"_2-3-有关ieee754",normalizedTitle:"2.3 有关ieee754",charIndex:569},{level:2,title:"2.4 幂和开根号",slug:"_2-4-幂和开根号",normalizedTitle:"2.4 幂和开根号",charIndex:1417},{level:2,title:"2.5 向上取整和向下取整",slug:"_2-5-向上取整和向下取整",normalizedTitle:"2.5 向上取整和向下取整",charIndex:1628},{level:2,title:"3.1 关系运算符",slug:"_3-1-关系运算符",normalizedTitle:"3.1 关系运算符",charIndex:2116},{level:2,title:"3.2 相等和全等",slug:"_3-2-相等和全等",normalizedTitle:"3.2 相等和全等",charIndex:2231},{level:2,title:"3.3 NaN不自等",slug:"_3-3-nan不自等",normalizedTitle:"3.3 nan不自等",charIndex:2721},{level:2,title:"3.4 JS中没有连比",slug:"_3-4-js中没有连比",normalizedTitle:"3.4 js中没有连比",charIndex:3180},{level:2,title:"4.1 逻辑运算符",slug:"_4-1-逻辑运算符",normalizedTitle:"4.1 逻辑运算符",charIndex:3256},{level:2,title:"4.2 非运算",slug:"_4-2-非运算",normalizedTitle:"4.2 非运算",charIndex:3303},{level:2,title:"4.3 与运算",slug:"_4-3-与运算",normalizedTitle:"4.3 与运算",charIndex:3684},{level:2,title:"4.4 或运算",slug:"_4-4-或运算",normalizedTitle:"4.4 或运算",charIndex:3726},{level:2,title:"4.5 短路运算",slug:"_4-5-短路运算",normalizedTitle:"4.5 短路运算",charIndex:3768},{level:2,title:"4.6 逻辑运算的优先级",slug:"_4-6-逻辑运算的优先级",normalizedTitle:"4.6 逻辑运算的优先级",charIndex:4344},{level:2,title:"5.1 赋值运算符",slug:"_5-1-赋值运算符",normalizedTitle:"5.1 赋值运算符",charIndex:4465},{level:2,title:"5.2 赋值运算产生值",slug:"_5-2-赋值运算产生值",normalizedTitle:"5.2 赋值运算产生值",charIndex:4542},{level:2,title:"5.3 快捷赋值",slug:"_5-3-快捷赋值",normalizedTitle:"5.3 快捷赋值",charIndex:4785},{level:2,title:"5.4 自增自减运算",slug:"_5-4-自增自减运算",normalizedTitle:"5.4 自增自减运算",charIndex:4828}],headersStr:"2.1 算术运算符 2.2 隐式类型转换 2.3 有关IEEE754 2.4 幂和开根号 2.5 向上取整和向下取整 3.1 关系运算符 3.2 相等和全等 3.3 NaN不自等 3.4 JS中没有连比 4.1 逻辑运算符 4.2 非运算 4.3 与运算 4.4 或运算 4.5 短路运算 4.6 逻辑运算的优先级 5.1 赋值运算符 5.2 赋值运算产生值 5.3 快捷赋值 5.4 自增自减运算",content:"# 【JS表达式与操作符】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是表达式和运算符\n\n表达式：由 操作数 和 运算符 组成的式子。\n\n表达式的分类：算术、关系、逻辑、赋值、综合。\n\n\n# 二、算术表达式\n\n\n# 2.1 算术运算符\n\n意义   运算符\n加    +\n减    -\n乘    *\n除    /\n取余   %\n\n> 推荐一律使用 () 来强制规定优先级！\n\n+ 有 “加法” 和 “连字符” 两种作用，如果 + 的某一边是字符串那么就为 ”连字符“，否则为 ”加法“。\n\n\n# 2.2 隐式类型转换\n\n如果参与数学运算的某操作数不是数字类型，那么 JS 会自动将此操作数转换为数字型。\n\n3 * '4';\t\t// 12\ntrue + true;\t// 2\nfalse + 2;\t\t// 2\n3 * '2天'; \t   // NaN\n\"z\" * \"j\";\t    // NaN\n3 + '2天'; \t   // '32天'\n3 + null;\t\t// 0\n3 * '';\t\t\t// 0\n3 * ' ';\t\t// 0\n3 + '';\t\t\t// '3'\n3 + ' ';\t\t// '3 '\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 隐式转换的本质是 JS 内部自动调用 Number() 函数\n\n\n# 2.3 有关IEEE754\n\n在 JS 中，有些小数的数学运算不是很精准。\n\n0.1 + 0.2;\t// 0.30000000000000004\n\n\n1\n\n\nJS 使用了 IEEE754 二进制浮点数算术标准，这会使一些个别的小数运算产生 “丢失精度” 问题。\n\n注意：不是所有的小数运算都会出现精度问题，只是少数部分。\n\n> 几乎所有的高级语言都使用了 IEEE754 二进制浮点数算术标准。\n> \n> IEEE754 二进制浮点数算术标准是计算机底层编译标准，了解即可！\n\n【解决办法】\n\n在进行小数运算时，要调用数字的 toFixed() 方法保留指定的小数位数。\n\n> toFixed() 括号内接受一个保留小数位数的参数。\n\n(0.1 + 0.2).toFixed(2);\t\t\t\t// '0.30'，默认得到一个字符串值\nNumber((0.1 + 0.2).toFixed(2));\t\t // 0.3\n\n\n1\n2\n\n\n> toFixed() 遵循（“四舍六入”，“五不一定”）原则。\n> \n> (0.9945).toFixed(3);\t// \"0.995\"\n> \n> \n> 1\n\n> 最后要注意浮点数的相等比较：\n> \n> 1 / 3 === (1 - 2 / 3);\t// false\n> \n> \n> 1\n> \n> \n> 这不是 JavaScript 的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n> \n> Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001;\t// true\n> \n> \n> 1\n\n> 还有一种解决技巧，就是将浮点数转换为整数进行计算：\n> \n> 0.1 + 0.2;\t// 0.30000000000000004\n> (0.1 * 10 + 0.2 * 10) / 10;\t// 0.3\n> \n> \n> 1\n> 2\n\n\n# 2.4 幂和开根号\n\nJS 中没有提供幂运算、开根号的运算符，需要使用 Math 对象的相关方法进行计算。\n\nMath.pow(a, b)：求 a 的 b 次方。\n\nMath.sqrt(a)：求 a 的平方根。\n\nMath.pow(2, 3);\t\t// 8\nMath.pow(3, 2);\t\t// 9\nMath.sqrt(81);\t\t// 9\nMath.sqrt(-81);\t\t// NaN\n\n\n1\n2\n3\n4\n\n\n\n# 2.5 向上取整和向下取整\n\nMath.ceil()：向上取整。\n\nMath.floor()：向下取整。\n\nMath.round()：把一个数字舍入为最接近的整数（“四舍六入”，“五不一定”）\n\n> 注意：向上、向下的标准是：X轴正方向为上！\n> \n> 负 ———— 0 ————> 正\n\nMath.ceil(2.4);\t\t\t// 3\nMath.floor(2.4);\t\t// 2\n\nMath.ceil(-2.4);\t\t// -2\nMath.floor(-2.4);\t\t// -3\n\nMath.ceil(2);\t\t\t// 2\nMath.floor(2);\t\t\t// 2\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意：由于底层的关系，无论是 toFixed() 还是 Math.round() 都不是完全遵循 “四舍五入”（无论正负），而是 “四舍六入，五不一定”，为什么非要这样呢？原因是没办法！因为小数在计算机底层的实现机制导致的问题！建议对于小数位数的处理不要用原生的函数来处理！最好是手动实现想要的处理代码，或者是借助第三方库！\n\n\n# 三、关系表达式\n\n\n# 3.1 关系运算符\n\n意义      运算符\n大于      >\n小于      <\n大于或等于   >=\n小于或等于   <=\n等于      ==\n不等于     !=\n全等于     ===\n不全等于    !==\n\n\n# 3.2 相等和全等\n\n两个等号 == 运算符，不考虑值的类型，它会进行隐式转换后比较值的字面量是否相等。\n\n三个等号 === 运算符，不仅比较值是否相同，同时比较类型是否相同。\n\n5 == '5';\t\t// true\n5 === '5';\t\t// false\n\n\n1\n2\n\n\n1 == true;\t\t\t// true\n1 === true;\t\t\t// false\n\n0 == false;\t\t\t// true\n0 === false; \t\t// false\n\n0 == undefined;\t\t// false\n0 === undefined;\t// false\n\nundefined == null;\t// true\nundefined === null;\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> null 和 undefined 用 == 进行比较涉及隐式强制类型转换，ES5 规范中规定。\n> \n> === 比较为 false，是因为 null 与 undefined 类型不同。\n> \n> 建议没有特殊情况请一律使用 ===\n\n\n# 3.3 NaN不自等\n\nNaN 作为一个特殊的数字类型值，它在用 == 比较的时候也有特殊的结果。\n\nNaN == NaN;\t\t\t// false\nNaN\t=== NaN;\t\t// false\n\n\n1\n2\n\n\n【如何判断某变量值为 NaN】\n\nisNaN() 函数可以用来判断变量值是否为 NaN。\n\nisNaN(NaN);\t\t// true\nisNaN(5);\t\t// false\nisNaN('5');\t\t// false\n\n\n1\n2\n3\n\n\n> 但 isNaN() 也不好用，它的机理是：只要该变量传入 Number() 的执行结果是 NaN，则 isNaN() 函数都会得到 true。\n> \n> 对于，undefined 和 null，这种情况一般来说需要先进行单独判断，再进行 isNaN 判断。\n> \n> isNaN(undefined);\t// true\n> isNaN('3天');\t   // true\n> isNaN(null);\t\t// false\n> \n> \n> 1\n> 2\n> 3\n\n\n# 3.4 JS中没有连比\n\n例如：3 <= a <= 15 的写法是错误的，应该为：a >= 3 && a <= 15。\n\n\n# 四、逻辑表达式\n\n\n# 4.1 逻辑运算符\n\n意义   运算符\n非    !\n与    &&\n或    ||\n\n\n# 4.2 非运算\n\n! 表示 “非”，也可以称为 “置反运算”。\n\n! 是一个 “单目运算符”，只需要一个操作数。\n\n置反运算的结果一定是布尔值。\n\n!true;\t\t\t// false\n!false;\t\t\t// true\n!0;\t\t\t\t// true\n!undefined;\t\t// true\n!'';\t\t\t// true\n!' ';\t\t\t// false\n!null;\t\t\t// true\n!'imooc';\t\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> !! 常用于确定一个值的布尔属性。\n> \n> !!true;\t\t// true\n> !!0;\t\t// false\n> !!'';\t\t// false\n> !!' ';\t\t// true\n> !!'imooc';\t// true\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 4.3 与运算\n\n&& 是 “双目运算符”。\n\n核心：全真为真、有假即假。\n\n\n# 4.4 或运算\n\n|| 是 “双目运算符”。\n\n核心：全假为假、有真即真。\n\n\n# 4.5 短路运算\n\n&& 与 ||，都属于 “短路运算符”。\n\n（1）&& 短路运算\n\n由于 && 运算的核心是：“全真为真、有假即假”，所以：\n\n * 如果 a && b 中 a 为真，那么该表达式的值由 b 决定（计算 a 又计算 b）\n * 如果 a && b 中 a 为假，那么该表达式的值由 a 决定（只计算 a）\n\n3 && 6;\t\t\t\t// 6\nundefined && 15;\t// undefined\n15 && undefined;\t// undefined\nnull && 2;\t\t\t// null\n'' && 16;\t\t\t// ''\nNaN && undefined;\t// NaN\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）|| 短路运算\n\n由于 || 运算的核心是：“全假为假、有真即真”，所以：\n\n * 如果 a || b 中 a 为真，那么该表达式的值由 a 决定（只计算 a）\n * 如果 a || b 中 a 为假，那么该表达式的值由 b 决定（计算 a 又计算 b）\n\n3 || 6;\t\t\t\t// 3\n0 || 6;\t\t\t\t// 6\nnull || undefined;\t// undefined\n'a' || 'b';\t\t\t// 'a'\nNaN || null;\t\t// null\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.6 逻辑运算的优先级\n\n优先级：! > && > ||\n\n!true || true;\t\t// true\n3 && 4 || 5 && 6；  // 4\n\n\n1\n2\n\n\n> 推荐使用 () 来规定优先级。\n\n\n# 五、赋值表达式\n\n\n# 5.1 赋值运算符\n\n意义     运算符\n赋值     =\n快捷赋值   +=、-=、*=、/=、%=\n自增运算   ++\n自减运算   --\n\n\n# 5.2 赋值运算产生值\n\n赋值运算也产生值，赋值号后面的值将作为 “赋值运算表达式的值”。\n\nvar a;\nconsole.log(a = 4);\t\t// 4\n\n\n1\n2\n\n\n这就意味着，可以连续使用赋值运算符。\n\nvar a, b, c;\na = b = c = 15;\nconsole.log(a);\t\t// 15\nconsole.log(b);\t\t// 15\nconsole.log(c); \t// 15\n\n\n1\n2\n3\n4\n5\n\n\n> 在实际开发中不建议使用连续赋值！\n\n\n# 5.3 快捷赋值\n\n快捷赋值运算符表示在 “原数值” 基础上进一步进行运算。\n\n\n# 5.4 自增自减运算\n\na++：先用再加；++a：先加再用。\n\na--：先用再减；--a：先减再用。\n\n\n# 六、综合运算的运算顺序\n\n非运算 > 数学运算 > 关系运算 > 逻辑运算\n\n> 建议使用 () 来规定优先级。",normalizedContent:"# 【js表达式与操作符】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是表达式和运算符\n\n表达式：由 操作数 和 运算符 组成的式子。\n\n表达式的分类：算术、关系、逻辑、赋值、综合。\n\n\n# 二、算术表达式\n\n\n# 2.1 算术运算符\n\n意义   运算符\n加    +\n减    -\n乘    *\n除    /\n取余   %\n\n> 推荐一律使用 () 来强制规定优先级！\n\n+ 有 “加法” 和 “连字符” 两种作用，如果 + 的某一边是字符串那么就为 ”连字符“，否则为 ”加法“。\n\n\n# 2.2 隐式类型转换\n\n如果参与数学运算的某操作数不是数字类型，那么 js 会自动将此操作数转换为数字型。\n\n3 * '4';\t\t// 12\ntrue + true;\t// 2\nfalse + 2;\t\t// 2\n3 * '2天'; \t   // nan\n\"z\" * \"j\";\t    // nan\n3 + '2天'; \t   // '32天'\n3 + null;\t\t// 0\n3 * '';\t\t\t// 0\n3 * ' ';\t\t// 0\n3 + '';\t\t\t// '3'\n3 + ' ';\t\t// '3 '\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 隐式转换的本质是 js 内部自动调用 number() 函数\n\n\n# 2.3 有关ieee754\n\n在 js 中，有些小数的数学运算不是很精准。\n\n0.1 + 0.2;\t// 0.30000000000000004\n\n\n1\n\n\njs 使用了 ieee754 二进制浮点数算术标准，这会使一些个别的小数运算产生 “丢失精度” 问题。\n\n注意：不是所有的小数运算都会出现精度问题，只是少数部分。\n\n> 几乎所有的高级语言都使用了 ieee754 二进制浮点数算术标准。\n> \n> ieee754 二进制浮点数算术标准是计算机底层编译标准，了解即可！\n\n【解决办法】\n\n在进行小数运算时，要调用数字的 tofixed() 方法保留指定的小数位数。\n\n> tofixed() 括号内接受一个保留小数位数的参数。\n\n(0.1 + 0.2).tofixed(2);\t\t\t\t// '0.30'，默认得到一个字符串值\nnumber((0.1 + 0.2).tofixed(2));\t\t // 0.3\n\n\n1\n2\n\n\n> tofixed() 遵循（“四舍六入”，“五不一定”）原则。\n> \n> (0.9945).tofixed(3);\t// \"0.995\"\n> \n> \n> 1\n\n> 最后要注意浮点数的相等比较：\n> \n> 1 / 3 === (1 - 2 / 3);\t// false\n> \n> \n> 1\n> \n> \n> 这不是 javascript 的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：\n> \n> math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001;\t// true\n> \n> \n> 1\n\n> 还有一种解决技巧，就是将浮点数转换为整数进行计算：\n> \n> 0.1 + 0.2;\t// 0.30000000000000004\n> (0.1 * 10 + 0.2 * 10) / 10;\t// 0.3\n> \n> \n> 1\n> 2\n\n\n# 2.4 幂和开根号\n\njs 中没有提供幂运算、开根号的运算符，需要使用 math 对象的相关方法进行计算。\n\nmath.pow(a, b)：求 a 的 b 次方。\n\nmath.sqrt(a)：求 a 的平方根。\n\nmath.pow(2, 3);\t\t// 8\nmath.pow(3, 2);\t\t// 9\nmath.sqrt(81);\t\t// 9\nmath.sqrt(-81);\t\t// nan\n\n\n1\n2\n3\n4\n\n\n\n# 2.5 向上取整和向下取整\n\nmath.ceil()：向上取整。\n\nmath.floor()：向下取整。\n\nmath.round()：把一个数字舍入为最接近的整数（“四舍六入”，“五不一定”）\n\n> 注意：向上、向下的标准是：x轴正方向为上！\n> \n> 负 ———— 0 ————> 正\n\nmath.ceil(2.4);\t\t\t// 3\nmath.floor(2.4);\t\t// 2\n\nmath.ceil(-2.4);\t\t// -2\nmath.floor(-2.4);\t\t// -3\n\nmath.ceil(2);\t\t\t// 2\nmath.floor(2);\t\t\t// 2\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 注意：由于底层的关系，无论是 tofixed() 还是 math.round() 都不是完全遵循 “四舍五入”（无论正负），而是 “四舍六入，五不一定”，为什么非要这样呢？原因是没办法！因为小数在计算机底层的实现机制导致的问题！建议对于小数位数的处理不要用原生的函数来处理！最好是手动实现想要的处理代码，或者是借助第三方库！\n\n\n# 三、关系表达式\n\n\n# 3.1 关系运算符\n\n意义      运算符\n大于      >\n小于      <\n大于或等于   >=\n小于或等于   <=\n等于      ==\n不等于     !=\n全等于     ===\n不全等于    !==\n\n\n# 3.2 相等和全等\n\n两个等号 == 运算符，不考虑值的类型，它会进行隐式转换后比较值的字面量是否相等。\n\n三个等号 === 运算符，不仅比较值是否相同，同时比较类型是否相同。\n\n5 == '5';\t\t// true\n5 === '5';\t\t// false\n\n\n1\n2\n\n\n1 == true;\t\t\t// true\n1 === true;\t\t\t// false\n\n0 == false;\t\t\t// true\n0 === false; \t\t// false\n\n0 == undefined;\t\t// false\n0 === undefined;\t// false\n\nundefined == null;\t// true\nundefined === null;\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> null 和 undefined 用 == 进行比较涉及隐式强制类型转换，es5 规范中规定。\n> \n> === 比较为 false，是因为 null 与 undefined 类型不同。\n> \n> 建议没有特殊情况请一律使用 ===\n\n\n# 3.3 nan不自等\n\nnan 作为一个特殊的数字类型值，它在用 == 比较的时候也有特殊的结果。\n\nnan == nan;\t\t\t// false\nnan\t=== nan;\t\t// false\n\n\n1\n2\n\n\n【如何判断某变量值为 nan】\n\nisnan() 函数可以用来判断变量值是否为 nan。\n\nisnan(nan);\t\t// true\nisnan(5);\t\t// false\nisnan('5');\t\t// false\n\n\n1\n2\n3\n\n\n> 但 isnan() 也不好用，它的机理是：只要该变量传入 number() 的执行结果是 nan，则 isnan() 函数都会得到 true。\n> \n> 对于，undefined 和 null，这种情况一般来说需要先进行单独判断，再进行 isnan 判断。\n> \n> isnan(undefined);\t// true\n> isnan('3天');\t   // true\n> isnan(null);\t\t// false\n> \n> \n> 1\n> 2\n> 3\n\n\n# 3.4 js中没有连比\n\n例如：3 <= a <= 15 的写法是错误的，应该为：a >= 3 && a <= 15。\n\n\n# 四、逻辑表达式\n\n\n# 4.1 逻辑运算符\n\n意义   运算符\n非    !\n与    &&\n或    ||\n\n\n# 4.2 非运算\n\n! 表示 “非”，也可以称为 “置反运算”。\n\n! 是一个 “单目运算符”，只需要一个操作数。\n\n置反运算的结果一定是布尔值。\n\n!true;\t\t\t// false\n!false;\t\t\t// true\n!0;\t\t\t\t// true\n!undefined;\t\t// true\n!'';\t\t\t// true\n!' ';\t\t\t// false\n!null;\t\t\t// true\n!'imooc';\t\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> !! 常用于确定一个值的布尔属性。\n> \n> !!true;\t\t// true\n> !!0;\t\t// false\n> !!'';\t\t// false\n> !!' ';\t\t// true\n> !!'imooc';\t// true\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n\n\n# 4.3 与运算\n\n&& 是 “双目运算符”。\n\n核心：全真为真、有假即假。\n\n\n# 4.4 或运算\n\n|| 是 “双目运算符”。\n\n核心：全假为假、有真即真。\n\n\n# 4.5 短路运算\n\n&& 与 ||，都属于 “短路运算符”。\n\n（1）&& 短路运算\n\n由于 && 运算的核心是：“全真为真、有假即假”，所以：\n\n * 如果 a && b 中 a 为真，那么该表达式的值由 b 决定（计算 a 又计算 b）\n * 如果 a && b 中 a 为假，那么该表达式的值由 a 决定（只计算 a）\n\n3 && 6;\t\t\t\t// 6\nundefined && 15;\t// undefined\n15 && undefined;\t// undefined\nnull && 2;\t\t\t// null\n'' && 16;\t\t\t// ''\nnan && undefined;\t// nan\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）|| 短路运算\n\n由于 || 运算的核心是：“全假为假、有真即真”，所以：\n\n * 如果 a || b 中 a 为真，那么该表达式的值由 a 决定（只计算 a）\n * 如果 a || b 中 a 为假，那么该表达式的值由 b 决定（计算 a 又计算 b）\n\n3 || 6;\t\t\t\t// 3\n0 || 6;\t\t\t\t// 6\nnull || undefined;\t// undefined\n'a' || 'b';\t\t\t// 'a'\nnan || null;\t\t// null\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.6 逻辑运算的优先级\n\n优先级：! > && > ||\n\n!true || true;\t\t// true\n3 && 4 || 5 && 6；  // 4\n\n\n1\n2\n\n\n> 推荐使用 () 来规定优先级。\n\n\n# 五、赋值表达式\n\n\n# 5.1 赋值运算符\n\n意义     运算符\n赋值     =\n快捷赋值   +=、-=、*=、/=、%=\n自增运算   ++\n自减运算   --\n\n\n# 5.2 赋值运算产生值\n\n赋值运算也产生值，赋值号后面的值将作为 “赋值运算表达式的值”。\n\nvar a;\nconsole.log(a = 4);\t\t// 4\n\n\n1\n2\n\n\n这就意味着，可以连续使用赋值运算符。\n\nvar a, b, c;\na = b = c = 15;\nconsole.log(a);\t\t// 15\nconsole.log(b);\t\t// 15\nconsole.log(c); \t// 15\n\n\n1\n2\n3\n4\n5\n\n\n> 在实际开发中不建议使用连续赋值！\n\n\n# 5.3 快捷赋值\n\n快捷赋值运算符表示在 “原数值” 基础上进一步进行运算。\n\n\n# 5.4 自增自减运算\n\na++：先用再加；++a：先加再用。\n\na--：先用再减；--a：先减再用。\n\n\n# 六、综合运算的运算顺序\n\n非运算 > 数学运算 > 关系运算 > 逻辑运算\n\n> 建议使用 () 来规定优先级。",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS流程控制",frontmatter:{title:"JS流程控制",date:"2020-04-30T11:11:33.000Z",permalink:"/pages/4b4e62/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/04.JS%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.html",relativePath:"20.JS/10.基础/04.JS流程控制.md",key:"v-3c877a2e",path:"/pages/4b4e62/",headersStr:null,content:"# 【JS流程控制】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、if 条件语句\n\nif (测试条件) {  \n    \n}\n\n\n1\n2\n3\n\n\nif (测试条件) { \n    \n} else {\n    \n}\n\n\n1\n2\n3\n4\n5\n\n\nif (测试条件) {\n    \n} else if (测试条件) {\n    \n} else {\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 条件语句可以嵌套（最好不要嵌套超过三层）\n * if-elseif-else 语句注意条件的区间（下一级条件的成立是建立在上一级条件不成立的前提下）\n * 可以只有 if 和 else if\n\n\n# 二、switch 选择语句\n\nswitch (变量/表达式) {\n    case 常量值/变量/表达式:\n        语句;\n        break;\n    case 常量值/变量/表达式:\n        语句;\n        break;\n    default:\n        语句;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 与其他高级语言不同，在 JS 中 case 后不仅仅只能跟常量值，还可以跟变量和表达式\n * 注意 switch 语句的 “开关” 特性（遇见 break 才跳出 switch，否则直接进入下一个 case），合理运用好 break（例如不加 break 可以实现多条 case 共用同一个语句体）\n * default 语句不是必须的\n\n\n# 三、三元运算符\n\n条件表达式 ? 表达式1 : 表达式2;\n\n当条件表达式为真时执行 表达式1 并返回结果，否则执行 表达式2 并返回结果。\n\n【三元运算符的用途】\n\n根据某个条件是否成立，在两个不同值中选择最终值。\n\nvar age = 24;\nvar type = age >= 18 ? '成年人' : '未成年人';\nalert(type);\n\n\n1\n2\n3\n\n\n\n# 四、for 循环语句\n\nfor (初次表达式; 判断条件; 历次表达式) {\n    \n}\n\n\n1\n2\n3\n\n\n在 JS 中，支持在 “初次表达式” 中声明变量并赋值。\n\n【执行过程】\n\n * 先执行 “初次表达式”（只唯一执行一次）\n * 判断条件（若条件为 false，退出循环）\n * 执行语句块\n * 执行 “历次表达式”\n * 判断条件（若条件为 false，退出循环）\n * 执行语句块\n * 执行 “历次表达式”\n * 判断条件（若条件为 false，退出循环）\n * ……\n\n【for ... in 循环】\n\nfor 循环的一个变体是 for ... in 循环，它可以把一个对象的所有属性依次循环出来：\n\n其中：key 是字符串类型，值为对象的属性名。\n\nvar o = {\n    name: 'Jerry',\n    age: 20,\n    city: 'Beijing'\n};\n\nfor (var key in o) {\n    console.log(key + ': ' + o[key]);\n}\n/*\n\"name: Jerry\"\n\"age: 20\"\n\"city: Beijing\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n要过滤掉对象继承的属性，用 hasOwnProperty() 来实现：\n\nvar o = {\n    name: 'Jerry',\n    age: 20,\n    city: 'Beijing'\n};\n\nfor (var key in o) {\n    if (o.hasOwnProperty(key)) {\n        console.log(key + ': ' + o[key]);\n    }\n}\n/*\n\"name: Jerry\"\n\"age: 20\"\n\"city: Beijing\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n由于数组也是对象的一种，因此，for ... in 循环可以直接循环出数组的索引：\n\n其中：i 是字符串类型，值为数组的索引值（字符串类型）。\n\nvar a = ['A', 'B', 'C'];\n\nfor (var i in a) {\n    console.log(i + ': ' + a[i]);\n}\n/*\n0: A\n1: B\n2: C\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n再次提醒：for ... in 对数组的循环得到的索引是 String 而不是 Number。\n\n【for ... of 循环】\n\nfor in 更适合遍历对象，当然也可以遍历数组，但是会存在一些问题，例如：索引为字符串型数字，不能直接进行几何运算！某些情况下，遍历顺序有可能不是按照实际数组的内部顺序！\n\n使用 for in 会遍历数组所有的可枚举属性，包括原型，如果不想遍历原型上的方法和属性的话，可以在循环内部判断一下，使用 hasOwnProperty() 方法可以判断某属性是不是该对象的实例属性：\n\nvar arr = [1, 2, 3];\nArray.prototype.n = 123;\n    \nfor (var i in arr) {\n  var res = arr[i];\n  console.log(res);\n}\n// 1 2 3 123\n\nfor(var i in arr) {\n    if(arr.hasOwnProperty(i)) {\n        var res = arr[i];\n  \t\tconsole.log(res);\n    }\n}\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nES6 中，引入了 for ... of 循环！适用遍历 数组/字符串/map/set 等拥有迭代器对象（iterator）的集合，但是不能遍历普通对象！如果想遍历对象的属性，你可以用 for in 循环（这也是它的本职工作）或用内建的 Object.keys() 方法（获取对象的实例属性组成的数组，不包括原型方法和属性）……\n\nfor of 遍历的是数组元素的值，而且 for of 遍历的只是数组内的元素，不包括原型属性和索引！\n\nvar arr = [1, 2, 3];\nArray.prototype.a = 123;\n\nfor (var value of arr) {\n  console.log(value);\n}\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nvar str = '13579';\n\nfor (var c of str) {\n    console.log(c);\n}\n// 1 3 5 7 9\n\n\n1\n2\n3\n4\n5\n6\n\n\n推荐：变量普通对象用：for in，变量数组及字符串等用：for of。\n\n\n# 五、while 循环语句\n\nwhile (判断条件) {\n    \n}\n\n\n1\n2\n3\n\n\ndo {\n    \n} while (判断条件);\n\n\n1\n2\n3\n\n\n在 while 中，先判断条件，条件满足时再执行语句体。\n\n在 do-while 中，do 内的语句块先执行一次，再判断条件。\n\n\n# 六、break 和 continue\n\nbreak;：立即终止本层次循环。\n\ncontinue;：立即跳过本层次循环，提前进入本层次的下一次循环。\n\n\n# 七、label 表达式\n\nlabel 是一个标签，可以配合 break 或 continue 使程序跳转到这个标签处执行（执行 break 或 continue），从而改变程序的执行流程。\n\n// 注意：label 不是一个特定的关键字，可以随便取名\nlabel: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i + j === 6) {\n            console.log(\"j=\" + j);\n            break label;\n        }\n    }\n    console.log(\"i=\" + i);\n}\n/*\nj=6\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlabel: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i + j === 6) {\n            console.log(\"j=\" + j);\n            continue label;\n        }\n    }\n    console.log(\"i=\" + i);\n}\n/*\nj=6\nj=5\nj=4\nj=3\nj=2\nj=1\nj=0\ni=7\ni=8\ni=9\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n// label + break 配合可以用在循环外的 if 语句中\nlabel: {\n    if (1 > 0) {\n        console.log(\"1\");\n        break label;\n    }\n    console.log(\"2\");\n}\n/*\n1\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 八、初识算法\n\n算法：解决方案的准确而完整的描述！\n\n * 输入\n * 输出\n * 有穷性\n * 确定性\n * 可行性\n\n> 好的算法还要满足：可读性、健壮性！",normalizedContent:"# 【js流程控制】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、if 条件语句\n\nif (测试条件) {  \n    \n}\n\n\n1\n2\n3\n\n\nif (测试条件) { \n    \n} else {\n    \n}\n\n\n1\n2\n3\n4\n5\n\n\nif (测试条件) {\n    \n} else if (测试条件) {\n    \n} else {\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 条件语句可以嵌套（最好不要嵌套超过三层）\n * if-elseif-else 语句注意条件的区间（下一级条件的成立是建立在上一级条件不成立的前提下）\n * 可以只有 if 和 else if\n\n\n# 二、switch 选择语句\n\nswitch (变量/表达式) {\n    case 常量值/变量/表达式:\n        语句;\n        break;\n    case 常量值/变量/表达式:\n        语句;\n        break;\n    default:\n        语句;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * 与其他高级语言不同，在 js 中 case 后不仅仅只能跟常量值，还可以跟变量和表达式\n * 注意 switch 语句的 “开关” 特性（遇见 break 才跳出 switch，否则直接进入下一个 case），合理运用好 break（例如不加 break 可以实现多条 case 共用同一个语句体）\n * default 语句不是必须的\n\n\n# 三、三元运算符\n\n条件表达式 ? 表达式1 : 表达式2;\n\n当条件表达式为真时执行 表达式1 并返回结果，否则执行 表达式2 并返回结果。\n\n【三元运算符的用途】\n\n根据某个条件是否成立，在两个不同值中选择最终值。\n\nvar age = 24;\nvar type = age >= 18 ? '成年人' : '未成年人';\nalert(type);\n\n\n1\n2\n3\n\n\n\n# 四、for 循环语句\n\nfor (初次表达式; 判断条件; 历次表达式) {\n    \n}\n\n\n1\n2\n3\n\n\n在 js 中，支持在 “初次表达式” 中声明变量并赋值。\n\n【执行过程】\n\n * 先执行 “初次表达式”（只唯一执行一次）\n * 判断条件（若条件为 false，退出循环）\n * 执行语句块\n * 执行 “历次表达式”\n * 判断条件（若条件为 false，退出循环）\n * 执行语句块\n * 执行 “历次表达式”\n * 判断条件（若条件为 false，退出循环）\n * ……\n\n【for ... in 循环】\n\nfor 循环的一个变体是 for ... in 循环，它可以把一个对象的所有属性依次循环出来：\n\n其中：key 是字符串类型，值为对象的属性名。\n\nvar o = {\n    name: 'jerry',\n    age: 20,\n    city: 'beijing'\n};\n\nfor (var key in o) {\n    console.log(key + ': ' + o[key]);\n}\n/*\n\"name: jerry\"\n\"age: 20\"\n\"city: beijing\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n要过滤掉对象继承的属性，用 hasownproperty() 来实现：\n\nvar o = {\n    name: 'jerry',\n    age: 20,\n    city: 'beijing'\n};\n\nfor (var key in o) {\n    if (o.hasownproperty(key)) {\n        console.log(key + ': ' + o[key]);\n    }\n}\n/*\n\"name: jerry\"\n\"age: 20\"\n\"city: beijing\"\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n由于数组也是对象的一种，因此，for ... in 循环可以直接循环出数组的索引：\n\n其中：i 是字符串类型，值为数组的索引值（字符串类型）。\n\nvar a = ['a', 'b', 'c'];\n\nfor (var i in a) {\n    console.log(i + ': ' + a[i]);\n}\n/*\n0: a\n1: b\n2: c\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n再次提醒：for ... in 对数组的循环得到的索引是 string 而不是 number。\n\n【for ... of 循环】\n\nfor in 更适合遍历对象，当然也可以遍历数组，但是会存在一些问题，例如：索引为字符串型数字，不能直接进行几何运算！某些情况下，遍历顺序有可能不是按照实际数组的内部顺序！\n\n使用 for in 会遍历数组所有的可枚举属性，包括原型，如果不想遍历原型上的方法和属性的话，可以在循环内部判断一下，使用 hasownproperty() 方法可以判断某属性是不是该对象的实例属性：\n\nvar arr = [1, 2, 3];\narray.prototype.n = 123;\n    \nfor (var i in arr) {\n  var res = arr[i];\n  console.log(res);\n}\n// 1 2 3 123\n\nfor(var i in arr) {\n    if(arr.hasownproperty(i)) {\n        var res = arr[i];\n  \t\tconsole.log(res);\n    }\n}\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nes6 中，引入了 for ... of 循环！适用遍历 数组/字符串/map/set 等拥有迭代器对象（iterator）的集合，但是不能遍历普通对象！如果想遍历对象的属性，你可以用 for in 循环（这也是它的本职工作）或用内建的 object.keys() 方法（获取对象的实例属性组成的数组，不包括原型方法和属性）……\n\nfor of 遍历的是数组元素的值，而且 for of 遍历的只是数组内的元素，不包括原型属性和索引！\n\nvar arr = [1, 2, 3];\narray.prototype.a = 123;\n\nfor (var value of arr) {\n  console.log(value);\n}\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nvar str = '13579';\n\nfor (var c of str) {\n    console.log(c);\n}\n// 1 3 5 7 9\n\n\n1\n2\n3\n4\n5\n6\n\n\n推荐：变量普通对象用：for in，变量数组及字符串等用：for of。\n\n\n# 五、while 循环语句\n\nwhile (判断条件) {\n    \n}\n\n\n1\n2\n3\n\n\ndo {\n    \n} while (判断条件);\n\n\n1\n2\n3\n\n\n在 while 中，先判断条件，条件满足时再执行语句体。\n\n在 do-while 中，do 内的语句块先执行一次，再判断条件。\n\n\n# 六、break 和 continue\n\nbreak;：立即终止本层次循环。\n\ncontinue;：立即跳过本层次循环，提前进入本层次的下一次循环。\n\n\n# 七、label 表达式\n\nlabel 是一个标签，可以配合 break 或 continue 使程序跳转到这个标签处执行（执行 break 或 continue），从而改变程序的执行流程。\n\n// 注意：label 不是一个特定的关键字，可以随便取名\nlabel: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i + j === 6) {\n            console.log(\"j=\" + j);\n            break label;\n        }\n    }\n    console.log(\"i=\" + i);\n}\n/*\nj=6\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nlabel: for (var i = 0; i < 10; i++) {\n    for (var j = 0; j < 10; j++) {\n        if (i + j === 6) {\n            console.log(\"j=\" + j);\n            continue label;\n        }\n    }\n    console.log(\"i=\" + i);\n}\n/*\nj=6\nj=5\nj=4\nj=3\nj=2\nj=1\nj=0\ni=7\ni=8\ni=9\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n// label + break 配合可以用在循环外的 if 语句中\nlabel: {\n    if (1 > 0) {\n        console.log(\"1\");\n        break label;\n    }\n    console.log(\"2\");\n}\n/*\n1\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 八、初识算法\n\n算法：解决方案的准确而完整的描述！\n\n * 输入\n * 输出\n * 有穷性\n * 确定性\n * 可行性\n\n> 好的算法还要满足：可读性、健壮性！",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS数组",frontmatter:{title:"JS数组",date:"2020-04-30T12:02:50.000Z",permalink:"/pages/39d0fd/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/05.JS%E6%95%B0%E7%BB%84.html",relativePath:"20.JS/10.基础/05.JS数组.md",key:"v-d0ab1154",path:"/pages/39d0fd/",headers:[{level:2,title:"2.1 方括号定义法",slug:"_2-1-方括号定义法",normalizedTitle:"2.1 方括号定义法",charIndex:190},{level:2,title:"2.2 new 定义法",slug:"_2-2-new-定义法",normalizedTitle:"2.2 new 定义法",charIndex:243},{level:2,title:"7.1 forEach() 方法",slug:"_7-1-foreach-方法",normalizedTitle:"7.1 foreach() 方法",charIndex:1226},{level:2,title:"7.2 map() 方法",slug:"_7-2-map-方法",normalizedTitle:"7.2 map() 方法",charIndex:1833},{level:2,title:"9.1 数组的头尾操作",slug:"_9-1-数组的头尾操作",normalizedTitle:"9.1 数组的头尾操作",charIndex:2563},{level:3,title:"9.1.1 push() 方法",slug:"_9-1-1-push-方法",normalizedTitle:"9.1.1 push() 方法",charIndex:2671},{level:3,title:"9.1.2 pop() 方法",slug:"_9-1-2-pop-方法",normalizedTitle:"9.1.2 pop() 方法",charIndex:2904},{level:3,title:"9.1.3 unshift() 方法",slug:"_9-1-3-unshift-方法",normalizedTitle:"9.1.3 unshift() 方法",charIndex:3121},{level:3,title:"9.1.4 shift() 方法",slug:"_9-1-4-shift-方法",normalizedTitle:"9.1.4 shift() 方法",charIndex:3231},{level:2,title:"9.2 splice() 方法",slug:"_9-2-splice-方法",normalizedTitle:"9.2 splice() 方法",charIndex:3335},{level:2,title:"9.3 slice() 方法",slug:"_9-3-slice-方法",normalizedTitle:"9.3 slice() 方法",charIndex:4455},{level:2,title:"9.4 join() 和 split() 方法",slug:"_9-4-join-和-split-方法",normalizedTitle:"9.4 join() 和 split() 方法",charIndex:5032},{level:2,title:"9.5 字符串和数组更多相关性",slug:"_9-5-字符串和数组更多相关性",normalizedTitle:"9.5 字符串和数组更多相关性",charIndex:5732},{level:2,title:"9.6 concat() 方法",slug:"_9-6-concat-方法",normalizedTitle:"9.6 concat() 方法",charIndex:6003},{level:2,title:"9.7 reverse() 方法",slug:"_9-7-reverse-方法",normalizedTitle:"9.7 reverse() 方法",charIndex:6259},{level:2,title:"9.8 indexOf() 和 includes() 方法",slug:"_9-8-indexof-和-includes-方法",normalizedTitle:"9.8 indexof() 和 includes() 方法",charIndex:6497},{level:2,title:"9.9 sort() 方法",slug:"_9-9-sort-方法",normalizedTitle:"9.9 sort() 方法",charIndex:7023},{level:2,title:"9.10 find/findIndex/findLastIndex() 方法",slug:"_9-10-find-findindex-findlastindex-方法",normalizedTitle:"9.10 find/findindex/findlastindex() 方法",charIndex:8723},{level:2,title:"9.11 filter() 方法",slug:"_9-11-filter-方法",normalizedTitle:"9.11 filter() 方法",charIndex:10043},{level:2,title:"9.12 有关数组在 ES6 中的增强",slug:"_9-12-有关数组在-es6-中的增强",normalizedTitle:"9.12 有关数组在 es6 中的增强",charIndex:10887},{level:2,title:"9.13 数组去重和随机样本",slug:"_9-13-数组去重和随机样本",normalizedTitle:"9.13 数组去重和随机样本",charIndex:10947},{level:2,title:"9.14 冒泡排序",slug:"_9-14-冒泡排序",normalizedTitle:"9.14 冒泡排序",charIndex:11559},{level:2,title:"9.15 快速排序（冒泡排序改进版）",slug:"_9-15-快速排序-冒泡排序改进版",normalizedTitle:"9.15 快速排序（冒泡排序改进版）",charIndex:11993}],headersStr:"2.1 方括号定义法 2.2 new 定义法 7.1 forEach() 方法 7.2 map() 方法 9.1 数组的头尾操作 9.1.1 push() 方法 9.1.2 pop() 方法 9.1.3 unshift() 方法 9.1.4 shift() 方法 9.2 splice() 方法 9.3 slice() 方法 9.4 join() 和 split() 方法 9.5 字符串和数组更多相关性 9.6 concat() 方法 9.7 reverse() 方法 9.8 indexOf() 和 includes() 方法 9.9 sort() 方法 9.10 find/findIndex/findLastIndex() 方法 9.11 filter() 方法 9.12 有关数组在 ES6 中的增强 9.13 数组去重和随机样本 9.14 冒泡排序 9.15 快速排序（冒泡排序改进版）",content:"# 【JS数组】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是数组\n\n数组（Array），顾名思义：用来存储一组相关值的类型。\n\n数组可以方便地对一组值进行求和、计算平均值、逐项遍历等操作。\n\nvar scoreArr = [87, 89, 93, 71, 100, 68, 94, 88];\n\n\n1\n\n\n> 数组名习惯以 Arr 结尾。\n\n\n# 二、数组的定义\n\n\n# 2.1 方括号定义法\n\nvar arr = ['A', 'B', 'C', 'D'];\n\n\n1\n\n\n\n# 2.2 new 定义法\n\nvar arr = new Array('A', 'B', 'C', 'D');\n\n\n1\n\n\nvar arr = new Array(4);\n// 定义一个长度为 4 的数组，但是这 4 项都是 undefined\n\n\n1\n2\n\n\n> 两种定义方法根据实际需求选择即可，两者的底层都是同样的实现逻辑。\n> \n> 推荐：方括号定义法！\n> \n>  * 如果是定义时就要指定数组的值，那么建议使用：var arr = ['A', 'B', 'C', 'D'];\n>  * 如果是定义时还不指定数组的值，那么建议使用：var arr = [];\n\n\n# 三、访问数组项\n\n> 注意：JS 中数组的元素可以是不同的数据类型！\n\n数组每一项都有下标，下标从 0 开始！\n\n可以使用 数组名[下标] 的形式，访问数组的任一项。\n\n\n# 四、下标越界\n\nJS 规定，访问数组中不存在的项会返回 undefined，不会报错！\n\n\n# 五、数组的长度\n\n数组的 length 属性表示它的长度。\n\n> 数组是引用类型，有自己的属性和方法。\n\nvar arr = ['A', 'B', 'C', 'D'];\nconsole.log(arr.length);\t// 4\n\n\n1\n2\n\n\n> 数组最后一项的下标是数组的长度减 1。\n\n\n# 六、更改数组项\n\n 1. 访问数组项\n 2. 更改数组值\n\n如果更改的数组项超过了 length-1，则会创造该项。\n\n> JS 数组是可以动态扩容的！\n\nvar arr = [1, 2, 3, 4];\narr[6] = 0;\nconsole.log(arr);\t// [1, 2, 3, 4, undefined, undefined, 0]\n\n\n1\n2\n3\n\n\n\n# 七、数组的遍历\n\n数组最大的优点就是方便遍历。\n\nvar arr = [1, 2, 3, 4];\nfor (var i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n\nvar a = ['A', 'B', 'C'];\nfor (var v of a) {\n    console.log(v); \t// 'A', 'B', 'C'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.1 forEach() 方法\n\nArray.forEach 方法为数组的每个元素都运行一个函数。\n\n语法：\n\narr.forEach(function(item, index, array) {\n  // ...\n});\n\n\n1\n2\n3\n\n\n案例：\n\n['Bilbo', 'Gandalf', 'Nazgul'].forEach(function (item, index, array) {\n  console.log(`${item} 的索引值为：${index}，在数组：${array} 中`);\n});\n\n或者：\n\nvar arr = ['Bilbo', 'Gandalf', 'Nazgul'];\narr.forEach(function (item, index, array) {\n  console.log(`${item} 的索引值为：${index}，在数组：${array} 中`);\n});\n// Bilbo 的索引值为：0，在数组：Bilbo,Gandalf,Nazgul 中\n// Gandalf 的索引值为：1，在数组：Bilbo,Gandalf,Nazgul 中\n// Nazgul 的索引值为：2，在数组：Bilbo,Gandalf,Nazgul 中\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该函数的结果（如果它有返回）会被抛弃和忽略。\n\n\n# 7.2 map() 方法\n\nArray.map 方法是最有用和经常使用的方法之一。\n\n它对数组的每个元素都调用函数，并返回结果数组。\n\n语法：\n\nvar result = arr.map(function(item, index, array) {\n  // ...\n})\n\n\n1\n2\n3\n\n\n例如，在这里我们将每个元素转换为它的字符串长度：\n\nvar lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(function(item, index, array) {\n    return item.length;\n});\nconsole.log(lengths); \n// [5, 7, 6]\n\n// 可以省略不需要的形参：\nvar arr = [\"Bilbo\", \"Gandalf\", \"Nazgul\"];\nvar lengths = arr.map(function(item) {\n    return item.length;\n});\nconsole.log(lengths); \n// [5, 7, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 八、数组类型的检测\n\n数组用 typeof 检测结果是 object。\n\nArray.isArray() 方法可以用来检测数组，返回一个布尔值。\n\n> isArray() 不兼容 IE678，所以后面课程中，还将介绍使用 “鸭式辨型” 检测方法。\n\nArray.isArray([1, 2, 3]);\t\t// true\nArray.isArray([]);\t\t\t\t// true\n\n\n1\n2\n\n\n\n# 九、数组的常用方法\n\n\n# 9.1 数组的头尾操作\n\n方法          功能\npush()      在尾部插入新项\npop()       在尾部删除\nunshift()   在头部插入新项\nshift()     在头部删除\n\n\n# 9.1.1 push() 方法\n\npush() 方法用来在数组末尾推入新项，参数就是要推入的项。\n\n如果要推入多项，可以用逗号隔开。\n\n调用 push() 方法后，数组会立即改变，不需要赋值。\n\nvar arr = [22, 33, 44, 55];\narr.push(66);\narr.push(77, 88, 99);\nconsole.log(arr);\n// [22, 33, 44, 55, 66, 77, 88, 99]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9.1.2 pop() 方法\n\n与 push() 方法相反，pop() 方法用来删除数组中的最后一项。\n\n() 里没有参数，默认弹出最后一项。\n\npop() 默认返回最后一项的值。\n\nvar arr = [22, 33, 44, 55];\nvar item =  arr.pop();\nconsole.log(arr);\t// [22, 33, 44]\nconsole.log(item);\t// 55\n\n\n1\n2\n3\n4\n\n\n\n# 9.1.3 unshift() 方法\n\nunshift() 方法用来在数组头部插入新项，参数就是要插入的项。\n\n如果要插入多项，可以用逗号隔开。\n\n调用 unshift() 方法后，数组会立即改变，不需要赋值。\n\n\n# 9.1.4 shift() 方法\n\n与 unshift() 方法相反，shift() 方法用来删除数组中的开头一项。\n\n() 里没有参数，默认弹出开头一项。\n\nshift() 默认返回开头一项的值。\n\n\n# 9.2 splice() 方法\n\nsplice() 方法用于替换数组中的指定项。\n\n> 由于 splice() 可以实现很多功能，所以也称为 JS 的 “多功能方法”。\n\n * 替换项\n\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n// 从下标为 3 的项开始，连续替换 2 项。即将 'D', 'E' 替换为 'X', 'Y', 'Z'\narr.splice(3, 2, 'X', 'Y', 'Z');\nconsole.log(arr);\n// ['A', 'B', 'C', 'X', 'Y', 'Z', 'F', 'G']\n\n\n1\n2\n3\n4\n5\n\n * 插入项\n\nvar arr = ['A', 'B', 'C', 'D'];\n// 从下标为 2 的项开始，连续替换 0 项，即：在 [2] 处插入。\narr.splice(2, 0, 'X', 'Y', 'Z');\nconsole.log(arr);\n// ['A', 'B', 'X', 'Y', 'Z', 'C', 'D']\n\n\n1\n2\n3\n4\n5\n\n * 删除项\n\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n// 从下标为 2 的项开始，连续替换 4 项（替换为空，即：删除）。\narr.splice(2, 4);\nconsole.log(arr);\n// ['A', 'B', 'G']\n\n\n1\n2\n3\n4\n5\n\n\nsplice() 方法会以数组形式返回被替换/删除的项。\n\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n// 从下标为 3 的项开始，连续替换 2 项。\nvar item = arr.splice(3, 2, 'X', 'Y', 'Z');\nconsole.log(arr);\n// ['A', 'B', 'C', 'X', 'Y', 'Z', 'F', 'G']\nconsole.log(item);\n// ['D', 'E']\n\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];\n// 从下标为 2 的项开始，连续替换 4 项（替换为空，即：删除）。\nvar item = arr.splice(2, 4);\nconsole.log(arr);\n// ['A', 'B', 'G']\nconsole.log(item);\n// ['C', 'D', 'E', 'F']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 slice() 方法\n\nslice() 方法用于得到子数组，类似于字符串中的 slice() 方法。\n\nslice(a, b) 截取的子数组从下标为 a 的项开始，到下标为 b（但不包括下标为 b 的项）结束。\n\nslice(a, b) 方法不会更改原有的数组。\n\nslice() 如果不提供第二个参数，则表示从指定项开始，提取后续所有项作为子数组。\n\nslice() 方法的参数允许为负数，表示数组的倒数第几项（记住不包括最后一项）。\n\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F'];\nvar childArr1 = arr.slice(2, 5);\nvar childArr2 = arr.slice(2);\nvar childArr3 = arr.slice(2, -1);\nconsole.log(arr);\t\t\t// ['A', 'B', 'C', 'D', 'E', 'F']\nconsole.log(childArr1);\t\t// ['C', 'D', 'E']\nconsole.log(childArr2);\t\t// ['C', 'D', 'E', 'F']\nconsole.log(childArr3);\t\t// ['C', 'D', 'E']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.4 join() 和 split() 方法\n\n数组的 join() 方法可以使 数组 转为 字符串。\n\n字符串的 split() 方法可以使 字符串 转为 数组。\n\n * join() 的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 toString() 方法。\n * split() 的参数表示以什么字符拆分字符串，一般不能留空。\n\n[22, 33, 44, 55].join();\t\t// \"22,33,44,55\"\n[22, 33, 44, 55].toString();\t// \"22,33,44,55\"\n[22, 33, 44, 55].join(',');\t\t// \"22,33,44,55\"\n[22, 33, 44, 55].join('-');\t\t// \"22-33-44-55\"\n[22, 33, 44, 55].join('~');\t\t// \"22~33~44~55\"\n\n\n1\n2\n3\n4\n5\n\n\n'abcdefg'.split();\t\t\t\t// [\"abcdefg\"]\n'abcdefg'.split('');\t\t\t// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n'a-b-c-d-e-f-g'.split('');\t\t// [\"a\", \"-\", \"b\", \"-\", \"c\", \"-\", \"d\", \"-\", \"e\", \"-\", \"f\", \"-\", \"g\"]\n'a-b-c-d-e-f-g'.split('-');\t\t// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\n\n1\n2\n3\n4\n\n\n\n# 9.5 字符串和数组更多相关性\n\n字符串也可以使用 [下标] 的形式访问某个字符，等价于 charAt() 方法。\n\n> 在对字符串中的字符进行遍历时不用转为数组，直接利用 [下标] 即可！\n\n'我爱前端'[0];\t\t\t// \"我\"\n'我爱前端'[1];\t\t\t// \"爱\"\n'我爱前端'.charAt(0);\t// \"我\"\n\n\n1\n2\n3\n\n\nvar str = '我爱前端';\nfor (var i = 0; i < str.length; i++) {\n    console.log(str[i]);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 9.6 concat() 方法\n\nconcat() 方法可以合并连接多个数组（以返回值的形式）。\n\nconcat() 方法不会改变原数组。\n\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = [5, 6, 7, 8];\nvar arr3 = [9, 10, 11];\nvar arr = arr1.concat(arr2, arr3);\nconsole.log(arr);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9.7 reverse() 方法\n\nreverse() 方法用来将一个数组中的全部项顺序置反。\n\nvar arr = ['A', 'B', 'C', 'D'];\narr.reverse();\nconsole.log(arr);\t// [\"D\", \"C\", \"B\", \"A\"]\n\n\n1\n2\n3\n\n\n【小案例】\n\n字符串 'ABCDEFG' 逆序。\n\n'ABCDEFG'.split('').reverse().join('');\n// \"GFEDCBA\"\n\n\n1\n2\n\n\n\n# 9.8 indexOf() 和 includes() 方法\n\nindexOf() 方法的功能是搜索数组中的元素，并返回它所在的位置，如果元素不存在，则返回 -1。\n\nincludes() 方法的功能是判断一个数组是否包含一个指定的值，返回一个布尔值。\n\n['A', 'B', 'C', 'D'].indexOf('C');\t// 2\n['A', 'B', 'C', 'D'].indexOf('D');\t// 3\n['A', 'B', 'C', 'D'].indexOf('X');\t// -1\n['A', 'B', 'B', 'B'].indexOf('B');\t// 1\n\n\n1\n2\n3\n4\n\n\n['A', 'B', 'C', 'D'].includes('D');\t// true\n['A', 'B', 'C', 'D'].includes('X');\t// false\n\n\n1\n2\n\n\n注意：indexOf() 及 includes() 方法的判断标准为 === 全相等！\n\n[11, 22, 33].includes('22');\t// false\n[11, 22, 33].indexOf('22');\t\t// -1\n\n\n1\n2\n\n\n\n# 9.9 sort() 方法\n\nsort() 方法用原地算法（直接改变原数组）对数组的元素进行排序，并返回数组。\n\n默认排序顺序是将元素转换为字符串，然后根据字典序进行排序（数字 ——> 大写字母 ——> 小写字母，字符串内逐个字符进行比较，相同时比较下一位）\n\nvar arr = [3, 18, 10, 24];\nconsole.log(arr.sort());\t// [ 10, 18, 24, 3 ]\n\nvar arr = ['A', 'a', 'c', 'D', 1];\nconsole.log(arr.sort());\t// [ 1, 'A', 'D', 'a', 'c' ]\n\nvar arr = ['aa', 'a0', 'aA', 'A1', 'Aa', 'AA'];\nconsole.log(arr.sort());\t// [ 'A1', 'AA', 'Aa', 'a0', 'aA', 'aa' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsort() 方法可以接收一个函数作为参数，我们可以在这个函数中自定义我们的排序规则：\n\narr.sort(function(a, b) {\n    // 比较规则...\n});\n// 参数a：前一个用于比较的元素。\n// 参数b：后一个用于比较的元素。\n\n\n1\n2\n3\n4\n5\n\n\nFUNCTION(A, B) 返回值   排序顺序\n> 0                  a 在 b 后\n< 0                  a 在 b 前\n=== 0                保持 a 和 b 的顺序\n\n案例1：按数字大小进行排序（降序）：\n\nvar arr = [3, 18, 10, 24];\narr.sort(function(a, b) {\n   if (a > b) {\n       return -1;\n   } else if (a < b) {\n       return 1;\n   } else {\n       return 0;\n   }\n});\nconsole.log(arr);\t// [ 24, 18, 10, 3 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n案例2：按照学生分数进行排序（降序）：\n\nvar students = [\n    { name: 'Edward', score: 66 },\n    { name: 'Sharpe', score: 84 },\n    { name: 'And', score: 58 },\n    { name: 'The', score: 92 },\n    { name: 'Magnetic', score: 99 },\n    { name: 'Zeros', score: 74 }\n];\nstudents.sort(function (a, b) {\n    if (a.score > b.score) {\n        return -1;\n    } else if (a.score < b.score) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nconsole.log(students);\n/*\n[ \n{ name: 'Magnetic', score: 99 },\n{ name: 'The', score: 92 },\n{ name: 'Sharpe', score: 84 },\n{ name: 'Zeros', score: 74 },\n{ name: 'Edward', score: 66 },\n{ name: 'And', score: 58 } \n]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n除了内置排序方法外，还有一些排序算法：冒泡排序 和 快速排序 将在后面介绍。\n\n\n# 9.10 find/findIndex/findLastIndex() 方法\n\n想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？\n\n这时可以用 Array.find 方法。\n\n语法如下：\n\nvar result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 如果返回 falsy，则继续迭代，如果一直没有返回 true，那么结束时返回 undefined\n});\n\n\n1\n2\n3\n4\n\n\n依次对数组中的每个元素调用该函数：\n\n * item 是元素。\n * index 是它的索引。\n * array 是数组本身。\n\n如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。\n\n例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id === 1 的那个用户：\n\nvar users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\nvar user = users.find(function(item) {\n    return item.id === 1;\n});\n\nconsole.log(user.name); // John\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在现实生活中，对象数组是很常见的，所以 find 方法非常有用。\n\n注意在这个例子中，我们传给了 find 一个单参数函数。这很典型，并且 find 方法的其他参数很少使用。\n\narr.findIndex 方法（与 arr.find）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 -1。\n\narr.findLastIndex 方法类似于 findIndex，但从右向左搜索，类似于 lastIndexOf。\n\n这是一个例子：\n\nvar users = [\n    { id: 1, name: 'John' },\n    { id: 2, name: 'Pete' },\n    { id: 3, name: 'Mary' },\n    { id: 4, name: 'John' }\n];\n\n// 寻找第一个 John 的索引\nconsole.log(\n    users.findIndex(function (user) {\n        return user.name === 'John';\n    })\n); // 0\n\n// 寻找最后一个 John 的索引\nconsole.log(\n    users.findLastIndex(function (user) {\n        return user.name === 'John';\n    })\n); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 9.11 filter() 方法\n\nfind 方法搜索的是使函数返回 true 的第一个（单个）元素。\n\n如果需要匹配的有很多，我们可以使用 Array.filter(fn)。\n\n语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组：\n\nfilter：过滤、过滤器\n\nvar results = arr.filter(function(item, index, array) {\n  // 如果返回 true，那么 item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\n例如：\n\nvar users = [\n  {id: 1, name: 'John'},\n  {id: 2, name: 'Pete'},\n  {id: 3, name: 'Jerry'},\n  {id: 4, name: 'Mary'}\n];\n\n// 返回前两个用户的数组\nvar someUsers = users.filter(function(item) {\n    return item.id < 3;\n});\nconsole.log(someUsers); // [ { id: 1, name: 'John' }, { id: 2, name: 'Pete' } ]\n\n// 返回用户名字含四个字母的数组\nvar fourNameUsers = users.filter(function(item) {\n    return item.name.length <= 4;\n});\nconsole.log(fourNameUsers);\t// [ { id: 1, name: 'John' }, { id: 2, name: 'Pete' }, { id: 4, name: 'Mary' } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 9.12 有关数组在 ES6 中的增强\n\n数组在 ES6 中新增了较多的新方法，将在 ES6 相关课程中介绍。\n\n\n# 9.13 数组去重和随机样本\n\n【数组去重】\n\n题目：去掉数组中的重复项。\n\n思路：准备一个空结果数组，遍历原数组，如果遍历到的项不在结果数组中，则推入结果数组。\n\nvar arr = [1, 1, 1, 2, 2, 3, 3, 3, 2, 1];\nvar resultArr = [];\nfor (var i = 0; i < arr.length; i++) {\n    if (!resultArr.includes(arr[i])) {\n        resultArr.push(arr[i]);\n    }\n}\nconsole.log(resultArr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【随机样本】\n\n题目：请随机从原数组中取 3 项。\n\n思路：准备一个空结果数组，遍历原数组，随机选择一项，推入结果数组，并且将这项在原数组中删除。\n\nvar arr = [3, 6, 10, 5, 8, 9];\nvar resultArr = [];\nfor (var i = 0; i < 3; i++) {\n    var n = parseInt(Math.random() * arr.length);\n    resultArr.push(arr[n]);\n    arr.splice(n, 1);\n}\nconsole.log(resultArr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.14 冒泡排序\n\n冒泡排序是一个著名的排序算法，也是最基础的交换排序。\n\n冒泡排序的核心思想：一趟一趟地进行多次项的两两比较，每次都会将最大的元素排好位置，如同水中的气泡上浮一样。\n\n> 时间复杂度：O(n²)\n\n\n\nvar arr = [9, 5, 6, 8, 2, 7, 3, 4, 1];\nvar temp;\nfor (var i = 0; i < arr.length - 1; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n        if (arr[i] > arr[j]) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\nconsole.log(arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 9.15 快速排序（冒泡排序改进版）\n\n快速排序（Quicksort）是使用得最广泛，速度也较快的排序算法。它是图灵奖得主 C. A. R. Hoare（1934--）于 1960 时提出来的。是二十世纪 10 大算法之一，非常重要！时间复杂度：O(nlogn)，稳定性：不稳定。\n\n\n\n快速排序与冒泡排序同属交换排序，不过快速排序采用了 “分治法” 的思想大大提高了排序的时间性能。\n\n\"快速排序\"的思想很简单，整个排序过程只需要三步：\n\n 1. 在数据集之中，选择一个元素作为 \"基准\"（pivot）\n\n 2. 所有小于 \"基准\" 的元素，都移到 \"基准\" 的左边；所有大于 \"基准\" 的元素，都移到 \"基准\" 的右边\n\n 3. 对 基准 左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止\n\n举例来说，现在有一个数据集 {85, 24, 63, 45, 17, 31, 96, 50}，怎么对其排序呢？\n\n第一步，选择中间的元素 45 作为 \"基准\"（基准值可以任意选择，但是选择中间的值比较容易理解）。\n\n第二步，按照顺序，将每个元素与 \"基准\" 进行比较，形成两个子集，一个 \"小于45\"，另一个 \"大于等于45\"。\n\n第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\n下面用 Javascript 语言实现上面的算法。\n\n首先，定义一个 quickSort 函数，它的参数是一个数组。\n\n var quickSort = function(arr) {\n };\n\n\n1\n2\n\n\n然后，检查数组的元素个数，如果小于等于 1，就返回。\n\n var quickSort = function(arr) {\n \tif (arr.length <= 1) {\n    \treturn arr; \n    }\n };\n\n\n1\n2\n3\n4\n5\n\n\n接着，选择 \"基准\"（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。\n\nvar quickSort = function(arr) {\n\tif (arr.length <= 1) {\n        return arr; \n    }\n    // Math.floor 向下取整\n 　　var pivotIndex = Math.floor(arr.length / 2) ;\n\t// splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。\n 　　var pivot = arr.splice(pivotIndex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后，开始遍历数组，小于 \"基准\" 的元素放入左边的子集，大于基准的元素放入右边的子集。\n\n var quickSort = function(arr) {\n \tif (arr.length <= 1) {\n        return arr; \n    }\n 　　var pivotIndex = Math.floor(arr.length / 2) ;\n 　　var pivot = arr.splice(pivotIndex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n 　　for (var i = 0; i < arr.length; i++) {\n       if (arr[i] < pivot) {\n           left.push(arr[i]);\n       } else {\n           right.push(arr[i]);\n       }\n   }\n };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后，使用递归不断重复这个过程，就可以得到排序后的数组。\n\n var quickSort = function(arr) {\n     if (arr.length <= 1) { \n         return arr; \n     }\n 　　var pivotIndex = Math.floor(arr.length / 2);\n 　　var pivot = arr.splice(pivotIndex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n 　　for (var i = 0; i < arr.length; i++) {\n       if (arr[i] < pivot) {\n           left.push(arr[i]);\n       } else {\n           right.push(arr[i]);\n       }\n   }\n     // concat 拼接数组\n     return quickSort(left).concat([pivot], quickSort(right));\n };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 十、二维数组\n\n二维数组：以数组作为数组元素的数组，即 “数组的数组”。\n\n二维数组可以看做是 “矩阵”。\n\n> matrix：矩阵\n\nvar matrix = [\n    [11, 33, 55],\n    [22, 33, 44],\n    [36, 49, 52],\n    [56, 10, 23]\n];\n\n// 二维数组长度\nconsole.log(matrix.length);\t\t// 4\nconsole.log(matrix[1].length);\t// 3\n\n// 遍历二维数组\nfor (var i = 0; i < matrix.length; i++) {\n    for (var j = 0; j < matrix[i].length; j++) {\n        console.log(matrix[i][j]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 十一、基本类型值和引用类型值\n\n【当 var a = b 赋值时】\n\n * 基本类型值：内存中产生新的副本\n * 引用类型值：内存中不产生新的副本，而是让新变量指向同一个对象（内存地址的副本）\n\n// 基本类型值\nvar a = 3;\nvar b = a;\na++;\nconsole.log(a);\t\t// 4\nconsloe.log(b);\t\t// 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 引用类型值\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = arr1;\narr1.push(5);\nconsole.log(arr1);\t// [1, 2, 3, 4, 5]\nconsole.log(arr2);\t// [1, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n6\n\n * 基本类型：number、boolean、string、undefined、null\n * 引用类型：array、object、function、regexp、……\n\n【相等 == 判断时的区别】\n\n * 基本类型进行相等 == 判断时，会比较 “值” 是否相等\n * 引用类型进行相等 == 判断时，会比较 “址” 是否相等，也就是说它会比较是否为内存中的同一个对象\n\n> 基本类型：==（自动转型后，比较值）；===（类型相同的情况下，比较值）\n> \n> 引用类型：== 和 === 效果一样！（因为当内存地址相同时，类型肯定相同）\n\n3 == 3;\t\t// true\n3 === 3;\t// true\n3 == '3';\t// true\n3 === '3';\t// false\n[1, 2, 3] == [1, 2, 3];\t\t// false\n[1, 2, 3] === [1, 2, 3];\t// false\n[] == [];\t// false\n[] === [];\t// false\n\nvar arr = [1, 2, 3];\narr == arr;\t\t// true\nvar arr2 = arr;\narr == arr2;\t// true，这里比较的是 arr 与 arr2 中保存的地址是否相等\narr === arr2;\t// true，由于类型相同，所以这里比较的也是 arr 与 arr2 中保存的地址是否相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 十二、深克隆和浅克隆\n\n> 深克隆和浅克隆需要手写代码实现，而不是简单的调用函数。\n\n使用 arr1 = arr2 的语法不会克隆数组（两个变量指向同一个内存地址）。\n\n浅克隆：只克隆数组的第一层，如果是多维数组，或者数组中的项是其他引用类型值，则不克隆其他更深层。\n\n深克隆：克隆数组的所有层，要用递归方法，在之后介绍。\n\n【浅克隆】\n\n> 核心思想：“藕断丝连”\n\nvar arr = [1, 2, 3, 4, [5, 6, 7]];\nvar resultArr = [];\nfor (var i = 0; i < arr.length; i++) {\n    resultArr.push(arr[i]);\n}\nconsole.log(resultArr);\t\t            // [1, 2, 3, 4, [5, 6, 7]]\nconsole.log(resultArr == arr);  \t\t// false    \nconsole.log(resultArr[4] == arr[4]);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 【js数组】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是数组\n\n数组（array），顾名思义：用来存储一组相关值的类型。\n\n数组可以方便地对一组值进行求和、计算平均值、逐项遍历等操作。\n\nvar scorearr = [87, 89, 93, 71, 100, 68, 94, 88];\n\n\n1\n\n\n> 数组名习惯以 arr 结尾。\n\n\n# 二、数组的定义\n\n\n# 2.1 方括号定义法\n\nvar arr = ['a', 'b', 'c', 'd'];\n\n\n1\n\n\n\n# 2.2 new 定义法\n\nvar arr = new array('a', 'b', 'c', 'd');\n\n\n1\n\n\nvar arr = new array(4);\n// 定义一个长度为 4 的数组，但是这 4 项都是 undefined\n\n\n1\n2\n\n\n> 两种定义方法根据实际需求选择即可，两者的底层都是同样的实现逻辑。\n> \n> 推荐：方括号定义法！\n> \n>  * 如果是定义时就要指定数组的值，那么建议使用：var arr = ['a', 'b', 'c', 'd'];\n>  * 如果是定义时还不指定数组的值，那么建议使用：var arr = [];\n\n\n# 三、访问数组项\n\n> 注意：js 中数组的元素可以是不同的数据类型！\n\n数组每一项都有下标，下标从 0 开始！\n\n可以使用 数组名[下标] 的形式，访问数组的任一项。\n\n\n# 四、下标越界\n\njs 规定，访问数组中不存在的项会返回 undefined，不会报错！\n\n\n# 五、数组的长度\n\n数组的 length 属性表示它的长度。\n\n> 数组是引用类型，有自己的属性和方法。\n\nvar arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.length);\t// 4\n\n\n1\n2\n\n\n> 数组最后一项的下标是数组的长度减 1。\n\n\n# 六、更改数组项\n\n 1. 访问数组项\n 2. 更改数组值\n\n如果更改的数组项超过了 length-1，则会创造该项。\n\n> js 数组是可以动态扩容的！\n\nvar arr = [1, 2, 3, 4];\narr[6] = 0;\nconsole.log(arr);\t// [1, 2, 3, 4, undefined, undefined, 0]\n\n\n1\n2\n3\n\n\n\n# 七、数组的遍历\n\n数组最大的优点就是方便遍历。\n\nvar arr = [1, 2, 3, 4];\nfor (var i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n\nvar a = ['a', 'b', 'c'];\nfor (var v of a) {\n    console.log(v); \t// 'a', 'b', 'c'\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 7.1 foreach() 方法\n\narray.foreach 方法为数组的每个元素都运行一个函数。\n\n语法：\n\narr.foreach(function(item, index, array) {\n  // ...\n});\n\n\n1\n2\n3\n\n\n案例：\n\n['bilbo', 'gandalf', 'nazgul'].foreach(function (item, index, array) {\n  console.log(`${item} 的索引值为：${index}，在数组：${array} 中`);\n});\n\n或者：\n\nvar arr = ['bilbo', 'gandalf', 'nazgul'];\narr.foreach(function (item, index, array) {\n  console.log(`${item} 的索引值为：${index}，在数组：${array} 中`);\n});\n// bilbo 的索引值为：0，在数组：bilbo,gandalf,nazgul 中\n// gandalf 的索引值为：1，在数组：bilbo,gandalf,nazgul 中\n// nazgul 的索引值为：2，在数组：bilbo,gandalf,nazgul 中\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n该函数的结果（如果它有返回）会被抛弃和忽略。\n\n\n# 7.2 map() 方法\n\narray.map 方法是最有用和经常使用的方法之一。\n\n它对数组的每个元素都调用函数，并返回结果数组。\n\n语法：\n\nvar result = arr.map(function(item, index, array) {\n  // ...\n})\n\n\n1\n2\n3\n\n\n例如，在这里我们将每个元素转换为它的字符串长度：\n\nvar lengths = [\"bilbo\", \"gandalf\", \"nazgul\"].map(function(item, index, array) {\n    return item.length;\n});\nconsole.log(lengths); \n// [5, 7, 6]\n\n// 可以省略不需要的形参：\nvar arr = [\"bilbo\", \"gandalf\", \"nazgul\"];\nvar lengths = arr.map(function(item) {\n    return item.length;\n});\nconsole.log(lengths); \n// [5, 7, 6]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 八、数组类型的检测\n\n数组用 typeof 检测结果是 object。\n\narray.isarray() 方法可以用来检测数组，返回一个布尔值。\n\n> isarray() 不兼容 ie678，所以后面课程中，还将介绍使用 “鸭式辨型” 检测方法。\n\narray.isarray([1, 2, 3]);\t\t// true\narray.isarray([]);\t\t\t\t// true\n\n\n1\n2\n\n\n\n# 九、数组的常用方法\n\n\n# 9.1 数组的头尾操作\n\n方法          功能\npush()      在尾部插入新项\npop()       在尾部删除\nunshift()   在头部插入新项\nshift()     在头部删除\n\n\n# 9.1.1 push() 方法\n\npush() 方法用来在数组末尾推入新项，参数就是要推入的项。\n\n如果要推入多项，可以用逗号隔开。\n\n调用 push() 方法后，数组会立即改变，不需要赋值。\n\nvar arr = [22, 33, 44, 55];\narr.push(66);\narr.push(77, 88, 99);\nconsole.log(arr);\n// [22, 33, 44, 55, 66, 77, 88, 99]\n\n\n1\n2\n3\n4\n5\n\n\n\n# 9.1.2 pop() 方法\n\n与 push() 方法相反，pop() 方法用来删除数组中的最后一项。\n\n() 里没有参数，默认弹出最后一项。\n\npop() 默认返回最后一项的值。\n\nvar arr = [22, 33, 44, 55];\nvar item =  arr.pop();\nconsole.log(arr);\t// [22, 33, 44]\nconsole.log(item);\t// 55\n\n\n1\n2\n3\n4\n\n\n\n# 9.1.3 unshift() 方法\n\nunshift() 方法用来在数组头部插入新项，参数就是要插入的项。\n\n如果要插入多项，可以用逗号隔开。\n\n调用 unshift() 方法后，数组会立即改变，不需要赋值。\n\n\n# 9.1.4 shift() 方法\n\n与 unshift() 方法相反，shift() 方法用来删除数组中的开头一项。\n\n() 里没有参数，默认弹出开头一项。\n\nshift() 默认返回开头一项的值。\n\n\n# 9.2 splice() 方法\n\nsplice() 方法用于替换数组中的指定项。\n\n> 由于 splice() 可以实现很多功能，所以也称为 js 的 “多功能方法”。\n\n * 替换项\n\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n// 从下标为 3 的项开始，连续替换 2 项。即将 'd', 'e' 替换为 'x', 'y', 'z'\narr.splice(3, 2, 'x', 'y', 'z');\nconsole.log(arr);\n// ['a', 'b', 'c', 'x', 'y', 'z', 'f', 'g']\n\n\n1\n2\n3\n4\n5\n\n * 插入项\n\nvar arr = ['a', 'b', 'c', 'd'];\n// 从下标为 2 的项开始，连续替换 0 项，即：在 [2] 处插入。\narr.splice(2, 0, 'x', 'y', 'z');\nconsole.log(arr);\n// ['a', 'b', 'x', 'y', 'z', 'c', 'd']\n\n\n1\n2\n3\n4\n5\n\n * 删除项\n\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n// 从下标为 2 的项开始，连续替换 4 项（替换为空，即：删除）。\narr.splice(2, 4);\nconsole.log(arr);\n// ['a', 'b', 'g']\n\n\n1\n2\n3\n4\n5\n\n\nsplice() 方法会以数组形式返回被替换/删除的项。\n\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n// 从下标为 3 的项开始，连续替换 2 项。\nvar item = arr.splice(3, 2, 'x', 'y', 'z');\nconsole.log(arr);\n// ['a', 'b', 'c', 'x', 'y', 'z', 'f', 'g']\nconsole.log(item);\n// ['d', 'e']\n\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];\n// 从下标为 2 的项开始，连续替换 4 项（替换为空，即：删除）。\nvar item = arr.splice(2, 4);\nconsole.log(arr);\n// ['a', 'b', 'g']\nconsole.log(item);\n// ['c', 'd', 'e', 'f']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 slice() 方法\n\nslice() 方法用于得到子数组，类似于字符串中的 slice() 方法。\n\nslice(a, b) 截取的子数组从下标为 a 的项开始，到下标为 b（但不包括下标为 b 的项）结束。\n\nslice(a, b) 方法不会更改原有的数组。\n\nslice() 如果不提供第二个参数，则表示从指定项开始，提取后续所有项作为子数组。\n\nslice() 方法的参数允许为负数，表示数组的倒数第几项（记住不包括最后一项）。\n\nvar arr = ['a', 'b', 'c', 'd', 'e', 'f'];\nvar childarr1 = arr.slice(2, 5);\nvar childarr2 = arr.slice(2);\nvar childarr3 = arr.slice(2, -1);\nconsole.log(arr);\t\t\t// ['a', 'b', 'c', 'd', 'e', 'f']\nconsole.log(childarr1);\t\t// ['c', 'd', 'e']\nconsole.log(childarr2);\t\t// ['c', 'd', 'e', 'f']\nconsole.log(childarr3);\t\t// ['c', 'd', 'e']\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.4 join() 和 split() 方法\n\n数组的 join() 方法可以使 数组 转为 字符串。\n\n字符串的 split() 方法可以使 字符串 转为 数组。\n\n * join() 的参数表示以什么字符作为连接符，如果留空则默认以逗号分隔，如同调用 tostring() 方法。\n * split() 的参数表示以什么字符拆分字符串，一般不能留空。\n\n[22, 33, 44, 55].join();\t\t// \"22,33,44,55\"\n[22, 33, 44, 55].tostring();\t// \"22,33,44,55\"\n[22, 33, 44, 55].join(',');\t\t// \"22,33,44,55\"\n[22, 33, 44, 55].join('-');\t\t// \"22-33-44-55\"\n[22, 33, 44, 55].join('~');\t\t// \"22~33~44~55\"\n\n\n1\n2\n3\n4\n5\n\n\n'abcdefg'.split();\t\t\t\t// [\"abcdefg\"]\n'abcdefg'.split('');\t\t\t// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n'a-b-c-d-e-f-g'.split('');\t\t// [\"a\", \"-\", \"b\", \"-\", \"c\", \"-\", \"d\", \"-\", \"e\", \"-\", \"f\", \"-\", \"g\"]\n'a-b-c-d-e-f-g'.split('-');\t\t// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\n\n\n1\n2\n3\n4\n\n\n\n# 9.5 字符串和数组更多相关性\n\n字符串也可以使用 [下标] 的形式访问某个字符，等价于 charat() 方法。\n\n> 在对字符串中的字符进行遍历时不用转为数组，直接利用 [下标] 即可！\n\n'我爱前端'[0];\t\t\t// \"我\"\n'我爱前端'[1];\t\t\t// \"爱\"\n'我爱前端'.charat(0);\t// \"我\"\n\n\n1\n2\n3\n\n\nvar str = '我爱前端';\nfor (var i = 0; i < str.length; i++) {\n    console.log(str[i]);\n}\n\n\n1\n2\n3\n4\n\n\n\n# 9.6 concat() 方法\n\nconcat() 方法可以合并连接多个数组（以返回值的形式）。\n\nconcat() 方法不会改变原数组。\n\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = [5, 6, 7, 8];\nvar arr3 = [9, 10, 11];\nvar arr = arr1.concat(arr2, arr3);\nconsole.log(arr);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 9.7 reverse() 方法\n\nreverse() 方法用来将一个数组中的全部项顺序置反。\n\nvar arr = ['a', 'b', 'c', 'd'];\narr.reverse();\nconsole.log(arr);\t// [\"d\", \"c\", \"b\", \"a\"]\n\n\n1\n2\n3\n\n\n【小案例】\n\n字符串 'abcdefg' 逆序。\n\n'abcdefg'.split('').reverse().join('');\n// \"gfedcba\"\n\n\n1\n2\n\n\n\n# 9.8 indexof() 和 includes() 方法\n\nindexof() 方法的功能是搜索数组中的元素，并返回它所在的位置，如果元素不存在，则返回 -1。\n\nincludes() 方法的功能是判断一个数组是否包含一个指定的值，返回一个布尔值。\n\n['a', 'b', 'c', 'd'].indexof('c');\t// 2\n['a', 'b', 'c', 'd'].indexof('d');\t// 3\n['a', 'b', 'c', 'd'].indexof('x');\t// -1\n['a', 'b', 'b', 'b'].indexof('b');\t// 1\n\n\n1\n2\n3\n4\n\n\n['a', 'b', 'c', 'd'].includes('d');\t// true\n['a', 'b', 'c', 'd'].includes('x');\t// false\n\n\n1\n2\n\n\n注意：indexof() 及 includes() 方法的判断标准为 === 全相等！\n\n[11, 22, 33].includes('22');\t// false\n[11, 22, 33].indexof('22');\t\t// -1\n\n\n1\n2\n\n\n\n# 9.9 sort() 方法\n\nsort() 方法用原地算法（直接改变原数组）对数组的元素进行排序，并返回数组。\n\n默认排序顺序是将元素转换为字符串，然后根据字典序进行排序（数字 ——> 大写字母 ——> 小写字母，字符串内逐个字符进行比较，相同时比较下一位）\n\nvar arr = [3, 18, 10, 24];\nconsole.log(arr.sort());\t// [ 10, 18, 24, 3 ]\n\nvar arr = ['a', 'a', 'c', 'd', 1];\nconsole.log(arr.sort());\t// [ 1, 'a', 'd', 'a', 'c' ]\n\nvar arr = ['aa', 'a0', 'aa', 'a1', 'aa', 'aa'];\nconsole.log(arr.sort());\t// [ 'a1', 'aa', 'aa', 'a0', 'aa', 'aa' ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nsort() 方法可以接收一个函数作为参数，我们可以在这个函数中自定义我们的排序规则：\n\narr.sort(function(a, b) {\n    // 比较规则...\n});\n// 参数a：前一个用于比较的元素。\n// 参数b：后一个用于比较的元素。\n\n\n1\n2\n3\n4\n5\n\n\nfunction(a, b) 返回值   排序顺序\n> 0                  a 在 b 后\n< 0                  a 在 b 前\n=== 0                保持 a 和 b 的顺序\n\n案例1：按数字大小进行排序（降序）：\n\nvar arr = [3, 18, 10, 24];\narr.sort(function(a, b) {\n   if (a > b) {\n       return -1;\n   } else if (a < b) {\n       return 1;\n   } else {\n       return 0;\n   }\n});\nconsole.log(arr);\t// [ 24, 18, 10, 3 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n案例2：按照学生分数进行排序（降序）：\n\nvar students = [\n    { name: 'edward', score: 66 },\n    { name: 'sharpe', score: 84 },\n    { name: 'and', score: 58 },\n    { name: 'the', score: 92 },\n    { name: 'magnetic', score: 99 },\n    { name: 'zeros', score: 74 }\n];\nstudents.sort(function (a, b) {\n    if (a.score > b.score) {\n        return -1;\n    } else if (a.score < b.score) {\n        return 1;\n    } else {\n        return 0;\n    }\n});\nconsole.log(students);\n/*\n[ \n{ name: 'magnetic', score: 99 },\n{ name: 'the', score: 92 },\n{ name: 'sharpe', score: 84 },\n{ name: 'zeros', score: 74 },\n{ name: 'edward', score: 66 },\n{ name: 'and', score: 58 } \n]\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n除了内置排序方法外，还有一些排序算法：冒泡排序 和 快速排序 将在后面介绍。\n\n\n# 9.10 find/findindex/findlastindex() 方法\n\n想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？\n\n这时可以用 array.find 方法。\n\n语法如下：\n\nvar result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 如果返回 falsy，则继续迭代，如果一直没有返回 true，那么结束时返回 undefined\n});\n\n\n1\n2\n3\n4\n\n\n依次对数组中的每个元素调用该函数：\n\n * item 是元素。\n * index 是它的索引。\n * array 是数组本身。\n\n如果它返回 true，则搜索停止，并返回 item。如果没有搜索到，则返回 undefined。\n\n例如，我们有一个存储用户的数组，每个用户都有 id 和 name 字段。让我们找到 id === 1 的那个用户：\n\nvar users = [\n  {id: 1, name: \"john\"},\n  {id: 2, name: \"pete\"},\n  {id: 3, name: \"mary\"}\n];\n\nvar user = users.find(function(item) {\n    return item.id === 1;\n});\n\nconsole.log(user.name); // john\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在现实生活中，对象数组是很常见的，所以 find 方法非常有用。\n\n注意在这个例子中，我们传给了 find 一个单参数函数。这很典型，并且 find 方法的其他参数很少使用。\n\narr.findindex 方法（与 arr.find）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 -1。\n\narr.findlastindex 方法类似于 findindex，但从右向左搜索，类似于 lastindexof。\n\n这是一个例子：\n\nvar users = [\n    { id: 1, name: 'john' },\n    { id: 2, name: 'pete' },\n    { id: 3, name: 'mary' },\n    { id: 4, name: 'john' }\n];\n\n// 寻找第一个 john 的索引\nconsole.log(\n    users.findindex(function (user) {\n        return user.name === 'john';\n    })\n); // 0\n\n// 寻找最后一个 john 的索引\nconsole.log(\n    users.findlastindex(function (user) {\n        return user.name === 'john';\n    })\n); // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 9.11 filter() 方法\n\nfind 方法搜索的是使函数返回 true 的第一个（单个）元素。\n\n如果需要匹配的有很多，我们可以使用 array.filter(fn)。\n\n语法与 find 大致相同，但是 filter 返回的是所有匹配元素组成的数组：\n\nfilter：过滤、过滤器\n\nvar results = arr.filter(function(item, index, array) {\n  // 如果返回 true，那么 item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n\n\n1\n2\n3\n4\n\n\n例如：\n\nvar users = [\n  {id: 1, name: 'john'},\n  {id: 2, name: 'pete'},\n  {id: 3, name: 'jerry'},\n  {id: 4, name: 'mary'}\n];\n\n// 返回前两个用户的数组\nvar someusers = users.filter(function(item) {\n    return item.id < 3;\n});\nconsole.log(someusers); // [ { id: 1, name: 'john' }, { id: 2, name: 'pete' } ]\n\n// 返回用户名字含四个字母的数组\nvar fournameusers = users.filter(function(item) {\n    return item.name.length <= 4;\n});\nconsole.log(fournameusers);\t// [ { id: 1, name: 'john' }, { id: 2, name: 'pete' }, { id: 4, name: 'mary' } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 9.12 有关数组在 es6 中的增强\n\n数组在 es6 中新增了较多的新方法，将在 es6 相关课程中介绍。\n\n\n# 9.13 数组去重和随机样本\n\n【数组去重】\n\n题目：去掉数组中的重复项。\n\n思路：准备一个空结果数组，遍历原数组，如果遍历到的项不在结果数组中，则推入结果数组。\n\nvar arr = [1, 1, 1, 2, 2, 3, 3, 3, 2, 1];\nvar resultarr = [];\nfor (var i = 0; i < arr.length; i++) {\n    if (!resultarr.includes(arr[i])) {\n        resultarr.push(arr[i]);\n    }\n}\nconsole.log(resultarr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【随机样本】\n\n题目：请随机从原数组中取 3 项。\n\n思路：准备一个空结果数组，遍历原数组，随机选择一项，推入结果数组，并且将这项在原数组中删除。\n\nvar arr = [3, 6, 10, 5, 8, 9];\nvar resultarr = [];\nfor (var i = 0; i < 3; i++) {\n    var n = parseint(math.random() * arr.length);\n    resultarr.push(arr[n]);\n    arr.splice(n, 1);\n}\nconsole.log(resultarr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 9.14 冒泡排序\n\n冒泡排序是一个著名的排序算法，也是最基础的交换排序。\n\n冒泡排序的核心思想：一趟一趟地进行多次项的两两比较，每次都会将最大的元素排好位置，如同水中的气泡上浮一样。\n\n> 时间复杂度：o(n²)\n\n\n\nvar arr = [9, 5, 6, 8, 2, 7, 3, 4, 1];\nvar temp;\nfor (var i = 0; i < arr.length - 1; i++) {\n    for (var j = i + 1; j < arr.length; j++) {\n        if (arr[i] > arr[j]) {\n            temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n}\nconsole.log(arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 9.15 快速排序（冒泡排序改进版）\n\n快速排序（quicksort）是使用得最广泛，速度也较快的排序算法。它是图灵奖得主 c. a. r. hoare（1934--）于 1960 时提出来的。是二十世纪 10 大算法之一，非常重要！时间复杂度：o(nlogn)，稳定性：不稳定。\n\n\n\n快速排序与冒泡排序同属交换排序，不过快速排序采用了 “分治法” 的思想大大提高了排序的时间性能。\n\n\"快速排序\"的思想很简单，整个排序过程只需要三步：\n\n 1. 在数据集之中，选择一个元素作为 \"基准\"（pivot）\n\n 2. 所有小于 \"基准\" 的元素，都移到 \"基准\" 的左边；所有大于 \"基准\" 的元素，都移到 \"基准\" 的右边\n\n 3. 对 基准 左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止\n\n举例来说，现在有一个数据集 {85, 24, 63, 45, 17, 31, 96, 50}，怎么对其排序呢？\n\n第一步，选择中间的元素 45 作为 \"基准\"（基准值可以任意选择，但是选择中间的值比较容易理解）。\n\n第二步，按照顺序，将每个元素与 \"基准\" 进行比较，形成两个子集，一个 \"小于45\"，另一个 \"大于等于45\"。\n\n第三步，对两个子集不断重复第一步和第二步，直到所有子集只剩下一个元素为止。\n\n下面用 javascript 语言实现上面的算法。\n\n首先，定义一个 quicksort 函数，它的参数是一个数组。\n\n var quicksort = function(arr) {\n };\n\n\n1\n2\n\n\n然后，检查数组的元素个数，如果小于等于 1，就返回。\n\n var quicksort = function(arr) {\n \tif (arr.length <= 1) {\n    \treturn arr; \n    }\n };\n\n\n1\n2\n3\n4\n5\n\n\n接着，选择 \"基准\"（pivot），并将其与原数组分离，再定义两个空数组，用来存放一左一右的两个子集。\n\nvar quicksort = function(arr) {\n\tif (arr.length <= 1) {\n        return arr; \n    }\n    // math.floor 向下取整\n 　　var pivotindex = math.floor(arr.length / 2) ;\n\t// splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。\n 　　var pivot = arr.splice(pivotindex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n然后，开始遍历数组，小于 \"基准\" 的元素放入左边的子集，大于基准的元素放入右边的子集。\n\n var quicksort = function(arr) {\n \tif (arr.length <= 1) {\n        return arr; \n    }\n 　　var pivotindex = math.floor(arr.length / 2) ;\n 　　var pivot = arr.splice(pivotindex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n 　　for (var i = 0; i < arr.length; i++) {\n       if (arr[i] < pivot) {\n           left.push(arr[i]);\n       } else {\n           right.push(arr[i]);\n       }\n   }\n };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n最后，使用递归不断重复这个过程，就可以得到排序后的数组。\n\n var quicksort = function(arr) {\n     if (arr.length <= 1) { \n         return arr; \n     }\n 　　var pivotindex = math.floor(arr.length / 2);\n 　　var pivot = arr.splice(pivotindex, 1)[0];\n 　　var left = [];\n 　　var right = [];\n 　　for (var i = 0; i < arr.length; i++) {\n       if (arr[i] < pivot) {\n           left.push(arr[i]);\n       } else {\n           right.push(arr[i]);\n       }\n   }\n     // concat 拼接数组\n     return quicksort(left).concat([pivot], quicksort(right));\n };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 十、二维数组\n\n二维数组：以数组作为数组元素的数组，即 “数组的数组”。\n\n二维数组可以看做是 “矩阵”。\n\n> matrix：矩阵\n\nvar matrix = [\n    [11, 33, 55],\n    [22, 33, 44],\n    [36, 49, 52],\n    [56, 10, 23]\n];\n\n// 二维数组长度\nconsole.log(matrix.length);\t\t// 4\nconsole.log(matrix[1].length);\t// 3\n\n// 遍历二维数组\nfor (var i = 0; i < matrix.length; i++) {\n    for (var j = 0; j < matrix[i].length; j++) {\n        console.log(matrix[i][j]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 十一、基本类型值和引用类型值\n\n【当 var a = b 赋值时】\n\n * 基本类型值：内存中产生新的副本\n * 引用类型值：内存中不产生新的副本，而是让新变量指向同一个对象（内存地址的副本）\n\n// 基本类型值\nvar a = 3;\nvar b = a;\na++;\nconsole.log(a);\t\t// 4\nconsloe.log(b);\t\t// 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 引用类型值\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = arr1;\narr1.push(5);\nconsole.log(arr1);\t// [1, 2, 3, 4, 5]\nconsole.log(arr2);\t// [1, 2, 3, 4, 5]\n\n\n1\n2\n3\n4\n5\n6\n\n * 基本类型：number、boolean、string、undefined、null\n * 引用类型：array、object、function、regexp、……\n\n【相等 == 判断时的区别】\n\n * 基本类型进行相等 == 判断时，会比较 “值” 是否相等\n * 引用类型进行相等 == 判断时，会比较 “址” 是否相等，也就是说它会比较是否为内存中的同一个对象\n\n> 基本类型：==（自动转型后，比较值）；===（类型相同的情况下，比较值）\n> \n> 引用类型：== 和 === 效果一样！（因为当内存地址相同时，类型肯定相同）\n\n3 == 3;\t\t// true\n3 === 3;\t// true\n3 == '3';\t// true\n3 === '3';\t// false\n[1, 2, 3] == [1, 2, 3];\t\t// false\n[1, 2, 3] === [1, 2, 3];\t// false\n[] == [];\t// false\n[] === [];\t// false\n\nvar arr = [1, 2, 3];\narr == arr;\t\t// true\nvar arr2 = arr;\narr == arr2;\t// true，这里比较的是 arr 与 arr2 中保存的地址是否相等\narr === arr2;\t// true，由于类型相同，所以这里比较的也是 arr 与 arr2 中保存的地址是否相等\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 十二、深克隆和浅克隆\n\n> 深克隆和浅克隆需要手写代码实现，而不是简单的调用函数。\n\n使用 arr1 = arr2 的语法不会克隆数组（两个变量指向同一个内存地址）。\n\n浅克隆：只克隆数组的第一层，如果是多维数组，或者数组中的项是其他引用类型值，则不克隆其他更深层。\n\n深克隆：克隆数组的所有层，要用递归方法，在之后介绍。\n\n【浅克隆】\n\n> 核心思想：“藕断丝连”\n\nvar arr = [1, 2, 3, 4, [5, 6, 7]];\nvar resultarr = [];\nfor (var i = 0; i < arr.length; i++) {\n    resultarr.push(arr[i]);\n}\nconsole.log(resultarr);\t\t            // [1, 2, 3, 4, [5, 6, 7]]\nconsole.log(resultarr == arr);  \t\t// false    \nconsole.log(resultarr[4] == arr[4]);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"JS函数",frontmatter:{title:"JS函数",date:"2020-04-30T12:03:52.000Z",permalink:"/pages/428206/",categories:["JS","基础"],tags:["Javascript"],readingShow:"top"},regularPath:"/20.JS/10.%E5%9F%BA%E7%A1%80/06.JS%E5%87%BD%E6%95%B0.html",relativePath:"20.JS/10.基础/06.JS函数.md",key:"v-23ff7de0",path:"/pages/428206/",headers:[{level:2,title:"6.1 函数的参数",slug:"_6-1-函数的参数",normalizedTitle:"6.1 函数的参数",charIndex:1605},{level:3,title:"6.1.1 “形实结合”",slug:"_6-1-1-形实结合",normalizedTitle:"6.1.1 “形实结合”",charIndex:2050},{level:3,title:"6.1.2 形参和实参个数不同的情况",slug:"_6-1-2-形参和实参个数不同的情况",normalizedTitle:"6.1.2 形参和实参个数不同的情况",charIndex:2067},{level:3,title:"6.1.3 arguments",slug:"_6-1-3-arguments",normalizedTitle:"6.1.3 arguments",charIndex:2090},{level:2,title:"6.2 函数的返回值",slug:"_6-2-函数的返回值",normalizedTitle:"6.2 函数的返回值",charIndex:2801},{level:2,title:"10.1 变量作用域",slug:"_10-1-变量作用域",normalizedTitle:"10.1 变量作用域",charIndex:5549},{level:2,title:"10.2 局部变量",slug:"_10-2-局部变量",normalizedTitle:"10.2 局部变量",charIndex:5769},{level:2,title:"10.3 全局变量",slug:"_10-3-全局变量",normalizedTitle:"10.3 全局变量",charIndex:5994},{level:2,title:"10.4 遮蔽效应",slug:"_10-4-遮蔽效应",normalizedTitle:"10.4 遮蔽效应",charIndex:6064},{level:2,title:"10.5 注意考虑变量声明提升的情况",slug:"_10-5-注意考虑变量声明提升的情况",normalizedTitle:"10.5 注意考虑变量声明提升的情况",charIndex:6253},{level:2,title:"10.6 形参也是局部变量",slug:"_10-6-形参也是局部变量",normalizedTitle:"10.6 形参也是局部变量",charIndex:6276},{level:2,title:"10.7 作用域链",slug:"_10-7-作用域链",normalizedTitle:"10.7 作用域链",charIndex:6294},{level:2,title:"10.8 不加 var 将定义全局变量",slug:"_10-8-不加-var-将定义全局变量",normalizedTitle:"10.8 不加 var 将定义全局变量",charIndex:6788},{level:2,title:"11.1 什么是闭包",slug:"_11-1-什么是闭包",normalizedTitle:"11.1 什么是闭包",charIndex:7266},{level:2,title:"11.2 观察闭包现象",slug:"_11-2-观察闭包现象",normalizedTitle:"11.2 观察闭包现象",charIndex:7376},{level:2,title:"11.3 闭包非常实用",slug:"_11-3-闭包非常实用",normalizedTitle:"11.3 闭包非常实用",charIndex:7454},{level:3,title:"11.3.1 闭包用途1 - 记忆性",slug:"_11-3-1-闭包用途1-记忆性",normalizedTitle:"11.3.1 闭包用途1 - 记忆性",charIndex:7555},{level:3,title:"11.3.2 闭包用途2 - 模拟私有变量",slug:"_11-3-2-闭包用途2-模拟私有变量",normalizedTitle:"11.3.2 闭包用途2 - 模拟私有变量",charIndex:8314},{level:3,title:"11.3.3 使用闭包的注意点",slug:"_11-3-3-使用闭包的注意点",normalizedTitle:"11.3.3 使用闭包的注意点",charIndex:9018},{level:3,title:"11.3.4 闭包的独立性",slug:"_11-3-4-闭包的独立性",normalizedTitle:"11.3.4 闭包的独立性",charIndex:9149},{level:2,title:"12.1 形成 IIFE 的方法",slug:"_12-1-形成-iife-的方法",normalizedTitle:"12.1 形成 iife 的方法",charIndex:9590},{level:2,title:"12.2 IIFE的作用1 - 为变量赋值",slug:"_12-2-iife的作用1-为变量赋值",normalizedTitle:"12.2 iife的作用1 - 为变量赋值",charIndex:9652},{level:2,title:"12.3 IIFE的作用2 - 将全局变量变为局部变量",slug:"_12-3-iife的作用2-将全局变量变为局部变量",normalizedTitle:"12.3 iife的作用2 - 将全局变量变为局部变量",charIndex:9938}],headersStr:"6.1 函数的参数 6.1.1 “形实结合” 6.1.2 形参和实参个数不同的情况 6.1.3 arguments 6.2 函数的返回值 10.1 变量作用域 10.2 局部变量 10.3 全局变量 10.4 遮蔽效应 10.5 注意考虑变量声明提升的情况 10.6 形参也是局部变量 10.7 作用域链 10.8 不加 var 将定义全局变量 11.1 什么是闭包 11.2 观察闭包现象 11.3 闭包非常实用 11.3.1 闭包用途1 - 记忆性 11.3.2 闭包用途2 - 模拟私有变量 11.3.3 使用闭包的注意点 11.3.4 闭包的独立性 12.1 形成 IIFE 的方法 12.2 IIFE的作用1 - 为变量赋值 12.3 IIFE的作用2 - 将全局变量变为局部变量",content:"# 【JS函数】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是函数\n\n函数就是语句的封装，可以让这些代码方便地被复用。\n\n函数具有 “一次定义，多次调用” 的优点。\n\n使用函数，可以简化代码，让代码更具有可读性。\n\n\n# 二、函数的定义\n\n和变量类似，函数必须先定义然后才能使用。\n\n使用 function 关键字定义函数。\n\n> function：函数、功能。\n\n【方式 1 函数声明】\n\nfunction fun() {\n    // 函数语句块\n}\n\n\n1\n2\n3\n\n * function：定义函数的关键字\n * fun：函数名（必须符合 JS 标识符命名规则）\n * ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号\n * {}：花括号内为函数语句块\n\n【方式 2 函数表达式】\n\nvar fun = function() {\n    // 函数语句块\n};\n\n\n1\n2\n3\n\n * function(){}：匿名函数\n * ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号\n * {}：花括号内为函数语句块\n * fun：变量（指向一个函数）\n\n> 风格说明：\n> \n> function fun() {\n>    \n> } // 末尾不需要加 ;\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> var fun = function() {\n>    \n> }; // 末尾应该加上 ;（因为这是一个赋值语句）\n> \n> \n> 1\n> 2\n> 3\n\n\n# 三、函数的调用\n\n执行函数体中的所有语句，就称为 “调用函数”。\n\n调用函数非常简单，只需要在函数名字后书写圆括号对即可。\n\nfun();\t// 调用函数\n\n\n1\n\n\n【小案例】\n\n// 定义函数，定义的函数是不会被立即执行的\nfunction fun() {\n    console.log('你好');\n    console.log('今天天气真好');\n}\n// 函数必须要等到调用的时候才能被执行\nfun();\nfun();\nfun();\n// 执行了三次\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 四、函数声明的提升\n\n和变量声明提升类似，函数声明也可以被提升。\n\nfun();\n// 在预解析阶段会被提升\nfunction fun() {\n    alert(\"函数被执行\");\n}\n\n\n1\n2\n3\n4\n5\n\n\n效果相当于：\n\nfunction fun() {\n    alert(\"函数被执行\");\n}\nfun();\n\n\n1\n2\n3\n4\n\n\n【函数表达式不能被提升】\n\nfun();\t// 报错！\nvar fun = function() {\n    alert(\"函数不能被执行\");\n};\n\n\n1\n2\n3\n4\n\n\n> 解释：函数表达式不能被提升的本质原因是函数表达式定义的其实是个变量，只不过是把函数赋给这个变量，而变量的提升只提升定义，不提升赋值！\n\n> 还是那个原则：先定义再使用！\n\n\n# 五、函数优先提升\n\n可以简单理解为：函数提升程度 > 变量提升程度。\n\nfun(); // B\n\nvar fun = function () {\n    alert('A');\n};\n\nfunction fun() {\n    alert('B');\n}\n\nfun(); // A\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n效果相当于：\n\nfunction fun() {\n    alert('B');\n}\n\nvar fun;\n\nfun(); // B\n\nfun = function () {\n    alert('A');\n};\n\nfun(); // A\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 六、函数的参数和返回值\n\n\n# 6.1 函数的参数\n\n参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值。\n\n函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开。\n\n// 形参\nfunction add(a, b) {\n    var sum = a + b;\n    console.log('a + b = ' + sum);\n}\n// 实参\nadd(3, 5);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 圆括号中定义 “形式参数”\n * 调用函数时传入 “实际参数”\n\n> “形式参数” 和 “实际参数” 是彼此独立的，除了传递值（复制值）之外，互不干扰！\n\n> 注意：JS 只有 “值传递” 没有 “引用传递”，对于引用类型的传递，传递的不是引用，而是那个变量里面的值（引用的地址）。\n> \n> 引用传递：修改形参，实参也会改变。JS 中复杂类型的实参是个地址值不需要改变，也改变不了，改变的是地址所指向的堆中的复杂类型的具体值，此处具有迷惑性，要加以辨别！\n\n\n# 6.1.1 “形实结合”\n\n\n# 6.1.2 形参和实参个数不同的情况\n\n\n# 6.1.3 arguments\n\n函数内 arguments 表示它接收到的实参列表，它是一个类数组对象。\n\n类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法。\n\nfunction fun() {\n    console.log(arguments);\t\t// 11 22 33 44\n    console.log(arguments[0]);\t// 11\n    console.log(arguments[1]);\t// 22\n    console.log(arguments[9]);\t// undefined\n}\nfun(11, 22, 33, 44);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【小案例】\n\nJS 本身没有函数的重载（函数名相同，形参个数不同），但是可以借助 arguments 模拟 “函数重载”。\n\n> 以下例子是一个典型的 “函数重载”，参数个数不同形成 “重载”。\n\nfunction fun() {\n    if (arguments.length == 0) {\n        console.log(0);\n    } else if (arguments.length == 1) {\n        console.log(1);\n    } else {\n        console.log(2);\n    }\n}\nfun(); // 0\nfun(1); // 1\nfun(1, 2); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.2 函数的返回值\n\n函数体内可以使用 return 关键字表示 “函数的返回值”。\n\nfunction sum(a, b) {\n    return a + b;\t// 函数的返回值\n}\nvar result = sum(3, 5);\t// 函数的返回值可以被变量接收\n\n\n1\n2\n3\n4\n\n\n调用一个有返回值的函数，可以被当做一个普通值，从而可以出现在任何可以书写值的地方。\n\nfunction sum(a, b) {\n    return a + b;\n}\nvar result = sum(3, 4) * sum(2, 6);\n\n\n1\n2\n3\n4\n\n\nfunction sum(a, b) {\n    return a + b;\n}\nvar result = sum(3, sum(4, 5));\t// 函数嵌套\n\n\n1\n2\n3\n4\n\n\n遇见 return 即退出函数。\n\n结合 if 语句的时候，往往不需要写 else 分支了。\n\n// 判断一个数字是否为偶数\nfunction checkEven(n) {\n    if (n % 2 == 0) {\n        return true;\n    }\n    return false;\n}\nvar result = checkEven(6);\nconsole.log(result);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 七、JS内置 sort() 方法\n\n数组排序可以使用 sort() 方法，这个方法的参数又是一个函数。\n\n> 如果不加参数，那么 sort() 默认从小到大排序（字典序：数字 ——> 大写字母 ——> 小写字母）\n\nvar arr = [33, 22, 55, 11];\n// arr.sort(function(a, b){});\narr.sort();\n\n\n1\n2\n3\n\n\n这个函数中 a、b 分别表示数组中靠前和考后的项，如果需要将它们交换位置，则返回正整数；否则就返回负数。\n\n// 从小到大排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n    if (a > b) {\n        return 1;\n    } else {\n        return -1;\n    }\n});\nconsole.log(arr);\t// [11, 22, 33, 55]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对以上算法进行简化：\n\n// 从小到大排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n\treturn a - b;\n});\nconsole.log(arr);\t// [11, 22, 33, 55]\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 从大到小排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n    return b - a;\n});\nconsole.log(arr);\t// [55, 33, 22, 11]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 八、递归\n\n函数的内部语句可以调用这个函数自身，从而发起对函数的一次迭代。在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代。当函数执行到某一次时，不再进行新的迭代，函数被一层一层返回，函数被递归。\n\n> 函数自己调用自己！\n\n递归是一种较为高级的编程思想，它把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。\n\n【小案例：求阶乘】\n\n// n! 的本质：n * (n-1)!\nfunction factorial(n) {\n    // 递归的出口\n    if (n == 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 递归技巧：\n> \n>  1. 分析问题，抽象出具体的数学模型\n>  2. 分析数学模型是否有 “规律性”\n>  3. 找到基本的 “规律”（比如：n! 的本质：n * (n-1)!）\n>  4. 将 “规律” 转换为代码（比如：return n * factorial(n - 1);）\n>  5. 找到 “出口” 也就是临界情况（比如：1! == 1）\n>  6. 将 “出口” 转化为代码（比如：if (n == 1) { return 1; }）\n>  7. 组合代码形成递归算法\n\n\n# 九、实现深克隆\n\n使用递归思想，整体思路和浅克隆类似，但稍微进行一些改动：如果遍历到的项是基本类型值，则直接推入结果数组；如果遍历到的项是数组，则重复执行浅克隆的操作。\n\nvar arr1 = [33, 44, 11, 22, [77, 88, [33, 44]]];\n\nfunction deepClone(arr) {\n    // 结果数组，“每一层”都有一个结果数组\n    var result = [];\n    // 遍历数组的每一项\n    for (var i = 0; i < arr.length; i++) {\n        // 类型判断，如果遍历到的项为数组\n        if (Array.isArray(arr[i])) {\n            // 递归\n            result.push(deepClone(arr[i]));\n        } else {\n            // 如果遍历到的项是基本类型，就直接推入到结果数组中\n            result.push(arr[i]);\n        }\n    }\n    // 返回结果数组\n    return result;\n}\n\nvar arr2 = deepClone(arr1);\nconsole.log(arr1); // [33, 44, 11, 22, [77, 88, [33, 44]]]\nconsole.log(arr2); // [33, 44, 11, 22, [77, 88, [33, 44]]]\nconsole.log(arr1[4] == arr2[4]); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 十、全局变量和局部变量\n\n\n# 10.1 变量作用域\n\nJS 是函数级作用域编程语言：变量只在其所定义时所在的 function 内部有意义。\n\n> 重点提示！\n> \n> 注意：JS 是函数级作用域编程语言，没有块级作用域的概念！\n> \n> 即：JS 中 if、switch、for、while 等 () {} 中的变量都不属于局部变量，而是外层函数的局部变量，如果没有外层函数，那么就是全局变量！\n> \n> 注：在 ES6 标准中，JS 引入了块级作用域概念！\n\n\n# 10.2 局部变量\n\nfunction fun(n) {\n    var a = n;\n}\n\nfun(3);\nconsole.log(a);\t// 报错\nconsole.log(n);\t// 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 变量 a 是在 fun 函数中被定义的，所以变量 a 只在 fun 函数内部有定义，fun 函数就是 a 的 “作用域”，变量 a 被称为 “局部变量”。\n> \n> 函数形参（n）也属于该函数的作用域！\n\n\n# 10.3 全局变量\n\n如果不将变量定义在任何函数的内部（包括形参），此时这个变量就是全局变量，它在任何函数内部都可以被访问和更改。\n\n\n# 10.4 遮蔽效应\n\n如果函数中也定义了和全局变量同名的变量，则函数内的局部变量会将全局的变量进行 “遮蔽”。\n\nvar a = 10;\nfunction fun() {\n    var a = 5;\n    a++;\n    console.log(a);\t// 6\n}\nfun();\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10.5 注意考虑变量声明提升的情况\n\n\n# 10.6 形参也是局部变量\n\n\n# 10.7 作用域链\n\n先来认识函数的嵌套：一个函数内部也可以定义一个函数。和局部变量类似，定义在一个函数内部的函数是局部变量。\n\nfunction fun() {\n    // 局部函数\n    function inner() {\n        console.log('你好');\n    }\n    // 调用局部函数\n    inner();\n}\n// 调用外部函数\nfun();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在函数嵌套中，变量会从内到外逐层寻找它的定义（先找本层，本层没有往上一层找，以此类推）。\n\nvar a = 10;\nvar b = 20;\nfunction fun() {\n    var c = 40;\n    function inner() {\n    \tvar a = 40;\n        var d = 50;\n        console.log(a, b, c, d);\t// 40 20 40 50\n    }\n    inner();\n}\nfun();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.8 不加 var 将定义全局变量\n\n在初次给变量赋值时，如果没有加 var，则将定义全局变量。\n\nfunction fun() {\n    a = 3;\n}\nfun();\nconsole.log(a);\t// 3\n\n\n1\n2\n3\n4\n5\n\n\n> 没有特殊情况，一律都要记得加 var。\n\n\n# 十一、闭包\n\n// 定义一个全局变量\nvar name = 'ABC';\n\n// 创建一个函数\nfunction fun() {\n    // 定义局部变量\n    var name = '周吉瑞';\n    // 返回一个局部函数\n    return function() {\n        console.log(name);\n    };\n}\n\n// 调用外部函数，就能得到局部函数，用变量 inn 来接收\nvar inn = fun();\n// 执行 inn 函数，就相当于在 fun 函数的外部，执行了局部函数\ninn(); // \"周吉瑞\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 11.1 什么是闭包\n\nJS 中函数会产生闭包。\n\n闭包是函数本身和该函数声明时所处的环境状态的组合。\n\n函数能够 “记忆” 其定义时所处的环境，即使函数不在其定义的环境中被调用，也能访问定义时所处环境的变量。\n\n\n# 11.2 观察闭包现象\n\n在 JS 中，每次创建函数时都会创建闭包。\n\n但是，闭包特性往往需要将函数 “换一个地方” 执行，才能被直观的体现出来。\n\n\n# 11.3 闭包非常实用\n\n闭包很有用，因为它允许我们将数据与操作该数据的函数关联起来，这与 “面向对象编程” 有少许相似之处。\n\n闭包的功能：记忆性、模拟私有变量（相当于把函数的数据封装了）。\n\n\n# 11.3.1 闭包用途1 - 记忆性\n\n当闭包产生时，函数所处环境的状态会始终保持在内存中，不会在外层函数调用后自动清除，这就是闭包的记忆性。\n\n【闭包的记忆性举例】\n\n创建体温检测函数 checkTemp(n)，可以检查体温 n 是否正常，函数会返回布尔值。\n\n但是，不同的小区有不同的体温检测标准，比如 A 小区体温合格线是 37.1℃，而 B 小区体温合格线是 37.3℃，应该怎么编程呢？\n\nfunction createCheckTemp(standardTemp) {\n    function checkTemp(n) {\n        if (n <= standardTemp) {\n            alert('你的体温正常');\n        } else {\n            alert('你的体温偏高');\n        }\n    }\n    return checkTemp;\n}\n\n// 创建一个 checkTemp 函数，它以 37.1 度为标准线\nvar checkTemp_A = createCheckTemp(37.1);\n\n// 再创建一个 checkTemp 函数， 它以 37.3 度为标准线\nvar checkTemp_B = createCheckTemp(37.3);\n\ncheckTemp_A(37.2);\t// \"你的体温偏高\"\ncheckTemp_A(37.0);\t// \"你的体温正常\"\ncheckTemp_B(37.2);\t// \"你的体温正常\"\ncheckTemp_B(37.6);\t// \"你的体温偏高\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 11.3.2 闭包用途2 - 模拟私有变量\n\n题目：请定义一个变量 a，要求是能保证这个 a 只能被进行指定的操作（如：加1、乘2），而不能进行其他操作，应该怎么编程呢？\n\n> 即：让变量变得安全，私有化！\n> \n> 在 Java、C++ 等语言中，有私有属性的概念，但是 JS 中只能用闭包来模拟。\n\n// 封装一个函数，这个函数的功能就是私有化变量\nfunction fun() {\n    // 定义一个局部变量 a\n    var a = 0;\n    // 返回一个对象\n    return {\n        getA: function () {\n            return a;\n        },\n        add: function () {\n            a++;\n        },\n        pow: function () {\n            a *= 2;\n        }\n    };\n}\n\nvar obj = fun();\n// 如果想在 fun 函数外面使用变量 a，唯一的方法就是调用 getA() 方法\nconsole.log(obj.getA()); // 0\n// 想让变量 a 进行加 1 操作\nobj.add();\nconsole.log(obj.getA()); // 1\nobj.pow();\nconsole.log(obj.getA()); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 11.3.3 使用闭包的注意点\n\n不能滥用闭包！否则会造成网页的性能问题，严重时可能导致 “内存泄漏”。\n\n所谓 “内存泄漏” 就是指程序中已经动态分配的内存由于某种原因未释放或无法释放。\n\n> 目前，Chrome 等比较先进的浏览器很少发生内存泄漏。\n\n\n# 11.3.4 闭包的独立性\n\nfunction addCount() {\n    var count = 0;\n    return function() {\n        count = count + 1;\n        console.log(count);\n    };\n}\nvar fun1 = addCount();\nvar fun2 = addCount();\nfun1();\t// 1\nfun2();\t// 1\nfun2();\t// 2\nfun2();\t// 3\nfun2();\t// 4\nfun1();\t// 2\n/* 即：闭包之间是互相独立的 */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 十二、立即执行函数 IIFE\n\nIIFE 立即调用函数表达式，是一种特殊的 JS 函数写法，一旦被定义，就立即被调用。\n\n(function () {\n    // 函数体语句\n})();\n\n\n1\n2\n3\n\n\n\n# 12.1 形成 IIFE 的方法\n\n> 蓝色括号里写传递的参数。\n\n> 常用 () 来将函数转为 “函数表达式”。\n\n\n# 12.2 IIFE的作用1 - 为变量赋值\n\nvar age = 12;\nvar sex = '男';\nvar title = (function () {\n    if (age < 18) {\n        return '小朋友';\n    } else {\n        if (sex == '男') {\n            return '先生';\n        } else {\n            return '女士';\n        }\n    }\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 12.3 IIFE的作用2 - 将全局变量变为局部变量\n\n先看一个问题：\n\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n    arr.push(function() {\n        console.log(i);\n    });\n    arr[i]();\n}\nconsole.log(\"#\")\nfor (var j = 0; j < arr.length; j++) {\n    arr[j]();\n}\n\n/*\n0\n1\n2\n3\n4\n#\n5\n5\n5\n5\n5\n*/\n\n/*\n解释：arr 数组中的每个元素都是 function(){alert(i)} 这个函数，\narr[i] ——> function(){alert(i)}\narr[i](); ——> function(){alert(i)}()\n由于 i 为全局变量（JS 没有块级作用域），所以所有函数闭包中的 i 都是全局的, 而 i 最终确定为 5，所以都输出 5；\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nIIFE 可以在一些场合（如 for 循环中）将全局变量变为局部变量，语法显得紧凑。\n\n> 在 ES6 中，有更好的方式可以约定变量的作用域！\n\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n    (function (i) {\n        arr.push(function () {\n            console.log(i);\n        });\n    })(i);\n}\nfor (var j = 0; j < arr.length; j++) {\n    arr[j]();\n}\n\n/*\n0\n1\n2\n3\n4\n*/\n\n/*\n解释：利用函数作用域把 i 约束为一个局部变量\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# 【js函数】\n\n> 原创内容，转载请注明出处！\n\n\n# 一、什么是函数\n\n函数就是语句的封装，可以让这些代码方便地被复用。\n\n函数具有 “一次定义，多次调用” 的优点。\n\n使用函数，可以简化代码，让代码更具有可读性。\n\n\n# 二、函数的定义\n\n和变量类似，函数必须先定义然后才能使用。\n\n使用 function 关键字定义函数。\n\n> function：函数、功能。\n\n【方式 1 函数声明】\n\nfunction fun() {\n    // 函数语句块\n}\n\n\n1\n2\n3\n\n * function：定义函数的关键字\n * fun：函数名（必须符合 js 标识符命名规则）\n * ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号\n * {}：花括号内为函数语句块\n\n【方式 2 函数表达式】\n\nvar fun = function() {\n    // 函数语句块\n};\n\n\n1\n2\n3\n\n * function(){}：匿名函数\n * ()：圆括号中是形参列表，即使没有形参，也必须书写圆括号\n * {}：花括号内为函数语句块\n * fun：变量（指向一个函数）\n\n> 风格说明：\n> \n> function fun() {\n>    \n> } // 末尾不需要加 ;\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> var fun = function() {\n>    \n> }; // 末尾应该加上 ;（因为这是一个赋值语句）\n> \n> \n> 1\n> 2\n> 3\n\n\n# 三、函数的调用\n\n执行函数体中的所有语句，就称为 “调用函数”。\n\n调用函数非常简单，只需要在函数名字后书写圆括号对即可。\n\nfun();\t// 调用函数\n\n\n1\n\n\n【小案例】\n\n// 定义函数，定义的函数是不会被立即执行的\nfunction fun() {\n    console.log('你好');\n    console.log('今天天气真好');\n}\n// 函数必须要等到调用的时候才能被执行\nfun();\nfun();\nfun();\n// 执行了三次\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 四、函数声明的提升\n\n和变量声明提升类似，函数声明也可以被提升。\n\nfun();\n// 在预解析阶段会被提升\nfunction fun() {\n    alert(\"函数被执行\");\n}\n\n\n1\n2\n3\n4\n5\n\n\n效果相当于：\n\nfunction fun() {\n    alert(\"函数被执行\");\n}\nfun();\n\n\n1\n2\n3\n4\n\n\n【函数表达式不能被提升】\n\nfun();\t// 报错！\nvar fun = function() {\n    alert(\"函数不能被执行\");\n};\n\n\n1\n2\n3\n4\n\n\n> 解释：函数表达式不能被提升的本质原因是函数表达式定义的其实是个变量，只不过是把函数赋给这个变量，而变量的提升只提升定义，不提升赋值！\n\n> 还是那个原则：先定义再使用！\n\n\n# 五、函数优先提升\n\n可以简单理解为：函数提升程度 > 变量提升程度。\n\nfun(); // b\n\nvar fun = function () {\n    alert('a');\n};\n\nfunction fun() {\n    alert('b');\n}\n\nfun(); // a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n效果相当于：\n\nfunction fun() {\n    alert('b');\n}\n\nvar fun;\n\nfun(); // b\n\nfun = function () {\n    alert('a');\n};\n\nfun(); // a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 六、函数的参数和返回值\n\n\n# 6.1 函数的参数\n\n参数是函数内的一些待定值，在调用函数时，必须传入这些参数的具体值。\n\n函数的参数可多可少，函数可以没有参数，也可以有多个参数，多个参数之间需要用逗号隔开。\n\n// 形参\nfunction add(a, b) {\n    var sum = a + b;\n    console.log('a + b = ' + sum);\n}\n// 实参\nadd(3, 5);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 圆括号中定义 “形式参数”\n * 调用函数时传入 “实际参数”\n\n> “形式参数” 和 “实际参数” 是彼此独立的，除了传递值（复制值）之外，互不干扰！\n\n> 注意：js 只有 “值传递” 没有 “引用传递”，对于引用类型的传递，传递的不是引用，而是那个变量里面的值（引用的地址）。\n> \n> 引用传递：修改形参，实参也会改变。js 中复杂类型的实参是个地址值不需要改变，也改变不了，改变的是地址所指向的堆中的复杂类型的具体值，此处具有迷惑性，要加以辨别！\n\n\n# 6.1.1 “形实结合”\n\n\n# 6.1.2 形参和实参个数不同的情况\n\n\n# 6.1.3 arguments\n\n函数内 arguments 表示它接收到的实参列表，它是一个类数组对象。\n\n类数组对象：所有属性均为从 0 开始的自然数序列，并且有 length 属性，和数组类似可以用方括号书写下标访问对象的某个属性值，但是不能调用数组的方法。\n\nfunction fun() {\n    console.log(arguments);\t\t// 11 22 33 44\n    console.log(arguments[0]);\t// 11\n    console.log(arguments[1]);\t// 22\n    console.log(arguments[9]);\t// undefined\n}\nfun(11, 22, 33, 44);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【小案例】\n\njs 本身没有函数的重载（函数名相同，形参个数不同），但是可以借助 arguments 模拟 “函数重载”。\n\n> 以下例子是一个典型的 “函数重载”，参数个数不同形成 “重载”。\n\nfunction fun() {\n    if (arguments.length == 0) {\n        console.log(0);\n    } else if (arguments.length == 1) {\n        console.log(1);\n    } else {\n        console.log(2);\n    }\n}\nfun(); // 0\nfun(1); // 1\nfun(1, 2); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 6.2 函数的返回值\n\n函数体内可以使用 return 关键字表示 “函数的返回值”。\n\nfunction sum(a, b) {\n    return a + b;\t// 函数的返回值\n}\nvar result = sum(3, 5);\t// 函数的返回值可以被变量接收\n\n\n1\n2\n3\n4\n\n\n调用一个有返回值的函数，可以被当做一个普通值，从而可以出现在任何可以书写值的地方。\n\nfunction sum(a, b) {\n    return a + b;\n}\nvar result = sum(3, 4) * sum(2, 6);\n\n\n1\n2\n3\n4\n\n\nfunction sum(a, b) {\n    return a + b;\n}\nvar result = sum(3, sum(4, 5));\t// 函数嵌套\n\n\n1\n2\n3\n4\n\n\n遇见 return 即退出函数。\n\n结合 if 语句的时候，往往不需要写 else 分支了。\n\n// 判断一个数字是否为偶数\nfunction checkeven(n) {\n    if (n % 2 == 0) {\n        return true;\n    }\n    return false;\n}\nvar result = checkeven(6);\nconsole.log(result);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 七、js内置 sort() 方法\n\n数组排序可以使用 sort() 方法，这个方法的参数又是一个函数。\n\n> 如果不加参数，那么 sort() 默认从小到大排序（字典序：数字 ——> 大写字母 ——> 小写字母）\n\nvar arr = [33, 22, 55, 11];\n// arr.sort(function(a, b){});\narr.sort();\n\n\n1\n2\n3\n\n\n这个函数中 a、b 分别表示数组中靠前和考后的项，如果需要将它们交换位置，则返回正整数；否则就返回负数。\n\n// 从小到大排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n    if (a > b) {\n        return 1;\n    } else {\n        return -1;\n    }\n});\nconsole.log(arr);\t// [11, 22, 33, 55]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n对以上算法进行简化：\n\n// 从小到大排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n\treturn a - b;\n});\nconsole.log(arr);\t// [11, 22, 33, 55]\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 从大到小排序\nvar arr = [33, 22, 55, 11];\narr.sort(function(a, b) {\n    return b - a;\n});\nconsole.log(arr);\t// [55, 33, 22, 11]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 八、递归\n\n函数的内部语句可以调用这个函数自身，从而发起对函数的一次迭代。在新的迭代中，又会执行调用函数自身的语句，从而又产生一次迭代。当函数执行到某一次时，不再进行新的迭代，函数被一层一层返回，函数被递归。\n\n> 函数自己调用自己！\n\n递归是一种较为高级的编程思想，它把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。\n\n【小案例：求阶乘】\n\n// n! 的本质：n * (n-1)!\nfunction factorial(n) {\n    // 递归的出口\n    if (n == 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> 递归技巧：\n> \n>  1. 分析问题，抽象出具体的数学模型\n>  2. 分析数学模型是否有 “规律性”\n>  3. 找到基本的 “规律”（比如：n! 的本质：n * (n-1)!）\n>  4. 将 “规律” 转换为代码（比如：return n * factorial(n - 1);）\n>  5. 找到 “出口” 也就是临界情况（比如：1! == 1）\n>  6. 将 “出口” 转化为代码（比如：if (n == 1) { return 1; }）\n>  7. 组合代码形成递归算法\n\n\n# 九、实现深克隆\n\n使用递归思想，整体思路和浅克隆类似，但稍微进行一些改动：如果遍历到的项是基本类型值，则直接推入结果数组；如果遍历到的项是数组，则重复执行浅克隆的操作。\n\nvar arr1 = [33, 44, 11, 22, [77, 88, [33, 44]]];\n\nfunction deepclone(arr) {\n    // 结果数组，“每一层”都有一个结果数组\n    var result = [];\n    // 遍历数组的每一项\n    for (var i = 0; i < arr.length; i++) {\n        // 类型判断，如果遍历到的项为数组\n        if (array.isarray(arr[i])) {\n            // 递归\n            result.push(deepclone(arr[i]));\n        } else {\n            // 如果遍历到的项是基本类型，就直接推入到结果数组中\n            result.push(arr[i]);\n        }\n    }\n    // 返回结果数组\n    return result;\n}\n\nvar arr2 = deepclone(arr1);\nconsole.log(arr1); // [33, 44, 11, 22, [77, 88, [33, 44]]]\nconsole.log(arr2); // [33, 44, 11, 22, [77, 88, [33, 44]]]\nconsole.log(arr1[4] == arr2[4]); // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 十、全局变量和局部变量\n\n\n# 10.1 变量作用域\n\njs 是函数级作用域编程语言：变量只在其所定义时所在的 function 内部有意义。\n\n> 重点提示！\n> \n> 注意：js 是函数级作用域编程语言，没有块级作用域的概念！\n> \n> 即：js 中 if、switch、for、while 等 () {} 中的变量都不属于局部变量，而是外层函数的局部变量，如果没有外层函数，那么就是全局变量！\n> \n> 注：在 es6 标准中，js 引入了块级作用域概念！\n\n\n# 10.2 局部变量\n\nfunction fun(n) {\n    var a = n;\n}\n\nfun(3);\nconsole.log(a);\t// 报错\nconsole.log(n);\t// 报错\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 变量 a 是在 fun 函数中被定义的，所以变量 a 只在 fun 函数内部有定义，fun 函数就是 a 的 “作用域”，变量 a 被称为 “局部变量”。\n> \n> 函数形参（n）也属于该函数的作用域！\n\n\n# 10.3 全局变量\n\n如果不将变量定义在任何函数的内部（包括形参），此时这个变量就是全局变量，它在任何函数内部都可以被访问和更改。\n\n\n# 10.4 遮蔽效应\n\n如果函数中也定义了和全局变量同名的变量，则函数内的局部变量会将全局的变量进行 “遮蔽”。\n\nvar a = 10;\nfunction fun() {\n    var a = 5;\n    a++;\n    console.log(a);\t// 6\n}\nfun();\nconsole.log(a);\t// 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10.5 注意考虑变量声明提升的情况\n\n\n# 10.6 形参也是局部变量\n\n\n# 10.7 作用域链\n\n先来认识函数的嵌套：一个函数内部也可以定义一个函数。和局部变量类似，定义在一个函数内部的函数是局部变量。\n\nfunction fun() {\n    // 局部函数\n    function inner() {\n        console.log('你好');\n    }\n    // 调用局部函数\n    inner();\n}\n// 调用外部函数\nfun();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在函数嵌套中，变量会从内到外逐层寻找它的定义（先找本层，本层没有往上一层找，以此类推）。\n\nvar a = 10;\nvar b = 20;\nfunction fun() {\n    var c = 40;\n    function inner() {\n    \tvar a = 40;\n        var d = 50;\n        console.log(a, b, c, d);\t// 40 20 40 50\n    }\n    inner();\n}\nfun();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 10.8 不加 var 将定义全局变量\n\n在初次给变量赋值时，如果没有加 var，则将定义全局变量。\n\nfunction fun() {\n    a = 3;\n}\nfun();\nconsole.log(a);\t// 3\n\n\n1\n2\n3\n4\n5\n\n\n> 没有特殊情况，一律都要记得加 var。\n\n\n# 十一、闭包\n\n// 定义一个全局变量\nvar name = 'abc';\n\n// 创建一个函数\nfunction fun() {\n    // 定义局部变量\n    var name = '周吉瑞';\n    // 返回一个局部函数\n    return function() {\n        console.log(name);\n    };\n}\n\n// 调用外部函数，就能得到局部函数，用变量 inn 来接收\nvar inn = fun();\n// 执行 inn 函数，就相当于在 fun 函数的外部，执行了局部函数\ninn(); // \"周吉瑞\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 11.1 什么是闭包\n\njs 中函数会产生闭包。\n\n闭包是函数本身和该函数声明时所处的环境状态的组合。\n\n函数能够 “记忆” 其定义时所处的环境，即使函数不在其定义的环境中被调用，也能访问定义时所处环境的变量。\n\n\n# 11.2 观察闭包现象\n\n在 js 中，每次创建函数时都会创建闭包。\n\n但是，闭包特性往往需要将函数 “换一个地方” 执行，才能被直观的体现出来。\n\n\n# 11.3 闭包非常实用\n\n闭包很有用，因为它允许我们将数据与操作该数据的函数关联起来，这与 “面向对象编程” 有少许相似之处。\n\n闭包的功能：记忆性、模拟私有变量（相当于把函数的数据封装了）。\n\n\n# 11.3.1 闭包用途1 - 记忆性\n\n当闭包产生时，函数所处环境的状态会始终保持在内存中，不会在外层函数调用后自动清除，这就是闭包的记忆性。\n\n【闭包的记忆性举例】\n\n创建体温检测函数 checktemp(n)，可以检查体温 n 是否正常，函数会返回布尔值。\n\n但是，不同的小区有不同的体温检测标准，比如 a 小区体温合格线是 37.1℃，而 b 小区体温合格线是 37.3℃，应该怎么编程呢？\n\nfunction createchecktemp(standardtemp) {\n    function checktemp(n) {\n        if (n <= standardtemp) {\n            alert('你的体温正常');\n        } else {\n            alert('你的体温偏高');\n        }\n    }\n    return checktemp;\n}\n\n// 创建一个 checktemp 函数，它以 37.1 度为标准线\nvar checktemp_a = createchecktemp(37.1);\n\n// 再创建一个 checktemp 函数， 它以 37.3 度为标准线\nvar checktemp_b = createchecktemp(37.3);\n\nchecktemp_a(37.2);\t// \"你的体温偏高\"\nchecktemp_a(37.0);\t// \"你的体温正常\"\nchecktemp_b(37.2);\t// \"你的体温正常\"\nchecktemp_b(37.6);\t// \"你的体温偏高\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 11.3.2 闭包用途2 - 模拟私有变量\n\n题目：请定义一个变量 a，要求是能保证这个 a 只能被进行指定的操作（如：加1、乘2），而不能进行其他操作，应该怎么编程呢？\n\n> 即：让变量变得安全，私有化！\n> \n> 在 java、c++ 等语言中，有私有属性的概念，但是 js 中只能用闭包来模拟。\n\n// 封装一个函数，这个函数的功能就是私有化变量\nfunction fun() {\n    // 定义一个局部变量 a\n    var a = 0;\n    // 返回一个对象\n    return {\n        geta: function () {\n            return a;\n        },\n        add: function () {\n            a++;\n        },\n        pow: function () {\n            a *= 2;\n        }\n    };\n}\n\nvar obj = fun();\n// 如果想在 fun 函数外面使用变量 a，唯一的方法就是调用 geta() 方法\nconsole.log(obj.geta()); // 0\n// 想让变量 a 进行加 1 操作\nobj.add();\nconsole.log(obj.geta()); // 1\nobj.pow();\nconsole.log(obj.geta()); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 11.3.3 使用闭包的注意点\n\n不能滥用闭包！否则会造成网页的性能问题，严重时可能导致 “内存泄漏”。\n\n所谓 “内存泄漏” 就是指程序中已经动态分配的内存由于某种原因未释放或无法释放。\n\n> 目前，chrome 等比较先进的浏览器很少发生内存泄漏。\n\n\n# 11.3.4 闭包的独立性\n\nfunction addcount() {\n    var count = 0;\n    return function() {\n        count = count + 1;\n        console.log(count);\n    };\n}\nvar fun1 = addcount();\nvar fun2 = addcount();\nfun1();\t// 1\nfun2();\t// 1\nfun2();\t// 2\nfun2();\t// 3\nfun2();\t// 4\nfun1();\t// 2\n/* 即：闭包之间是互相独立的 */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 十二、立即执行函数 iife\n\niife 立即调用函数表达式，是一种特殊的 js 函数写法，一旦被定义，就立即被调用。\n\n(function () {\n    // 函数体语句\n})();\n\n\n1\n2\n3\n\n\n\n# 12.1 形成 iife 的方法\n\n> 蓝色括号里写传递的参数。\n\n> 常用 () 来将函数转为 “函数表达式”。\n\n\n# 12.2 iife的作用1 - 为变量赋值\n\nvar age = 12;\nvar sex = '男';\nvar title = (function () {\n    if (age < 18) {\n        return '小朋友';\n    } else {\n        if (sex == '男') {\n            return '先生';\n        } else {\n            return '女士';\n        }\n    }\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 12.3 iife的作用2 - 将全局变量变为局部变量\n\n先看一个问题：\n\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n    arr.push(function() {\n        console.log(i);\n    });\n    arr[i]();\n}\nconsole.log(\"#\")\nfor (var j = 0; j < arr.length; j++) {\n    arr[j]();\n}\n\n/*\n0\n1\n2\n3\n4\n#\n5\n5\n5\n5\n5\n*/\n\n/*\n解释：arr 数组中的每个元素都是 function(){alert(i)} 这个函数，\narr[i] ——> function(){alert(i)}\narr[i](); ——> function(){alert(i)}()\n由于 i 为全局变量（js 没有块级作用域），所以所有函数闭包中的 i 都是全局的, 而 i 最终确定为 5，所以都输出 5；\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\niife 可以在一些场合（如 for 循环中）将全局变量变为局部变量，语法显得紧凑。\n\n> 在 es6 中，有更好的方式可以约定变量的作用域！\n\nvar arr = [];\nfor (var i = 0; i < 5; i++) {\n    (function (i) {\n        arr.push(function () {\n            console.log(i);\n        });\n    })(i);\n}\nfor (var j = 0; j < arr.length; j++) {\n    arr[j]();\n}\n\n/*\n0\n1\n2\n3\n4\n*/\n\n/*\n解释：利用函数作用域把 i 约束为一个局部变量\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"ES6语法扩展",frontmatter:{title:"ES6语法扩展",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/067486/",categories:["JS","ES6"],tags:[null],readingShow:"top"},regularPath:"/20.JS/20.ES6/02.ES6%E8%AF%AD%E6%B3%95%E6%89%A9%E5%B1%95.html",relativePath:"20.JS/20.ES6/02.ES6语法扩展.md",key:"v-f69f579a",path:"/pages/067486/",headers:[{level:2,title:"一、剩余参数",slug:"一、剩余参数",normalizedTitle:"一、剩余参数",charIndex:2},{level:3,title:"1.2 认识剩余参数",slug:"_1-2-认识剩余参数",normalizedTitle:"1.2 认识剩余参数",charIndex:13},{level:3,title:"1.3 剩余参数的本质",slug:"_1-3-剩余参数的本质",normalizedTitle:"1.3 剩余参数的本质",charIndex:67},{level:3,title:"1.4 注意事项",slug:"_1-4-注意事项",normalizedTitle:"1.4 注意事项",charIndex:323},{level:4,title:"1.4.1 箭头函数的剩余参数",slug:"_1-4-1-箭头函数的剩余参数",normalizedTitle:"1.4.1 箭头函数的剩余参数",charIndex:335},{level:4,title:"1.4.2 使用剩余参数替代 arguments 获取实际参数",slug:"_1-4-2-使用剩余参数替代-arguments-获取实际参数",normalizedTitle:"1.4.2 使用剩余参数替代 arguments 获取实际参数",charIndex:415},{level:4,title:"1.4.3 剩余参数的位置",slug:"_1-4-3-剩余参数的位置",normalizedTitle:"1.4.3 剩余参数的位置",charIndex:504},{level:3,title:"1.5 剩余参数的应用",slug:"_1-5-剩余参数的应用",normalizedTitle:"1.5 剩余参数的应用",charIndex:555},{level:2,title:"二、数组展开运算符",slug:"二、数组展开运算符",normalizedTitle:"二、数组展开运算符",charIndex:1247},{level:3,title:"2.1 认识数组展开运算符",slug:"_2-1-认识数组展开运算符",normalizedTitle:"2.1 认识数组展开运算符",charIndex:1261},{level:3,title:"2.2 数组展开运算符的基本用法",slug:"_2-2-数组展开运算符的基本用法",normalizedTitle:"2.2 数组展开运算符的基本用法",charIndex:1455},{level:3,title:"2.3 区分剩余参数和展开运算符",slug:"_2-3-区分剩余参数和展开运算符",normalizedTitle:"2.3 区分剩余参数和展开运算符",charIndex:1563},{level:3,title:"2.4 数组展开运算符的应用",slug:"_2-4-数组展开运算符的应用",normalizedTitle:"2.4 数组展开运算符的应用",charIndex:1772},{level:4,title:"2.4.1 复制数组",slug:"_2-4-1-复制数组",normalizedTitle:"2.4.1 复制数组",charIndex:1790},{level:4,title:"2.4.2 合并数组",slug:"_2-4-2-合并数组",normalizedTitle:"2.4.2 合并数组",charIndex:1931},{level:4,title:"2.4.3 字符串转为数组",slug:"_2-4-3-字符串转为数组",normalizedTitle:"2.4.3 字符串转为数组",charIndex:2076},{level:4,title:"2.4.4 类数组转为数组",slug:"_2-4-4-类数组转为数组",normalizedTitle:"2.4.4 类数组转为数组",charIndex:2298},{level:2,title:"三、对象展开运算符",slug:"三、对象展开运算符",normalizedTitle:"三、对象展开运算符",charIndex:2560},{level:3,title:"3.1 展开对象",slug:"_3-1-展开对象",normalizedTitle:"3.1 展开对象",charIndex:2574},{level:3,title:"3.2 合并对象",slug:"_3-2-合并对象",normalizedTitle:"3.2 合并对象",charIndex:2810},{level:3,title:"3.3 注意事项",slug:"_3-3-注意事项",normalizedTitle:"3.3 注意事项",charIndex:3201},{level:4,title:"3.3.1 空对象的展开",slug:"_3-3-1-空对象的展开",normalizedTitle:"3.3.1 空对象的展开",charIndex:3213},{level:4,title:"3.3.2 非对象的展开",slug:"_3-3-2-非对象的展开",normalizedTitle:"3.3.2 非对象的展开",charIndex:3328},{level:4,title:"3.3.3 字符串的展开",slug:"_3-3-3-字符串的展开",normalizedTitle:"3.3.3 字符串的展开",charIndex:3572},{level:4,title:"3.3.4 数组的展开",slug:"_3-3-4-数组的展开",normalizedTitle:"3.3.4 数组的展开",charIndex:3853},{level:4,title:"3.3.5 对象中对象属性的展开",slug:"_3-3-5-对象中对象属性的展开",normalizedTitle:"3.3.5 对象中对象属性的展开",charIndex:3933},{level:3,title:"3.4 对象展开运算符的应用",slug:"_3-4-对象展开运算符的应用",normalizedTitle:"3.4 对象展开运算符的应用",charIndex:4356},{level:4,title:"3.4.1 复制对象",slug:"_3-4-1-复制对象",normalizedTitle:"3.4.1 复制对象",charIndex:4374},{level:4,title:"3.4.2 用户参数和默认参数",slug:"_3-4-2-用户参数和默认参数",normalizedTitle:"3.4.2 用户参数和默认参数",charIndex:4491},{level:2,title:"四、Set 和 Map",slug:"四、set-和-map",normalizedTitle:"四、set 和 map",charIndex:5152},{level:3,title:"4.1 什么是 Set？",slug:"_4-1-什么是-set",normalizedTitle:"4.1 什么是 set？",charIndex:5168},{level:3,title:"4.2 Set 实例的方法和属性",slug:"_4-2-set-实例的方法和属性",normalizedTitle:"4.2 set 实例的方法和属性",charIndex:5417},{level:4,title:"4.2.1 add 方法",slug:"_4-2-1-add-方法",normalizedTitle:"4.2.1 add 方法",charIndex:5437},{level:4,title:"4.2.2 has 方法",slug:"_4-2-2-has-方法",normalizedTitle:"4.2.2 has 方法",charIndex:5579},{level:4,title:"4.2.3 delete 方法",slug:"_4-2-3-delete-方法",normalizedTitle:"4.2.3 delete 方法",charIndex:5734},{level:4,title:"4.2.4 clear 方法",slug:"_4-2-4-clear-方法",normalizedTitle:"4.2.4 clear 方法",charIndex:5933},{level:4,title:"4.2.5 forEach 方法",slug:"_4-2-5-foreach-方法",normalizedTitle:"4.2.5 foreach 方法",charIndex:6067},{level:4,title:"4.2.6 size 属性",slug:"_4-2-6-size-属性",normalizedTitle:"4.2.6 size 属性",charIndex:6980},{level:3,title:"4.3 Set 构造函数的参数",slug:"_4-3-set-构造函数的参数",normalizedTitle:"4.3 set 构造函数的参数",charIndex:7101},{level:3,title:"4.4 Set 注意事项",slug:"_4-4-set-注意事项",normalizedTitle:"4.4 set 注意事项",charIndex:7851},{level:3,title:"4.5 Set 的应用",slug:"_4-5-set-的应用",normalizedTitle:"4.5 set 的应用",charIndex:8151},{level:3,title:"4.6 什么是 Map？",slug:"_4-6-什么是-map",normalizedTitle:"4.6 什么是 map？",charIndex:8829},{level:3,title:"4.7 Map 实例的方法和属性",slug:"_4-7-map-实例的方法和属性",normalizedTitle:"4.7 map 实例的方法和属性",charIndex:9510},{level:4,title:"4.7.1 set 方法",slug:"_4-7-1-set-方法",normalizedTitle:"4.7.1 set 方法",charIndex:9530},{level:4,title:"4.7.2 get 方法",slug:"_4-7-2-get-方法",normalizedTitle:"4.7.2 get 方法",charIndex:9687},{level:4,title:"4.7.3 has 方法",slug:"_4-7-3-has-方法",normalizedTitle:"4.7.3 has 方法",charIndex:9856},{level:4,title:"4.7.4 delete 方法",slug:"_4-7-4-delete-方法",normalizedTitle:"4.7.4 delete 方法",charIndex:10032},{level:4,title:"4.7.5 clear 方法",slug:"_4-7-5-clear-方法",normalizedTitle:"4.7.5 clear 方法",charIndex:10132},{level:4,title:"4.7.6 forEach 方法",slug:"_4-7-6-foreach-方法",normalizedTitle:"4.7.6 foreach 方法",charIndex:10167},{level:4,title:"4.7.7 size 属性",slug:"_4-7-7-size-属性",normalizedTitle:"4.7.7 size 属性",charIndex:10273},{level:3,title:"4.8 Map 构造函数的参数",slug:"_4-8-map-构造函数的参数",normalizedTitle:"4.8 map 构造函数的参数",charIndex:10333},{level:3,title:"4.9 Map 注意事项",slug:"_4-9-map-注意事项",normalizedTitle:"4.9 map 注意事项",charIndex:11041},{level:3,title:"4.10 Map 的应用",slug:"_4-10-map-的应用",normalizedTitle:"4.10 map 的应用",charIndex:11225},{level:2,title:"五、Iterator 遍历器与 for...of 循环",slug:"五、iterator-遍历器与-for-of-循环",normalizedTitle:"五、iterator 遍历器与 for...of 循环",charIndex:12129},{level:3,title:"5.1 什么是 Iterator？",slug:"_5-1-什么是-iterator",normalizedTitle:"5.1 什么是 iterator？",charIndex:12161},{level:3,title:"5.2 Iterator 解惑",slug:"_5-2-iterator-解惑",normalizedTitle:"5.2 iterator 解惑",charIndex:12694},{level:3,title:"5.3 for...of 的用法",slug:"_5-3-for-of-的用法",normalizedTitle:"5.3 for...of 的用法",charIndex:12899},{level:3,title:"5.4 原生可遍历与非原生可遍历",slug:"_5-4-原生可遍历与非原生可遍历",normalizedTitle:"5.4 原生可遍历与非原生可遍历",charIndex:14026},{level:4,title:"5.4.1 什么是可遍历",slug:"_5-4-1-什么是可遍历",normalizedTitle:"5.4.1 什么是可遍历",charIndex:14046},{level:4,title:"5.4.2 原生可遍历的有哪些？",slug:"_5-4-2-原生可遍历的有哪些",normalizedTitle:"5.4.2 原生可遍历的有哪些？",charIndex:14141},{level:4,title:"5.4.3 非原生可遍历的有哪些？",slug:"_5-4-3-非原生可遍历的有哪些",normalizedTitle:"5.4.3 非原生可遍历的有哪些？",charIndex:14214},{level:4,title:"5.4.4 使用了 Iterator 的其他场合",slug:"_5-4-4-使用了-iterator-的其他场合",normalizedTitle:"5.4.4 使用了 iterator 的其他场合",charIndex:14302},{level:2,title:"六、ES6 新增方法",slug:"六、es6-新增方法",normalizedTitle:"六、es6 新增方法",charIndex:14374},{level:3,title:"6.1 字符串新增方法",slug:"_6-1-字符串新增方法",normalizedTitle:"6.1 字符串新增方法",charIndex:14389},{level:4,title:"6.1.1 includes()",slug:"_6-1-1-includes",normalizedTitle:"6.1.1 includes()",charIndex:14404},{level:4,title:"6.1.2 padStart() 和 padEnd()",slug:"_6-1-2-padstart-和-padend",normalizedTitle:"6.1.2 padstart() 和 padend()",charIndex:15372},{level:4,title:"6.1.3 trimStart() 和 trimEnd()",slug:"_6-1-3-trimstart-和-trimend",normalizedTitle:"6.1.3 trimstart() 和 trimend()",charIndex:15979},{level:3,title:"6.2 数组新增方法",slug:"_6-2-数组新增方法",normalizedTitle:"6.2 数组新增方法",charIndex:16883},{level:4,title:"6.2.1 includes()",slug:"_6-2-1-includes",normalizedTitle:"6.2.1 includes()",charIndex:16897},{level:4,title:"6.2.2 Array.from()",slug:"_6-2-2-array-from",normalizedTitle:"6.2.2 array.from()",charIndex:17491},{level:4,title:"6.2.3 find() 和 findIndex()",slug:"_6-2-3-find-和-findindex",normalizedTitle:"6.2.3 find() 和 findindex()",charIndex:18473},{level:3,title:"6.3 对象新增方法",slug:"_6-3-对象新增方法",normalizedTitle:"6.3 对象新增方法",charIndex:19398},{level:4,title:"6.3.1 Object.assign()",slug:"_6-3-1-object-assign",normalizedTitle:"6.3.1 object.assign()",charIndex:19412},{level:4,title:"6.3.2 Object.keys()、Object.values() 和 Object.entries()",slug:"_6-3-2-object-keys-、object-values-和-object-entries",normalizedTitle:"6.3.2 object.keys()、object.values() 和 object.entries()",charIndex:21470}],headersStr:"一、剩余参数 1.2 认识剩余参数 1.3 剩余参数的本质 1.4 注意事项 1.4.1 箭头函数的剩余参数 1.4.2 使用剩余参数替代 arguments 获取实际参数 1.4.3 剩余参数的位置 1.5 剩余参数的应用 二、数组展开运算符 2.1 认识数组展开运算符 2.2 数组展开运算符的基本用法 2.3 区分剩余参数和展开运算符 2.4 数组展开运算符的应用 2.4.1 复制数组 2.4.2 合并数组 2.4.3 字符串转为数组 2.4.4 类数组转为数组 三、对象展开运算符 3.1 展开对象 3.2 合并对象 3.3 注意事项 3.3.1 空对象的展开 3.3.2 非对象的展开 3.3.3 字符串的展开 3.3.4 数组的展开 3.3.5 对象中对象属性的展开 3.4 对象展开运算符的应用 3.4.1 复制对象 3.4.2 用户参数和默认参数 四、Set 和 Map 4.1 什么是 Set？ 4.2 Set 实例的方法和属性 4.2.1 add 方法 4.2.2 has 方法 4.2.3 delete 方法 4.2.4 clear 方法 4.2.5 forEach 方法 4.2.6 size 属性 4.3 Set 构造函数的参数 4.4 Set 注意事项 4.5 Set 的应用 4.6 什么是 Map？ 4.7 Map 实例的方法和属性 4.7.1 set 方法 4.7.2 get 方法 4.7.3 has 方法 4.7.4 delete 方法 4.7.5 clear 方法 4.7.6 forEach 方法 4.7.7 size 属性 4.8 Map 构造函数的参数 4.9 Map 注意事项 4.10 Map 的应用 五、Iterator 遍历器与 for...of 循环 5.1 什么是 Iterator？ 5.2 Iterator 解惑 5.3 for...of 的用法 5.4 原生可遍历与非原生可遍历 5.4.1 什么是可遍历 5.4.2 原生可遍历的有哪些？ 5.4.3 非原生可遍历的有哪些？ 5.4.4 使用了 Iterator 的其他场合 六、ES6 新增方法 6.1 字符串新增方法 6.1.1 includes() 6.1.2 padStart() 和 padEnd() 6.1.3 trimStart() 和 trimEnd() 6.2 数组新增方法 6.2.1 includes() 6.2.2 Array.from() 6.2.3 find() 和 findIndex() 6.3 对象新增方法 6.3.1 Object.assign() 6.3.2 Object.keys()、Object.values() 和 Object.entries()",content:"# 一、剩余参数\n\n\n# 1.2 认识剩余参数\n\nconst add = (x, y, z, ...args) => {};\n\n\n# 1.3 剩余参数的本质\n\n剩余参数永远是个数组，即使没有值，也是个空数组。\n\nconst add = (x, y, ...args) => {\n    console.log(x, y, args);\n};\nadd();\t\t\t\t\t// undefined undefined []\nadd(1);\t\t\t\t\t// 1 undefined []\nadd(1, 2);\t\t\t\t// 1 2 []\nadd(1, 2, 3, 4, 5);\t\t// 1 2 [ 3, 4, 5 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.4 注意事项\n\n# 1.4.1 箭头函数的剩余参数\n\n箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号。\n\nconst add = (...args) => {};\n\n# 1.4.2 使用剩余参数替代 arguments 获取实际参数\n\n * 剩余参数是一个 “真数组”，arguments 是一个 “类数组”\n * 剩余参数的名字可以自定义\n\n# 1.4.3 剩余参数的位置\n\n剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。\n\n\n# 1.5 剩余参数的应用\n\n作为数组的应用：\n\nconst add = (...args) => {\n    let sum = 0;\n\n    for (let i = 0; i < args.length; i++) {\n        sum += args[i];\n    } // 当然此处，arguments 也可以\n\n    return sum;\n};\n\nconsole.log(add());\t\t\t// 0\nconsole.log(add(1, 1));\t\t// 2\nconsole.log(add(1, 2, 3));\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n与解构赋值结合使用：\n\n（剩余参数不一定非要作为函数参数使用）\n\n * 与数组解构赋值结合\n\nconst func = ([num, ...args]) => {};\nfunc([1, 2, 3]);\n\n\n1\n2\n\n * 与对象解构赋值结合\n\nconst {x, y, ...z} = {a: 3, x: 1, y: 2, b: 4};\nconsole.log(x, y, z);\n// 1 2 { a: 3, b: 4 }\n// 这里的剩余参数是个对象（准确的应该叫：剩余元素）\n\n\n1\n2\n3\n4\n\n\nconst func = ({x, y, ...z}) => {\n    console.log(x, y, z);\t// 1 2 { a: 3, b: 4 }\n};\nfunc({a: 3, x: 1, y: 2, b: 4});\n\n\n1\n2\n3\n4\n\n\n\n# 二、数组展开运算符\n\n\n# 2.1 认识数组展开运算符\n\n剩余参数：参数列表 ——> 参数数组\n\n数组展开运算符：参数数组 ——> 参数列表\n\n案例：\n\n> 如果我们需要求 [3, 1, 2] 中的最大值，那么我们是不能直接通过 Math.max() 来求的，因为 Math.max() 接受的不能是数组，而是一个一个的参数，比如：Math.max(3, 1, 2)，所以把参数数组转化为参数列表才是关键。\n\n\n# 2.2 数组展开运算符的基本用法\n\n用法与剩余参数类似\n\nconsole.log(Math.min(...[3, 1, 2]));\n\n相当于\n\nconsole.log(Math.min(3, 1, 2));\n\n\n# 2.3 区分剩余参数和展开运算符\n\nconst add = (...args) => {\n    console.log(args);\t\t// [ 1, 2, 3 ]\n    console.log(...args);\t// 1 2 3\n};\nadd(1, 2, 3);\n\n\n1\n2\n3\n4\n5\n\n\nconsole.log([...[1, 2, 3], 4]);\t// [ 1, 2, 3, 4 ]\n\n\n1\n\n\n\n# 2.4 数组展开运算符的应用\n\n# 2.4.1 复制数组\n\nconst a = [1, 2, 3];\nconst b = [...a];\na[1] = 5;\nconsole.log(a);\t\t// [ 1, 5, 3 ]\nconsole.log(b);\t\t// [ 1, 2, 3 ]\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.2 合并数组\n\nconst a = [1, 2];\nconst b = [3];\nconst c = [4, 5];\nconsole.log([0, ...a, 99, ...c, ...b]);\n// [0, 1, 2, 99, 4, 5, 3]\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.3 字符串转为数组\n\n字符串可以按照数组的形式展开。\n\nconsole.log(...'alex');\t\t\t\t// a l e x\nconsole.log('a', 'l', 'e', 'x');\t// a l e x\n\nconsole.log([...'alex']);\t\t\t// [ 'a', 'l', 'e', 'x' ]\n// ES6 之前字符串转数组是通过：'alex'.split('');\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.4 类数组转为数组\n\n// arguments\nfunction func() {\n    console.log(arguments);\t\t\t// [Arguments] { '0': 1, '1': 2 }\n    console.log([...arguments]);\t// [ 1, 2 ]\n}\nfunc(1, 2);\n\n// NodeList\nconsole.log([...document.querySelectorAll('p')].push);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、对象展开运算符\n\n\n# 3.1 展开对象\n\n对象不能直接展开，必须在 {} 中展开。\n\nconst apple = {\n    color: '红色',\n    shape: '球形',\n    taste: '甜'\n};\nconsole.log({...apple});\t\t\t// { color: '红色', shape: '球形', taste: '甜' }\nconsole.log({...apple} === apple);\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.2 合并对象\n\nconst apple = {\n    color: '红色',\n    shape: '球形',\n    taste: '甜'\n};\n\nconst pen = {\n    color: '黑色',\n    shape: '圆柱形',\n    use: '写字'\n};\n\n// 新对象拥有全部属性，相同属性，后者覆盖前者\nconsole.log({...apple, ...pen});\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log({...pen, ...apple});\t// { color: '红色', shape: '球形', use: '写字', taste: '甜' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.3 注意事项\n\n# 3.3.1 空对象的展开\n\n如果展开一个空对象，则没有任何效果。\n\nconsole.log({...{}});\t\t\t// {}\nconsole.log({...{}, a: 1});\t\t// { a: 1 }\n\n\n1\n2\n\n\n# 3.3.2 非对象的展开\n\n如果展开的不是对象，则会自动将其转为对象，再将其属性罗列出来（没有属性便为空）。\n\nconsole.log({...1});\t\t\t// {}\nconsole.log(new Object(1));\t\t// [Number: 1]\nconsole.log({...undefined});\t// {}\nconsole.log({...null});\t\t\t// {}\nconsole.log({...true});\t\t\t// {}\n\n\n1\n2\n3\n4\n5\n\n\n# 3.3.3 字符串的展开\n\n如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n// 字符串在对象中展开\nconsole.log({...'alex'});\t\t// { '0': 'a', '1': 'l', '2': 'e', '3': 'x' }\n\n// 字符串在数组中展开\nconsole.log([...'alex']);\t\t// [ 'a', 'l', 'e', 'x' ]\n\n// 字符串直接展开\nconsole.log(...'alex');\t\t\t// a l e x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.3.4 数组的展开\n\nconsole.log({...[1, 2, 3]});\t// { '0': 1, '1': 2, '2': 3 }\n\n\n1\n\n\n# 3.3.5 对象中对象属性的展开\n\n不会展开对象中的对象属性。\n\nconst apple = {\n    feature: {\n        taste: '甜'\n    }\n};\n\nconst pen = {\n    feature: {\n        color: '黑色',\n        shape: '圆柱形'\n    },\n    use: '写字'\n};\n\nconsole.log({...apple});\t\t\t// { feature: { taste: '甜' } }\n\n// feature 会直接覆盖，因为 feature 不能展开\nconsole.log({...apple, ...pen});\t// { feature: { color: '黑色', shape: '圆柱形' }, use: '写字' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.4 对象展开运算符的应用\n\n# 3.4.1 复制对象\n\nconst a = {x: 1, y: 2};\nconst c = {...a};\nconsole.log(c, c === a);\n// { x: 1, y: 2 } false\n\n\n1\n2\n3\n4\n\n\n# 3.4.2 用户参数和默认参数\n\nconst logUser = userParam => {\n    const defaultPeram = {\n        username: 'ZhangSan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const param = {...defaultPeram, ...userParam};\n    console.log(param.username, param.age, param.sex);\n};\n\nlogUser({username: 'jerry'});\t// jerry 0 male\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再优化：\n\nconst logUser = userParam => {\n    const defaultPeram = {\n        username: 'ZhangSan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const {username, age, sex} = {...defaultPeram, ...userParam};\n    console.log(username, age, sex);\n};\n\nlogUser({username: 'jerry'});\t// jerry 0 male\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、Set 和 Map\n\n\n# 4.1 什么是 Set？\n\nSet 是一系列无序、没有重复值的数据集合。\n\n> 数组是一系列有序（下标索引）的数据集合。\n\nconst s = new Set();\ns.add(1);\ns.add(2);\n\n// Set 中不能有重复的成员\ns.add(1);\nconsole.log(s);\t\t// Set(2) { 1, 2 }\n\n// Set 没有下标去标识每一个值，所以 Set 是无序的，也不能像数组那样通过下标去访问 Set 的成员。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.2 Set 实例的方法和属性\n\n# 4.2.1 add 方法\n\nconst s = new Set();\ns.add(0);\n// 可以连写\ns.add(1).add(2).add(2).add(3);\nconsole.log(s);\t\t// Set(4) { 0, 1, 2, 3 }\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.2 has 方法\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\nconsole.log(s.has(1));\t// true\nconsole.log(s.has(4));\t// false\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.3 delete 方法\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\ns.delete(2);\n// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错\ns.delete(4);\nconsole.log(s);\t// Set(3) { 0, 1, 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.2.4 clear 方法\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\ns.clear();\nconsole.log(s);\t// Set(0) {}\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.5 forEach 方法\n\n作用：用于遍历 Set 的（按照成员添加进集合的顺序遍历）。\n\nforEach 方法可以接受两个参数，第一个是：回调函数，第二个是：指定回调函数的 this 指向。\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\ns.forEach(function (value, key, set) {\n    // Set 中 value = key，原因：好多数据结构都有 forEach 方法，为了方便统一，所以参数是统一的，但是参数的意义各有不同\n    // set 就是 s 本身\n    console.log(value, key, set === s);\n    console.log(this);\n});\n\n/*\n0 0 true\nWindow\n1 1 true\nWindow\n2 2 true\nWindow\n3 3 true\nWindow \n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\ns.forEach(function (value, key, set) {\n    // Set 中 value = key，原因：好多数据结构都有 forEach 方法，为了方便统一，所以参数是统一的，但是参数的意义各有不同\n    // set 就是 s 本身\n    console.log(value, key, set === s);\n    console.log(this);\n}, document);\n\n/*\n0 0 true\n#document\n1 1 true\n#document\n2 2 true\n#document\n3 3 true\n#document\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 4.2.6 size 属性\n\nconst s = new Set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\nconsole.log(s.size);\t// 4\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.3 Set 构造函数的参数\n\n * 数组\n * 字符串、arguments、NodeList、Set 等\n\n【数组】\n\nconst s = new Set([1, 2, 1]);\nconsole.log(s);\t\t// Set(2) { 1, 2 }\n\n\n1\n2\n\n\n【字符串】\n\nconsole.log(new Set('hiii'));\t// Set(2) { 'h', 'i' }\n\n\n1\n\n\n【arguments】\n\nfunction func() {\n    console.log(new Set(arguments));\n}\nfunc(1, 2, 1);\t// Set(2) { 1, 2 }\n\n\n1\n2\n3\n4\n\n\n【NodeList】\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    console.log(new Set(document.querySelectorAll('P')));\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n【Set】\n\nconst s = new Set([1, 2, 1]);\nconsole.log(new Set(s));\t// Set(2) { 1, 2 }\nconsole.log(s);\t\t\t\t// Set(2) { 1, 2 }\n// 这也是复制一个 Set 的方法\n\n\n1\n2\n3\n4\n\n\n\n# 4.4 Set 注意事项\n\n【Set 如何判断重复】\n\n * Set 对重复值的判断基本遵循严格相等（===）\n\n * 但是对于 NaN 的判断与 === 不同，Set 中 NaN 等于 NaN\n\nconst s = new Set();\ns.add({}).add({});\nconsole.log({} === {});\t // false\nconsole.log(s);\t\t\t // Set(2) { {}, {} }\n\n\n1\n2\n3\n4\n\n\n【什么时候使用 Set】\n\n * 数组或字符串需要去重时\n * 不需要通过下标访问，只需要遍历时\n * 为了使用 Set 提供的方法和属性时\n\n\n# 4.5 Set 的应用\n\n【数组去重】\n\nconst s = new Set([1, 2, 1]);\nconsole.log(s);\t\t\t// Set(2) { 1, 2 }\nconsole.log([...s]);\t// [ 1, 2 ]\n\n\n1\n2\n3\n\n\n【字符串去重】\n\nconst s = new Set('abbacbd');\nconsole.log(s);\t\t\t\t\t// Set(4) { 'a', 'b', 'c', 'd' }\nconsole.log([...s].join(''));\t// abcd\n\n\n1\n2\n3\n\n\n【存放 DOM 元素】\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    // 这里使用 Set 是因为我们不需要通过下标去访问，只需直接遍历即可\n    const s = new Set(document.querySelectorAll('p'));\n    s.forEach(function (elem) {\n        elem.style.color = 'red';\n    });\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.6 什么是 Map？\n\nMap 可以理解为：“映射”。\n\nMap 和 对象 都是键值对的集合。\n\n// 键 ——> 值，key ——> value\n// 对象：\nconst person = {\n    name: 'alex',\n    age: 18\n};\n\n// Map：\nconst m = new Map();\nm.set('name', 'alex');\nm.set('age', 18);\nconsole.log(m);\t\t// Map(2) { 'name' => 'alex', 'age' => 18 }\n\n// Map 和 对象 的区别：\n// 对象一般用字符串当作 “键”（当然在书写时字符串键的引号可以去掉）.\n// Map 中的 “键” 可以是一切类型。\nconst m = new Map();\nm.set(true, 'true');\nm.set({}, 'object');\nm.set(new Set([1, 2]), 'set');\nm.set(undefined, 'undefined');\nconsole.log(m);\n/*\nMap(4) {\n  true => 'true',\n  {} => 'object',\n  Set(2) { 1, 2 } => 'set',\n  undefined => 'undefined'\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.7 Map 实例的方法和属性\n\n# 4.7.1 set 方法\n\nconst m = new Map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m);\t\t// Map(2) { 'age' => 22, true => 'true' }\n\n\n1\n2\n3\n\n\n# 4.7.2 get 方法\n\nconst m = new Map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m.get('age'));\t\t// 22\nconsole.log(m.get(true));\t\t// true\n\n\n1\n2\n3\n4\n\n\n# 4.7.3 has 方法\n\nconst m = new Map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m.has('age'));\t\t\t// true\nconsole.log(m.has('true'));\t\t\t// false\n\n\n1\n2\n3\n4\n\n\n# 4.7.4 delete 方法\n\nm.delete('age');\n// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错\nm.delete('name');\n\n\n1\n2\n3\n\n\n# 4.7.5 clear 方法\n\nm.clear();\n\n\n1\n\n\n# 4.7.6 forEach 方法\n\nm.forEach(function (value, key, map) {\n    console.log(this);\n}, document);\n\n\n1\n2\n3\n\n\n# 4.7.7 size 属性\n\n// 对象没有类似的属性\nconsole.log(m.size);\n\n\n1\n2\n\n\n\n# 4.8 Map 构造函数的参数\n\n * 二维数组\n * Set、Map 等\n\n【二维数组】\n\nconsole.log(new Map([\n    ['name', 'alex'],\n    ['age', 18]\n]));\n// Map(2) { 'name' => 'alex', 'age' => 18 }\n\n\n1\n2\n3\n4\n5\n\n\n【Set、Map】\n\n// Set\n// Set 中也必须体现出键和值\nconst s = new Set([\n    ['name', 'alex'],\n    ['age', 18]\n]);\nconsole.log(new Map(s));\nconsole.log(s);\n// Map(2) { 'name' => 'alex', 'age' => 18 }\n// Set(2) { [ 'name', 'alex' ], [ 'age', 18 ] }\n\n// Map\nconst m = new Map([\n    ['name', 'alex'],\n    ['age', 18]\n]);\nconsole.log(m);\nconst m2 = new Map(m);\nconsole.log(m2, m2 === m);\n// Map(2) { 'name' => 'alex', 'age' => 18 }\n// Map(2) { 'name' => 'alex', 'age' => 18 } false\n// Map 复制的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 4.9 Map 注意事项\n\n【Map 如何判断键名是否相同】\n\n> 在 Set 中遇到重复的值直接去掉后者，而 Map 中遇到重复的键值则是后面的覆盖前面的。\n\n * 基本遵循严格相等（===）\n * Map 中 NaN 也是等于 NaN\n\n【什么时候使用 Map】\n\n * 如果只是需要键值对结构\n * 需要字符串以外的值做键\n * 对象一般用在模拟实体上\n\n\n# 4.10 Map 的应用\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    const [p1, p2, p3] = document.querySelectorAll('p');\n    const m = new Map([\n        [p1, {\n            color: 'red',\n            backgroundColor: 'yellow',\n            fontSize: '40px'\n        }],\n        [p2, {\n            color: 'green',\n            backgroundColor: 'pink',\n            fontSize: '40px'\n        }],\n        [p3, {\n            color: 'blue',\n            backgroundColor: 'orange',\n            fontSize: '40px'\n        }]\n    ]);\n    m.forEach((propObj, elem) => {\n        for (const p in propObj) {\n            elem.style[p] = propObj[p];\n        }\n    });\t// 由于不需要改变 this 指向，所以可以使用箭头函数\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n\n# 五、Iterator 遍历器与 for...of 循环\n\n\n# 5.1 什么是 Iterator？\n\n（1）Iterator 的作用\n\nIterator：遍历器（迭代器）\n\n> 其实是一个底层的迭代机制，主要了解即可。\n\n（2）使用 Iterator\n\nconst it = [1, 2][Symbol.iterator](); // 数组天生就有 Symbol.iterator 方法\nconsole.log(it.next()); // { value: 1, done: false }\nconsole.log(it.next()); // { value: 2, done: false }\nconsole.log(it.next()); // { value: undefined, done: true }\n// it：可遍历对象（可迭代对象）\n// Symbol.iterator：可遍历对象的生成方法\n// value：值，done：是否遍历完成\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（3）什么是 Iterator？\n\nSymbol.iterator（可遍历对象的生成方法）——> it（可遍历对象）——> it.next() ——> it.next() ——> ... （直到 done 为 true）\n\n\n# 5.2 Iterator 解惑\n\n（1）为什么需要 Iterator 遍历器？\n\n遍历数组：for 循环和 forEach 方法\n\n遍历对象：for in 循环\n\nIterator 遍历器是一个统一的遍历方式！\n\n（2）如何更方便的使用 Iterator\n\n之前：Symbol.iterator ——> it ——> next()\n\n优化：把上面的步骤进行封装（已经封装好了：for...of 循环）\n\n\n# 5.3 for...of 的用法\n\n原理：\n\nconst arr = [1, 2, 3];\nconst it = arr[Symbol.iterator]();\nlet next = it.next();\nwhile (!next.done) {\n    ...\n    next = it.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfor...of：\n\nconst arr = [1, 2, 3];\nfor (const item of arr) {\n    ...\n}\n\n\n1\n2\n3\n4\n\n\n> for...of 循环只会遍历出那些 done 为 false 时，对应的 value 值。\n\n【与 break、continue 一起使用】\n\nconst arr = [1, 2, 3];\nfor (const item of arr) {\n    if (item === 2) {\n        // break;\n    \tcontinue;\n    }\n    console.log(item);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【在 for...of 中获取数组的索引】\n\nconst arr = [1, 2, 3];\nconsole.log(arr.keys());\nfor (const key of arr.keys()) {\n    console.log(key);\n}\n// keys() 得到的是索引的可遍历对象，可以遍历出索引值\n/*\nObject [Array Iterator] {}\n0\n1\n2\n*/\n\n\nfor (const value of arr.values()) {\n    console.log(value);\n}\n// values() 得到的是值的可遍历对象，可以遍历出值\n/*\n1\n2\n3\n*/\n\n\nfor (const entries of arr.entries()) {\n    console.log(entrie);\n}\n/*\n[ 0, 1 ]\n[ 1, 2 ]\n[ 2, 3 ]\n*/\n\n// 结合解构赋值\nfor (const [index, value] of arr.entries()) {\n    console.log(index, value);\n}\n/*\n0 1\n1 2\n2 3\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.4 原生可遍历与非原生可遍历\n\n# 5.4.1 什么是可遍历\n\n只要有 Symbol.iterator 方法，并且这个方法可以生成可遍历对象，就是可遍历的。\n\n只要可遍历，就可以使用 for...of 循环来统一遍历。\n\n# 5.4.2 原生可遍历的有哪些？\n\n * 数组\n * 字符串\n * Set\n * Map\n * arguments\n * NodeList\n\n# 5.4.3 非原生可遍历的有哪些？\n\n * 对象\n\n（手动添加一个 Symbol.iterator 方法，或者是将数组的 Symbol.iterator 方法赋给对象）\n\n# 5.4.4 使用了 Iterator 的其他场合\n\n * 数组的展开运算符\n * 数组的解构赋值\n * Set 和 Map 的构造函数\n\n\n# 六、ES6 新增方法\n\n\n# 6.1 字符串新增方法\n\n# 6.1.1 includes()\n\n判断字符串中是否含有某些字符。\n\n// 基本用法\nconsole.log('abc'.includes('a'));\t\t// true\nconsole.log('abc'.includes('ab'));\t\t// true\nconsole.log('abc'.includes('bc'));\t\t// true\nconsole.log('abc'.includes('ac'));\t\t// false\n\n\n// 接受第二个参数\n// 表示开始搜索的位置，默认是 0\nconsole.log('abc'.includes('a'));\t\t// true\nconsole.log('abc'.includes('a', 0));\t// true\nconsole.log('abc'.includes('a', 1));\t// false\n\n\n// 应用（改变路径）\n// https://www.imooc.com/course/list\n// https://www.imooc.com/course/list?c=fe&sort=pop&name=value\nlet url = 'https://www.imooc.com/course/list';\nconst addURLParam = (url, name, value) => {\n    url += url.includes('?') ? '' : '?';\n\n    url += `${name}=${value}`;\n\n    return url;\n};\nurl = addURLParam(url, 'c', 'fe');\nconsole.log(url);\t// https://www.imooc.com/course/list?c=fe\nurl = addURLParam(url, 'sort', 'pop');\nconsole.log(url);\t// https://www.imooc.com/course/list?c=fesort=pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 6.1.2 padStart() 和 padEnd()\n\n根据所需长度补全字符串。\n\n// 基本用法\nconsole.log('x'.padStart(5, 'ab'));\t\t// ababx\nconsole.log('x'.padEnd(5, 'ab'));\t\t// xabab\nconsole.log('x'.padEnd(4, 'ab'));\t\t// xaba\n\n// 注意事项\n// 原字符串的长度，等于或大于最大长度，不会消减原字符串，字符串补全不生效，返回原字符串\nconsole.log('xxx'.padStart(2, 'ab'));\t// xxx\nconsole.log('xxx'.padEnd(2, 'ab'));\t\t// xxx\n\n// 如果省略第二个参数，默认使用空格补全长度\nconsole.log('x'.padStart(4));\t\t\t//    x\nconsole.log('x'.padEnd(4));\t\t\t\t// x\n\n// 应用（显示日期格式）\n// 2020-10-10\n// 2020-01-01\nconsole.log('10'.padStart(2, 0));\t\t// 10\nconsole.log('1'.padStart(2, 0));\t\t// 01\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 6.1.3 trimStart() 和 trimEnd()\n\n清除字符串的首或尾空格，中间的空格不会清除。\n\n// 基本用法\nconst s = '  a b c  ';\nconsole.log(s);\t\t\t\t\t\t//   a b c\nconsole.log(s.trimStart());\t\t\t// a b c  \nconsole.log(s.trimLeft());\t\t\t// a b c \nconsole.log(s.trimEnd());\t\t\t//   a b c\nconsole.log(s.trimRight());\t\t\t//   a b c\n// 两头同时去除空格\nconsole.log(s.trim());\t\t\t\t// a b c\n\n// 应用（表单提交检查首尾是否有空格）\nconst usernameInput = document.getElementById('username');\nconst btn = document.getElementById('btn');\n\nbtn.addEventListener(\n    'click',\n    () => {\n        console.log(usernameInput.value);\n\n        // 验证首尾是否有空格\n        console.log(usernameInput.value.trim());\n        if (usernameInput.value.trim() !== '') {\n            // 可以提交\n            console.log('可以提交');\n        } else {\n            // 不能提交\n            console.log('不能提交');\n        }\n    },\n    false\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 6.2 数组新增方法\n\n# 6.2.1 includes()\n\n// 基本用法\n// 判断数组中是否含有某个成员\nconsole.log([1, 2, 3].includes('2'));\t // false\nconsole.log([1, 2, 3].includes(2));\t\t // true\n\n// 第二个参数表示搜索的起始位置，默认值是 0\nconsole.log([1, 2, 3].includes(2, 2));\t // false\n\n// 基本遵循严格相等（===），但是对于 NaN 的判断与 === 不同，includes 认为 NaN === NaN\nconsole.log(NaN === NaN);\t\t\t\t\t// false\nconsole.log([1, 2, NaN].includes(NaN));\t\t// true\n\n// 应用\n// 去重\n// [1, 2, 1];\nconst arr = [];\nfor (const item of [1, 2, 1]) {\n    if (!arr.includes(item)) {\n        arr.push(item);\n    }\n}\nconsole.log(arr);\t// [ 1, 2 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 6.2.2 Array.from()\n\n将其他数据类型转换成数组。\n\n// 基本用法\nconsole.log(Array.from('str'));\t\t// [ 's', 't', 'r' ]\n\n// 哪些可以通过 Array.from() 转换成数组？\n// 1、所有可遍历的：数组、字符串、Set、Map、NodeList、arguments\nconsole.log(Array.from(new Set([1, 2, 1])));\t// [ 1, 2 ]\nconsole.log([...new Set([1, 2, 1])]);\t\t\t// [ 1, 2 ]\n// 2、拥有 length 属性的任意对象\nconst obj = {\n    '0': 'a',\n    '1': 'b',\n    name: 'Alex',\n    length: 3\n};\n// 只会把数字键的转为数组元素\nconsole.log(Array.from(obj));\t// [ 'a', 'b', undefined ]\nconsole.log([...obj]);\t\t\t// 报错！\n\n// 第二个参数\n// 作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组\nconsole.log(\n    [1, 2].map(value => {\n    \treturn value * 2;\n    })\n);\t// [ 2, 4 ]\n\nconsole.log(Array.from('12', value => value * 2));\t\t\t// [ 2, 4 ]\nconsole.log(Array.from('12').map(value => value * 2));\t\t// [ 2, 4 ]\n\n// 第三个参数（修改 this 指向）\nArray.from(\n    '12',\n    function () {\n        console.log(this);\n    },\n    document\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n# 6.2.3 find() 和 findIndex()\n\nfind()：找到满足条件的一个立即返回 findIndex()：找到满足条件的一个，立即返回其索引\n\n// 基本用法\nconsole.log([1, 5, 10, 15].find((value, index, arr) => {\n        return value > 9;\n    })\n);\n// 10\nconsole.log([1, 5, 10, 15].findIndex((value, index, arr) => {\n        return value > 9;\n    })\n);\n// 2\n\n// 第二个参数指定 this\n[1, 5, 10, 15].find(function (value, index, arr) {\n    console.log(this);\n    return value > 9;\n}, document);\n\n// 应用\nconst students = [\n    {\n        name: '张三',\n        sex: '男',\n        age: 16\n    },\n    {\n        name: '李四',\n        sex: '女',\n        age: 22\n    },\n    {\n        name: '王二麻子',\n        sex: '男',\n        age: 32\n    }\n];\nconsole.log(students.find(value => value.sex === '女'));\n// { name: '李四', sex: '女', age: 22 }\nconsole.log(students.findIndex(value => value.sex === '女'));\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 6.3 对象新增方法\n\n# 6.3.1 Object.assign()\n\n用来合并对象。\n\n// 基本用法\n// Object.assign(目标对象, 源对象1, 源对象2, ...);\nconst apple = {\n    color: '红色',\n    shape: '圆形',\n    taste: '甜'\n};\nconst pen = {\n    color: '黑色',\n    shape: '圆柱形',\n    use: '写字'\n};\nconsole.log(Object.assign(apple, pen));\t\n// 后面的覆盖前面的（最终返回的不是新的，而是修改了前面的）\n// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\n// Object.assign 直接合并到了第一个参数中，返回的就是合并后的对象\nconsole.log(apple);\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log(Object.assign(apple, pen) === apple);\t// true\n\n\n// 可以合并多个对象\n// 第一个参数使用一个空对象来实现合并返回一个新对象的目的\nconsole.log(Object.assign({}, apple, pen));\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log(apple);\t// { color: '红色', shape: '圆形', taste: '甜' }\nconsole.log({...apple, ...pen}); // { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\n\n\n// 注意事项\n// (1) 基本数据类型作为源对象\n// 与对象的展开类似，先转换成对象，再合并\nconsole.log(Object.assign({}, undefined));\t// {}\nconsole.log(Object.assign({}, null));\t\t// {}\nconsole.log(Object.assign({}, 1));\t\t\t// {}\nconsole.log(Object.assign({}, true));\t\t// {}\nconsole.log(Object.assign({}, 'str'));\t\t// { '0': 's', '1': 't', '2': 'r' }\n// (2) 同名属性的替换\n// 后面的直接覆盖前面的\nconst apple = {\n    color: ['红色', '黄色'],\n    shape: '圆形',\n    taste: '甜'\n};\nconst pen = {\n    color: ['黑色', '银色'],\n    shape: '圆柱形',\n    use: '写字'\n};\nconsole.log(Object.assign({}, apple, pen));\t// { color: [ '黑色', '银色' ], shape: '圆柱形', taste: '甜', use: '写字' }\n\n\n// 应用\n// 合并默认参数和用户参数\nconst logUser = userOptions => {\n    const DEFAULTS = {\n        username: 'ZhangSan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const options = Object.assign({}, DEFAULTS, userOptions);\n    console.log(options);\n};\nlogUser();\t\t\t\t\t\t// { username: 'ZhangSan', age: 0, sex: 'male' }\nlogUser({});\t\t\t\t\t// { username: 'ZhangSan', age: 0, sex: 'male' }\nlogUser({username: 'Alex'});\t// { username: 'Alex', age: 0, sex: 'male' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 6.3.2 Object.keys()、Object.values() 和 Object.entries()\n\n// 基本用法\nconst person = {\n    name: 'Alex',\n    age: 18\n};\n// 返回键数组\nconsole.log(Object.keys(person));\t\t// [ 'name', 'age' ]\n// 返回值数组\nconsole.log(Object.values(person));\t\t// [ 'Alex', 18 ]\n// 返回键值二维数组\nconsole.log(Object.entries(person));\t// [ [ 'name', 'Alex' ], [ 'age', 18 ] ]\n\n\n// 与数组类似方法的区别\nconsole.log([1, 2].keys());\t\t\t// Object [Array Iterator] {}\nconsole.log([1, 2].values());\t\t// Object [Array Iterator] {}\nconsole.log([1, 2].entries());\t\t// Object [Array Iterator] {}\n// 数组的 keys()、values()、entries() 等方法是实例方法，返回的都是 Iterator\n// 对象的 Object.keys()、Object.values()、Object.entries() 等方法是构造函数方法，返回的是数组\n\n\n// 应用（使用 for...of 循环遍历对象）\nconst person = {\n    name: 'Alex',\n    age: 18\n};\nfor (const key of Object.keys(person)) {\n    console.log(key);\t\t\n}\n// name\n// age\nfor (const value of Object.values(person)) {\n    console.log(value);\t\t\n}\n// Alex\n// 18\nfor (const entries of Object.entries(person)) {\n    console.log(entries);\t\n}\n// [ 'name', 'Alex' ]\n// [ 'age', 18 ]\nfor (const [key, value] of Object.entries(person)) {\n    console.log(key, value);\n}\n// name Alex\n// age 18\n\n// Object.keys()/values()/entires() 并不能保证顺序一定是你看到的样子，这一点和 for in 是一样的\n// 如果对遍历顺序有要求那么不能用 for in 以及这种方法，而要用其他方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",normalizedContent:"# 一、剩余参数\n\n\n# 1.2 认识剩余参数\n\nconst add = (x, y, z, ...args) => {};\n\n\n# 1.3 剩余参数的本质\n\n剩余参数永远是个数组，即使没有值，也是个空数组。\n\nconst add = (x, y, ...args) => {\n    console.log(x, y, args);\n};\nadd();\t\t\t\t\t// undefined undefined []\nadd(1);\t\t\t\t\t// 1 undefined []\nadd(1, 2);\t\t\t\t// 1 2 []\nadd(1, 2, 3, 4, 5);\t\t// 1 2 [ 3, 4, 5 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.4 注意事项\n\n# 1.4.1 箭头函数的剩余参数\n\n箭头函数的参数部分即使只有一个剩余参数，也不能省略圆括号。\n\nconst add = (...args) => {};\n\n# 1.4.2 使用剩余参数替代 arguments 获取实际参数\n\n * 剩余参数是一个 “真数组”，arguments 是一个 “类数组”\n * 剩余参数的名字可以自定义\n\n# 1.4.3 剩余参数的位置\n\n剩余参数只能是最后一个参数，之后不能再有其他参数，否则会报错。\n\n\n# 1.5 剩余参数的应用\n\n作为数组的应用：\n\nconst add = (...args) => {\n    let sum = 0;\n\n    for (let i = 0; i < args.length; i++) {\n        sum += args[i];\n    } // 当然此处，arguments 也可以\n\n    return sum;\n};\n\nconsole.log(add());\t\t\t// 0\nconsole.log(add(1, 1));\t\t// 2\nconsole.log(add(1, 2, 3));\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n与解构赋值结合使用：\n\n（剩余参数不一定非要作为函数参数使用）\n\n * 与数组解构赋值结合\n\nconst func = ([num, ...args]) => {};\nfunc([1, 2, 3]);\n\n\n1\n2\n\n * 与对象解构赋值结合\n\nconst {x, y, ...z} = {a: 3, x: 1, y: 2, b: 4};\nconsole.log(x, y, z);\n// 1 2 { a: 3, b: 4 }\n// 这里的剩余参数是个对象（准确的应该叫：剩余元素）\n\n\n1\n2\n3\n4\n\n\nconst func = ({x, y, ...z}) => {\n    console.log(x, y, z);\t// 1 2 { a: 3, b: 4 }\n};\nfunc({a: 3, x: 1, y: 2, b: 4});\n\n\n1\n2\n3\n4\n\n\n\n# 二、数组展开运算符\n\n\n# 2.1 认识数组展开运算符\n\n剩余参数：参数列表 ——> 参数数组\n\n数组展开运算符：参数数组 ——> 参数列表\n\n案例：\n\n> 如果我们需要求 [3, 1, 2] 中的最大值，那么我们是不能直接通过 math.max() 来求的，因为 math.max() 接受的不能是数组，而是一个一个的参数，比如：math.max(3, 1, 2)，所以把参数数组转化为参数列表才是关键。\n\n\n# 2.2 数组展开运算符的基本用法\n\n用法与剩余参数类似\n\nconsole.log(math.min(...[3, 1, 2]));\n\n相当于\n\nconsole.log(math.min(3, 1, 2));\n\n\n# 2.3 区分剩余参数和展开运算符\n\nconst add = (...args) => {\n    console.log(args);\t\t// [ 1, 2, 3 ]\n    console.log(...args);\t// 1 2 3\n};\nadd(1, 2, 3);\n\n\n1\n2\n3\n4\n5\n\n\nconsole.log([...[1, 2, 3], 4]);\t// [ 1, 2, 3, 4 ]\n\n\n1\n\n\n\n# 2.4 数组展开运算符的应用\n\n# 2.4.1 复制数组\n\nconst a = [1, 2, 3];\nconst b = [...a];\na[1] = 5;\nconsole.log(a);\t\t// [ 1, 5, 3 ]\nconsole.log(b);\t\t// [ 1, 2, 3 ]\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.2 合并数组\n\nconst a = [1, 2];\nconst b = [3];\nconst c = [4, 5];\nconsole.log([0, ...a, 99, ...c, ...b]);\n// [0, 1, 2, 99, 4, 5, 3]\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.3 字符串转为数组\n\n字符串可以按照数组的形式展开。\n\nconsole.log(...'alex');\t\t\t\t// a l e x\nconsole.log('a', 'l', 'e', 'x');\t// a l e x\n\nconsole.log([...'alex']);\t\t\t// [ 'a', 'l', 'e', 'x' ]\n// es6 之前字符串转数组是通过：'alex'.split('');\n\n\n1\n2\n3\n4\n5\n\n\n# 2.4.4 类数组转为数组\n\n// arguments\nfunction func() {\n    console.log(arguments);\t\t\t// [arguments] { '0': 1, '1': 2 }\n    console.log([...arguments]);\t// [ 1, 2 ]\n}\nfunc(1, 2);\n\n// nodelist\nconsole.log([...document.queryselectorall('p')].push);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、对象展开运算符\n\n\n# 3.1 展开对象\n\n对象不能直接展开，必须在 {} 中展开。\n\nconst apple = {\n    color: '红色',\n    shape: '球形',\n    taste: '甜'\n};\nconsole.log({...apple});\t\t\t// { color: '红色', shape: '球形', taste: '甜' }\nconsole.log({...apple} === apple);\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.2 合并对象\n\nconst apple = {\n    color: '红色',\n    shape: '球形',\n    taste: '甜'\n};\n\nconst pen = {\n    color: '黑色',\n    shape: '圆柱形',\n    use: '写字'\n};\n\n// 新对象拥有全部属性，相同属性，后者覆盖前者\nconsole.log({...apple, ...pen});\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log({...pen, ...apple});\t// { color: '红色', shape: '球形', use: '写字', taste: '甜' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 3.3 注意事项\n\n# 3.3.1 空对象的展开\n\n如果展开一个空对象，则没有任何效果。\n\nconsole.log({...{}});\t\t\t// {}\nconsole.log({...{}, a: 1});\t\t// { a: 1 }\n\n\n1\n2\n\n\n# 3.3.2 非对象的展开\n\n如果展开的不是对象，则会自动将其转为对象，再将其属性罗列出来（没有属性便为空）。\n\nconsole.log({...1});\t\t\t// {}\nconsole.log(new object(1));\t\t// [number: 1]\nconsole.log({...undefined});\t// {}\nconsole.log({...null});\t\t\t// {}\nconsole.log({...true});\t\t\t// {}\n\n\n1\n2\n3\n4\n5\n\n\n# 3.3.3 字符串的展开\n\n如果展开运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象。\n\n// 字符串在对象中展开\nconsole.log({...'alex'});\t\t// { '0': 'a', '1': 'l', '2': 'e', '3': 'x' }\n\n// 字符串在数组中展开\nconsole.log([...'alex']);\t\t// [ 'a', 'l', 'e', 'x' ]\n\n// 字符串直接展开\nconsole.log(...'alex');\t\t\t// a l e x\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.3.4 数组的展开\n\nconsole.log({...[1, 2, 3]});\t// { '0': 1, '1': 2, '2': 3 }\n\n\n1\n\n\n# 3.3.5 对象中对象属性的展开\n\n不会展开对象中的对象属性。\n\nconst apple = {\n    feature: {\n        taste: '甜'\n    }\n};\n\nconst pen = {\n    feature: {\n        color: '黑色',\n        shape: '圆柱形'\n    },\n    use: '写字'\n};\n\nconsole.log({...apple});\t\t\t// { feature: { taste: '甜' } }\n\n// feature 会直接覆盖，因为 feature 不能展开\nconsole.log({...apple, ...pen});\t// { feature: { color: '黑色', shape: '圆柱形' }, use: '写字' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.4 对象展开运算符的应用\n\n# 3.4.1 复制对象\n\nconst a = {x: 1, y: 2};\nconst c = {...a};\nconsole.log(c, c === a);\n// { x: 1, y: 2 } false\n\n\n1\n2\n3\n4\n\n\n# 3.4.2 用户参数和默认参数\n\nconst loguser = userparam => {\n    const defaultperam = {\n        username: 'zhangsan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const param = {...defaultperam, ...userparam};\n    console.log(param.username, param.age, param.sex);\n};\n\nloguser({username: 'jerry'});\t// jerry 0 male\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n再优化：\n\nconst loguser = userparam => {\n    const defaultperam = {\n        username: 'zhangsan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const {username, age, sex} = {...defaultperam, ...userparam};\n    console.log(username, age, sex);\n};\n\nloguser({username: 'jerry'});\t// jerry 0 male\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 四、set 和 map\n\n\n# 4.1 什么是 set？\n\nset 是一系列无序、没有重复值的数据集合。\n\n> 数组是一系列有序（下标索引）的数据集合。\n\nconst s = new set();\ns.add(1);\ns.add(2);\n\n// set 中不能有重复的成员\ns.add(1);\nconsole.log(s);\t\t// set(2) { 1, 2 }\n\n// set 没有下标去标识每一个值，所以 set 是无序的，也不能像数组那样通过下标去访问 set 的成员。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 4.2 set 实例的方法和属性\n\n# 4.2.1 add 方法\n\nconst s = new set();\ns.add(0);\n// 可以连写\ns.add(1).add(2).add(2).add(3);\nconsole.log(s);\t\t// set(4) { 0, 1, 2, 3 }\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.2 has 方法\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\nconsole.log(s.has(1));\t// true\nconsole.log(s.has(4));\t// false\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.3 delete 方法\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\ns.delete(2);\n// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错\ns.delete(4);\nconsole.log(s);\t// set(3) { 0, 1, 3 }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.2.4 clear 方法\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\ns.clear();\nconsole.log(s);\t// set(0) {}\n\n\n1\n2\n3\n4\n5\n\n\n# 4.2.5 foreach 方法\n\n作用：用于遍历 set 的（按照成员添加进集合的顺序遍历）。\n\nforeach 方法可以接受两个参数，第一个是：回调函数，第二个是：指定回调函数的 this 指向。\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\ns.foreach(function (value, key, set) {\n    // set 中 value = key，原因：好多数据结构都有 foreach 方法，为了方便统一，所以参数是统一的，但是参数的意义各有不同\n    // set 就是 s 本身\n    console.log(value, key, set === s);\n    console.log(this);\n});\n\n/*\n0 0 true\nwindow\n1 1 true\nwindow\n2 2 true\nwindow\n3 3 true\nwindow \n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\ns.foreach(function (value, key, set) {\n    // set 中 value = key，原因：好多数据结构都有 foreach 方法，为了方便统一，所以参数是统一的，但是参数的意义各有不同\n    // set 就是 s 本身\n    console.log(value, key, set === s);\n    console.log(this);\n}, document);\n\n/*\n0 0 true\n#document\n1 1 true\n#document\n2 2 true\n#document\n3 3 true\n#document\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 4.2.6 size 属性\n\nconst s = new set();\ns.add(0);\ns.add(1).add(2).add(2).add(3);\n\nconsole.log(s.size);\t// 4\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.3 set 构造函数的参数\n\n * 数组\n * 字符串、arguments、nodelist、set 等\n\n【数组】\n\nconst s = new set([1, 2, 1]);\nconsole.log(s);\t\t// set(2) { 1, 2 }\n\n\n1\n2\n\n\n【字符串】\n\nconsole.log(new set('hiii'));\t// set(2) { 'h', 'i' }\n\n\n1\n\n\n【arguments】\n\nfunction func() {\n    console.log(new set(arguments));\n}\nfunc(1, 2, 1);\t// set(2) { 1, 2 }\n\n\n1\n2\n3\n4\n\n\n【nodelist】\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    console.log(new set(document.queryselectorall('p')));\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n【set】\n\nconst s = new set([1, 2, 1]);\nconsole.log(new set(s));\t// set(2) { 1, 2 }\nconsole.log(s);\t\t\t\t// set(2) { 1, 2 }\n// 这也是复制一个 set 的方法\n\n\n1\n2\n3\n4\n\n\n\n# 4.4 set 注意事项\n\n【set 如何判断重复】\n\n * set 对重复值的判断基本遵循严格相等（===）\n\n * 但是对于 nan 的判断与 === 不同，set 中 nan 等于 nan\n\nconst s = new set();\ns.add({}).add({});\nconsole.log({} === {});\t // false\nconsole.log(s);\t\t\t // set(2) { {}, {} }\n\n\n1\n2\n3\n4\n\n\n【什么时候使用 set】\n\n * 数组或字符串需要去重时\n * 不需要通过下标访问，只需要遍历时\n * 为了使用 set 提供的方法和属性时\n\n\n# 4.5 set 的应用\n\n【数组去重】\n\nconst s = new set([1, 2, 1]);\nconsole.log(s);\t\t\t// set(2) { 1, 2 }\nconsole.log([...s]);\t// [ 1, 2 ]\n\n\n1\n2\n3\n\n\n【字符串去重】\n\nconst s = new set('abbacbd');\nconsole.log(s);\t\t\t\t\t// set(4) { 'a', 'b', 'c', 'd' }\nconsole.log([...s].join(''));\t// abcd\n\n\n1\n2\n3\n\n\n【存放 dom 元素】\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    // 这里使用 set 是因为我们不需要通过下标去访问，只需直接遍历即可\n    const s = new set(document.queryselectorall('p'));\n    s.foreach(function (elem) {\n        elem.style.color = 'red';\n    });\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.6 什么是 map？\n\nmap 可以理解为：“映射”。\n\nmap 和 对象 都是键值对的集合。\n\n// 键 ——> 值，key ——> value\n// 对象：\nconst person = {\n    name: 'alex',\n    age: 18\n};\n\n// map：\nconst m = new map();\nm.set('name', 'alex');\nm.set('age', 18);\nconsole.log(m);\t\t// map(2) { 'name' => 'alex', 'age' => 18 }\n\n// map 和 对象 的区别：\n// 对象一般用字符串当作 “键”（当然在书写时字符串键的引号可以去掉）.\n// map 中的 “键” 可以是一切类型。\nconst m = new map();\nm.set(true, 'true');\nm.set({}, 'object');\nm.set(new set([1, 2]), 'set');\nm.set(undefined, 'undefined');\nconsole.log(m);\n/*\nmap(4) {\n  true => 'true',\n  {} => 'object',\n  set(2) { 1, 2 } => 'set',\n  undefined => 'undefined'\n}\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 4.7 map 实例的方法和属性\n\n# 4.7.1 set 方法\n\nconst m = new map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m);\t\t// map(2) { 'age' => 22, true => 'true' }\n\n\n1\n2\n3\n\n\n# 4.7.2 get 方法\n\nconst m = new map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m.get('age'));\t\t// 22\nconsole.log(m.get(true));\t\t// true\n\n\n1\n2\n3\n4\n\n\n# 4.7.3 has 方法\n\nconst m = new map();\nm.set('age', 18).set(true, 'true').set('age', 22);\nconsole.log(m.has('age'));\t\t\t// true\nconsole.log(m.has('true'));\t\t\t// false\n\n\n1\n2\n3\n4\n\n\n# 4.7.4 delete 方法\n\nm.delete('age');\n// 使用 delete 删除不存在的成员，什么都不会发生，也不会报错\nm.delete('name');\n\n\n1\n2\n3\n\n\n# 4.7.5 clear 方法\n\nm.clear();\n\n\n1\n\n\n# 4.7.6 foreach 方法\n\nm.foreach(function (value, key, map) {\n    console.log(this);\n}, document);\n\n\n1\n2\n3\n\n\n# 4.7.7 size 属性\n\n// 对象没有类似的属性\nconsole.log(m.size);\n\n\n1\n2\n\n\n\n# 4.8 map 构造函数的参数\n\n * 二维数组\n * set、map 等\n\n【二维数组】\n\nconsole.log(new map([\n    ['name', 'alex'],\n    ['age', 18]\n]));\n// map(2) { 'name' => 'alex', 'age' => 18 }\n\n\n1\n2\n3\n4\n5\n\n\n【set、map】\n\n// set\n// set 中也必须体现出键和值\nconst s = new set([\n    ['name', 'alex'],\n    ['age', 18]\n]);\nconsole.log(new map(s));\nconsole.log(s);\n// map(2) { 'name' => 'alex', 'age' => 18 }\n// set(2) { [ 'name', 'alex' ], [ 'age', 18 ] }\n\n// map\nconst m = new map([\n    ['name', 'alex'],\n    ['age', 18]\n]);\nconsole.log(m);\nconst m2 = new map(m);\nconsole.log(m2, m2 === m);\n// map(2) { 'name' => 'alex', 'age' => 18 }\n// map(2) { 'name' => 'alex', 'age' => 18 } false\n// map 复制的方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 4.9 map 注意事项\n\n【map 如何判断键名是否相同】\n\n> 在 set 中遇到重复的值直接去掉后者，而 map 中遇到重复的键值则是后面的覆盖前面的。\n\n * 基本遵循严格相等（===）\n * map 中 nan 也是等于 nan\n\n【什么时候使用 map】\n\n * 如果只是需要键值对结构\n * 需要字符串以外的值做键\n * 对象一般用在模拟实体上\n\n\n# 4.10 map 的应用\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    const [p1, p2, p3] = document.queryselectorall('p');\n    const m = new map([\n        [p1, {\n            color: 'red',\n            backgroundcolor: 'yellow',\n            fontsize: '40px'\n        }],\n        [p2, {\n            color: 'green',\n            backgroundcolor: 'pink',\n            fontsize: '40px'\n        }],\n        [p3, {\n            color: 'blue',\n            backgroundcolor: 'orange',\n            fontsize: '40px'\n        }]\n    ]);\n    m.foreach((propobj, elem) => {\n        for (const p in propobj) {\n            elem.style[p] = propobj[p];\n        }\n    });\t// 由于不需要改变 this 指向，所以可以使用箭头函数\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n\n\n# 五、iterator 遍历器与 for...of 循环\n\n\n# 5.1 什么是 iterator？\n\n（1）iterator 的作用\n\niterator：遍历器（迭代器）\n\n> 其实是一个底层的迭代机制，主要了解即可。\n\n（2）使用 iterator\n\nconst it = [1, 2][symbol.iterator](); // 数组天生就有 symbol.iterator 方法\nconsole.log(it.next()); // { value: 1, done: false }\nconsole.log(it.next()); // { value: 2, done: false }\nconsole.log(it.next()); // { value: undefined, done: true }\n// it：可遍历对象（可迭代对象）\n// symbol.iterator：可遍历对象的生成方法\n// value：值，done：是否遍历完成\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n（3）什么是 iterator？\n\nsymbol.iterator（可遍历对象的生成方法）——> it（可遍历对象）——> it.next() ——> it.next() ——> ... （直到 done 为 true）\n\n\n# 5.2 iterator 解惑\n\n（1）为什么需要 iterator 遍历器？\n\n遍历数组：for 循环和 foreach 方法\n\n遍历对象：for in 循环\n\niterator 遍历器是一个统一的遍历方式！\n\n（2）如何更方便的使用 iterator\n\n之前：symbol.iterator ——> it ——> next()\n\n优化：把上面的步骤进行封装（已经封装好了：for...of 循环）\n\n\n# 5.3 for...of 的用法\n\n原理：\n\nconst arr = [1, 2, 3];\nconst it = arr[symbol.iterator]();\nlet next = it.next();\nwhile (!next.done) {\n    ...\n    next = it.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nfor...of：\n\nconst arr = [1, 2, 3];\nfor (const item of arr) {\n    ...\n}\n\n\n1\n2\n3\n4\n\n\n> for...of 循环只会遍历出那些 done 为 false 时，对应的 value 值。\n\n【与 break、continue 一起使用】\n\nconst arr = [1, 2, 3];\nfor (const item of arr) {\n    if (item === 2) {\n        // break;\n    \tcontinue;\n    }\n    console.log(item);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n【在 for...of 中获取数组的索引】\n\nconst arr = [1, 2, 3];\nconsole.log(arr.keys());\nfor (const key of arr.keys()) {\n    console.log(key);\n}\n// keys() 得到的是索引的可遍历对象，可以遍历出索引值\n/*\nobject [array iterator] {}\n0\n1\n2\n*/\n\n\nfor (const value of arr.values()) {\n    console.log(value);\n}\n// values() 得到的是值的可遍历对象，可以遍历出值\n/*\n1\n2\n3\n*/\n\n\nfor (const entries of arr.entries()) {\n    console.log(entrie);\n}\n/*\n[ 0, 1 ]\n[ 1, 2 ]\n[ 2, 3 ]\n*/\n\n// 结合解构赋值\nfor (const [index, value] of arr.entries()) {\n    console.log(index, value);\n}\n/*\n0 1\n1 2\n2 3\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 5.4 原生可遍历与非原生可遍历\n\n# 5.4.1 什么是可遍历\n\n只要有 symbol.iterator 方法，并且这个方法可以生成可遍历对象，就是可遍历的。\n\n只要可遍历，就可以使用 for...of 循环来统一遍历。\n\n# 5.4.2 原生可遍历的有哪些？\n\n * 数组\n * 字符串\n * set\n * map\n * arguments\n * nodelist\n\n# 5.4.3 非原生可遍历的有哪些？\n\n * 对象\n\n（手动添加一个 symbol.iterator 方法，或者是将数组的 symbol.iterator 方法赋给对象）\n\n# 5.4.4 使用了 iterator 的其他场合\n\n * 数组的展开运算符\n * 数组的解构赋值\n * set 和 map 的构造函数\n\n\n# 六、es6 新增方法\n\n\n# 6.1 字符串新增方法\n\n# 6.1.1 includes()\n\n判断字符串中是否含有某些字符。\n\n// 基本用法\nconsole.log('abc'.includes('a'));\t\t// true\nconsole.log('abc'.includes('ab'));\t\t// true\nconsole.log('abc'.includes('bc'));\t\t// true\nconsole.log('abc'.includes('ac'));\t\t// false\n\n\n// 接受第二个参数\n// 表示开始搜索的位置，默认是 0\nconsole.log('abc'.includes('a'));\t\t// true\nconsole.log('abc'.includes('a', 0));\t// true\nconsole.log('abc'.includes('a', 1));\t// false\n\n\n// 应用（改变路径）\n// https://www.imooc.com/course/list\n// https://www.imooc.com/course/list?c=fe&sort=pop&name=value\nlet url = 'https://www.imooc.com/course/list';\nconst addurlparam = (url, name, value) => {\n    url += url.includes('?') ? '' : '?';\n\n    url += `${name}=${value}`;\n\n    return url;\n};\nurl = addurlparam(url, 'c', 'fe');\nconsole.log(url);\t// https://www.imooc.com/course/list?c=fe\nurl = addurlparam(url, 'sort', 'pop');\nconsole.log(url);\t// https://www.imooc.com/course/list?c=fesort=pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 6.1.2 padstart() 和 padend()\n\n根据所需长度补全字符串。\n\n// 基本用法\nconsole.log('x'.padstart(5, 'ab'));\t\t// ababx\nconsole.log('x'.padend(5, 'ab'));\t\t// xabab\nconsole.log('x'.padend(4, 'ab'));\t\t// xaba\n\n// 注意事项\n// 原字符串的长度，等于或大于最大长度，不会消减原字符串，字符串补全不生效，返回原字符串\nconsole.log('xxx'.padstart(2, 'ab'));\t// xxx\nconsole.log('xxx'.padend(2, 'ab'));\t\t// xxx\n\n// 如果省略第二个参数，默认使用空格补全长度\nconsole.log('x'.padstart(4));\t\t\t//    x\nconsole.log('x'.padend(4));\t\t\t\t// x\n\n// 应用（显示日期格式）\n// 2020-10-10\n// 2020-01-01\nconsole.log('10'.padstart(2, 0));\t\t// 10\nconsole.log('1'.padstart(2, 0));\t\t// 01\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 6.1.3 trimstart() 和 trimend()\n\n清除字符串的首或尾空格，中间的空格不会清除。\n\n// 基本用法\nconst s = '  a b c  ';\nconsole.log(s);\t\t\t\t\t\t//   a b c\nconsole.log(s.trimstart());\t\t\t// a b c  \nconsole.log(s.trimleft());\t\t\t// a b c \nconsole.log(s.trimend());\t\t\t//   a b c\nconsole.log(s.trimright());\t\t\t//   a b c\n// 两头同时去除空格\nconsole.log(s.trim());\t\t\t\t// a b c\n\n// 应用（表单提交检查首尾是否有空格）\nconst usernameinput = document.getelementbyid('username');\nconst btn = document.getelementbyid('btn');\n\nbtn.addeventlistener(\n    'click',\n    () => {\n        console.log(usernameinput.value);\n\n        // 验证首尾是否有空格\n        console.log(usernameinput.value.trim());\n        if (usernameinput.value.trim() !== '') {\n            // 可以提交\n            console.log('可以提交');\n        } else {\n            // 不能提交\n            console.log('不能提交');\n        }\n    },\n    false\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 6.2 数组新增方法\n\n# 6.2.1 includes()\n\n// 基本用法\n// 判断数组中是否含有某个成员\nconsole.log([1, 2, 3].includes('2'));\t // false\nconsole.log([1, 2, 3].includes(2));\t\t // true\n\n// 第二个参数表示搜索的起始位置，默认值是 0\nconsole.log([1, 2, 3].includes(2, 2));\t // false\n\n// 基本遵循严格相等（===），但是对于 nan 的判断与 === 不同，includes 认为 nan === nan\nconsole.log(nan === nan);\t\t\t\t\t// false\nconsole.log([1, 2, nan].includes(nan));\t\t// true\n\n// 应用\n// 去重\n// [1, 2, 1];\nconst arr = [];\nfor (const item of [1, 2, 1]) {\n    if (!arr.includes(item)) {\n        arr.push(item);\n    }\n}\nconsole.log(arr);\t// [ 1, 2 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 6.2.2 array.from()\n\n将其他数据类型转换成数组。\n\n// 基本用法\nconsole.log(array.from('str'));\t\t// [ 's', 't', 'r' ]\n\n// 哪些可以通过 array.from() 转换成数组？\n// 1、所有可遍历的：数组、字符串、set、map、nodelist、arguments\nconsole.log(array.from(new set([1, 2, 1])));\t// [ 1, 2 ]\nconsole.log([...new set([1, 2, 1])]);\t\t\t// [ 1, 2 ]\n// 2、拥有 length 属性的任意对象\nconst obj = {\n    '0': 'a',\n    '1': 'b',\n    name: 'alex',\n    length: 3\n};\n// 只会把数字键的转为数组元素\nconsole.log(array.from(obj));\t// [ 'a', 'b', undefined ]\nconsole.log([...obj]);\t\t\t// 报错！\n\n// 第二个参数\n// 作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组\nconsole.log(\n    [1, 2].map(value => {\n    \treturn value * 2;\n    })\n);\t// [ 2, 4 ]\n\nconsole.log(array.from('12', value => value * 2));\t\t\t// [ 2, 4 ]\nconsole.log(array.from('12').map(value => value * 2));\t\t// [ 2, 4 ]\n\n// 第三个参数（修改 this 指向）\narray.from(\n    '12',\n    function () {\n        console.log(this);\n    },\n    document\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n# 6.2.3 find() 和 findindex()\n\nfind()：找到满足条件的一个立即返回 findindex()：找到满足条件的一个，立即返回其索引\n\n// 基本用法\nconsole.log([1, 5, 10, 15].find((value, index, arr) => {\n        return value > 9;\n    })\n);\n// 10\nconsole.log([1, 5, 10, 15].findindex((value, index, arr) => {\n        return value > 9;\n    })\n);\n// 2\n\n// 第二个参数指定 this\n[1, 5, 10, 15].find(function (value, index, arr) {\n    console.log(this);\n    return value > 9;\n}, document);\n\n// 应用\nconst students = [\n    {\n        name: '张三',\n        sex: '男',\n        age: 16\n    },\n    {\n        name: '李四',\n        sex: '女',\n        age: 22\n    },\n    {\n        name: '王二麻子',\n        sex: '男',\n        age: 32\n    }\n];\nconsole.log(students.find(value => value.sex === '女'));\n// { name: '李四', sex: '女', age: 22 }\nconsole.log(students.findindex(value => value.sex === '女'));\n// 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 6.3 对象新增方法\n\n# 6.3.1 object.assign()\n\n用来合并对象。\n\n// 基本用法\n// object.assign(目标对象, 源对象1, 源对象2, ...);\nconst apple = {\n    color: '红色',\n    shape: '圆形',\n    taste: '甜'\n};\nconst pen = {\n    color: '黑色',\n    shape: '圆柱形',\n    use: '写字'\n};\nconsole.log(object.assign(apple, pen));\t\n// 后面的覆盖前面的（最终返回的不是新的，而是修改了前面的）\n// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\n// object.assign 直接合并到了第一个参数中，返回的就是合并后的对象\nconsole.log(apple);\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log(object.assign(apple, pen) === apple);\t// true\n\n\n// 可以合并多个对象\n// 第一个参数使用一个空对象来实现合并返回一个新对象的目的\nconsole.log(object.assign({}, apple, pen));\t// { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\nconsole.log(apple);\t// { color: '红色', shape: '圆形', taste: '甜' }\nconsole.log({...apple, ...pen}); // { color: '黑色', shape: '圆柱形', taste: '甜', use: '写字' }\n\n\n// 注意事项\n// (1) 基本数据类型作为源对象\n// 与对象的展开类似，先转换成对象，再合并\nconsole.log(object.assign({}, undefined));\t// {}\nconsole.log(object.assign({}, null));\t\t// {}\nconsole.log(object.assign({}, 1));\t\t\t// {}\nconsole.log(object.assign({}, true));\t\t// {}\nconsole.log(object.assign({}, 'str'));\t\t// { '0': 's', '1': 't', '2': 'r' }\n// (2) 同名属性的替换\n// 后面的直接覆盖前面的\nconst apple = {\n    color: ['红色', '黄色'],\n    shape: '圆形',\n    taste: '甜'\n};\nconst pen = {\n    color: ['黑色', '银色'],\n    shape: '圆柱形',\n    use: '写字'\n};\nconsole.log(object.assign({}, apple, pen));\t// { color: [ '黑色', '银色' ], shape: '圆柱形', taste: '甜', use: '写字' }\n\n\n// 应用\n// 合并默认参数和用户参数\nconst loguser = useroptions => {\n    const defaults = {\n        username: 'zhangsan',\n        age: 0,\n        sex: 'male'\n    };\n\n    const options = object.assign({}, defaults, useroptions);\n    console.log(options);\n};\nloguser();\t\t\t\t\t\t// { username: 'zhangsan', age: 0, sex: 'male' }\nloguser({});\t\t\t\t\t// { username: 'zhangsan', age: 0, sex: 'male' }\nloguser({username: 'alex'});\t// { username: 'alex', age: 0, sex: 'male' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 6.3.2 object.keys()、object.values() 和 object.entries()\n\n// 基本用法\nconst person = {\n    name: 'alex',\n    age: 18\n};\n// 返回键数组\nconsole.log(object.keys(person));\t\t// [ 'name', 'age' ]\n// 返回值数组\nconsole.log(object.values(person));\t\t// [ 'alex', 18 ]\n// 返回键值二维数组\nconsole.log(object.entries(person));\t// [ [ 'name', 'alex' ], [ 'age', 18 ] ]\n\n\n// 与数组类似方法的区别\nconsole.log([1, 2].keys());\t\t\t// object [array iterator] {}\nconsole.log([1, 2].values());\t\t// object [array iterator] {}\nconsole.log([1, 2].entries());\t\t// object [array iterator] {}\n// 数组的 keys()、values()、entries() 等方法是实例方法，返回的都是 iterator\n// 对象的 object.keys()、object.values()、object.entries() 等方法是构造函数方法，返回的是数组\n\n\n// 应用（使用 for...of 循环遍历对象）\nconst person = {\n    name: 'alex',\n    age: 18\n};\nfor (const key of object.keys(person)) {\n    console.log(key);\t\t\n}\n// name\n// age\nfor (const value of object.values(person)) {\n    console.log(value);\t\t\n}\n// alex\n// 18\nfor (const entries of object.entries(person)) {\n    console.log(entries);\t\n}\n// [ 'name', 'alex' ]\n// [ 'age', 18 ]\nfor (const [key, value] of object.entries(person)) {\n    console.log(key, value);\n}\n// name alex\n// age 18\n\n// object.keys()/values()/entires() 并不能保证顺序一定是你看到的样子，这一点和 for in 是一样的\n// 如果对遍历顺序有要求那么不能用 for in 以及这种方法，而要用其他方法\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"ES6基础入门",frontmatter:{title:"ES6基础入门",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/75e0f9/",categories:["JS","ES6"],tags:[null],readingShow:"top"},regularPath:"/20.JS/20.ES6/01.ES6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html",relativePath:"20.JS/20.ES6/01.ES6基础入门.md",key:"v-5eb8472a",path:"/pages/75e0f9/",headers:[{level:2,title:"一、初始 ES6",slug:"一、初始-es6",normalizedTitle:"一、初始 es6",charIndex:2},{level:3,title:"1.1 ES6 简介",slug:"_1-1-es6-简介",normalizedTitle:"1.1 es6 简介",charIndex:15},{level:3,title:"1.2 let 和 const",slug:"_1-2-let-和-const",normalizedTitle:"1.2 let 和 const",charIndex:344},{level:4,title:"1.2.1 变量与常量",slug:"_1-2-1-变量与常量",normalizedTitle:"1.2.1 变量与常量",charIndex:423},{level:4,title:"1.2.2 const",slug:"_1-2-2-const",normalizedTitle:"1.2.2 const",charIndex:473},{level:4,title:"1.2.3 什么时候用 let，什么使用用 const",slug:"_1-2-3-什么时候用-let-什么使用用-const",normalizedTitle:"1.2.3 什么时候用 let，什么使用用 const",charIndex:948},{level:3,title:"1.3 let、const 与 var 的区别",slug:"_1-3-let、const-与-var-的区别",normalizedTitle:"1.3 let、const 与 var 的区别",charIndex:1094},{level:4,title:"1.3.1 重复声明",slug:"_1-3-1-重复声明",normalizedTitle:"1.3.1 重复声明",charIndex:1222},{level:4,title:"1.3.2 变量提升",slug:"_1-3-2-变量提升",normalizedTitle:"1.3.2 变量提升",charIndex:1523},{level:4,title:"1.3.3 暂时性死区",slug:"_1-3-3-暂时性死区",normalizedTitle:"1.3.3 暂时性死区",charIndex:1662},{level:4,title:"1.3.4 window 对象的属性和方法（全局作用域中）",slug:"_1-3-4-window-对象的属性和方法-全局作用域中",normalizedTitle:"1.3.4 window 对象的属性和方法（全局作用域中）",charIndex:2021},{level:4,title:"1.3.5 块级作用域",slug:"_1-3-5-块级作用域",normalizedTitle:"1.3.5 块级作用域",charIndex:2364},{level:3,title:"1.4 let 和 const 的应用",slug:"_1-4-let-和-const-的应用",normalizedTitle:"1.4 let 和 const 的应用",charIndex:2629},{level:2,title:"二、模板字符串",slug:"二、模板字符串",normalizedTitle:"二、模板字符串",charIndex:5974},{level:3,title:"2.1 认识模板字符串",slug:"_2-1-认识模板字符串",normalizedTitle:"2.1 认识模板字符串",charIndex:5986},{level:3,title:"2.2 模板字符串与一般字符串的区别",slug:"_2-2-模板字符串与一般字符串的区别",normalizedTitle:"2.2 模板字符串与一般字符串的区别",charIndex:6055},{level:3,title:"2.3 模板字符串的注意事项",slug:"_2-3-模板字符串的注意事项",normalizedTitle:"2.3 模板字符串的注意事项",charIndex:6704},{level:4,title:"2.3.1 输出多行字符串",slug:"_2-3-1-输出多行字符串",normalizedTitle:"2.3.1 输出多行字符串",charIndex:6722},{level:4,title:"2.3.2 输出 `  和 `` 等特殊字符",slug:"_2-3-2-输出-和-等特殊字符",normalizedTitle:"2.3.2 输出 `  和 `` 等特殊字符",charIndex:null},{level:4,title:"2.3.3 模板字符串的注入",slug:"_2-3-3-模板字符串的注入",normalizedTitle:"2.3.3 模板字符串的注入",charIndex:7104},{level:2,title:"2.4 模板字符串的应用",slug:"_2-4-模板字符串的应用",normalizedTitle:"2.4 模板字符串的应用",charIndex:7481},{level:2,title:"三、箭头函数",slug:"三、箭头函数",normalizedTitle:"三、箭头函数",charIndex:8725},{level:3,title:"3.1 认识箭头函数",slug:"_3-1-认识箭头函数",normalizedTitle:"3.1 认识箭头函数",charIndex:8736},{level:3,title:"3.2 箭头函数注意事项",slug:"_3-2-箭头函数注意事项",normalizedTitle:"3.2 箭头函数注意事项",charIndex:8965},{level:4,title:"3.2.1 单个参数",slug:"_3-2-1-单个参数",normalizedTitle:"3.2.1 单个参数",charIndex:8981},{level:4,title:"3.2.2 单行函数体",slug:"_3-2-2-单行函数体",normalizedTitle:"3.2.2 单行函数体",charIndex:9185},{level:3,title:"3.2.3 单行对象",slug:"_3-2-3-单行对象",normalizedTitle:"3.2.3 单行对象",charIndex:9344},{level:3,title:"3.3 非箭头函数中的 this 指向",slug:"_3-3-非箭头函数中的-this-指向",normalizedTitle:"3.3 非箭头函数中的 this 指向",charIndex:9656},{level:4,title:"3.3.1 全局作用域中的 this 指向",slug:"_3-3-1-全局作用域中的-this-指向",normalizedTitle:"3.3.1 全局作用域中的 this 指向",charIndex:9679},{level:4,title:"3.3.2 一般函数（非箭头函数）中的 this 指向",slug:"_3-3-2-一般函数-非箭头函数-中的-this-指向",normalizedTitle:"3.3.2 一般函数（非箭头函数）中的 this 指向",charIndex:9741},{level:3,title:"3.4 箭头函数没有 this",slug:"_3-4-箭头函数没有-this",normalizedTitle:"3.4 箭头函数没有 this",charIndex:10338},{level:3,title:"3.5 不适用箭头函数的场景",slug:"_3-5-不适用箭头函数的场景",normalizedTitle:"3.5 不适用箭头函数的场景",charIndex:10374},{level:4,title:"3.4.1 作为构造函数",slug:"_3-4-1-作为构造函数",normalizedTitle:"3.4.1 作为构造函数",charIndex:10392},{level:4,title:"3.4.2 需要 this 指向调用对象的时候",slug:"_3-4-2-需要-this-指向调用对象的时候",normalizedTitle:"3.4.2 需要 this 指向调用对象的时候",charIndex:10440},{level:4,title:"3.4.3 需要使用 arguments 的时候",slug:"_3-4-3-需要使用-arguments-的时候",normalizedTitle:"3.4.3 需要使用 arguments 的时候",charIndex:10517},{level:3,title:"3.6 箭头函数的应用",slug:"_3-6-箭头函数的应用",normalizedTitle:"3.6 箭头函数的应用",charIndex:10585},{level:2,title:"四、解构赋值",slug:"四、解构赋值",normalizedTitle:"四、解构赋值",charIndex:14569},{level:3,title:"4.1 数组的解构赋值",slug:"_4-1-数组的解构赋值",normalizedTitle:"4.1 数组的解构赋值",charIndex:14691},{level:4,title:"4.1.1 原理",slug:"_4-1-1-原理",normalizedTitle:"4.1.1 原理",charIndex:14706},{level:4,title:"4.1.2 数组解构赋值的默认值",slug:"_4-1-2-数组解构赋值的默认值",normalizedTitle:"4.1.2 数组解构赋值的默认值",charIndex:14915},{level:4,title:"4.1.3 数组解构赋值的应用",slug:"_4-1-3-数组解构赋值的应用",normalizedTitle:"4.1.3 数组解构赋值的应用",charIndex:15489},{level:3,title:"4.2 对象的解构赋值",slug:"_4-2-对象的解构赋值",normalizedTitle:"4.2 对象的解构赋值",charIndex:16356},{level:4,title:"4.2.1 原理",slug:"_4-2-1-原理",normalizedTitle:"4.2.1 原理",charIndex:16371},{level:4,title:"4.2.2 标准写法",slug:"_4-2-2-标准写法",normalizedTitle:"4.2.2 标准写法",charIndex:16515},{level:4,title:"4.2.3 对象解构赋值的默认值",slug:"_4-2-3-对象解构赋值的默认值",normalizedTitle:"4.2.3 对象解构赋值的默认值",charIndex:16800},{level:4,title:"4.2.4 将一个已经声明的变量用于解构赋值",slug:"_4-2-4-将一个已经声明的变量用于解构赋值",normalizedTitle:"4.2.4 将一个已经声明的变量用于解构赋值",charIndex:16889},{level:4,title:"4.2.5 对象解构赋值可以取到继承属性",slug:"_4-2-5-对象解构赋值可以取到继承属性",normalizedTitle:"4.2.5 对象解构赋值可以取到继承属性",charIndex:17033},{level:4,title:"4.2.6 对象解构赋值的应用",slug:"_4-2-6-对象解构赋值的应用",normalizedTitle:"4.2.6 对象解构赋值的应用",charIndex:17179},{level:3,title:"4.3 其它数据类型的解构赋值",slug:"_4-3-其它数据类型的解构赋值",normalizedTitle:"4.3 其它数据类型的解构赋值",charIndex:18310},{level:4,title:"4.3.1 字符串的解构赋值",slug:"_4-3-1-字符串的解构赋值",normalizedTitle:"4.3.1 字符串的解构赋值",charIndex:18329},{level:4,title:"4.3.2 数值和布尔值的解构赋值",slug:"_4-3-2-数值和布尔值的解构赋值",normalizedTitle:"4.3.2 数值和布尔值的解构赋值",charIndex:18569},{level:4,title:"4.3.3 undefined 和 null 没有解构赋值",slug:"_4-3-3-undefined-和-null-没有解构赋值",normalizedTitle:"4.3.3 undefined 和 null 没有解构赋值",charIndex:19094},{level:2,title:"五、对象字面量的增强",slug:"五、对象字面量的增强",normalizedTitle:"五、对象字面量的增强",charIndex:19174},{level:3,title:"5.1 属性和方法的简洁表示法",slug:"_5-1-属性和方法的简洁表示法",normalizedTitle:"5.1 属性和方法的简洁表示法",charIndex:19189},{level:4,title:"5.1.1 对象字面量",slug:"_5-1-1-对象字面量",normalizedTitle:"5.1.1 对象字面量",charIndex:19208},{level:4,title:"5.1.1 属性的简洁表示法",slug:"_5-1-1-属性的简洁表示法",normalizedTitle:"5.1.1 属性的简洁表示法",charIndex:19547},{level:4,title:"5.1.2 方法的简洁表示法",slug:"_5-1-2-方法的简洁表示法",normalizedTitle:"5.1.2 方法的简洁表示法",charIndex:19946},{level:3,title:"5.2 方括号语法",slug:"_5-2-方括号语法",normalizedTitle:"5.2 方括号语法",charIndex:20098},{level:4,title:"5.2.1 方括号语法的用法",slug:"_5-2-1-方括号语法的用法",normalizedTitle:"5.2.1 方括号语法的用法",charIndex:20111},{level:4,title:"5.2.2 方括号中可以放什么",slug:"_5-2-2-方括号中可以放什么",normalizedTitle:"5.2.2 方括号中可以放什么",charIndex:20567},{level:4,title:"5.2.3 放括号语法和点语法的区别",slug:"_5-2-3-放括号语法和点语法的区别",normalizedTitle:"5.2.3 放括号语法和点语法的区别",charIndex:20849},{level:2,title:"六、函数参数的默认值",slug:"六、函数参数的默认值",normalizedTitle:"六、函数参数的默认值",charIndex:21037},{level:3,title:"6.1 认识函数参数的默认值",slug:"_6-1-认识函数参数的默认值",normalizedTitle:"6.1 认识函数参数的默认值",charIndex:21052},{level:3,title:"6.2 函数参数默认值的基本用法",slug:"_6-2-函数参数默认值的基本用法",normalizedTitle:"6.2 函数参数默认值的基本用法",charIndex:21103},{level:3,title:"6.3 默认值的生效条件",slug:"_6-3-默认值的生效条件",normalizedTitle:"6.3 默认值的生效条件",charIndex:21484},{level:3,title:"6.4 默认值表达式",slug:"_6-4-默认值表达式",normalizedTitle:"6.4 默认值表达式",charIndex:21574},{level:3,title:"6.5 设置默认值的小技巧",slug:"_6-5-设置默认值的小技巧",normalizedTitle:"6.5 设置默认值的小技巧",charIndex:21616},{level:3,title:"6.6函数参数默认值的应用",slug:"_6-6函数参数默认值的应用",normalizedTitle:"6.6函数参数默认值的应用",charIndex:21799}],headersStr:"一、初始 ES6 1.1 ES6 简介 1.2 let 和 const 1.2.1 变量与常量 1.2.2 const 1.2.3 什么时候用 let，什么使用用 const 1.3 let、const 与 var 的区别 1.3.1 重复声明 1.3.2 变量提升 1.3.3 暂时性死区 1.3.4 window 对象的属性和方法（全局作用域中） 1.3.5 块级作用域 1.4 let 和 const 的应用 二、模板字符串 2.1 认识模板字符串 2.2 模板字符串与一般字符串的区别 2.3 模板字符串的注意事项 2.3.1 输出多行字符串 2.3.2 输出 `  和 `` 等特殊字符 2.3.3 模板字符串的注入 2.4 模板字符串的应用 三、箭头函数 3.1 认识箭头函数 3.2 箭头函数注意事项 3.2.1 单个参数 3.2.2 单行函数体 3.2.3 单行对象 3.3 非箭头函数中的 this 指向 3.3.1 全局作用域中的 this 指向 3.3.2 一般函数（非箭头函数）中的 this 指向 3.4 箭头函数没有 this 3.5 不适用箭头函数的场景 3.4.1 作为构造函数 3.4.2 需要 this 指向调用对象的时候 3.4.3 需要使用 arguments 的时候 3.6 箭头函数的应用 四、解构赋值 4.1 数组的解构赋值 4.1.1 原理 4.1.2 数组解构赋值的默认值 4.1.3 数组解构赋值的应用 4.2 对象的解构赋值 4.2.1 原理 4.2.2 标准写法 4.2.3 对象解构赋值的默认值 4.2.4 将一个已经声明的变量用于解构赋值 4.2.5 对象解构赋值可以取到继承属性 4.2.6 对象解构赋值的应用 4.3 其它数据类型的解构赋值 4.3.1 字符串的解构赋值 4.3.2 数值和布尔值的解构赋值 4.3.3 undefined 和 null 没有解构赋值 五、对象字面量的增强 5.1 属性和方法的简洁表示法 5.1.1 对象字面量 5.1.1 属性的简洁表示法 5.1.2 方法的简洁表示法 5.2 方括号语法 5.2.1 方括号语法的用法 5.2.2 方括号中可以放什么 5.2.3 放括号语法和点语法的区别 六、函数参数的默认值 6.1 认识函数参数的默认值 6.2 函数参数默认值的基本用法 6.3 默认值的生效条件 6.4 默认值表达式 6.5 设置默认值的小技巧 6.6函数参数默认值的应用",content:"# 一、初始 ES6\n\n\n# 1.1 ES6 简介\n\nES6 = ECMAScript 这门标准的第 6 代版本（2015）。\n\n * ECMAScript 是语言的标准\n * 6 是版本号\n\nECMA：欧洲计算机制造商协会\n\n具体内容：语法 + API\n\n历史版本：ES1——>3、ES5——>6（ES4 被废弃了）\n\n我们目前使用 JS 的大部分内容都是 ES3 的部分。\n\nES 与 JS 的关系：JavaScript(浏览器端) = ESMAScript(语法+API) + DOM + BOM\n\nES6 的兼容性：\n\n * 主流浏览器的最新版本几乎都全部支持 ES6\n * IE 老版本等不支持的浏览器，可以使用 Babel 转码\n * 总之，请放心大胆地使用 ES6\n\n\n# 1.2 let 和 const\n\n简单解释：\n\n * let 用于声明变量（对应之前的 var）\n * const 用于声明常量（之前没有常量的概念）\n\n# 1.2.1 变量与常量\n\n变量：初始化后可以重新赋值的量\n\n常量：初始化后不可以重新赋值的量\n\n# 1.2.2 const\n\n（1）为什么需要 const\n\n因为某些量的值是一直固定的，不需要也不能被修改，如果被修改就会报错。\n\n（2）const 注意事项\n\n * 使用 const 声明常量，一但声明就必须立即初始化，不能分开赋值\n   \n   const name = 'jerry'; √\n   -------------------------\n   const name;\n   name = 'jerry'; ×\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * const 声明的常量，允许在不重新赋值的情况下修改它的值\n   \n   // 基本数据类型不适用\n   -------------------\n   // 引用数据类型\n   const person = {\n       username: 'jerry'\n   };\n   \n   person.username = 'zjr'; √\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n# 1.2.3 什么时候用 let，什么使用用 const\n\n原则：如果不知道用什么的时候，就用 const\n\n原因：如果应该是常量，那么刚好符合需求。如果应该是变量，那么后来报错时，再来改为变量也为时不晚。同时，一开始就设置为常量还会避免真的需要为常量时，该值在后来被意外修改的情况。\n\n\n# 1.3 let、const 与 var 的区别\n\n * 重复声明\n * 变量提升\n * 暂时性死区\n * window 对象的属性和方法（全局作用域中）\n * 块级作用域\n\n> 下面以 let 与 var 的对比来说明，const 与 let 同理\n\n# 1.3.1 重复声明\n\nvar a = 10;\nvar a = 24;\nconsole.log(a);\t\t// 24\n\n\n1\n2\n3\n\n\nlet a = 10;\nlet a = 24;\nconsole.log(a);\t\t// 报错\n\n\n1\n2\n3\n\n\nfunction func(a) {\n    var a = 1;\n    console.log(a);\t\t// 1\n}\nfunc(24);\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a) {\n    let a = 1;\n    console.log(a);\t\t// 报错\n}\nfunc(24);\n\n\n1\n2\n3\n4\n5\n\n\n# 1.3.2 变量提升\n\nconsole.log(a);\t\t// undefined\nvar a = 24;\n\n\n1\n2\n\n\nconsole.log(a);\t\t// 报错\nlet a = 24;\n\n\n1\n2\n\n\n> 对于所有的变量和常量来说都应该遵循：先声明后使用的原则！\n\n# 1.3.3 暂时性死区\n\n只要作用域内存在 let、const，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。\n\nlet a = 2;\nfunction func() {\n    console.log(a);\t\t// 报错\n    let a = 1;\n}\nfunc();\n\n\n1\n2\n3\n4\n5\n6\n\n\nlet a = 2;\nfunction func() {\n    console.log(a);\t\t// 2\n}\nfunc();\n\n\n1\n2\n3\n4\n5\n\n\n即：只要作用域内出现了同名的 let 或 const，那么就会去找这个量（向前找），如果找不到也不会跳去外部找，只会直接报错！\n\n> 只要我们遵守 “先声明后使用”，那么其实就基本不会遇到变量提升及暂时性死区问题。\n\n# 1.3.4 window 对象的属性和方法（全局作用域中）\n\n全局作用域中，var 声明的变量，function 声明的函数，会自动变成 window 对象的属性或方法。\n\nvar age = 18;\nfunction add() {}\nconsole.log(window.age);\t\t\t// 18\nconsole.log(window.add === add);\t // true\n\n\n1\n2\n3\n4\n\n\nlet age = 18;\nconst add = function() {}\nconsole.log(window.age);\t\t\t// undefined\nconsole.log(window.add === add);\t // false\n\n\n1\n2\n3\n4\n\n\n# 1.3.5 块级作用域\n\n * var 没有块级作用域\n\nfor (var i = 0; i < 3; i++) {\n}\nconsole.log(i);\t\t// 3\n\n\n1\n2\n3\n\n * let、const 有块级作用域\n\nfor (let i = 0; i < 3; i++) {\n}\nconsole.log(i);\t\t// 报错\n\n\n1\n2\n3\n\n\n * 作用域链：内层作用域 ——> 外层作用域 ——> 全局作用域\n\n * 块级作用域：除了对象 {}，函数 {}（函数作用域）之外的一切 {} 都属于块级作用域。\n\n\n# 1.4 let 和 const 的应用\n\n要求：在页面上显示三个按钮（1、2、3），点击任何一个按钮便显示该按钮对应的数字。\n\n * 使用 var\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"X-UA-Compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n     var btns = document.querySelectorAll('.btn');\n\n     for (var i = 0; i < btns.length; i++) {\n       btns[i].addEventListener(\n         'click',\n         function () {\n           console.log(i);\n         },\n         false\n       );\n     }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n无论点击谁都是 3，这是因为 var 没有块级作用域，三个点击事件函数中的 i 都是同一个全局变量，最终 i 都为 3 了，所以固然都输出 3。\n\n * 使用 var，同时利用闭包\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"X-UA-Compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n    var btns = document.querySelectorAll('.btn');\n\n    for (var i = 0; i < btns.length; i++) {\n        (function (index) {\n            btns[index].addEventListener(\n                'click',\n                function () {\n                    console.log(index);\n                },\n                false\n            );\n        })(i);\n    }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n三个点击事件函数中的 i 对应到三个闭包上，且闭包的 i 为函数参数（局部变量），分别是 0、1、2。\n\n * 使用 let\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"X-UA-Compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n    let btns = document.querySelectorAll('.btn');\n\n    for (let i = 0; i < btns.length; i++) {\n        btns[i].addEventListener(\n            'click',\n            function () {\n                console.log(i);\n            },\n            false\n        );\n    }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 二、模板字符串\n\n\n# 2.1 认识模板字符串\n\n * 普通字符串：\n\n'字符串'\n\"字符串\"\n\n\n1\n2\n\n * 模板字符串：\n\n`字符串`\n\n\n1\n\n\n\n# 2.2 模板字符串与一般字符串的区别\n\n * 对于普通用法没有区别\n\nconst name1 = 'zjr';\nconst name2 = `zjr`;\nconsole.log(name1, name2, name1 === name2);\n// zjr zjr true\n\n\n1\n2\n3\n4\n\n * 字符串拼接的巨大区别\n\nconst person = {\n    name: 'zjr',\n    age: 18,\n    sex: '男'\n};\n\nconst info =\n    '我的名字是：' + person.name +\n    '，性别是：' + person.sex +\n    '，今年：' + person.age + '岁';\n\nconsole.log(info);\n\n// 我的名字是：zjr，性别是：男，今年：18岁\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nconst person = {\n    name: `zjr`,\n    age: 18,\n    sex: `男`\n};\n\nconst info = `我的名字是：${person.name}，性别是：${person.sex}，今年：${person.age}岁`;\n\nconsole.log(info);\n\n// 我的名字是：zjr，性别是：male，今年：18岁\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 模板字符串最大的优势：方便注入！\n\n\n# 2.3 模板字符串的注意事项\n\n# 2.3.1 输出多行字符串\n\n// 一般字符串\nconst info = '第一行\\n第二行';\nconsole.log(info);\n/*\n第一行\n第二行\n*/\n\n\n// 模板字符串\nconst info = `第一行\n第二行`;\t// 注意不能有缩进\nconsole.log(info);\n/*\n第一行\n第二行\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 模板字符串中，所有的空格、换行或缩进都会被保存在输出中\n\n# 2.3.2 输出 `` 和` 等特殊字符\n\nconst info = `\\``;\t// ```\nconst info = `\\\\`;\t// `\\`\nconst info = `\"\"`;\t// `\"\"`\nconst info = `''`;\t// `''`\n\n\n1\n2\n3\n4\n\n\n# 2.3.3 模板字符串的注入\n\nconst username = 'alex';\nconst person = {\n    age: 18,\n    sex: `male`\n};\nconst getSex = function (sex) {\n    return sex === `male` ? '男' : '女';\n};\n\nconst info = `${username},${person.age + 2},${getSex(person.sex)}`;\nconsole.log(info);\n\n// alex,20,男\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 模板字符串的 ${} 注入可以兼容几乎所有的值！\n> \n> 模板字符串、字符串、数值、布尔值、表达式、函数……（只要结果是个 “值” 即可）\n\n\n# 2.4 模板字符串的应用\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>模板字符串的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 300px;\n            font-size: 22px;\n        }\n\n        ul {\n            padding: 0;\n        }\n\n        p {\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n<p>学生信息表</p>\n<ul id=\"list\">\n    <li style=\"list-style: none;\">信息加载中……</li>\n</ul>\n\n<script>\n    // 数据（此处只是模拟数据，后期是通过 Ajax 从后台获取）\n    const students = [\n        {\n            username: 'Alex',\n            age: 18,\n            sex: 'male'\n        },\n        {\n            username: 'ZhangSan',\n            age: 28,\n            sex: 'male'\n        },\n        {\n            username: 'LiSi',\n            age: 20,\n            sex: 'female'\n        }\n    ];\n\n    const list = document.getElementById('list');\n\n    let html = '';\n\n    for (let i = 0; i < students.length; i++) {\n        html += `<li>我的名字是：${students[i].username},${students[i].sex},${students[i].age}</li>`;\n    }\n\n    list.innerHTML = html;\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 三、箭头函数\n\n\n# 3.1 认识箭头函数\n\n普通函数：\n\n * function 函数名() {}\n * const 变量名 = function () {};\n\n箭头函数：\n\n * 参数 => 函数体\n\n * () => {}\n\n> 由于箭头函数是匿名函数，所以我们通常把它赋给一个变量\n\nconst add = (x, y) => {\n    return x + y;\n};\n\nconsole.log(add(1, 1));\t\t// 2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.2 箭头函数注意事项\n\n# 3.2.1 单个参数\n\nconst add = (x) => {\n    return x + 1;\n};\n\n// 单个参数可以省略 ()\nconst add = x => {\n    return x + 1;\n};\n\n// 无参数或0个参数不能省略 ()\nconst test = () => {\n    return 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 3.2.2 单行函数体\n\nconst add = (x, y) => {\n    return x + y;\n};\n\n// 单行函数体可以省略 return 和 {}，且一但省略就 return 和 {} 都要一起省略\nconst add = (x, y) => x + y; \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.2.3 单行对象\n\nconst add = (x, y) => {\n    return {\n        value: x + y\n    };\n};\n\n// const add = (x, y) => {value: x + y};  报错！因为 {} 会产生歧义！\n// () 可以将语句变为表达式，从而 {} 就可以被顺理成章解释为对象\nconst add = (x, y) => ({value: x + y});\n\n// 数组就没有以上问题\nconst add = (x, y) => [x, y];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 推荐：一般情况最好不要简写！\n\n\n# 3.3 非箭头函数中的 this 指向\n\n# 3.3.1 全局作用域中的 this 指向\n\nconsole.log(this);\n// window\n\n\n1\n2\n\n\n# 3.3.2 一般函数（非箭头函数）中的 this 指向\n\n> 只有在函数调用的时候 this 指向才能确定，不调用的时候，不知道指向谁。\n> \n> this 指向和函数在哪儿没有关系，只和谁在调用有关。\n\nfunction add() {\n    console.log(this);\n}\n\nadd();\t// window\n// 在非严格模式下，this 其实是先指向 undefined，然后被自动转为了 window\n\n\n1\n2\n3\n4\n5\n6\n\n\n'use strict'\t// 严格模式\n\nfunction add() {\n    console.log(this);\n}\n\nadd();\t// undefined\n// 在严格模式下，this 为 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n'use strict'\t// 严格模式\n\nfunction add() {\n    console.log(this);\n}\n\nconst calc = {\n    add: add\n};\n\ncalc.add();\t\t// 上下文 this 为 calc\n\nconst adder = calc.add;\nadder();\t\t// 指向 undefined（非严格模式下指向 window）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3.4 箭头函数没有 this\n\n> 箭头函数没有 this！\n\n\n# 3.5 不适用箭头函数的场景\n\n# 3.4.1 作为构造函数\n\n因为箭头函数没有 this，而构造函数的核心就是 this。\n\n# 3.4.2 需要 this 指向调用对象的时候\n\n因为箭头函数没有 this，所以如果箭头函数中出现了 this，那么这个 this 就是外层的！\n\n# 3.4.3 需要使用 arguments 的时候\n\n箭头函数没有 arguments。\n\n（这个问题有替代解决方案：剩余参数）\n\n\n# 3.6 箭头函数的应用\n\n> 主要应用就是：箭头函数没有 this 这一特性！\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getElementById('btn');\n    const result = document.getElementById('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n            btn.addEventListener(\n                'click',\n                function () {\n                    setInterval(function () {\n                        console.log(this);\t// 计时器 this 是指向 window\n                        this.time++;\n                        result.innerHTML = this.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n----------------------------------------\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getElementById('btn');\n    const result = document.getElementById('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n         \t// 用 that 或 self 代替 this\n            var that = this;\n            btn.addEventListener(\n                'click',\n                function () {\n                    setInterval(function () {\n                        that.time++;\n                        result.innerHTML = that.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n----------------------------------------\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getElementById('btn');\n    const result = document.getElementById('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n            btn.addEventListener(\n                'click',\n                // 箭头函数中没有 this，所以下面的 this 是 start 的\n                () => {\n                    setInterval(() => {\n                        console.log(this);\n                        this.time++;\n                        result.innerHTML = this.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 四、解构赋值\n\n认识解构赋值：\n\nconst [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c);\t// 1 2 3\n\n\n1\n2\n\n\n解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量。\n\n\n# 4.1 数组的解构赋值\n\n# 4.1.1 原理\n\n 1. 模式（结构）匹配 [] = [1, 2, 3];\n\n 2. 索引值相同的完成赋值 const [a, b, c] = [1, 2, 3];\n\n 3. 举例\n    \n    const [a, [, , b], c] = [1, [2, 3, 4], 5];\n    console.log(a, b, c);\t// 1 4 5\n    \n    \n    1\n    2\n    \n\n# 4.1.2 数组解构赋值的默认值\n\n（1）默认值的基本用法\n\nconst [a, b] = [];\nconsole.log(a, b);\t// undefined undefined\n\n// ---------------------------------------\nconst [a = 1, b = 2] = [];\nconsole.log(a, b);\t// 1 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）默认值的生效条件\n\n只有当一个数组成员严格等于 (===) undefined 时，对应的默认值才会生效。\n\nconst [a = 1, b = 2] = [3, 0];\t\t// 3 0\nconst [a = 1, b = 2] = [3, null];\t// 3 null\nconst [a = 1, b = 2] = [3];\t\t    // 3 2\n\n\n1\n2\n3\n\n\n（3）默认值表达式\n\n如果默认值是表达式，默认值表达式是惰性求值的（即：当无需用到默认值时，表达式是不会求值的）\n\nconst func = () => {\n    return 24;\n};\n\nconst [a = func()] = [1];\t// 1\nconst [b = func()] = [];\t// 24\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 4.1.3 数组解构赋值的应用\n\n（1）arguments\n\nfunction func() {\n    const [a, b] = arguments;\n    console.log(a, b);\t// 1 2\n}\nfunc(1, 2);\n\n\n1\n2\n3\n4\n5\n\n\n（2）NodeList\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>NodeList</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    const [p1, p2, p3] = document.querySelectorAll('p');\n    console.log(p1, p2, p3);\n    /*\n    <p>1</p>\n\t<p>2</p>\n\t<p>3</p>\n\t*/\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n（3）函数参数的解构赋值\n\nconst array = [1, 1];\n// const add = arr => arr[0] + arr[1];\nconst add = ([x = 0, y = 0]) => x + y;\nconsole.log(add(array));\t// 2\nconsole.log(add([]));\t\t// 0\n\n\n1\n2\n3\n4\n5\n\n\n（4）交换变量的值\n\nlet x = 2, y = 1;\n\n// 原来\nlet tmp = x;\nx = y;\ny = tmp;\n\n// 现在\n[x, y] = [y, x];\n// 理解：[x, y] = [2, 1]\nconsole.log(x, y);\n// 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.2 对象的解构赋值\n\n# 4.2.1 原理\n\n 1. 模式（结构）匹配 {} = {};\n 2. 属性名相同的完成赋值 const {name, age} = {name: 'jerry', age: 18}; 或 const {age, name} = {name: 'jerry', age: 18};\n\n# 4.2.2 标准写法\n\nconst {age: age, name: name} = {name: 'jerry', age: '18'};\n或\nconst {'name': name, 'age': age} = {name: 'jerry', age: '18'};\n\n// 这样写法的一个最大的好处就是可以自定义别名\nconst {name: myName, age: myAge} = {name: 'jerry', age: '18'};\nconsole.log(myName, myAge);\t// jerry 18\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.2.3 对象解构赋值的默认值\n\n 1. 对象的属性值严格等于 undefined 时，对应的默认值才会生效。\n\n 2. 如果默认值是表达式，默认值表达式是惰性求值的。\n\n# 4.2.4 将一个已经声明的变量用于解构赋值\n\n整个赋值需要在圆括号中进行：\n\nlet x = 2;\n({x} = {x: 1});\n// 如果不加 ()，那么 {x} 会被浏览器误认为是普通的代码块\n// 已经声明的变量用于数组的解构赋值就不会遇到这个问题\n\n\n1\n2\n3\n4\n\n\n# 4.2.5 对象解构赋值可以取到继承属性\n\nconst {toString} = {};\nconsole.log(toString);\t// [Function: toString]\n// toString 是 object 的属性，而任何对象都继承自 Object\n\n\n1\n2\n3\n\n\n# 4.2.6 对象解构赋值的应用\n\n（1）对象作为函数参数\n\n// 之前\nconst logPersonInfo = user => console.log(user.name, user.age);\nlogPersonInfo({name: 'jerry', age: 18});\n\n// 之后\nconst logPersonInfo = ({age = 21, name = 'ZJR'}) => console.log(name, age);\nlogPersonInfo({name: 'jerry', age: 18});\t// jerry 18\nlogPersonInfo({});\t// ZJR 21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）复杂的嵌套（主要是缕清逻辑关系即可）\n\nconst obj = {\n    x: 1,\n    y: [2, 3, 4],\n    z: {\n        a: 5,\n        b: 6\n    }\n};\n\n// ----------------------------------------------------\nconst {x, y, z} = obj;\nconsole.log(x, y, z);\t// 1 [ 2, 3, 4 ] { a: 5, b: 6 }\n\n// ----------------------------------------------------\nconst {y: [, y2]} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// 报错\n\n// ----------------------------------------------------\nconst {y: y, y: [, y2]} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// [ 2, 3, 4 ]\n\n// ----------------------------------------------------\nconst {y, y: [, y2], z, z: {b}} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// [ 2, 3, 4 ]\nconsole.log(z);\t\t// { a: 5, b: 6 }\nconsole.log(b);\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4.3 其它数据类型的解构赋值\n\n# 4.3.1 字符串的解构赋值\n\n既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。\n\n// 数组形式解构赋值\nconst [a, b, , , c] = 'hello';\nconsole.log(a, b, c);\t// h e o\n\n// 对象形式解构赋值\nconst {0: a, 1: b, 4: o, length} = 'hello';\nconsole.log(a, b, o, length);\t// h e o 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.3.2 数值和布尔值的解构赋值\n\n只能按照对象的形式来解构赋值。\n\n（会先自动将等号右边的值转为对象）\n\n// 先来复习一下将数值和布尔值转化为对象\nconsole.log(new Number(123));\nconsole.log(new Boolean(true));\n// 转化后的对象里没有任何的属性（没有 123 这个属性，也没有 true 这个属性）和方法，\n// 所有的属性和方法都在它的继承 __proto__ 中，比如 toString 方法就是继承来的。\n\n// 里面的值只能是默认值，继承的方法倒是可以取到\nconst {a = 1, toString} = 123;\nconsole.log(a, toString);\t// 1 [Function: toString]\n\n// 里面的值只能是默认值，继承的方法倒是可以取到\nconst {b = 1, toString} = true;\nconsole.log(b, toString);\t// 1 [Function: toString]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 知道有这回事即可，一般都用不到，因为没太大意义。\n\n# 4.3.3 undefined 和 null 没有解构赋值\n\n由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。\n\n\n# 五、对象字面量的增强\n\n\n# 5.1 属性和方法的简洁表示法\n\n# 5.1.1 对象字面量\n\n// 实例化构造函数生成对象\nconst person = new Object();\nperson.age = 18;\nperson.speak = function() {};\nconsole.log(person);\t// { age: 18, speak: [Function (anonymous)] }\n\n// 对象字面量\nconst person = {\n    age: 18,\n    speak: function() {}\n};\nconsole.log(person);\t// { age: 18, speak: [Function (anonymous)] }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5.1.1 属性的简洁表示法\n\nconst age = 18;\nconst person = {\n    age: age\n};\nconsole.log(person.age);\t// 18\n\n// -----------------------\n\nconst age = 18;\nconst person = {\n    'age': age\n};\nconsole.log(person.age);\t// 18\n\n// -----------------------\n\n// 键名和变量或常量名一样的时候，可以只写一个\nconst age = 18;\nconst person = {\n    age\n};\nconsole.log(person.age);\t// 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 5.1.2 方法的简洁表示法\n\nconst person = {\n    // speak: function() {}\n    speak() {}\n};\n\nconsole.log(person);\t// { speak: [Function: speak] }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.2 方括号语法\n\n# 5.2.1 方括号语法的用法\n\nconst prop = 'age';\nconst person = {};\nperson.prop = 18;\nconsole.log(person);\t// { prop: 18 }\n\n// -----------------------------------------\n\nconst prop = 'age';\nconst person = {};\nperson[prop] = 18;\nconsole.log(person);\t// { age: 18 }\n\n// -----------------------------------------\n\n// ES6 增强\nconst prop = 'age';\nconst person = {\n    [prop]: 18\n};\nconsole.log(person);\t// { age: 18 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 5.2.2 方括号中可以放什么\n\n// [值、可以得到值的表达式]\nconst prop = 'age';\nconst func = () => 'age2';\nconst person = {\n    [prop]: 18,\n    [func()]: 24,\n    ['sex']: 'man',\n    ['s' + 'ex2']: 'womam'\n};\nconsole.log(person);\t// { age: 18, age2: 24, sex: 'man', sex2: 'womam' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 5.2.3 放括号语法和点语法的区别\n\n 1. 点语法是方括号语法的特殊形式\n 2. 属性名由数字、字母、下划线以及 $ 构成，并且数字还不能打头的时候可以使用点语法（合法标识符）\n 3. 能用点语法优先使用点语法\n\nconst person = {\n    age: 18\n};\n\nperson.age 等价于 person['age']\n\n\n1\n2\n3\n4\n5\n\n\n\n# 六、函数参数的默认值\n\n\n# 6.1 认识函数参数的默认值\n\n调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值\n\n\n# 6.2 函数参数默认值的基本用法\n\n// 之前的默认值实现方式\nconst multiply = (x, y) => {\n    if (typeof y === 'undefined') {\n        y = 3;\n    }\n    return x * y;\n};\nconsole.log(multiply(2, 2));\t// 4\nconsole.log(multiply(2));\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// ES6 默认值实现方式\nconst multiply = (x, y = 3) => {\n    return x * y;\n};\nconsole.log(multiply(2, 2));\t// 4\nconsole.log(multiply(2));\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6.3 默认值的生效条件\n\n不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效。\n\n注意：null 就是 null，不会使用默认值。\n\n\n# 6.4 默认值表达式\n\n如果默认值是表达式，那么默认值表达式是惰性求值的。\n\n\n# 6.5 设置默认值的小技巧\n\n函数参数的默认值最好从参数列表的右边开始设置。\n\n// 从左边开始设置默认值的缺陷\nconst multiply = (x = 1, y) => x * y;\nconsole.log(multiply(undefined, 2));\t// 2\n// 为了避免歧义，前面的参数必须指定为 undefined\n\n\n1\n2\n3\n4\n\n\n\n# 6.6函数参数默认值的应用\n\n接收很多参数的时候\n\n// 普通时候\nconst logUser = (username = 'zjr', age = 18, sex = 'male') => {\n    console.log(username, age, sex);\n};\n// 需要能够记住参数的顺序，如果参数较多那么需要配合文档，使用不方便\nlogUser('jerry', 18, 'male');\n\n// ------------------------------------------------------------\n\n// 接收一个对象作为参数\n// 不需要记住参数的顺序\nconst logUser = options => {\n    console.log(options.username, options.age, options.sex);\n};\nlogUser({\n    username: 'jerry',\n    age: 18,\n    sex: 'male'\n});\n\n// ------------------------------------------------------------\n\n// 再优化\nconst logUser = ({username, age, sex}) => {\n    console.log(username, age, sex);\n};\n\nlogUser({\n    username: 'jerry',\n    age: 18,\n    sex: 'male'\n});\n\n// ------------------------------------------------------------\n\n// 引入默认值\nconst logUser = ({\n    username = 'zjr',\n    age = 18,\n    sex = 'male'\n}) => {\n    console.log(username, age, sex);\n};\n\n// 其实是解构赋值原理\nlogUser({username: 'jerry'});\t// jerry 18 male\n\nlogUser({});\t// zjr 18 male\n\nlogUser();\t\t// 报错，因为这样相当于传了一个 undefined，不符合解构赋值\n\n// ------------------------------------------------------------\n\n// 再优化（函数默认值 + 解构赋值 + 解构赋值默认值）\nconst logUser = ({\n    username = 'zjr',\n    age = 18,\n    sex = 'male'\n} = {}) => {\n    console.log(username, age, sex);\n};\nlogUser();\t// zjr 18 male\n\n/* \n解释：\n1、options 与 {username = 'zjr', age = 18, sex = 'male'} 互等\n2、{username = 'zjr', age = 18, sex = 'male'} = {} 其实就是 options = {}\n3、由于 logUser() 的实参为 undefined，所以默认值为 {}\n4、再因为 {username = 'zjr', age = 18, sex = 'male'} = {} 是解构赋值\n5、由于 {} 内为 undefined，所以解构赋值启用默认值\n5、所以真正的形参为 {username = 'zjr', age = 18, sex = 'male'}\n注明：这样做的好处是增加函数的健壮性！\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n",normalizedContent:"# 一、初始 es6\n\n\n# 1.1 es6 简介\n\nes6 = ecmascript 这门标准的第 6 代版本（2015）。\n\n * ecmascript 是语言的标准\n * 6 是版本号\n\necma：欧洲计算机制造商协会\n\n具体内容：语法 + api\n\n历史版本：es1——>3、es5——>6（es4 被废弃了）\n\n我们目前使用 js 的大部分内容都是 es3 的部分。\n\nes 与 js 的关系：javascript(浏览器端) = esmascript(语法+api) + dom + bom\n\nes6 的兼容性：\n\n * 主流浏览器的最新版本几乎都全部支持 es6\n * ie 老版本等不支持的浏览器，可以使用 babel 转码\n * 总之，请放心大胆地使用 es6\n\n\n# 1.2 let 和 const\n\n简单解释：\n\n * let 用于声明变量（对应之前的 var）\n * const 用于声明常量（之前没有常量的概念）\n\n# 1.2.1 变量与常量\n\n变量：初始化后可以重新赋值的量\n\n常量：初始化后不可以重新赋值的量\n\n# 1.2.2 const\n\n（1）为什么需要 const\n\n因为某些量的值是一直固定的，不需要也不能被修改，如果被修改就会报错。\n\n（2）const 注意事项\n\n * 使用 const 声明常量，一但声明就必须立即初始化，不能分开赋值\n   \n   const name = 'jerry'; √\n   -------------------------\n   const name;\n   name = 'jerry'; ×\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * const 声明的常量，允许在不重新赋值的情况下修改它的值\n   \n   // 基本数据类型不适用\n   -------------------\n   // 引用数据类型\n   const person = {\n       username: 'jerry'\n   };\n   \n   person.username = 'zjr'; √\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n# 1.2.3 什么时候用 let，什么使用用 const\n\n原则：如果不知道用什么的时候，就用 const\n\n原因：如果应该是常量，那么刚好符合需求。如果应该是变量，那么后来报错时，再来改为变量也为时不晚。同时，一开始就设置为常量还会避免真的需要为常量时，该值在后来被意外修改的情况。\n\n\n# 1.3 let、const 与 var 的区别\n\n * 重复声明\n * 变量提升\n * 暂时性死区\n * window 对象的属性和方法（全局作用域中）\n * 块级作用域\n\n> 下面以 let 与 var 的对比来说明，const 与 let 同理\n\n# 1.3.1 重复声明\n\nvar a = 10;\nvar a = 24;\nconsole.log(a);\t\t// 24\n\n\n1\n2\n3\n\n\nlet a = 10;\nlet a = 24;\nconsole.log(a);\t\t// 报错\n\n\n1\n2\n3\n\n\nfunction func(a) {\n    var a = 1;\n    console.log(a);\t\t// 1\n}\nfunc(24);\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a) {\n    let a = 1;\n    console.log(a);\t\t// 报错\n}\nfunc(24);\n\n\n1\n2\n3\n4\n5\n\n\n# 1.3.2 变量提升\n\nconsole.log(a);\t\t// undefined\nvar a = 24;\n\n\n1\n2\n\n\nconsole.log(a);\t\t// 报错\nlet a = 24;\n\n\n1\n2\n\n\n> 对于所有的变量和常量来说都应该遵循：先声明后使用的原则！\n\n# 1.3.3 暂时性死区\n\n只要作用域内存在 let、const，它们所声明的变量或常量就自动 “绑定” 这个区域，不再受到外部作用域的影响。\n\nlet a = 2;\nfunction func() {\n    console.log(a);\t\t// 报错\n    let a = 1;\n}\nfunc();\n\n\n1\n2\n3\n4\n5\n6\n\n\nlet a = 2;\nfunction func() {\n    console.log(a);\t\t// 2\n}\nfunc();\n\n\n1\n2\n3\n4\n5\n\n\n即：只要作用域内出现了同名的 let 或 const，那么就会去找这个量（向前找），如果找不到也不会跳去外部找，只会直接报错！\n\n> 只要我们遵守 “先声明后使用”，那么其实就基本不会遇到变量提升及暂时性死区问题。\n\n# 1.3.4 window 对象的属性和方法（全局作用域中）\n\n全局作用域中，var 声明的变量，function 声明的函数，会自动变成 window 对象的属性或方法。\n\nvar age = 18;\nfunction add() {}\nconsole.log(window.age);\t\t\t// 18\nconsole.log(window.add === add);\t // true\n\n\n1\n2\n3\n4\n\n\nlet age = 18;\nconst add = function() {}\nconsole.log(window.age);\t\t\t// undefined\nconsole.log(window.add === add);\t // false\n\n\n1\n2\n3\n4\n\n\n# 1.3.5 块级作用域\n\n * var 没有块级作用域\n\nfor (var i = 0; i < 3; i++) {\n}\nconsole.log(i);\t\t// 3\n\n\n1\n2\n3\n\n * let、const 有块级作用域\n\nfor (let i = 0; i < 3; i++) {\n}\nconsole.log(i);\t\t// 报错\n\n\n1\n2\n3\n\n\n * 作用域链：内层作用域 ——> 外层作用域 ——> 全局作用域\n\n * 块级作用域：除了对象 {}，函数 {}（函数作用域）之外的一切 {} 都属于块级作用域。\n\n\n# 1.4 let 和 const 的应用\n\n要求：在页面上显示三个按钮（1、2、3），点击任何一个按钮便显示该按钮对应的数字。\n\n * 使用 var\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"x-ua-compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n     var btns = document.queryselectorall('.btn');\n\n     for (var i = 0; i < btns.length; i++) {\n       btns[i].addeventlistener(\n         'click',\n         function () {\n           console.log(i);\n         },\n         false\n       );\n     }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n无论点击谁都是 3，这是因为 var 没有块级作用域，三个点击事件函数中的 i 都是同一个全局变量，最终 i 都为 3 了，所以固然都输出 3。\n\n * 使用 var，同时利用闭包\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"x-ua-compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n    var btns = document.queryselectorall('.btn');\n\n    for (var i = 0; i < btns.length; i++) {\n        (function (index) {\n            btns[index].addeventlistener(\n                'click',\n                function () {\n                    console.log(index);\n                },\n                false\n            );\n        })(i);\n    }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n三个点击事件函数中的 i 对应到三个闭包上，且闭包的 i 为函数参数（局部变量），分别是 0、1、2。\n\n * 使用 let\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <meta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"/>\n    <meta content=\"ie=edge\" http-equiv=\"x-ua-compatible\"/>\n    <title>let 和 const 的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 150px;\n        }\n\n        .btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 80px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button class=\"btn\">0</button>\n<button class=\"btn\">1</button>\n<button class=\"btn\">2</button>\n\n<script>\n    let btns = document.queryselectorall('.btn');\n\n    for (let i = 0; i < btns.length; i++) {\n        btns[i].addeventlistener(\n            'click',\n            function () {\n                console.log(i);\n            },\n            false\n        );\n    }\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 二、模板字符串\n\n\n# 2.1 认识模板字符串\n\n * 普通字符串：\n\n'字符串'\n\"字符串\"\n\n\n1\n2\n\n * 模板字符串：\n\n`字符串`\n\n\n1\n\n\n\n# 2.2 模板字符串与一般字符串的区别\n\n * 对于普通用法没有区别\n\nconst name1 = 'zjr';\nconst name2 = `zjr`;\nconsole.log(name1, name2, name1 === name2);\n// zjr zjr true\n\n\n1\n2\n3\n4\n\n * 字符串拼接的巨大区别\n\nconst person = {\n    name: 'zjr',\n    age: 18,\n    sex: '男'\n};\n\nconst info =\n    '我的名字是：' + person.name +\n    '，性别是：' + person.sex +\n    '，今年：' + person.age + '岁';\n\nconsole.log(info);\n\n// 我的名字是：zjr，性别是：男，今年：18岁\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nconst person = {\n    name: `zjr`,\n    age: 18,\n    sex: `男`\n};\n\nconst info = `我的名字是：${person.name}，性别是：${person.sex}，今年：${person.age}岁`;\n\nconsole.log(info);\n\n// 我的名字是：zjr，性别是：male，今年：18岁\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 模板字符串最大的优势：方便注入！\n\n\n# 2.3 模板字符串的注意事项\n\n# 2.3.1 输出多行字符串\n\n// 一般字符串\nconst info = '第一行\\n第二行';\nconsole.log(info);\n/*\n第一行\n第二行\n*/\n\n\n// 模板字符串\nconst info = `第一行\n第二行`;\t// 注意不能有缩进\nconsole.log(info);\n/*\n第一行\n第二行\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 模板字符串中，所有的空格、换行或缩进都会被保存在输出中\n\n# 2.3.2 输出 `` 和` 等特殊字符\n\nconst info = `\\``;\t// ```\nconst info = `\\\\`;\t// `\\`\nconst info = `\"\"`;\t// `\"\"`\nconst info = `''`;\t// `''`\n\n\n1\n2\n3\n4\n\n\n# 2.3.3 模板字符串的注入\n\nconst username = 'alex';\nconst person = {\n    age: 18,\n    sex: `male`\n};\nconst getsex = function (sex) {\n    return sex === `male` ? '男' : '女';\n};\n\nconst info = `${username},${person.age + 2},${getsex(person.sex)}`;\nconsole.log(info);\n\n// alex,20,男\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 模板字符串的 ${} 注入可以兼容几乎所有的值！\n> \n> 模板字符串、字符串、数值、布尔值、表达式、函数……（只要结果是个 “值” 即可）\n\n\n# 2.4 模板字符串的应用\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>模板字符串的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 300px;\n            font-size: 22px;\n        }\n\n        ul {\n            padding: 0;\n        }\n\n        p {\n            margin-bottom: 10px;\n        }\n    </style>\n</head>\n<body>\n<p>学生信息表</p>\n<ul id=\"list\">\n    <li style=\"list-style: none;\">信息加载中……</li>\n</ul>\n\n<script>\n    // 数据（此处只是模拟数据，后期是通过 ajax 从后台获取）\n    const students = [\n        {\n            username: 'alex',\n            age: 18,\n            sex: 'male'\n        },\n        {\n            username: 'zhangsan',\n            age: 28,\n            sex: 'male'\n        },\n        {\n            username: 'lisi',\n            age: 20,\n            sex: 'female'\n        }\n    ];\n\n    const list = document.getelementbyid('list');\n\n    let html = '';\n\n    for (let i = 0; i < students.length; i++) {\n        html += `<li>我的名字是：${students[i].username},${students[i].sex},${students[i].age}</li>`;\n    }\n\n    list.innerhtml = html;\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 三、箭头函数\n\n\n# 3.1 认识箭头函数\n\n普通函数：\n\n * function 函数名() {}\n * const 变量名 = function () {};\n\n箭头函数：\n\n * 参数 => 函数体\n\n * () => {}\n\n> 由于箭头函数是匿名函数，所以我们通常把它赋给一个变量\n\nconst add = (x, y) => {\n    return x + y;\n};\n\nconsole.log(add(1, 1));\t\t// 2\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.2 箭头函数注意事项\n\n# 3.2.1 单个参数\n\nconst add = (x) => {\n    return x + 1;\n};\n\n// 单个参数可以省略 ()\nconst add = x => {\n    return x + 1;\n};\n\n// 无参数或0个参数不能省略 ()\nconst test = () => {\n    return 1;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 3.2.2 单行函数体\n\nconst add = (x, y) => {\n    return x + y;\n};\n\n// 单行函数体可以省略 return 和 {}，且一但省略就 return 和 {} 都要一起省略\nconst add = (x, y) => x + y; \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.2.3 单行对象\n\nconst add = (x, y) => {\n    return {\n        value: x + y\n    };\n};\n\n// const add = (x, y) => {value: x + y};  报错！因为 {} 会产生歧义！\n// () 可以将语句变为表达式，从而 {} 就可以被顺理成章解释为对象\nconst add = (x, y) => ({value: x + y});\n\n// 数组就没有以上问题\nconst add = (x, y) => [x, y];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n> 推荐：一般情况最好不要简写！\n\n\n# 3.3 非箭头函数中的 this 指向\n\n# 3.3.1 全局作用域中的 this 指向\n\nconsole.log(this);\n// window\n\n\n1\n2\n\n\n# 3.3.2 一般函数（非箭头函数）中的 this 指向\n\n> 只有在函数调用的时候 this 指向才能确定，不调用的时候，不知道指向谁。\n> \n> this 指向和函数在哪儿没有关系，只和谁在调用有关。\n\nfunction add() {\n    console.log(this);\n}\n\nadd();\t// window\n// 在非严格模式下，this 其实是先指向 undefined，然后被自动转为了 window\n\n\n1\n2\n3\n4\n5\n6\n\n\n'use strict'\t// 严格模式\n\nfunction add() {\n    console.log(this);\n}\n\nadd();\t// undefined\n// 在严格模式下，this 为 undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n'use strict'\t// 严格模式\n\nfunction add() {\n    console.log(this);\n}\n\nconst calc = {\n    add: add\n};\n\ncalc.add();\t\t// 上下文 this 为 calc\n\nconst adder = calc.add;\nadder();\t\t// 指向 undefined（非严格模式下指向 window）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3.4 箭头函数没有 this\n\n> 箭头函数没有 this！\n\n\n# 3.5 不适用箭头函数的场景\n\n# 3.4.1 作为构造函数\n\n因为箭头函数没有 this，而构造函数的核心就是 this。\n\n# 3.4.2 需要 this 指向调用对象的时候\n\n因为箭头函数没有 this，所以如果箭头函数中出现了 this，那么这个 this 就是外层的！\n\n# 3.4.3 需要使用 arguments 的时候\n\n箭头函数没有 arguments。\n\n（这个问题有替代解决方案：剩余参数）\n\n\n# 3.6 箭头函数的应用\n\n> 主要应用就是：箭头函数没有 this 这一特性！\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getelementbyid('btn');\n    const result = document.getelementbyid('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n            btn.addeventlistener(\n                'click',\n                function () {\n                    setinterval(function () {\n                        console.log(this);\t// 计时器 this 是指向 window\n                        this.time++;\n                        result.innerhtml = this.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getelementbyid('btn');\n    const result = document.getelementbyid('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n         \t// 用 that 或 self 代替 this\n            var that = this;\n            btn.addeventlistener(\n                'click',\n                function () {\n                    setinterval(function () {\n                        that.time++;\n                        result.innerhtml = that.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n----------------------------------------\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\"/>\n    <title>箭头函数的应用</title>\n    <style>\n        body {\n            padding: 50px 0 0 250px;\n            font-size: 30px;\n        }\n\n        #btn {\n            width: 100px;\n            height: 100px;\n            margin-right: 20px;\n            font-size: 30px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n<button id=\"btn\">开始</button>\n<span id=\"result\">0</span>\n\n<script>\n    const btn = document.getelementbyid('btn');\n    const result = document.getelementbyid('result');\n\n    const timer = {\n        time: 0,\n        start: function () {\n            // 我们希望的 this 是 start 里的 this，因为这个 this 才会指向 time\n            btn.addeventlistener(\n                'click',\n                // 箭头函数中没有 this，所以下面的 this 是 start 的\n                () => {\n                    setinterval(() => {\n                        console.log(this);\n                        this.time++;\n                        result.innerhtml = this.time;\n                    }, 1000);\n                },\n                false\n            );\n        }\n    };\n\n    timer.start();\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 四、解构赋值\n\n认识解构赋值：\n\nconst [a, b, c] = [1, 2, 3];\nconsole.log(a, b, c);\t// 1 2 3\n\n\n1\n2\n\n\n解析某一数据的结构，将我们想要的东西提取出来，赋值给变量或常量。\n\n\n# 4.1 数组的解构赋值\n\n# 4.1.1 原理\n\n 1. 模式（结构）匹配 [] = [1, 2, 3];\n\n 2. 索引值相同的完成赋值 const [a, b, c] = [1, 2, 3];\n\n 3. 举例\n    \n    const [a, [, , b], c] = [1, [2, 3, 4], 5];\n    console.log(a, b, c);\t// 1 4 5\n    \n    \n    1\n    2\n    \n\n# 4.1.2 数组解构赋值的默认值\n\n（1）默认值的基本用法\n\nconst [a, b] = [];\nconsole.log(a, b);\t// undefined undefined\n\n// ---------------------------------------\nconst [a = 1, b = 2] = [];\nconsole.log(a, b);\t// 1 2\n\n\n1\n2\n3\n4\n5\n6\n\n\n（2）默认值的生效条件\n\n只有当一个数组成员严格等于 (===) undefined 时，对应的默认值才会生效。\n\nconst [a = 1, b = 2] = [3, 0];\t\t// 3 0\nconst [a = 1, b = 2] = [3, null];\t// 3 null\nconst [a = 1, b = 2] = [3];\t\t    // 3 2\n\n\n1\n2\n3\n\n\n（3）默认值表达式\n\n如果默认值是表达式，默认值表达式是惰性求值的（即：当无需用到默认值时，表达式是不会求值的）\n\nconst func = () => {\n    return 24;\n};\n\nconst [a = func()] = [1];\t// 1\nconst [b = func()] = [];\t// 24\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 4.1.3 数组解构赋值的应用\n\n（1）arguments\n\nfunction func() {\n    const [a, b] = arguments;\n    console.log(a, b);\t// 1 2\n}\nfunc(1, 2);\n\n\n1\n2\n3\n4\n5\n\n\n（2）nodelist\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>nodelist</title>\n</head>\n<body>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<script>\n    const [p1, p2, p3] = document.queryselectorall('p');\n    console.log(p1, p2, p3);\n    /*\n    <p>1</p>\n\t<p>2</p>\n\t<p>3</p>\n\t*/\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n（3）函数参数的解构赋值\n\nconst array = [1, 1];\n// const add = arr => arr[0] + arr[1];\nconst add = ([x = 0, y = 0]) => x + y;\nconsole.log(add(array));\t// 2\nconsole.log(add([]));\t\t// 0\n\n\n1\n2\n3\n4\n5\n\n\n（4）交换变量的值\n\nlet x = 2, y = 1;\n\n// 原来\nlet tmp = x;\nx = y;\ny = tmp;\n\n// 现在\n[x, y] = [y, x];\n// 理解：[x, y] = [2, 1]\nconsole.log(x, y);\n// 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 4.2 对象的解构赋值\n\n# 4.2.1 原理\n\n 1. 模式（结构）匹配 {} = {};\n 2. 属性名相同的完成赋值 const {name, age} = {name: 'jerry', age: 18}; 或 const {age, name} = {name: 'jerry', age: 18};\n\n# 4.2.2 标准写法\n\nconst {age: age, name: name} = {name: 'jerry', age: '18'};\n或\nconst {'name': name, 'age': age} = {name: 'jerry', age: '18'};\n\n// 这样写法的一个最大的好处就是可以自定义别名\nconst {name: myname, age: myage} = {name: 'jerry', age: '18'};\nconsole.log(myname, myage);\t// jerry 18\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.2.3 对象解构赋值的默认值\n\n 1. 对象的属性值严格等于 undefined 时，对应的默认值才会生效。\n\n 2. 如果默认值是表达式，默认值表达式是惰性求值的。\n\n# 4.2.4 将一个已经声明的变量用于解构赋值\n\n整个赋值需要在圆括号中进行：\n\nlet x = 2;\n({x} = {x: 1});\n// 如果不加 ()，那么 {x} 会被浏览器误认为是普通的代码块\n// 已经声明的变量用于数组的解构赋值就不会遇到这个问题\n\n\n1\n2\n3\n4\n\n\n# 4.2.5 对象解构赋值可以取到继承属性\n\nconst {tostring} = {};\nconsole.log(tostring);\t// [function: tostring]\n// tostring 是 object 的属性，而任何对象都继承自 object\n\n\n1\n2\n3\n\n\n# 4.2.6 对象解构赋值的应用\n\n（1）对象作为函数参数\n\n// 之前\nconst logpersoninfo = user => console.log(user.name, user.age);\nlogpersoninfo({name: 'jerry', age: 18});\n\n// 之后\nconst logpersoninfo = ({age = 21, name = 'zjr'}) => console.log(name, age);\nlogpersoninfo({name: 'jerry', age: 18});\t// jerry 18\nlogpersoninfo({});\t// zjr 21\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n（2）复杂的嵌套（主要是缕清逻辑关系即可）\n\nconst obj = {\n    x: 1,\n    y: [2, 3, 4],\n    z: {\n        a: 5,\n        b: 6\n    }\n};\n\n// ----------------------------------------------------\nconst {x, y, z} = obj;\nconsole.log(x, y, z);\t// 1 [ 2, 3, 4 ] { a: 5, b: 6 }\n\n// ----------------------------------------------------\nconst {y: [, y2]} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// 报错\n\n// ----------------------------------------------------\nconst {y: y, y: [, y2]} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// [ 2, 3, 4 ]\n\n// ----------------------------------------------------\nconst {y, y: [, y2], z, z: {b}} = obj;\nconsole.log(y2);\t// 3\nconsole.log(y);\t\t// [ 2, 3, 4 ]\nconsole.log(z);\t\t// { a: 5, b: 6 }\nconsole.log(b);\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4.3 其它数据类型的解构赋值\n\n# 4.3.1 字符串的解构赋值\n\n既可以用数组的形式来解构赋值，也可以用对象的形式来解构赋值。\n\n// 数组形式解构赋值\nconst [a, b, , , c] = 'hello';\nconsole.log(a, b, c);\t// h e o\n\n// 对象形式解构赋值\nconst {0: a, 1: b, 4: o, length} = 'hello';\nconsole.log(a, b, o, length);\t// h e o 5\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 4.3.2 数值和布尔值的解构赋值\n\n只能按照对象的形式来解构赋值。\n\n（会先自动将等号右边的值转为对象）\n\n// 先来复习一下将数值和布尔值转化为对象\nconsole.log(new number(123));\nconsole.log(new boolean(true));\n// 转化后的对象里没有任何的属性（没有 123 这个属性，也没有 true 这个属性）和方法，\n// 所有的属性和方法都在它的继承 __proto__ 中，比如 tostring 方法就是继承来的。\n\n// 里面的值只能是默认值，继承的方法倒是可以取到\nconst {a = 1, tostring} = 123;\nconsole.log(a, tostring);\t// 1 [function: tostring]\n\n// 里面的值只能是默认值，继承的方法倒是可以取到\nconst {b = 1, tostring} = true;\nconsole.log(b, tostring);\t// 1 [function: tostring]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n> 知道有这回事即可，一般都用不到，因为没太大意义。\n\n# 4.3.3 undefined 和 null 没有解构赋值\n\n由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。\n\n\n# 五、对象字面量的增强\n\n\n# 5.1 属性和方法的简洁表示法\n\n# 5.1.1 对象字面量\n\n// 实例化构造函数生成对象\nconst person = new object();\nperson.age = 18;\nperson.speak = function() {};\nconsole.log(person);\t// { age: 18, speak: [function (anonymous)] }\n\n// 对象字面量\nconst person = {\n    age: 18,\n    speak: function() {}\n};\nconsole.log(person);\t// { age: 18, speak: [function (anonymous)] }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 5.1.1 属性的简洁表示法\n\nconst age = 18;\nconst person = {\n    age: age\n};\nconsole.log(person.age);\t// 18\n\n// -----------------------\n\nconst age = 18;\nconst person = {\n    'age': age\n};\nconsole.log(person.age);\t// 18\n\n// -----------------------\n\n// 键名和变量或常量名一样的时候，可以只写一个\nconst age = 18;\nconst person = {\n    age\n};\nconsole.log(person.age);\t// 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 5.1.2 方法的简洁表示法\n\nconst person = {\n    // speak: function() {}\n    speak() {}\n};\n\nconsole.log(person);\t// { speak: [function: speak] }\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 5.2 方括号语法\n\n# 5.2.1 方括号语法的用法\n\nconst prop = 'age';\nconst person = {};\nperson.prop = 18;\nconsole.log(person);\t// { prop: 18 }\n\n// -----------------------------------------\n\nconst prop = 'age';\nconst person = {};\nperson[prop] = 18;\nconsole.log(person);\t// { age: 18 }\n\n// -----------------------------------------\n\n// es6 增强\nconst prop = 'age';\nconst person = {\n    [prop]: 18\n};\nconsole.log(person);\t// { age: 18 }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 5.2.2 方括号中可以放什么\n\n// [值、可以得到值的表达式]\nconst prop = 'age';\nconst func = () => 'age2';\nconst person = {\n    [prop]: 18,\n    [func()]: 24,\n    ['sex']: 'man',\n    ['s' + 'ex2']: 'womam'\n};\nconsole.log(person);\t// { age: 18, age2: 24, sex: 'man', sex2: 'womam' }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 5.2.3 放括号语法和点语法的区别\n\n 1. 点语法是方括号语法的特殊形式\n 2. 属性名由数字、字母、下划线以及 $ 构成，并且数字还不能打头的时候可以使用点语法（合法标识符）\n 3. 能用点语法优先使用点语法\n\nconst person = {\n    age: 18\n};\n\nperson.age 等价于 person['age']\n\n\n1\n2\n3\n4\n5\n\n\n\n# 六、函数参数的默认值\n\n\n# 6.1 认识函数参数的默认值\n\n调用函数的时候传参了，就用传递的参数；如果没传参，就用默认值\n\n\n# 6.2 函数参数默认值的基本用法\n\n// 之前的默认值实现方式\nconst multiply = (x, y) => {\n    if (typeof y === 'undefined') {\n        y = 3;\n    }\n    return x * y;\n};\nconsole.log(multiply(2, 2));\t// 4\nconsole.log(multiply(2));\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n// es6 默认值实现方式\nconst multiply = (x, y = 3) => {\n    return x * y;\n};\nconsole.log(multiply(2, 2));\t// 4\nconsole.log(multiply(2));\t\t// 6\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 6.3 默认值的生效条件\n\n不传参数，或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效。\n\n注意：null 就是 null，不会使用默认值。\n\n\n# 6.4 默认值表达式\n\n如果默认值是表达式，那么默认值表达式是惰性求值的。\n\n\n# 6.5 设置默认值的小技巧\n\n函数参数的默认值最好从参数列表的右边开始设置。\n\n// 从左边开始设置默认值的缺陷\nconst multiply = (x = 1, y) => x * y;\nconsole.log(multiply(undefined, 2));\t// 2\n// 为了避免歧义，前面的参数必须指定为 undefined\n\n\n1\n2\n3\n4\n\n\n\n# 6.6函数参数默认值的应用\n\n接收很多参数的时候\n\n// 普通时候\nconst loguser = (username = 'zjr', age = 18, sex = 'male') => {\n    console.log(username, age, sex);\n};\n// 需要能够记住参数的顺序，如果参数较多那么需要配合文档，使用不方便\nloguser('jerry', 18, 'male');\n\n// ------------------------------------------------------------\n\n// 接收一个对象作为参数\n// 不需要记住参数的顺序\nconst loguser = options => {\n    console.log(options.username, options.age, options.sex);\n};\nloguser({\n    username: 'jerry',\n    age: 18,\n    sex: 'male'\n});\n\n// ------------------------------------------------------------\n\n// 再优化\nconst loguser = ({username, age, sex}) => {\n    console.log(username, age, sex);\n};\n\nloguser({\n    username: 'jerry',\n    age: 18,\n    sex: 'male'\n});\n\n// ------------------------------------------------------------\n\n// 引入默认值\nconst loguser = ({\n    username = 'zjr',\n    age = 18,\n    sex = 'male'\n}) => {\n    console.log(username, age, sex);\n};\n\n// 其实是解构赋值原理\nloguser({username: 'jerry'});\t// jerry 18 male\n\nloguser({});\t// zjr 18 male\n\nloguser();\t\t// 报错，因为这样相当于传了一个 undefined，不符合解构赋值\n\n// ------------------------------------------------------------\n\n// 再优化（函数默认值 + 解构赋值 + 解构赋值默认值）\nconst loguser = ({\n    username = 'zjr',\n    age = 18,\n    sex = 'male'\n} = {}) => {\n    console.log(username, age, sex);\n};\nloguser();\t// zjr 18 male\n\n/* \n解释：\n1、options 与 {username = 'zjr', age = 18, sex = 'male'} 互等\n2、{username = 'zjr', age = 18, sex = 'male'} = {} 其实就是 options = {}\n3、由于 loguser() 的实参为 undefined，所以默认值为 {}\n4、再因为 {username = 'zjr', age = 18, sex = 'male'} = {} 是解构赋值\n5、由于 {} 内为 undefined，所以解构赋值启用默认值\n5、所以真正的形参为 {username = 'zjr', age = 18, sex = 'male'}\n注明：这样做的好处是增加函数的健壮性！\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"ES6之Module模块",frontmatter:{title:"ES6之Module模块",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/65b11e/",categories:["JS","ES6"],tags:[null],readingShow:"top"},regularPath:"/20.JS/20.ES6/04.ES6%E4%B9%8BModule%E6%A8%A1%E5%9D%97.html",relativePath:"20.JS/20.ES6/04.ES6之Module模块.md",key:"v-70df8a60",path:"/pages/65b11e/",headers:[{level:2,title:"一、Module模块",slug:"一、module模块",normalizedTitle:"一、module模块",charIndex:2},{level:3,title:"1.1 初识Module",slug:"_1-1-初识module",normalizedTitle:"1.1 初识module",charIndex:17},{level:3,title:"1.2 Module的基本用法",slug:"_1-2-module的基本用法",normalizedTitle:"1.2 module的基本用法",charIndex:299},{level:3,title:"1.3 Module的导入导出",slug:"_1-3-module的导入导出",normalizedTitle:"1.3 module的导入导出",charIndex:600},{level:4,title:"1.3.1 export default 导出和对应的 import 导入",slug:"_1-3-1-export-default-导出和对应的-import-导入",normalizedTitle:"1.3.1 export default 导出和对应的 import 导入",charIndex:727},{level:4,title:"1.3.2 export 导出和对应的 import 导入",slug:"_1-3-2-export-导出和对应的-import-导入",normalizedTitle:"1.3.2 export 导出和对应的 import 导入",charIndex:2312},{level:3,title:"1.4 Module的注意事项",slug:"_1-4-module的注意事项",normalizedTitle:"1.4 module的注意事项",charIndex:4903},{level:4,title:"1.4.1 Module的注意事项",slug:"_1-4-1-module的注意事项",normalizedTitle:"1.4.1 module的注意事项",charIndex:4922}],headersStr:"一、Module模块 1.1 初识Module 1.2 Module的基本用法 1.3 Module的导入导出 1.3.1 export default 导出和对应的 import 导入 1.3.2 export 导出和对应的 import 导入 1.4 Module的注意事项 1.4.1 Module的注意事项",content:'# 一、Module模块\n\n\n# 1.1 初识Module\n\n（1）什么是模块\n\n模块：一个一个的局部作用域的代码块。\n\n（2）什么是模块系统\n\n模块系统：系统的解决了模块化一系列问题。\n\n 1. 模块化的写法（之前我们用立即执行函数模拟模块化，ES6 则实现了针对模块化的语法）\n 2. 消除全局变量（模块中的变量都是局部的，不同模块之间不会相互干扰，可以通过特定语法暴露指定内容）\n 3. 管理加载顺序（之前我们将一个总的 JavaScript 程序分几个文件写，但在最终合并调用时，js 的引入需要满足前后依赖关系。比如：被引用的 js 文件就一定要在引用它的 js 文件之前加载）\n\n\n# 1.2 Module的基本用法\n\n> 注意：Module 要生效，必须在服务器环境下才能执行。\n> \n> 普通的 HTML、JS 是本地文件环境，地址以 file 协议开头，服务器则以 http 或 https 开头。\n> \n> 方法：VSCode 中使用 Live Server 拓展，WebStorm 默认就是服务器环境。\n\n * 一个 JS 文件就是一个模块\n * 用 import 关键字导入模块\n * 用 export 关键字导出模块需要暴露的部分\n * 在使用 script 标签加载的时候，需要加上 type="module"，否则就以普通 JS 文件的形式引入了，就不是模块了\n\n\n# 1.3 Module的导入导出\n\n> 导出的东西可以被导入（import），并访问到！\n> \n> 对于导入和导出有两种方法：\n> \n>  * export default 导出，import 导入\n>  * export 导出，import 导入\n\n# 1.3.1 export default 导出和对应的 import 导入\n\n（1）一个模块没有导出，是否可以将其导入？\n\n\x3c!-- 一个模块没有导出，也可以将其导入 --\x3e\n\x3c!-- 被导入的模块的代码都会执行一遍，并且同一个模块的导入只执行一遍！ --\x3e\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <title>Module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    import "./test.js";\t\t// 浏览器控制台打印：test\n    import "./test.js";\t\t// 不执行\n    import "./test.js";\t\t// 不执行\n    import "./test02.js";\t// 浏览器控制台打印：test02\n    import "./test.js";\t\t// 不执行\n    import "./test02.js";\t// 不执行\n<\/script>\n</body>\n</html>\n\n----------------------------------------------------\n\x3c!-- test.js --\x3e\n\nconsole.log("test");\n\n----------------------------------------------------\n\x3c!-- test02.js --\x3e\n\nconsole.log("test02");\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n（2）一个模块中只能有一个 export default。\n\n【module.js】\n\n// 模块中的变量都是局部的\nconst age = 18;\nconst sex = "male";\n\nexport default age;\t\t\t// 通过 export default 导出（暴露）一个值\n// export default sex;\t\t// 报错！因为 export default 只能在一个文件中导出一次！！！\n\n/*\nexport default 24;\t\t\t\t// 可以导出值\nexport default {};\t\t\t\t// 可以导出对象\nexport default function(){};\t // 可以导出函数\nexport default class{};\t\t\t // 可以导出class\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【index.html】\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <title>Module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    // import 之后跟一个模块的别名，推荐别名与导出时的名字相同，比如这里就用 age\n    import age from "./module.js";\n    console.log(age);\t// 18\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 1.3.2 export 导出和对应的 import 导入\n\n（1）基本用法\n\n【module.js】\n\n/*\nconst age = 18;\nexport age;\t\t// 报错\n*/\n\n// export 后面只能跟声明或语句！\nexport const age = 18;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【index.html】\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <title>Module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    // import aaa from "./module.js";\t// 报错！ \n    // export 导出的模块，在导入时不能随意取别名，名称必须与模块导出时相同！并且要使用类似于解构赋值的{}形式！\n    \n    import {age} from "./module.js";\t// 注意：名称不能随意取，一定要与模块相同\n    console.log(age);\t// 18;\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意：在用 export 导出时，也可以用类似于解构赋值的{}形式！\n\n【module.js】\n\nconst age = 18;\n\nexport {age};\n\n\n1\n2\n3\n\n\n（2）多个导入\n\n【module.js】\n\n// 1、采用声明或语句的形式\n/*\nexport funciton fn() {};\nexport class className {};\nexport const age = 18;\n*/\n\n// 2、采用解构赋值的形式\nfunction fn() {};\nclass className {};\nconst age = 18;\n\n/* 方式 1：\nexport {fn};\nexport {className};\nexport {age};\n*/\n\n// 方式 2：\nexport {fn, className, age};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n【index.html】\n\n<!DOCTYPE html>\n<html lang="zh-CN">\n<head>\n    <meta charset="UTF-8">\n    <title>Module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    /* 方式 1：\n    import {fn} from "./module.js";\n    import {className} from "./module.js";\n    import {age} from "./module.js";\n    */\n    // 方式 2：\n    import {fn, className, age} from "./module.js";\n    console.log(fn);\t\t\t// ƒ fn() {}\n    console.log(className);\t\t// class className {}\n    console.log(age);\t    \t// 18\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n（3）导出导入时起别名\n\nexport {fn as func, className as cN, age};\n\n\n1\n\n\nimport {func, cN, age as nl} from "./module.js";\nconsole.log(func);\t\t\t// ƒ fn() {}\nconsole.log(cN);\t\t\t// class className {}\nconsole.log(nl);\t    \t// 18\n\n\n1\n2\n3\n4\n\n\n（4）整体导入\n\n// 之前的导入方式，如果导入的模块不多那么还好，但是一但模块数量多了起来，那么就特别费劲\n// import {fn, className, age} from "./module.js";\n\n// 整体导入\n// 将同一文件里的所有模块导入到一个对象中\n// 不仅对 export 有效，同时对 export default 也同样有效\nimport * as imObj from "./module.js";\nconsole.log(imObj);\t\t\t\t\t// 见图片\nconsole.log(imObj.fn);\t\t\t\t// ƒ fn() {}\nconsole.log(imObj.className);\t\t// class className {}\nconsole.log(imObj.age);\t\t\t\t// 18\n// export default 也同样有效：imObj.default\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n（5）同时导入\n\n当我们需要分别导入 export default 和 export 时，可以使用同时导入的方式。\n\n// 我们可以分开实现\nimport {fn, className, age} from "./module.js";\nimport sex from "./module.js";\n\n\n1\n2\n3\n\n\n// 更推荐使用同时导入的方式\nimport sex, {fn, className, age} from "./module.js";\n// 注意：export default 必须在 export 之前\n\n\n1\n2\n3\n\n\n\n# 1.4 Module的注意事项\n\n# 1.4.1 Module的注意事项\n\n（1）模块顶层的 this 指向\n\n顶层：不在 if、for、while、函数等局部作用域之外的部分。\n\n在模块中顶层的 this 指向 undefined！（千万不要误以为指向 window）\n\n> 模块中顶层的 this 指向 undefined，所以我们可以利用这个特性，检测模块有没有被正确的导入。比如：当 script 标签中没有 type="moudel" 时，模块就没有被成功引入，那么 this 就指向的是 window。\n\n> 当我们需要指定必须以模块的方式导入时，我们可以这样做：\n> \n> 【module.js】\n> \n> if (typeof this !== "undefined") {\n>     throw new Error("请使用模块的方式加载！");\n> }\n> \n> \n> 1\n> 2\n> 3\n\n（2）import 关键字和 import() 函数\n\n * import 命令具有提升效果，无论写在哪都会提升到代码的头部，率先执行！\n\n * import 执行的时候，代码还没有执行，所以我们不能将 import 嵌入到代码逻辑中！\n   \n   // 以下做法时错误的！\n   if (...) {\n       import "./pc.js";\n   } else {\n       import "./mobile.js";\n   }\n   // import 和 export 命令只能在模块的顶层，不能在代码块中执行！ \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * import() 可以按条件导入，并且返回一个 promise 对象\n   \n   if (...) {\n       import("pc.js").then().catch();\n   } else {\n       import("mobile.js").then().catch();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n（3）导入导出的复合写法\n\n复合写法：在一条语句中同时完成导入和导出。\n\n// 导入导出的复合写法\nexport {age} from "./module.js";\n\n// 等价于\nimport {age} from "./module.js";\nexport {age} from "./module.js";\n// 先导入用，用完后再导出，相当于 “中转站”\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# 一、module模块\n\n\n# 1.1 初识module\n\n（1）什么是模块\n\n模块：一个一个的局部作用域的代码块。\n\n（2）什么是模块系统\n\n模块系统：系统的解决了模块化一系列问题。\n\n 1. 模块化的写法（之前我们用立即执行函数模拟模块化，es6 则实现了针对模块化的语法）\n 2. 消除全局变量（模块中的变量都是局部的，不同模块之间不会相互干扰，可以通过特定语法暴露指定内容）\n 3. 管理加载顺序（之前我们将一个总的 javascript 程序分几个文件写，但在最终合并调用时，js 的引入需要满足前后依赖关系。比如：被引用的 js 文件就一定要在引用它的 js 文件之前加载）\n\n\n# 1.2 module的基本用法\n\n> 注意：module 要生效，必须在服务器环境下才能执行。\n> \n> 普通的 html、js 是本地文件环境，地址以 file 协议开头，服务器则以 http 或 https 开头。\n> \n> 方法：vscode 中使用 live server 拓展，webstorm 默认就是服务器环境。\n\n * 一个 js 文件就是一个模块\n * 用 import 关键字导入模块\n * 用 export 关键字导出模块需要暴露的部分\n * 在使用 script 标签加载的时候，需要加上 type="module"，否则就以普通 js 文件的形式引入了，就不是模块了\n\n\n# 1.3 module的导入导出\n\n> 导出的东西可以被导入（import），并访问到！\n> \n> 对于导入和导出有两种方法：\n> \n>  * export default 导出，import 导入\n>  * export 导出，import 导入\n\n# 1.3.1 export default 导出和对应的 import 导入\n\n（1）一个模块没有导出，是否可以将其导入？\n\n\x3c!-- 一个模块没有导出，也可以将其导入 --\x3e\n\x3c!-- 被导入的模块的代码都会执行一遍，并且同一个模块的导入只执行一遍！ --\x3e\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    import "./test.js";\t\t// 浏览器控制台打印：test\n    import "./test.js";\t\t// 不执行\n    import "./test.js";\t\t// 不执行\n    import "./test02.js";\t// 浏览器控制台打印：test02\n    import "./test.js";\t\t// 不执行\n    import "./test02.js";\t// 不执行\n<\/script>\n</body>\n</html>\n\n----------------------------------------------------\n\x3c!-- test.js --\x3e\n\nconsole.log("test");\n\n----------------------------------------------------\n\x3c!-- test02.js --\x3e\n\nconsole.log("test02");\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n（2）一个模块中只能有一个 export default。\n\n【module.js】\n\n// 模块中的变量都是局部的\nconst age = 18;\nconst sex = "male";\n\nexport default age;\t\t\t// 通过 export default 导出（暴露）一个值\n// export default sex;\t\t// 报错！因为 export default 只能在一个文件中导出一次！！！\n\n/*\nexport default 24;\t\t\t\t// 可以导出值\nexport default {};\t\t\t\t// 可以导出对象\nexport default function(){};\t // 可以导出函数\nexport default class{};\t\t\t // 可以导出class\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n【index.html】\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    // import 之后跟一个模块的别名，推荐别名与导出时的名字相同，比如这里就用 age\n    import age from "./module.js";\n    console.log(age);\t// 18\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# 1.3.2 export 导出和对应的 import 导入\n\n（1）基本用法\n\n【module.js】\n\n/*\nconst age = 18;\nexport age;\t\t// 报错\n*/\n\n// export 后面只能跟声明或语句！\nexport const age = 18;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n【index.html】\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    // import aaa from "./module.js";\t// 报错！ \n    // export 导出的模块，在导入时不能随意取别名，名称必须与模块导出时相同！并且要使用类似于解构赋值的{}形式！\n    \n    import {age} from "./module.js";\t// 注意：名称不能随意取，一定要与模块相同\n    console.log(age);\t// 18;\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意：在用 export 导出时，也可以用类似于解构赋值的{}形式！\n\n【module.js】\n\nconst age = 18;\n\nexport {age};\n\n\n1\n2\n3\n\n\n（2）多个导入\n\n【module.js】\n\n// 1、采用声明或语句的形式\n/*\nexport funciton fn() {};\nexport class classname {};\nexport const age = 18;\n*/\n\n// 2、采用解构赋值的形式\nfunction fn() {};\nclass classname {};\nconst age = 18;\n\n/* 方式 1：\nexport {fn};\nexport {classname};\nexport {age};\n*/\n\n// 方式 2：\nexport {fn, classname, age};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n【index.html】\n\n<!doctype html>\n<html lang="zh-cn">\n<head>\n    <meta charset="utf-8">\n    <title>module</title>\n</head>\n<body>\n\x3c!-- script 标签需要加上 type="module" --\x3e\n<script type="module">\n    /* 方式 1：\n    import {fn} from "./module.js";\n    import {classname} from "./module.js";\n    import {age} from "./module.js";\n    */\n    // 方式 2：\n    import {fn, classname, age} from "./module.js";\n    console.log(fn);\t\t\t// ƒ fn() {}\n    console.log(classname);\t\t// class classname {}\n    console.log(age);\t    \t// 18\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n（3）导出导入时起别名\n\nexport {fn as func, classname as cn, age};\n\n\n1\n\n\nimport {func, cn, age as nl} from "./module.js";\nconsole.log(func);\t\t\t// ƒ fn() {}\nconsole.log(cn);\t\t\t// class classname {}\nconsole.log(nl);\t    \t// 18\n\n\n1\n2\n3\n4\n\n\n（4）整体导入\n\n// 之前的导入方式，如果导入的模块不多那么还好，但是一但模块数量多了起来，那么就特别费劲\n// import {fn, classname, age} from "./module.js";\n\n// 整体导入\n// 将同一文件里的所有模块导入到一个对象中\n// 不仅对 export 有效，同时对 export default 也同样有效\nimport * as imobj from "./module.js";\nconsole.log(imobj);\t\t\t\t\t// 见图片\nconsole.log(imobj.fn);\t\t\t\t// ƒ fn() {}\nconsole.log(imobj.classname);\t\t// class classname {}\nconsole.log(imobj.age);\t\t\t\t// 18\n// export default 也同样有效：imobj.default\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n（5）同时导入\n\n当我们需要分别导入 export default 和 export 时，可以使用同时导入的方式。\n\n// 我们可以分开实现\nimport {fn, classname, age} from "./module.js";\nimport sex from "./module.js";\n\n\n1\n2\n3\n\n\n// 更推荐使用同时导入的方式\nimport sex, {fn, classname, age} from "./module.js";\n// 注意：export default 必须在 export 之前\n\n\n1\n2\n3\n\n\n\n# 1.4 module的注意事项\n\n# 1.4.1 module的注意事项\n\n（1）模块顶层的 this 指向\n\n顶层：不在 if、for、while、函数等局部作用域之外的部分。\n\n在模块中顶层的 this 指向 undefined！（千万不要误以为指向 window）\n\n> 模块中顶层的 this 指向 undefined，所以我们可以利用这个特性，检测模块有没有被正确的导入。比如：当 script 标签中没有 type="moudel" 时，模块就没有被成功引入，那么 this 就指向的是 window。\n\n> 当我们需要指定必须以模块的方式导入时，我们可以这样做：\n> \n> 【module.js】\n> \n> if (typeof this !== "undefined") {\n>     throw new error("请使用模块的方式加载！");\n> }\n> \n> \n> 1\n> 2\n> 3\n\n（2）import 关键字和 import() 函数\n\n * import 命令具有提升效果，无论写在哪都会提升到代码的头部，率先执行！\n\n * import 执行的时候，代码还没有执行，所以我们不能将 import 嵌入到代码逻辑中！\n   \n   // 以下做法时错误的！\n   if (...) {\n       import "./pc.js";\n   } else {\n       import "./mobile.js";\n   }\n   // import 和 export 命令只能在模块的顶层，不能在代码块中执行！ \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * import() 可以按条件导入，并且返回一个 promise 对象\n   \n   if (...) {\n       import("pc.js").then().catch();\n   } else {\n       import("mobile.js").then().catch();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n（3）导入导出的复合写法\n\n复合写法：在一条语句中同时完成导入和导出。\n\n// 导入导出的复合写法\nexport {age} from "./module.js";\n\n// 等价于\nimport {age} from "./module.js";\nexport {age} from "./module.js";\n// 先导入用，用完后再导出，相当于 “中转站”\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - 介绍与安装",frontmatter:{title:"Git - 介绍与安装",date:"2021-02-08T12:52:18.000Z",permalink:"/git/introduce/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/01.Git%20-%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85.html",relativePath:"40.工具/20.开发管理 - Git/01.Git - 介绍与安装.md",key:"v-0a54f67d",path:"/git/introduce/",headers:[{level:2,title:"Git概述",slug:"git概述",normalizedTitle:"git概述",charIndex:61},{level:3,title:"何为版本控制",slug:"何为版本控制",normalizedTitle:"何为版本控制",charIndex:72},{level:3,title:"为什么需要版本控制",slug:"为什么需要版本控制",normalizedTitle:"为什么需要版本控制",charIndex:84},{level:3,title:"版本控制工具",slug:"版本控制工具",normalizedTitle:"版本控制工具",charIndex:99},{level:2,title:"Git简介",slug:"git简介",normalizedTitle:"git简介",charIndex:109},{level:3,title:"Git简史",slug:"git简史",normalizedTitle:"git简史",charIndex:120},{level:3,title:"Git优势",slug:"git优势",normalizedTitle:"git优势",charIndex:131},{level:3,title:"Git结构",slug:"git结构",normalizedTitle:"git结构",charIndex:142},{level:3,title:"代码托管中心",slug:"代码托管中心",normalizedTitle:"代码托管中心",charIndex:153},{level:3,title:"Git下载与安装",slug:"git下载与安装",normalizedTitle:"git下载与安装",charIndex:165},{level:3,title:"Git安装验证",slug:"git安装验证",normalizedTitle:"git安装验证",charIndex:179},{level:2,title:"本地库和远程库",slug:"本地库和远程库",normalizedTitle:"本地库和远程库",charIndex:190},{level:3,title:"团队内部协作",slug:"团队内部协作",normalizedTitle:"团队内部协作",charIndex:203},{level:3,title:"跨团队协作",slug:"跨团队协作",normalizedTitle:"跨团队协作",charIndex:215}],headersStr:"Git概述 何为版本控制 为什么需要版本控制 版本控制工具 Git简介 Git简史 Git优势 Git结构 代码托管中心 Git下载与安装 Git安装验证 本地库和远程库 团队内部协作 跨团队协作",content:"笔记\n\nGit 是非常强大的版本管理工具，开发人员必须掌握的一门技术。\n\n2022-02-08 @Du Wu\n\n\n\n * Git概述\n   * 何为版本控制\n   * 为什么需要版本控制\n   * 版本控制工具\n * Git简介\n   * Git简史\n   * Git优势\n   * Git结构\n   * 代码托管中心\n   * Git下载与安装\n   * Git安装验证\n * 本地库和远程库\n   * 团队内部协作\n   * 跨团队协作\n\n\n\n\n# Git概述\n\nGit 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。\n\nGit 易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 Subversion、CVS、Perforce 和 ClearCase 等版本控制工具。\n\n\n# 何为版本控制\n\n版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。\n\n版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。\n\n\n# 为什么需要版本控制\n\n> 协同修改\n\n * 多人并行不悖的修改服务器端的同一个文件\n\n> 数据备份\n\n * 不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态\n\n> 版本管理\n\n * 在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。这方面 SVN 采用的是增量式管理的方式，而 Git 采取了文件系统快照的方式\n\n> 权限控制\n\n * 对团队中参与开发的人员进行权限控制\n\n * 对团队外开发者贡献的代码进行审核，这是 Git 独有\n\n> 历史记录\n\n * 查看修改人、修改时间、修改内容、日志信息\n\n * 将本地文件恢复到某一个历史状态\n\n> 分支管理\n\n * 允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率\n\n\n# 版本控制工具\n\n> 集中式版本控制工具\n\nCVS、SVN、VSS ......\n\n集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n\n这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。\n\n事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。\n\n\n\n> 分布式版本控制工具\n\nGit、Mercurial、Bazaar、Darcs ......\n\n像 Git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。\n\n分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷：\n\n 1. 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）\n 2. 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）\n\n\n\n\n# Git简介\n\n\n# Git简史\n\n\n\n\n# Git优势\n\n * 大部分操作在本地完成，不需要联网\n\n * 完整性保证\n\n * 尽可能添加数据而不是删除或修改数据\n\n * 分支操作非常快捷流畅\n\n * 与 Linux 命令全面兼\n\n\n# Git结构\n\n\n\nGit 本地结构分为：\n\n * 工作区，即我们写的代码文件\n * 暂存区，通过 git add 指令将代码文件添加到暂存区\n * 本地库，通过 git commit 指令将暂存区的代码文件添加到本地库\n * 远程库，通过 git push 指令将本地库的代码文件上传到远程库，即备份到云端\n\n\n# 代码托管中心\n\n代码托管中心的任务：维护远程库。\n\n> 局域网环境下\n\n * GitLab 服务器\n\n> 外网环境下\n\n * GitHub（国外）\n\n * Gitee 码云（国内）\n\n\n# Git下载与安装\n\n官网地址：https://git-scm.com/\n\n官网下载地址：https://git-scm.com/download\n\n这里演示 Windows 的安装步骤：\n\n 1. 安装到一个没有中文，没有空格的目录下，不建议放在 C 盘\n\n\n\n 2. 默认值\n\n\n\n 3. 建议选择 Vim 编辑器，也就是 Linux 使用的编辑器\n\n\n\n 4. 默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步\n\n\n\n 5. 建议不修改 PATH 环境变量，否则一些环境变量无法使用\n\n\n\n 6. 使用默认值，即 OpenSSL 库，限制性低\n\n\n\n 7. 选择第一个默认值\n\n\n\n 8. 选择 Git 提供的终端，不要合并到 CMD 终端，否则 Git 的一些命令会覆盖 CMD 的命令\n\n\n\n 9. 选择 Git pull 合并的模式，选择默认，然后下一步\n\n\n\n 10. 选择 Git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步\n\n\n\n 11. 其他配置，选择默认设置，然后下一步\n\n\n\n 12. 实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 Install 按钮，开始安装 Git\n\n\n\n自此，安装成功。\n\n\n# Git安装验证\n\n在 Git Bash 终端里输入 git --version 查看 git 版本，如图所示，说明 Git 安装成功。\n\n\n\n\n# 本地库和远程库\n\n\n# 团队内部协作\n\n\n\n当第一个本地库 push 到远程库时，第二个本地库就可以 clone 到自己，当修改了一些内容后，第二个本地库先加入团队，然后重新 push 到远程库，然后第一个本地库就可以 pull 更新自己。\n\n\n# 跨团队协作\n\n\n\n当第一个本地库和第二个本地库需要第三个本地库的帮忙，那么可以让第三个本地库 fork 到自己的远程库，然后 clone 到自己，修改好代码后重新 push 到自己的远程库，接着 pull request 给第一个远程库，此时并不是立即合并，而是由第一个本地库进行审核无误，再合并，最后第一个本地库和第二个本地库通过 pull 更新自己。",normalizedContent:"笔记\n\ngit 是非常强大的版本管理工具，开发人员必须掌握的一门技术。\n\n2022-02-08 @du wu\n\n\n\n * git概述\n   * 何为版本控制\n   * 为什么需要版本控制\n   * 版本控制工具\n * git简介\n   * git简史\n   * git优势\n   * git结构\n   * 代码托管中心\n   * git下载与安装\n   * git安装验证\n * 本地库和远程库\n   * 团队内部协作\n   * 跨团队协作\n\n\n\n\n# git概述\n\ngit 是一个免费的、开源的分布式版本控制系统，可以快速高效地处理从小型到大型的各种项目。\n\ngit 易于学习，占地面积小，性能极快。它具有廉价的本地库，方便的暂存区域和多个工作流分支等特性。其性能优于 subversion、cvs、perforce 和 clearcase 等版本控制工具。\n\n\n# 何为版本控制\n\n版本控制是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。\n\n版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。\n\n\n# 为什么需要版本控制\n\n> 协同修改\n\n * 多人并行不悖的修改服务器端的同一个文件\n\n> 数据备份\n\n * 不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态\n\n> 版本管理\n\n * 在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。这方面 svn 采用的是增量式管理的方式，而 git 采取了文件系统快照的方式\n\n> 权限控制\n\n * 对团队中参与开发的人员进行权限控制\n\n * 对团队外开发者贡献的代码进行审核，这是 git 独有\n\n> 历史记录\n\n * 查看修改人、修改时间、修改内容、日志信息\n\n * 将本地文件恢复到某一个历史状态\n\n> 分支管理\n\n * 允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率\n\n\n# 版本控制工具\n\n> 集中式版本控制工具\n\ncvs、svn、vss ......\n\n集中化的版本控制系统诸如 cvs、svn 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。\n\n这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。\n\n事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。\n\n\n\n> 分布式版本控制工具\n\ngit、mercurial、bazaar、darcs ......\n\n像 git 这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。\n\n分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷：\n\n 1. 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）\n 2. 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）\n\n\n\n\n# git简介\n\n\n# git简史\n\n\n\n\n# git优势\n\n * 大部分操作在本地完成，不需要联网\n\n * 完整性保证\n\n * 尽可能添加数据而不是删除或修改数据\n\n * 分支操作非常快捷流畅\n\n * 与 linux 命令全面兼\n\n\n# git结构\n\n\n\ngit 本地结构分为：\n\n * 工作区，即我们写的代码文件\n * 暂存区，通过 git add 指令将代码文件添加到暂存区\n * 本地库，通过 git commit 指令将暂存区的代码文件添加到本地库\n * 远程库，通过 git push 指令将本地库的代码文件上传到远程库，即备份到云端\n\n\n# 代码托管中心\n\n代码托管中心的任务：维护远程库。\n\n> 局域网环境下\n\n * gitlab 服务器\n\n> 外网环境下\n\n * github（国外）\n\n * gitee 码云（国内）\n\n\n# git下载与安装\n\n官网地址：https://git-scm.com/\n\n官网下载地址：https://git-scm.com/download\n\n这里演示 windows 的安装步骤：\n\n 1. 安装到一个没有中文，没有空格的目录下，不建议放在 c 盘\n\n\n\n 2. 默认值\n\n\n\n 3. 建议选择 vim 编辑器，也就是 linux 使用的编辑器\n\n\n\n 4. 默认分支名设置，选择让 git 决定，分支名默认为 master，下一步\n\n\n\n 5. 建议不修改 path 环境变量，否则一些环境变量无法使用\n\n\n\n 6. 使用默认值，即 openssl 库，限制性低\n\n\n\n 7. 选择第一个默认值\n\n\n\n 8. 选择 git 提供的终端，不要合并到 cmd 终端，否则 git 的一些命令会覆盖 cmd 的命令\n\n\n\n 9. 选择 git pull 合并的模式，选择默认，然后下一步\n\n\n\n 10. 选择 git 的凭据管理器，选择默认的跨平台的凭据管理器，然后下一步\n\n\n\n 11. 其他配置，选择默认设置，然后下一步\n\n\n\n 12. 实验室功能，技术还不成熟，有已知的 bug，不要勾选，然后点击右下角的 install 按钮，开始安装 git\n\n\n\n自此，安装成功。\n\n\n# git安装验证\n\n在 git bash 终端里输入 git --version 查看 git 版本，如图所示，说明 git 安装成功。\n\n\n\n\n# 本地库和远程库\n\n\n# 团队内部协作\n\n\n\n当第一个本地库 push 到远程库时，第二个本地库就可以 clone 到自己，当修改了一些内容后，第二个本地库先加入团队，然后重新 push 到远程库，然后第一个本地库就可以 pull 更新自己。\n\n\n# 跨团队协作\n\n\n\n当第一个本地库和第二个本地库需要第三个本地库的帮忙，那么可以让第三个本地库 fork 到自己的远程库，然后 clone 到自己，修改好代码后重新 push 到自己的远程库，接着 pull request 给第一个远程库，此时并不是立即合并，而是由第一个本地库进行审核无误，再合并，最后第一个本地库和第二个本地库通过 pull 更新自己。",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"ES6之Promise与Class类",frontmatter:{title:"ES6之Promise与Class类",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/8bebf7/",categories:["JS","ES6"],tags:[null],readingShow:"top"},regularPath:"/20.JS/20.ES6/03.ES6%E4%B9%8BPromise%E4%B8%8EClass%E7%B1%BB.html",relativePath:"20.JS/20.ES6/03.ES6之Promise与Class类.md",key:"v-e278e442",path:"/pages/8bebf7/",headers:[{level:2,title:"一、Promise",slug:"一、promise",normalizedTitle:"一、promise",charIndex:2},{level:3,title:"1.1 Promise 是什么？",slug:"_1-1-promise-是什么",normalizedTitle:"1.1 promise 是什么？",charIndex:16},{level:4,title:"异步的概念",slug:"异步的概念",normalizedTitle:"异步的概念",charIndex:59},{level:4,title:"什么时候用异步编程",slug:"什么时候用异步编程",normalizedTitle:"什么时候用异步编程",charIndex:329},{level:4,title:"回调函数（callback function）",slug:"回调函数-callback-function",normalizedTitle:"回调函数（callback function）",charIndex:802},{level:3,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1345},{level:3,title:"实例",slug:"实例-2",normalizedTitle:"实例",charIndex:1345},{level:3,title:"实例",slug:"实例-3",normalizedTitle:"实例",charIndex:1345},{level:3,title:"1.2 Promise 的基本用法",slug:"_1-2-promise-的基本用法",normalizedTitle:"1.2 promise 的基本用法",charIndex:5653},{level:4,title:"1.2.1 实例化构造函数生成实例对象",slug:"_1-2-1-实例化构造函数生成实例对象",normalizedTitle:"1.2.1 实例化构造函数生成实例对象",charIndex:5674},{level:4,title:"1.2.2 Promise 的状态",slug:"_1-2-2-promise-的状态",normalizedTitle:"1.2.2 promise 的状态",charIndex:5737},{level:4,title:"1.2.3 then 方法",slug:"_1-2-3-then-方法",normalizedTitle:"1.2.3 then 方法",charIndex:6174},{level:4,title:"1.2.4 resolve 和 reject 函数的参数",slug:"_1-2-4-resolve-和-reject-函数的参数",normalizedTitle:"1.2.4 resolve 和 reject 函数的参数",charIndex:6365},{level:3,title:"1.3 then()",slug:"_1-3-then",normalizedTitle:"1.3 then()",charIndex:6595},{level:3,title:"1.4 catch()",slug:"_1-4-catch",normalizedTitle:"1.4 catch()",charIndex:12100},{level:3,title:"1.5 finally()",slug:"_1-5-finally",normalizedTitle:"1.5 finally()",charIndex:13182},{level:3,title:"1.6 Promise.resolve()和Promise.reject()",slug:"_1-6-promise-resolve-和promise-reject",normalizedTitle:"1.6 promise.resolve()和promise.reject()",charIndex:14078},{level:3,title:"1.7 Promise.all()",slug:"_1-7-promise-all",normalizedTitle:"1.7 promise.all()",charIndex:16091},{level:3,title:"1.8 Promise.race()和Promise.allSettled()",slug:"_1-8-promise-race-和promise-allsettled",normalizedTitle:"1.8 promise.race()和promise.allsettled()",charIndex:17791},{level:3,title:"1.9 Promise的注意事项",slug:"_1-9-promise的注意事项",normalizedTitle:"1.9 promise的注意事项",charIndex:18067},{level:4,title:"1.9.1 resolve或reject执行后的代码",slug:"_1-9-1-resolve或reject执行后的代码",normalizedTitle:"1.9.1 resolve或reject执行后的代码",charIndex:18087},{level:4,title:"1.9.2 Promise.all/race/allSettled的参数问题",slug:"_1-9-2-promise-all-race-allsettled的参数问题",normalizedTitle:"1.9.2 promise.all/race/allsettled的参数问题",charIndex:18433},{level:4,title:"1.9.3 Promise.all/race/allSettled的错误处理",slug:"_1-9-3-promise-all-race-allsettled的错误处理",normalizedTitle:"1.9.3 promise.all/race/allsettled的错误处理",charIndex:18894},{level:3,title:"1.10 Promise的应用",slug:"_1-10-promise的应用",normalizedTitle:"1.10 promise的应用",charIndex:19064},{level:2,title:"二、Class类",slug:"二、class类",normalizedTitle:"二、class类",charIndex:20738},{level:3,title:"2.1 认识Class",slug:"_2-1-认识class",normalizedTitle:"2.1 认识class",charIndex:20751},{level:3,title:"2.2 Class的基本用法",slug:"_2-2-class的基本用法",normalizedTitle:"2.2 class的基本用法",charIndex:20823},{level:3,title:"2.3 Class与构造函数",slug:"_2-3-class与构造函数",normalizedTitle:"2.3 class与构造函数",charIndex:22393},{level:3,title:"2.4 Class的两种定义形式",slug:"_2-4-class的两种定义形式",normalizedTitle:"2.4 class的两种定义形式",charIndex:23082},{level:4,title:"2.4.1 声明形式",slug:"_2-4-1-声明形式",normalizedTitle:"2.4.1 声明形式",charIndex:23102},{level:4,title:"2.4.2 表达式形式",slug:"_2-4-2-表达式形式",normalizedTitle:"2.4.2 表达式形式",charIndex:23223},{level:3,title:"2.5 实例属性、静态方法和静态属性",slug:"_2-5-实例属性、静态方法和静态属性",normalizedTitle:"2.5 实例属性、静态方法和静态属性",charIndex:23531},{level:4,title:"2.5.1 实例属性",slug:"_2-5-1-实例属性",normalizedTitle:"2.5.1 实例属性",charIndex:23553},{level:4,title:"2.5.2 静态方法",slug:"_2-5-2-静态方法",normalizedTitle:"2.5.2 静态方法",charIndex:24434},{level:4,title:"2.5.3 静态属性",slug:"_2-5-3-静态属性",normalizedTitle:"2.5.3 静态属性",charIndex:25638},{level:3,title:"2.6 私有属性和方法",slug:"_2-6-私有属性和方法",normalizedTitle:"2.6 私有属性和方法",charIndex:25994},{level:3,title:"2.7 extends",slug:"_2-7-extends",normalizedTitle:"2.7 extends",charIndex:27427},{level:4,title:"2.7.1 子类继承父类",slug:"_2-7-1-子类继承父类",normalizedTitle:"2.7.1 子类继承父类",charIndex:27442},{level:4,title:"2.7.2 改写继承的属性或方法",slug:"_2-7-2-改写继承的属性或方法",normalizedTitle:"2.7.2 改写继承的属性或方法",charIndex:28277},{level:3,title:"2.8 super",slug:"_2-8-super",normalizedTitle:"2.8 super",charIndex:29314},{level:4,title:"2.8.1 作为函数调用",slug:"_2-8-1-作为函数调用",normalizedTitle:"2.8.1 作为函数调用",charIndex:29327},{level:4,title:"2.8.2 作为对象使用",slug:"_2-8-2-作为对象使用",normalizedTitle:"2.8.2 作为对象使用",charIndex:29781}],headersStr:"一、Promise 1.1 Promise 是什么？ 异步的概念 什么时候用异步编程 回调函数（callback function） 实例 实例 实例 1.2 Promise 的基本用法 1.2.1 实例化构造函数生成实例对象 1.2.2 Promise 的状态 1.2.3 then 方法 1.2.4 resolve 和 reject 函数的参数 1.3 then() 1.4 catch() 1.5 finally() 1.6 Promise.resolve()和Promise.reject() 1.7 Promise.all() 1.8 Promise.race()和Promise.allSettled() 1.9 Promise的注意事项 1.9.1 resolve或reject执行后的代码 1.9.2 Promise.all/race/allSettled的参数问题 1.9.3 Promise.all/race/allSettled的错误处理 1.10 Promise的应用 二、Class类 2.1 认识Class 2.2 Class的基本用法 2.3 Class与构造函数 2.4 Class的两种定义形式 2.4.1 声明形式 2.4.2 表达式形式 2.5 实例属性、静态方法和静态属性 2.5.1 实例属性 2.5.2 静态方法 2.5.3 静态属性 2.6 私有属性和方法 2.7 extends 2.7.1 子类继承父类 2.7.2 改写继承的属性或方法 2.8 super 2.8.1 作为函数调用 2.8.2 作为对象使用",content:'# 一、Promise\n\n\n# 1.1 Promise 是什么？\n\nPromise 是异步操作的一种解决方案。\n\n# 异步的概念\n\n异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。\n\n在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。\n\n简单来理解就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。\n\n以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：异步就是从主线程发射一个子线程来完成任务。\n\n\n\n# 什么时候用异步编程\n\n在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。\n\n现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。\n\n为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情（或者是一些需要等待某个时机在背后自动执行的任务，比如：事件监听），比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。\n\nJavaScript 是单线程语言，为了解决多线程问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。\n\n# 回调函数（callback function）\n\n在 JavaScript 中，回调函数具体的定义为：函数A 作为参数（函数引用）传递到另一个 函数B 中，并且这个 函数B 执行函数A。我们就说 函数A 叫做回调函数。如果没有名称（函数表达式），就叫做匿名回调函数。\n\n回调函数就是一个作为参数的函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。\n\n注意：回调和异步不是同一个东西，许多人误认为 js 中每个回调函数都是异步处理的，实际上并不是，可以同步回调，也可以异步回调。只不过说：回调可以是同步也可以是异步，异步必须放在回调里执行，也就是对于一个异步任务只有回调函数里的才是异步的部分。\n\n回调同步的例子：\n\nconst test = function (func) {\nfunc();\n}\n\ntest(() => {\nconsole.log(\'func\');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n回调异步的例子：\n\nsetTimeout(()=>{\nconsole.log(\'one\');\n}, 3000);\nconsole.log(\'two\');\n\n\n1\n2\n3\n4\n\n\n\n# 实例\n\nsetInterval() 和 setTimeout() 是两个异步语句。\n\n异步（asynchronous）：不会阻塞 CPU 继续执行其他语句，当异步完成时（包含回调函数的主函数的正常语句完成时），会执行 “回调函数”（callback）。\n\n<!DOCTYPE html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo"></p>\n<p>异步方式，不影响后续执行。</p>\n<script>\n  function print() {\n      document.getElementById("demo").innerHTML = "RUNOOB!";\n  }\n  setTimeout(print, 3000);\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 "print"，在命令行输出 "RUNOOB!"。\n\n当然，JavaScript 语法十分友好，我们不必单独定义一个函数 print ，我们常常将上面的程序写成：\n\n\n# 实例\n\n<!DOCTYPE html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo"></p>\n<p>异步方式，不影响后续执行。</p>\n<script>\nsetTimeout(function () {\n  document.getElementById("demo").innerHTML = "RUNOOB!";\n}, 3000);\n/* ES6 箭头函数写法\nsetTimeout(() => {\n  document.getElementById("demo").innerHTML = "RUNOOB!";\n}, 3000);\n*/\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n注意： 既然 setTimeout 会在子线程中等待 3 秒，在 setTimeout 函数执行之后主线程并没有停止，所以：\n\n\n# 实例\n\n<!DOCTYPE html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo1"></p>\n<p id="demo2"></p>\n<script>\nsetTimeout(function () {\n  document.getElementById("demo1").innerHTML = "RUNOOB-1!";\n}, 3000);\ndocument.getElementById("demo2").innerHTML = "RUNOOB-2!";\n<\/script>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段程序的执行结果是： （之前常用的异步操作解决方案是：回调函数）\n\ndocument.addEventListener(\n    \'click\',\n    () => {\n        console.log(\'这里是异步的\');\n    },\n    false\n);\nconsole.log(\'这里是同步的\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n什么时候使用 Promise 呢？\n\nPromise 一般用来解决层层嵌套的回调函数（回调地狱 callback hell）的问题。\n\n例如下面展示两个回调地狱的例子：\n\n例子1：分别间隔一秒打印省市县\n\n<!DOCTYPE html>\n<html lang="zh">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>回调举例</title>\n</head>\n\n<body>\n<script>\n    /*\n    // 此种方式，省市县都会在一秒后同时打印，没有实现要求\n    setTimeout(() => {\n        console.log("云南省");\n    }, 1000);\n    setTimeout(() => {\n        console.log("玉溪市");\n    }, 1000);\n    setTimeout(() => {\n        console.log("峨山县");\n    }, 1000);\n    */\n\n    // 通过回调函数的方式，实现异步\n    setTimeout(() => {\n        console.log("云南省");\n        let str01 = "云南省";\n        setTimeout(() => {\n            console.log(str01 + "玉溪市");\n            let str02 = "云南省玉溪市";\n            setTimeout(() => {\n                console.log(str02 + "峨山县");\n            }, 1000, str02);\n        }, 1000, str01);\n    }, 1000);\n    console.log("通过回调函数的方式，实现异步");\n<\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n\n例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8"/>\n    <title>Promise</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n\n        #box {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n            transition: all 0.5s;\n        }\n    </style>\n</head>\n<body>\n<div id="box"></div>\n<script>    \n    // 运动函数\n    const move = (el, {x = 0, y = 0} = {}, end = () => {}) => {\n        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n        el.addEventListener(\n            // transitionend 事件在 CSS 完成过渡后触发。\n            \'transitionend\',\n            () => {\n                end();\n            },\n            false\n        );\n    };\n\n    const boxEl = document.getElementById(\'box\');\n\n    // 形成回调地狱\n    document.addEventListener(\n        \'click\',\n        () => {\n            move(boxEl, {x: 150}, () => {\n                move(boxEl, {x: 150, y: 150}, () => {\n                    move(boxEl, {y: 150}, () => {\n                        move(boxEl, {x: 0, y: 0});\n                    });\n                });\n            });\n        },\n        false\n    );\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 1.2 Promise 的基本用法\n\n# 1.2.1 实例化构造函数生成实例对象\n\nPromise 实质上是一个构造函数，所以我们一般通过实例化的方式来使用它。\n\n# 1.2.2 Promise 的状态\n\nPromise 有三个状态：pending（等待）、fulfilled 或 resolved（成功）、rejected（失败）。\n\n并且 Promise 必须接收一个回调函数，这个回调函数有两个参数，这两个参数也是两个函数，(resolve, reject) => {}。\n\n * 实例化 Promise 后，默认是等待状态。\n\n * 当执行 resolve() 函数时，Promise 从等待状态——>成功状态。\n\n * 当执行 reject() 函数时，Promise 从等待状态——>失败状态。\n\n注意：当 Promise 的状态一但从等待转变为某一个状态后，后续的转变就自动忽略了，比如：先调用 resolve() 再调用 reject()，那么 Promise 的最终结果是成功状态。\n\n> 注意：这里的 resolve reject 只是一个形参，可以取任意名字，但是我们约定直接使用 resolve reject。\n\n# 1.2.3 then 方法\n\n当我们实例化 Promise 后得到的 Promise 对象便具有一个 then 方法。\n\nthen 方法具有两个回调函数作为参数 ()=>{}, ()=>{}。\n\n * 当 Promise 对象为成功状态时就默认自动执行 then 方法的第一个回调函数\n * 当 Promise 对象为失败状态时就默认自动执行 then 方法的第二个回调函数\n\n# 1.2.4 resolve 和 reject 函数的参数\n\nresolve() 和 reject() 函数是可以接收参数的。\n\n * resolve() 接收的参数会传递给 then 方法的第一个回调函数\n * reject() 接收的参数会传递给 then 方法的第二个回调函数\n\n注意：通常我们不仅仅会传递一个基本数据类型的值，我们还常常传递对象，比如再 reject 中传递一个错误对象：\n\nreject(new Error("出错了！"));\n\n\n# 1.3 then()\n\n 1. then 方法的两个回调函数什么时候执行\n    \n    * pending——>resolved时，执行 then 的第一个回调函数\n    * pending——>rejected 时，执行 then 的第二个回调函数\n\n 2. then 方法执行后的返回值\n    \n    * then 方法执行后默认自动返回一个新的 Promise 对象\n\n 3. then 方法返回的 Promise 对象的状态改变\n    \n    * then 方法其实默认返回的是 undefined，即：return undefined，但是 ES6 的机制规定：当 then 返回 undefined 时，那么会将这个 undefined 包装成一个 Promise，并且这个 Promise 默认调用了 resilve() 方法（成功态），并且把 undefined 作为了 resilve() 的参数，相当于：\n      \n      const p = new Promise((resolve, reject) => {\n          resolve();\n      });\n      p.then(() => {\n          // 默认会执行这一条\n          // return undefined;\n      }, () => {\n      });\n      \n      // 实际上，return 会包装为一个 Promise 对象，同时默认执行 resolve()，并把 return 的值作为 resolve() 的参数\n      /*\n      return new Promise(resolve => {\n          resolve(undefined);\n      });\n      */\n      \n      // -----------------------------\n      // 如果我们在这个返回的 Promise 上继续调用 then 方法，并接收参数的话，可以发现 then 中成功接收到了被 Promise 包装后的参数\n      const p2 = new Promise((resolve, reject) => {\n          resolve();\n      });\n      p2.then(() => {\n          // 默认会执行这一条\n          // return undefined;\n      }).then(data => {\n          console.log(data);  // 打印 undefined\n          // 手动 return 一个值\n          return 24;\n          // 相当于：return new Promise(resolve => {resolve(24);});\n      }).then((data) => {\n          console.log(data);\t// 打印 24\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      30\n      31\n      32\n      \n    \n    * 如果我们要让 then 返回一个失败状态的 Promise，那么我们可以手动 return 一个 Promise 并执行 reject() 方法。\n      \n      const p3 = new Promise((resolve, reject) => {\n          resolve();\n      });\n      p3.then(() => {\n          // 手动返回一个调用了 reject 的 Promise\n          return new Promise((resolve, reject) => {\n              reject("失败");\n          })\n      }).then(() => {}, errData => {\n          console.log(errData);\t// 失败\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n> 总结：Promise 是一个构造函数，需要 new 才能使用。在 new Promise() 的时候需要传递一个匿名回调函数作为 Promise() 唯一的参数，这个回调函数有两个参数 resolve reject，这两个参数也是函数，当回调函数执行第一个 resolve 函数后 Promise 便变为了成功状态，反之回调函数执行了 reject 后 Promise 便变为了失败状态，且每个 Promise 只能要么执行 resolve，要么执行 reject，不能同时执行！当 Promise 被 new 之后就会有一个 then 方法，该方法默认接收两个匿名回调函数作为参数，其中第一个回调函数是在 Promise 为成功状态时自动调用的，反之第二个回调函数是在 Promise 为失败状态时自动调用的，并且这两个回调函数是可以接收参数的，参数就来自于 resolve 或 reject 调用时传递的实参！在 then 方法执行后会默认返回 undefined（在没有指定返回值的情况下），ES6 会将其包装为一个新的成功态的 Promise，该 Promise 会自动执行 resolve 函数，该函数的参数来自于 then 方法的返回值（如果没有返回值那么默认就返回 undefined）。如果需要返回一个失败态的 Promise，那么需要在 then 中手动指定返回值：\n> \n> return new Promise((resolve, reject) => {\n> \treject(参数);\n> }\n> \n> \n> 1\n> 2\n> 3\n\n学习了以上知识，现在我们来用 Promise 改造之前的两个回调地狱案例。\n\n案例一：分别间隔一秒打印省市县。\n\n<!DOCTYPE html>\n<html lang="zh">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Promise</title>\n</head>\n\n<body>\n<script>\n    // 通过 Promise 的方式，解决回调地狱\n    new Promise((resolve) => {\n        setTimeout(() => {\n            console.log("云南省");\n            resolve("云南省");\n        }, 1000);\n    }).then(res => {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                console.log(res + "玉溪市");\n                resolve(res + "玉溪市");\n            }, 1000);\n        });\n    }).then(res => {\n        setTimeout(() => {\n            console.log(res + "峨山县");\n        }, 1000);\n    });\n\n    console.log("通过 Promise 的方式，实现异步");\n<\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动。\n\n// 利用 Promise 解决回调地狱问题\n// 例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8"/>\n    <title>Promise</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n\n        #box {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n            transition: all 0.5s;\n        }\n    </style>\n</head>\n<body>\n<div id="box"></div>\n<script>\n    // 运动函数\n    const move = (el, {x = 0, y = 0} = {}, end = () => {}) => {\n        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n        el.addEventListener(\n            // transitionend 事件在 CSS 完成过渡后触发。\n            \'transitionend\',\n            () => {\n                end();\n            },\n            false\n        );\n    };\n\n    const boxEl = document.getElementById(\'box\');\n\n    const movePromise = (el, point) => {\n        return new Promise(resolve => {\n            move(el, point, () => {\n                resolve();\n            });\n        });\n    };\n\n    document.addEventListener(\n        \'click\', () => {\n            movePromise(boxEl, {x: 150}).then(() => {\n                return movePromise(boxEl, {x: 150, y: 150});\n            }).then(() => {\n                return movePromise(boxEl, {y: 150});\n            }).then(() => {\n                movePromise(boxEl, {x: 0, y: 0});\n            })\n        }, false);\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n通过上述两个改造后的例子，可以看到，Promise 让原先回调的“嵌套”型模式转变为了 Promise 的“并列”型模式，这就解决了回调地狱的问题。\n\n\n# 1.4 catch()\n\n由之前的例子可以看出，我们在使用 Promise 的时候，大部分情况下，我们只用 resolve() 方法（成功态），所以在 Promise 回调函数中我们常常省略 reject 函数参数，在 then 中我们常常省略第二个回调函数。\n\n但是我们还是需要处理异步中的异常，所以 ES6 中提供了我们一个 catch() 方法专门用来处理 Promise 的异常部分（失败态）。\n\n * catch 专门用来处理 rejected 状态\n\n * catch 本质上是 then 的特例\n\nnew Promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);   // 失败\n});\n\n// -------------------------------------\n// 上面的代码本质上等同于\nnew Promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).then(null, err => {\n    console.log(err);\t// 失败\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 在 Promise 中，一但出现了错误状态，那么这个错误是不会消失的，会一直向下传递，直到遇到可以处理错误的函数。\n\n由于 catch 是 then 的特例，所以 catch 依旧返回的是一个 Promise 对象，我们可以在 catch 后继续调用 then。\n\nnew Promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);   // 失败\n    return "测试";\n}).then(res => {\n   console.log(res);\t// 测试 \n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 一般总是建议，Promise 对象后面要跟一个或多个 catch 方法，这样可以处理 Promise 内部发生的错误！\n\n\n# 1.5 finally()\n\n当 Promise 状态发生变化时，不论如何变化都会执行，不变化不执行。\n\n * finally() 不能接收参数。\n\n * finally 也是 then 的特例。\n\nnew Promise(resolve => {\n    resolve("测试01");\n}).finally(data => {\n    console.log(data + " finally01");\n    return new Promise((resolve, reject) => {\n        reject("测试02");\n    })\n}).finally(data => {\n    console.log(data + " finally02")\n}).catch(err => {\n    console.log("catch: " + err);\n});\n\n/*\nundefined finally01\nundefined finally02\ncatch: 测试02\n*/\n\n// 从以上示例可以看出：finally 可以接收正确状态或错误状态，但是不能接收参数。\n\n// -------------------------------------\n// finally 也是 then 的特例\n// finally 等同于：\nnew Promise((resolve, reject) => {\n    ...\n}).then(res => {\n    return res;\n}, err => {\n    return new Promise((resolve, reject) => {\n        reject(err);\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nfinally：主要是用来处理一些必做操作，比如在操作数据库之后（无论成功与否）都要关闭数据库连接。\n\n\n# 1.6 Promise.resolve()和Promise.reject()\n\n以上两者都是 Promise 构造函数的方法。\n\n> 下面我们以 Promise.resolve() 举例，Promise.reject() 同理。\n\n// Promise.resolve() 可以理解为普通成功状态的一种简写形式\nnew Promise(resolve => resolve(\'foo\'));\n// 简写\nPromise.resolve(\'foo\');\n\n\n1\n2\n3\n4\n\n\nPromise.resolve() 与 Promise.reject() 的参数问题：\n\n1、一般参数\n\nPromise.resolve(\'foo\').then(data => {\n    console.log(data);\n})\t// foo\n\n\n1\n2\n3\n\n\n2、特殊参数：Promise 作为参数\n\nconst p1 = new Promise(resolve => {\n    setTimeout(resolve, 1000, \'我执行了\');\n    /*\n    上述延时器写法相当于：\n    setTimeout(()=>{\n        resolve(\'我执行了\');\n    }, 1000);\n     */\n});\nPromise.resolve(p1).then(data => {\n    console.log(data);\t// 等待一秒后，输出 \'我执行了\'\n});\n\n/*\n当 Promise.resolve() 接收的是 Promise 对象时，直接返回这个 Promise 对象，什么都不做\n*/\n\n// 所以，以上代码等同于：\np1.then(data => {\n   console.log(data); // 等待一秒后，输出 \'我执行了\'\n});\n\n// 验证\nconsole.log(Promise.resolve(p1) === p1);\t// true\n\n// 由于 Promise.resolve() 可以理解为普通成功状态的一种简写形式，所以：\nnew Promise(resolve => resolve(p1)).then(data => {\n   console.log(data); // 等待一秒后，输出 \'我执行了\'\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n3、特殊参数：具有 then 方法的对象（了解即可）\n\nconst thenable = {\n    then() {\n        console.log(\'then\');\n    }\n};\nPromise.resolve(thenable).then(\n    res => console.log("res " + res),\n    err => console.log("err " + err)\n);\n\n/*\nthen\n*/\n\n// 当接收一个含 then 方法的对象时，Promise.resolve() 会直接调用 then 方法。\n\n// 为什么不会执行 then 中的两个回调函数呢？\nconsole.log(Promise.resolve(thenable));\n/*\nPromise { <pending> }\nthen\n*/\n// 可见，当接收一个含 then 方法的对象时，默认返回一个 Promise 并且是等待状态的，没有状态的变化，那么就不可能会执行 then 的回调函数\n// 如果我们要改变这个返回的 Promise 对象的状态，并让 then 的回调对应处理的话，ES6 规定了以下写法：\nconst thenable02 = {\n    then(resolve, reject) {\n        console.log(\'then\');\n        resolve(\'then\');\n    }\n};\nPromise.resolve(thenable02).then(\n    res => console.log("res " + res),\n    err => console.log("err " + err)\n);\n/*\nthen\nres then\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> 与 Promise.resolve() 不同，Promise.reject() 无论接收什么类型的参数，都会原封不动的向后传递！\n\n\n# 1.7 Promise.all()\n\nPromise.all() 关注多个 Promise 对象的状态变化。\n\n可以传入多个 Promise 实例，包装成一个新的 Promise 实例返回。\n\n/*\nPromise.all() 的状态变化与所有传入的 Promise 实例对象状态有关\n所有状态都变成 resolved，最终的状态才会变成 resolved\n只要有一个变成 rejected，最终的状态就变成 rejected\n用途举例：在用 Ajax 从后端接口获取数据的时候，如果全部获取到了，那么才处理，否则不处理。\n*/\n\nconst delay = ms => {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n};\n\n// 示例一：所有状态都变为 resolved\nconst p1 = delay(1000).then(() => {\n    console.log(\'p1 完成了\');\n    return \'p1\';\n});\nconst p2 = delay(2000).then(() => {\n    console.log(\'p2 完成了\');\n    return \'p2\';\n});\nconst p = Promise.all([p1, p2]);\np.then(res => {\n    console.log(res + " 成功");\n}, err => {\n    console.log(err + " 失败");\n});\n\n/*\np1 完成了\np2 完成了\np1,p2 成功\n*/\n/*\n解释：\n1、Promise.all() 直接执行两个 Promise 实例\n2、执行 p1，输出 p1 完成了\n3、检测到 resolved，Promise.all() 继续执行\n4、执行 p2，输出 p2 完成了\n5、检测到 resolved，由于 Promise 已经全部执行完，所以执行 then 第一个回调输出 p1,p2 成功，Promise.all() 终止。\n*/\n\n// 示例二：出现一个 rejected 状态\nconst p1 = delay(1000).then(() => {\n    console.log(\'p1 完成了\');\n    return Promise.reject(\'p1\');\n});\nconst p2 = delay(2000).then(() => {\n    console.log(\'p2 完成了\');\n    return \'p2\';\n});\nconst p = Promise.all([p1, p2]);\np.then(res => {\n    console.log(res + " 成功");\n}, err => {\n    console.log(err + " 失败");\n});\n/*\np1 完成了\np1 失败\np2 完成了\n*/\n/*\n解释：\n1、Promise.all() 直接执行两个 Promise 实例\n2、执行 p1，输出 p1 完成了\n3、检测到 rejected，Promise.all() 直接变为 rejected，执行 then 第二个回调输出 p1 失败，至此 Promise.all() 已经执行完毕。\n4、由于 p2 延迟了两秒执行所以在后面输出（如果 p2 延时小于 p1，那么应该先输出 p2 完成了，然后在是 p1 完成了，p1 失败）\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 1.8 Promise.race()和Promise.allSettled()\n\n * Promise.race()\n\nPromise.race() 的状态取决于第一个完成的 Promise 实例对象，如果第一个完成的成功了，那么最终就是成功的；如果第一个完成的失败了，那么最终就是失败的。\n\n * Promise.allSettled()\n\nPromise.allSettled() 的状态与传入的 Promise 状态无关。\n\n它永远都是成功的，只会执行 then 的第一个回调函数。\n\n用途：用于记录下各个 Promise 的表现。\n\n\n\n\n# 1.9 Promise的注意事项\n\n# 1.9.1 resolve或reject执行后的代码\n\nresolve或reject后的代码依旧是会执行的，但是极度不推荐这么做。\n\n为了确保安全，推荐在调用 resolve 或 reject 函数的时候加上 return，不再执行它们后面的代码。\n\nnew Promise((resolve, reject) => {\n    resolve();\n    console.log(\'hi\');\t// hi\n});\n\n// 推荐加上 return\nnew Promise((resolve, reject) => {\n    return resolve();\n    // console.log(\'hi\');\t// 不输出\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.9.2 Promise.all/race/allSettled的参数问题\n\n * 参数如果不是 Promise 数组，会将不是 Promise 数组的元素转变成 Promise 对象且是成功态的。\n\n// 举例：\nPromise.all([1, 2, 3]).then(datas => {\n    console.log(datas);\n});\n\n// 等价于：\nPromise.all([\n    Promise.resolve(1),\n    Promise.resolve(2),\n    Promise.resolve(3)\n]).then(datas => {\n    console.log(datas);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 不只是数组，任何可遍历的类型都可以作为参数\n\n依旧是会将其转变成 Promise 对象且是成功态的。\n\n> 原生可遍历：数组、字符串、Set、Map、NodeList、arguments 非原生可遍历：迭代器\n\n# 1.9.3 Promise.all/race/allSettled的错误处理\n\n * 单独处理：在每一个 Promise 对象后用 catch() 单独处理\n * 统一处理：在 Promise.all/race/allSettled 后用 catch() 统一处理\n\n> 注意：某个错误一但处理过一次，那么就不会在后续再被处理了。\n\n\n# 1.10 Promise的应用\n\n【异步加载图片】\n\n异步加载：也称为图片的预加载。利用 js 代码提前加载图片，用户需要时可以直接从本地缓存获取，但是会增加服务器前端的压力。这样做可以提高用户的体验，因为同步加载大图片的时候，图片会一层一层的显示处理，但是经过预加载后，直接显示出整张图片。\n\n <!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8"/>\n    <title>Promise 的应用</title>\n    <style>\n        #img {\n            width: 24%;\n            padding: 24px;\n        }\n    </style>\n</head>\n<body>\n\x3c!-- 一般加载图片方式 --\x3e\n\x3c!-- <img src="https://scpic.chinaz.net/files/pic/pic9/202009/apic27858.jpg" alt=""/> --\x3e\n<img src="" alt="" id="img">\n\n<script>\n    // 异步加载图片\n    // 异步加载图片函数（参数：图片路径）\n    const loadImgAsync = url => {\n        // Promise 实现异步\n        return new Promise((resolve, reject) => {\n            // 创建一个图片对象\n            const img = new Image();\n\n            // 图片成功加载触发事件\n            img.onload = () => {\n                resolve(img);\n            };\n\n            // 图片加载失败触发事件\n            img.onerror = () => {\n                reject(new Error(`Could not load image at ${url}`));\n            };\n\n            // 这个放在 onload 与 onerror 之后\n            // 一但给 img.src 赋值，那么便立马开始发送请求加载图片（在后台加载，页面上不会显示）\n            // 注意：这里的 src 是 img 对象的属性，与 html 中 img 的 src 无关\n            img.src = url;\n        });\n    };\n\n    const imgDOM = document.getElementById(\'img\');\n    loadImgAsync(\'https://scpic.chinaz.net/files/pic/pic9/202009/apic27858.jpg\')\n        .then(img => {\n            // 如果加载成功，那么把后台缓存的图片显示到页面上\n            imgDOM.src = img.src;\n        })\n        .catch(err => {\n            console.log(err);\n        });\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n\n\n# 二、Class类\n\n\n# 2.1 认识Class\n\n类：人类、狗类\n\n实例、对象：中国人、藏獒\n\n> 类可以看作是对象的模板，用一个类可以创建出许多不同的对象。\n\n\n# 2.2 Class的基本用法\n\nclass Person{}\n\n注意：类名 Person 后没有 ()，同时 {} 后也不应该加 ;。\n\n每一个类中都包含一个构造方法，这个构造方法可以手动写出来，也可以不写，如果手动不写那么浏览器也会默认自动添加。\n\nclass Person {\n    // 实例化时执行构造方法，所以必须有构造方法，但可以不写出来\n    constructor() {\n        console.log("构造方法自动执行");\n    }\n}\n\n// 实例化一个 Person 对象（必须采用 new 语法）\nconst p = new Person();\t\t// 构造方法自动执行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通常情况下，我们会在构造函数中进行对象属性初始化。\n\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst zjr = new Person(\'jerry\', 18);\nconsole.log(zjr.name);\t\t// jerry\nconsole.log(zjr.age);\t\t// 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在构造函数中，我们确实可以添加方法，但是不建议这么做，因为这样的处理方式会导致每一个实例的对象中都单独保存了一份该方法，造成内存的浪费。\n\n我们应该将方法写在 class 类中，这样所有的对象都共享同一个方法。\n\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n        this.speak = () => {\n            console.log(this.name + " say Hi!");\n        }\n    }\n}\n\nconst zjr = new Person(\'jerry\', 18);\nzjr.speak();\t// jerry say Hi!\n\nconst lxy = new Person(\'Dragon\', 18);\nlxy.speak();\t// Dragon say Hi!\n\nconsole.log(zjr.speak === lxy.speak);\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// 一般我们把属性定义在构造方法中，把方法定义在类中\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 方法定义在类中的写法\n    speak() {\n        console.log(this.name + " say Hi!");\n    }\n}\n\nconst zjr = new Person(\'jerry\', 18);\nzjr.speak();\t// jerry say Hi!\n\nconst lxy = new Person(\'Dragon\', 18);\nlxy.speak();\t// Dragon say Hi!\n\nconsole.log(zjr.speak === lxy.speak);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.3 Class与构造函数\n\n将上述的 Class 改造为之前学习过的构造函数：\n\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.speak = function() {\n    console.log(this.name + " sya Hi!");\n}\n\nconst zjr = new Person(\'jarry\', 18);\nzjr.speak();\t// jerry say Hi!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> Class 与 构造函数 的关系：\n> \n> 在 ES6 之前，要在 JavaScript 中实现面向对象编程，便要借助于构造函数。\n> \n> 在 ES6 之后，实现面向对象编程便可以使用 Class。\n> \n> 推荐：以后的面向对象编程请优先使用 Class。\n> \n> > Class 的底层实现机制还是 构造函数 的再次封装！\n> > \n> > 例如：console.log(typeof Person); 结果为：function，所以 Class 的底层实际上还是构造函数。\n> > \n> > 例如：console.log(Person.prototype.speak); 结果可以得到 speak 函数，所以 Class 底层实际上是构造函数，且依旧有原型。\n> > \n> > 甚至，我们可以给 Person 的原型上添加方法，依旧可以达到相应的效果，但是极不推荐这样做！\n\n\n# 2.4 Class的两种定义形式\n\n# 2.4.1 声明形式\n\nclass Person {\n    constructor() {\n        ...\n    }\n    speak() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2.4.2 表达式形式\n\n// 匿名 class 赋给一个变量\nconst Person = class {\n    constructor() {\n        ...\n    }\n    speak() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由于匿名函数可以实现立即执行函数，所以我们模仿立即执行函数的方式也可以实现立即执行类。\n\nnew (class {\n    constructor() {\n        console.log("constructor");\t\t// constructor\n    }\n})();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.5 实例属性、静态方法和静态属性\n\n# 2.5.1 实例属性\n\n我们之前将类的属性利用 this 的方式写在了构造方法里，把类的方法写在了 class 里。\n\n现在我们还可以把类的属性和方法写在 class 里，然后在构造方法里进行值的修改，或者是提供一个 get set 方法来间接控制变量。\n\nclass Person {\n    _age = 0;        // 类属性之前不能加 var 或 let\n    _sex = \'male\';   // 类属性被赋予的值相当于就是属性的默认值\n    \n    /*\n    // get、set 还可以用这样的格式来写\n    // 这里其实本质上就是定义一个类属性，只不过这个属性指向一个函数而已\n    getSex = function() {\n        return this._age;\n    };\n    */\n\n    get age() {\n        return this._age;\n    }\n\n    set age(value) {\n        this._age = value;\n    }\n\n    get sex() {\n        return this._sex;\n    }\n\n    set sex(value) {\n        this._sex = value;\n    }\n\n    constructor(age, sex) {\n        this._age = age;\n        this._sex = sex;\n    }\n\n    // 类的方法不能用 function 关键字\n    speak() {\n        console.log(this._age + " " + this._sex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 2.5.2 静态方法\n\n对于类的普通方法，我们要调用它，必须先实例化对象，然后再用对象来 “打点” 调用。\n\n如果我们要想直接利用类来调用，那么就要在类中创建静态方法。\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n    \n    // 除了类的静态方法之外，是可以定义类的同名普通方法的\n    speak() {\n        console.log("说话");\n    }\n    \n    static speak() {\n        console.log("人类可以说话")\n    }\n}\n\n// 一个是类的方法（静态方法），一个是实例对象的方法（普通方法），所以不会冲突\nPerson.speak();\t\t// 人类可以说话\nconst p = new Person(\'Alex\', 18);\np.speak();\t\t\t// 说话\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n静态方法的 this 指向问题：静态方法的 this 指向这个类本身。\n\n注意：普通方法 this 指向具体的对象，而静态方法的 this 指向类本身。\n\nclass Person {\n    // 静态属性\n    static _name = "user";\n    static _age = 18;\n\n    constructor(name, age) {\n        this._name = name;\n        this._age = age;\n    }\n\n    static test() {\n        console.log("静态方法");\n    }\n\n    // 静态方法\n    static readme() {\n        // 静态方法中的 this 指向 Person 类本身\n        // 并且静态方法的 this 只能引用到类的静态属性及静态方法\n        console.log(this._name + " " + this._age);\n        this.test();\n    }\n}\n\nPerson.readme();\nconsole.log(Person._name);\n/*\nuser 18\n静态方法\nuser\n*/\n\n/*\n再次注意：静态方法中只能使用类的静态属性与静态方法\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.5.3 静态属性\n\n静态属性也就是类的属性，依旧使用 static 关键字。\n\n注意：静态属性 static 的定义方法目前只是一个提案，目前不推荐这样写！某些浏览器不支持。\n\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    // 目前不推荐 static 这种写法，因为还只是一个提案\n    // static version = "1.0";\n    \n    // 推荐利用静态方法来间接实现静态属性\n    static getVersion() {\n        return "1.0";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.6 私有属性和方法\n\nJavaScript 本身没有私有属性和方法，所以我们利用其它方式来实现私有化。\n\n// 方式一：在属性开头加上 _ 表示私有\nclass Person {\n    constructor(name) {\n        this._name = name;\n    }\n    \n    _speak() {\n        console.log("speak");\n    }\n    \n    getName() {\n        return this._name;\n    }\n}\n\nconst p = new Person(\'Alex\');\nconsole.log(p.name);\t// 报错！\n// console.log(p._name);\t// Alex，但是这样做就无意义了，违背了私有化的初衷\n\n/*\n注意：加下划线的方式实际上只是行业中约定俗成的一种方法，\n我们依旧可以通过 p._name，来访问，但是这样做就无意义了！所以这种方法的使用纯靠程序员自觉。\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8"/>\n    <title>Class私有属性</title>\n</head>\n<body>\n<script>\n    // 方式二：将私有属性和方法移出类（使用模块）\n    // 由于我们还没有学习过模块，所以我们目前用立即执行函数（闭包原理）来模拟\n    (function () {\n        let name = "";\n        let speak = function () {\n            console.log("speak");\n        }\n\n        class Person {\n            constructor(username) {\n                name = username;\n            }\n\n            getName() {\n                return name;\n            }\n\n            runSpeak() {\n                speak();\n            }\n        }\n\n        // 将类添加到全局作用域中暴露\n        window.Person = Person;\n    })();\n\n    const p = new Person(\'Alex\');\n    console.log(p.name);\t// 报错\n    console.log(p.getName());\t// Alex\n    p.runSpeak();\t// speak\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.7 extends\n\n# 2.7.1 子类继承父类\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n        this.say = function() {\n            console.log("say");\n        };\n    }\n    speak() {\n        console.log("speak");\n    };\n    static speak() {\n        console.log("static speak");\n    };\n}\nPerson.version = "1.0";\n\n// 子类继承\nclass Programmer extends Person {\n    constructor(name, sex) {\n        // 调用父类的构造方法\n        super(name, sex);\n    }\n}\n\n// 测试\nconst zjr = new Programmer(\'jerry\', \'男\');\nconsole.log(zjr.name);\t\t\t\t// jerry\nconsole.log(zjr.sex);\t\t\t\t// 男\nzjr.say();\t\t\t\t\t\t   // say\nzjr.speak();\t\t\t\t\t   // speak\nProgrammer.speak();\t\t\t\t    // static speak\nconsole.log(Programmer.version);\t // 1.0 \n// 由此可见，子类集成了父类所以属性及方法！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.7.2 改写继承的属性或方法\n\nclass Person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n        this.say = function () {\n            console.log("say");\n        };\n    }\n\n    speak() {\n        console.log("speak");\n    };\n\n    static speak() {\n        console.log("static speak");\n    };\n}\n\nPerson.version = "1.0";\n\n// 子类继承\nclass Programmer extends Person {\n    constructor(name, sex, age) {\n        // 调用父类的构造方法，super 必须在子类构造方法第一行写\n        super(name, sex);\n        // 改写父类属性\n        this.name = \'zjr\';\n        // 新增子类属性\n        this.age = age;\n    }\n\n    // 改写父类属性\n    speak() {\n        console.log("子类 speak");\n    }\n\n    // 新增子类属性\n    hi() {\n        console.log("Hi!");\n    }\n}\n\nconst zjr = new Programmer(\'jerry\', \'男\', 18);\nconsole.log(zjr.name);\t\t// zjr\nconsole.log(zjr.sex);\t\t// 男\nconsole.log(zjr.age);\t\t// 18\nzjr.speak();\t\t\t   // 子类 speak\nzjr.say();\t\t\t\t   // say\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 2.8 super\n\n# 2.8.1 作为函数调用\n\n// super 作为函数使用，代表了父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错\nclass Person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n}\n\nclass Programmer extends Person {\n    constructor(name, sex) {\n        super(name, sex);\n        // super 虽然代表了父类的构造方法，但是内部的 this 指向子类的实例\n        // 当然 super 中的 this 是隐含的，不能显示的写出来，否则会报错！\n    }\n}\n\nconst zjr = new Programmer(\'jerry\', \'男\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2.8.2 作为对象使用\n\n// super 作为对象使用，代表了父类的原型对象 Person.prototype\n// 所以我们可以通过 super 访问父类的方法了\nclass Person {\n    name = "Person";\n\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n\n    speak() {\n        console.log("speak");\n    }\n\n    static speak() {\n        console.log("static speak");\n        console.log(this.name);\n    }\n}\n\nclass Programmer extends Person {\n    name = "Programmer";\n\n    constructor(name, sex) {\n        super(name, sex);\n        // 在构造方法中使用\n        super.speak();\n    }\n\n    speak() {\n        // 在一般方法中使用\n        super.speak();\n        console.log("子类 speak");\n    }\n\n    static speak() {\n        // 在静态方法中使用\n        // 指向父类，而不是父类的原型对象\n        // 原因是：我们此时调用的是父类的方法（静态方法属于父类），而不是父类原型对象上的方法\n        super.speak();\n        console.log("重写 static speak");\n        // 通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例\n    }\n}\n\nconst zjr = new Programmer(\'jerry\', \'男\');\nzjr.speak();\nProgrammer.speak();\n\n/*\nspeak\nspeak\n子类 speak\nstatic speak\nProgrammer\n重写 static speak\n*/\n\n// 注意：super.name 是 undefined！\n// 因为 super 作为对象是表示父类的原型对象 Person.prototype，而原型对象上并没有父类属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n',normalizedContent:'# 一、promise\n\n\n# 1.1 promise 是什么？\n\npromise 是异步操作的一种解决方案。\n\n# 异步的概念\n\n异步（asynchronous, async）是与同步（synchronous, sync）相对的概念。\n\n在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。\n\n简单来理解就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。\n\n以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：异步就是从主线程发射一个子线程来完成任务。\n\n\n\n# 什么时候用异步编程\n\n在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。\n\n现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。\n\n为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情（或者是一些需要等待某个时机在背后自动执行的任务，比如：事件监听），比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。\n\njavascript 是单线程语言，为了解决多线程问题，javascript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。\n\n# 回调函数（callback function）\n\n在 javascript 中，回调函数具体的定义为：函数a 作为参数（函数引用）传递到另一个 函数b 中，并且这个 函数b 执行函数a。我们就说 函数a 叫做回调函数。如果没有名称（函数表达式），就叫做匿名回调函数。\n\n回调函数就是一个作为参数的函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。\n\n注意：回调和异步不是同一个东西，许多人误认为 js 中每个回调函数都是异步处理的，实际上并不是，可以同步回调，也可以异步回调。只不过说：回调可以是同步也可以是异步，异步必须放在回调里执行，也就是对于一个异步任务只有回调函数里的才是异步的部分。\n\n回调同步的例子：\n\nconst test = function (func) {\nfunc();\n}\n\ntest(() => {\nconsole.log(\'func\');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n回调异步的例子：\n\nsettimeout(()=>{\nconsole.log(\'one\');\n}, 3000);\nconsole.log(\'two\');\n\n\n1\n2\n3\n4\n\n\n\n# 实例\n\nsetinterval() 和 settimeout() 是两个异步语句。\n\n异步（asynchronous）：不会阻塞 cpu 继续执行其他语句，当异步完成时（包含回调函数的主函数的正常语句完成时），会执行 “回调函数”（callback）。\n\n<!doctype html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo"></p>\n<p>异步方式，不影响后续执行。</p>\n<script>\n  function print() {\n      document.getelementbyid("demo").innerhtml = "runoob!";\n  }\n  settimeout(print, 3000);\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n\n这段程序中的 settimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 "print"，在命令行输出 "runoob!"。\n\n当然，javascript 语法十分友好，我们不必单独定义一个函数 print ，我们常常将上面的程序写成：\n\n\n# 实例\n\n<!doctype html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo"></p>\n<p>异步方式，不影响后续执行。</p>\n<script>\nsettimeout(function () {\n  document.getelementbyid("demo").innerhtml = "runoob!";\n}, 3000);\n/* es6 箭头函数写法\nsettimeout(() => {\n  document.getelementbyid("demo").innerhtml = "runoob!";\n}, 3000);\n*/\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n注意： 既然 settimeout 会在子线程中等待 3 秒，在 settimeout 函数执行之后主线程并没有停止，所以：\n\n\n# 实例\n\n<!doctype html>\n<html>\n\n<head>\n<meta charset="utf-8">\n<title>菜鸟教程(runoob.com)</title>\n</head>\n\n<body>\n\n<p>回调函数等待 3 秒后执行。</p>\n<p id="demo1"></p>\n<p id="demo2"></p>\n<script>\nsettimeout(function () {\n  document.getelementbyid("demo1").innerhtml = "runoob-1!";\n}, 3000);\ndocument.getelementbyid("demo2").innerhtml = "runoob-2!";\n<\/script>\n\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段程序的执行结果是： （之前常用的异步操作解决方案是：回调函数）\n\ndocument.addeventlistener(\n    \'click\',\n    () => {\n        console.log(\'这里是异步的\');\n    },\n    false\n);\nconsole.log(\'这里是同步的\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n什么时候使用 promise 呢？\n\npromise 一般用来解决层层嵌套的回调函数（回调地狱 callback hell）的问题。\n\n例如下面展示两个回调地狱的例子：\n\n例子1：分别间隔一秒打印省市县\n\n<!doctype html>\n<html lang="zh">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>回调举例</title>\n</head>\n\n<body>\n<script>\n    /*\n    // 此种方式，省市县都会在一秒后同时打印，没有实现要求\n    settimeout(() => {\n        console.log("云南省");\n    }, 1000);\n    settimeout(() => {\n        console.log("玉溪市");\n    }, 1000);\n    settimeout(() => {\n        console.log("峨山县");\n    }, 1000);\n    */\n\n    // 通过回调函数的方式，实现异步\n    settimeout(() => {\n        console.log("云南省");\n        let str01 = "云南省";\n        settimeout(() => {\n            console.log(str01 + "玉溪市");\n            let str02 = "云南省玉溪市";\n            settimeout(() => {\n                console.log(str02 + "峨山县");\n            }, 1000, str02);\n        }, 1000, str01);\n    }, 1000);\n    console.log("通过回调函数的方式，实现异步");\n<\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n\n例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8"/>\n    <title>promise</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n\n        #box {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n            transition: all 0.5s;\n        }\n    </style>\n</head>\n<body>\n<div id="box"></div>\n<script>    \n    // 运动函数\n    const move = (el, {x = 0, y = 0} = {}, end = () => {}) => {\n        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n        el.addeventlistener(\n            // transitionend 事件在 css 完成过渡后触发。\n            \'transitionend\',\n            () => {\n                end();\n            },\n            false\n        );\n    };\n\n    const boxel = document.getelementbyid(\'box\');\n\n    // 形成回调地狱\n    document.addeventlistener(\n        \'click\',\n        () => {\n            move(boxel, {x: 150}, () => {\n                move(boxel, {x: 150, y: 150}, () => {\n                    move(boxel, {y: 150}, () => {\n                        move(boxel, {x: 0, y: 0});\n                    });\n                });\n            });\n        },\n        false\n    );\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 1.2 promise 的基本用法\n\n# 1.2.1 实例化构造函数生成实例对象\n\npromise 实质上是一个构造函数，所以我们一般通过实例化的方式来使用它。\n\n# 1.2.2 promise 的状态\n\npromise 有三个状态：pending（等待）、fulfilled 或 resolved（成功）、rejected（失败）。\n\n并且 promise 必须接收一个回调函数，这个回调函数有两个参数，这两个参数也是两个函数，(resolve, reject) => {}。\n\n * 实例化 promise 后，默认是等待状态。\n\n * 当执行 resolve() 函数时，promise 从等待状态——>成功状态。\n\n * 当执行 reject() 函数时，promise 从等待状态——>失败状态。\n\n注意：当 promise 的状态一但从等待转变为某一个状态后，后续的转变就自动忽略了，比如：先调用 resolve() 再调用 reject()，那么 promise 的最终结果是成功状态。\n\n> 注意：这里的 resolve reject 只是一个形参，可以取任意名字，但是我们约定直接使用 resolve reject。\n\n# 1.2.3 then 方法\n\n当我们实例化 promise 后得到的 promise 对象便具有一个 then 方法。\n\nthen 方法具有两个回调函数作为参数 ()=>{}, ()=>{}。\n\n * 当 promise 对象为成功状态时就默认自动执行 then 方法的第一个回调函数\n * 当 promise 对象为失败状态时就默认自动执行 then 方法的第二个回调函数\n\n# 1.2.4 resolve 和 reject 函数的参数\n\nresolve() 和 reject() 函数是可以接收参数的。\n\n * resolve() 接收的参数会传递给 then 方法的第一个回调函数\n * reject() 接收的参数会传递给 then 方法的第二个回调函数\n\n注意：通常我们不仅仅会传递一个基本数据类型的值，我们还常常传递对象，比如再 reject 中传递一个错误对象：\n\nreject(new error("出错了！"));\n\n\n# 1.3 then()\n\n 1. then 方法的两个回调函数什么时候执行\n    \n    * pending——>resolved时，执行 then 的第一个回调函数\n    * pending——>rejected 时，执行 then 的第二个回调函数\n\n 2. then 方法执行后的返回值\n    \n    * then 方法执行后默认自动返回一个新的 promise 对象\n\n 3. then 方法返回的 promise 对象的状态改变\n    \n    * then 方法其实默认返回的是 undefined，即：return undefined，但是 es6 的机制规定：当 then 返回 undefined 时，那么会将这个 undefined 包装成一个 promise，并且这个 promise 默认调用了 resilve() 方法（成功态），并且把 undefined 作为了 resilve() 的参数，相当于：\n      \n      const p = new promise((resolve, reject) => {\n          resolve();\n      });\n      p.then(() => {\n          // 默认会执行这一条\n          // return undefined;\n      }, () => {\n      });\n      \n      // 实际上，return 会包装为一个 promise 对象，同时默认执行 resolve()，并把 return 的值作为 resolve() 的参数\n      /*\n      return new promise(resolve => {\n          resolve(undefined);\n      });\n      */\n      \n      // -----------------------------\n      // 如果我们在这个返回的 promise 上继续调用 then 方法，并接收参数的话，可以发现 then 中成功接收到了被 promise 包装后的参数\n      const p2 = new promise((resolve, reject) => {\n          resolve();\n      });\n      p2.then(() => {\n          // 默认会执行这一条\n          // return undefined;\n      }).then(data => {\n          console.log(data);  // 打印 undefined\n          // 手动 return 一个值\n          return 24;\n          // 相当于：return new promise(resolve => {resolve(24);});\n      }).then((data) => {\n          console.log(data);\t// 打印 24\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      30\n      31\n      32\n      \n    \n    * 如果我们要让 then 返回一个失败状态的 promise，那么我们可以手动 return 一个 promise 并执行 reject() 方法。\n      \n      const p3 = new promise((resolve, reject) => {\n          resolve();\n      });\n      p3.then(() => {\n          // 手动返回一个调用了 reject 的 promise\n          return new promise((resolve, reject) => {\n              reject("失败");\n          })\n      }).then(() => {}, errdata => {\n          console.log(errdata);\t// 失败\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n\n> 总结：promise 是一个构造函数，需要 new 才能使用。在 new promise() 的时候需要传递一个匿名回调函数作为 promise() 唯一的参数，这个回调函数有两个参数 resolve reject，这两个参数也是函数，当回调函数执行第一个 resolve 函数后 promise 便变为了成功状态，反之回调函数执行了 reject 后 promise 便变为了失败状态，且每个 promise 只能要么执行 resolve，要么执行 reject，不能同时执行！当 promise 被 new 之后就会有一个 then 方法，该方法默认接收两个匿名回调函数作为参数，其中第一个回调函数是在 promise 为成功状态时自动调用的，反之第二个回调函数是在 promise 为失败状态时自动调用的，并且这两个回调函数是可以接收参数的，参数就来自于 resolve 或 reject 调用时传递的实参！在 then 方法执行后会默认返回 undefined（在没有指定返回值的情况下），es6 会将其包装为一个新的成功态的 promise，该 promise 会自动执行 resolve 函数，该函数的参数来自于 then 方法的返回值（如果没有返回值那么默认就返回 undefined）。如果需要返回一个失败态的 promise，那么需要在 then 中手动指定返回值：\n> \n> return new promise((resolve, reject) => {\n> \treject(参数);\n> }\n> \n> \n> 1\n> 2\n> 3\n\n学习了以上知识，现在我们来用 promise 改造之前的两个回调地狱案例。\n\n案例一：分别间隔一秒打印省市县。\n\n<!doctype html>\n<html lang="zh">\n\n<head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>promise</title>\n</head>\n\n<body>\n<script>\n    // 通过 promise 的方式，解决回调地狱\n    new promise((resolve) => {\n        settimeout(() => {\n            console.log("云南省");\n            resolve("云南省");\n        }, 1000);\n    }).then(res => {\n        return new promise((resolve) => {\n            settimeout(() => {\n                console.log(res + "玉溪市");\n                resolve(res + "玉溪市");\n            }, 1000);\n        });\n    }).then(res => {\n        settimeout(() => {\n            console.log(res + "峨山县");\n        }, 1000);\n    });\n\n    console.log("通过 promise 的方式，实现异步");\n<\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n\n例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动。\n\n// 利用 promise 解决回调地狱问题\n// 例子2：当我们点击窗口后，盒子依次 “右——>下——>左” 移动\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8"/>\n    <title>promise</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n        }\n\n        #box {\n            width: 300px;\n            height: 300px;\n            background-color: red;\n            transition: all 0.5s;\n        }\n    </style>\n</head>\n<body>\n<div id="box"></div>\n<script>\n    // 运动函数\n    const move = (el, {x = 0, y = 0} = {}, end = () => {}) => {\n        el.style.transform = `translate3d(${x}px, ${y}px, 0)`;\n        el.addeventlistener(\n            // transitionend 事件在 css 完成过渡后触发。\n            \'transitionend\',\n            () => {\n                end();\n            },\n            false\n        );\n    };\n\n    const boxel = document.getelementbyid(\'box\');\n\n    const movepromise = (el, point) => {\n        return new promise(resolve => {\n            move(el, point, () => {\n                resolve();\n            });\n        });\n    };\n\n    document.addeventlistener(\n        \'click\', () => {\n            movepromise(boxel, {x: 150}).then(() => {\n                return movepromise(boxel, {x: 150, y: 150});\n            }).then(() => {\n                return movepromise(boxel, {y: 150});\n            }).then(() => {\n                movepromise(boxel, {x: 0, y: 0});\n            })\n        }, false);\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n通过上述两个改造后的例子，可以看到，promise 让原先回调的“嵌套”型模式转变为了 promise 的“并列”型模式，这就解决了回调地狱的问题。\n\n\n# 1.4 catch()\n\n由之前的例子可以看出，我们在使用 promise 的时候，大部分情况下，我们只用 resolve() 方法（成功态），所以在 promise 回调函数中我们常常省略 reject 函数参数，在 then 中我们常常省略第二个回调函数。\n\n但是我们还是需要处理异步中的异常，所以 es6 中提供了我们一个 catch() 方法专门用来处理 promise 的异常部分（失败态）。\n\n * catch 专门用来处理 rejected 状态\n\n * catch 本质上是 then 的特例\n\nnew promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);   // 失败\n});\n\n// -------------------------------------\n// 上面的代码本质上等同于\nnew promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).then(null, err => {\n    console.log(err);\t// 失败\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n> 在 promise 中，一但出现了错误状态，那么这个错误是不会消失的，会一直向下传递，直到遇到可以处理错误的函数。\n\n由于 catch 是 then 的特例，所以 catch 依旧返回的是一个 promise 对象，我们可以在 catch 后继续调用 then。\n\nnew promise((resolve, reject) => {\n    reject("失败");\n}).then(res => {\n    console.log(res);\n}).catch(err => {\n    console.log(err);   // 失败\n    return "测试";\n}).then(res => {\n   console.log(res);\t// 测试 \n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 一般总是建议，promise 对象后面要跟一个或多个 catch 方法，这样可以处理 promise 内部发生的错误！\n\n\n# 1.5 finally()\n\n当 promise 状态发生变化时，不论如何变化都会执行，不变化不执行。\n\n * finally() 不能接收参数。\n\n * finally 也是 then 的特例。\n\nnew promise(resolve => {\n    resolve("测试01");\n}).finally(data => {\n    console.log(data + " finally01");\n    return new promise((resolve, reject) => {\n        reject("测试02");\n    })\n}).finally(data => {\n    console.log(data + " finally02")\n}).catch(err => {\n    console.log("catch: " + err);\n});\n\n/*\nundefined finally01\nundefined finally02\ncatch: 测试02\n*/\n\n// 从以上示例可以看出：finally 可以接收正确状态或错误状态，但是不能接收参数。\n\n// -------------------------------------\n// finally 也是 then 的特例\n// finally 等同于：\nnew promise((resolve, reject) => {\n    ...\n}).then(res => {\n    return res;\n}, err => {\n    return new promise((resolve, reject) => {\n        reject(err);\n    })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nfinally：主要是用来处理一些必做操作，比如在操作数据库之后（无论成功与否）都要关闭数据库连接。\n\n\n# 1.6 promise.resolve()和promise.reject()\n\n以上两者都是 promise 构造函数的方法。\n\n> 下面我们以 promise.resolve() 举例，promise.reject() 同理。\n\n// promise.resolve() 可以理解为普通成功状态的一种简写形式\nnew promise(resolve => resolve(\'foo\'));\n// 简写\npromise.resolve(\'foo\');\n\n\n1\n2\n3\n4\n\n\npromise.resolve() 与 promise.reject() 的参数问题：\n\n1、一般参数\n\npromise.resolve(\'foo\').then(data => {\n    console.log(data);\n})\t// foo\n\n\n1\n2\n3\n\n\n2、特殊参数：promise 作为参数\n\nconst p1 = new promise(resolve => {\n    settimeout(resolve, 1000, \'我执行了\');\n    /*\n    上述延时器写法相当于：\n    settimeout(()=>{\n        resolve(\'我执行了\');\n    }, 1000);\n     */\n});\npromise.resolve(p1).then(data => {\n    console.log(data);\t// 等待一秒后，输出 \'我执行了\'\n});\n\n/*\n当 promise.resolve() 接收的是 promise 对象时，直接返回这个 promise 对象，什么都不做\n*/\n\n// 所以，以上代码等同于：\np1.then(data => {\n   console.log(data); // 等待一秒后，输出 \'我执行了\'\n});\n\n// 验证\nconsole.log(promise.resolve(p1) === p1);\t// true\n\n// 由于 promise.resolve() 可以理解为普通成功状态的一种简写形式，所以：\nnew promise(resolve => resolve(p1)).then(data => {\n   console.log(data); // 等待一秒后，输出 \'我执行了\'\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n3、特殊参数：具有 then 方法的对象（了解即可）\n\nconst thenable = {\n    then() {\n        console.log(\'then\');\n    }\n};\npromise.resolve(thenable).then(\n    res => console.log("res " + res),\n    err => console.log("err " + err)\n);\n\n/*\nthen\n*/\n\n// 当接收一个含 then 方法的对象时，promise.resolve() 会直接调用 then 方法。\n\n// 为什么不会执行 then 中的两个回调函数呢？\nconsole.log(promise.resolve(thenable));\n/*\npromise { <pending> }\nthen\n*/\n// 可见，当接收一个含 then 方法的对象时，默认返回一个 promise 并且是等待状态的，没有状态的变化，那么就不可能会执行 then 的回调函数\n// 如果我们要改变这个返回的 promise 对象的状态，并让 then 的回调对应处理的话，es6 规定了以下写法：\nconst thenable02 = {\n    then(resolve, reject) {\n        console.log(\'then\');\n        resolve(\'then\');\n    }\n};\npromise.resolve(thenable02).then(\n    res => console.log("res " + res),\n    err => console.log("err " + err)\n);\n/*\nthen\nres then\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n> 与 promise.resolve() 不同，promise.reject() 无论接收什么类型的参数，都会原封不动的向后传递！\n\n\n# 1.7 promise.all()\n\npromise.all() 关注多个 promise 对象的状态变化。\n\n可以传入多个 promise 实例，包装成一个新的 promise 实例返回。\n\n/*\npromise.all() 的状态变化与所有传入的 promise 实例对象状态有关\n所有状态都变成 resolved，最终的状态才会变成 resolved\n只要有一个变成 rejected，最终的状态就变成 rejected\n用途举例：在用 ajax 从后端接口获取数据的时候，如果全部获取到了，那么才处理，否则不处理。\n*/\n\nconst delay = ms => {\n    return new promise(resolve => {\n        settimeout(resolve, ms);\n    });\n};\n\n// 示例一：所有状态都变为 resolved\nconst p1 = delay(1000).then(() => {\n    console.log(\'p1 完成了\');\n    return \'p1\';\n});\nconst p2 = delay(2000).then(() => {\n    console.log(\'p2 完成了\');\n    return \'p2\';\n});\nconst p = promise.all([p1, p2]);\np.then(res => {\n    console.log(res + " 成功");\n}, err => {\n    console.log(err + " 失败");\n});\n\n/*\np1 完成了\np2 完成了\np1,p2 成功\n*/\n/*\n解释：\n1、promise.all() 直接执行两个 promise 实例\n2、执行 p1，输出 p1 完成了\n3、检测到 resolved，promise.all() 继续执行\n4、执行 p2，输出 p2 完成了\n5、检测到 resolved，由于 promise 已经全部执行完，所以执行 then 第一个回调输出 p1,p2 成功，promise.all() 终止。\n*/\n\n// 示例二：出现一个 rejected 状态\nconst p1 = delay(1000).then(() => {\n    console.log(\'p1 完成了\');\n    return promise.reject(\'p1\');\n});\nconst p2 = delay(2000).then(() => {\n    console.log(\'p2 完成了\');\n    return \'p2\';\n});\nconst p = promise.all([p1, p2]);\np.then(res => {\n    console.log(res + " 成功");\n}, err => {\n    console.log(err + " 失败");\n});\n/*\np1 完成了\np1 失败\np2 完成了\n*/\n/*\n解释：\n1、promise.all() 直接执行两个 promise 实例\n2、执行 p1，输出 p1 完成了\n3、检测到 rejected，promise.all() 直接变为 rejected，执行 then 第二个回调输出 p1 失败，至此 promise.all() 已经执行完毕。\n4、由于 p2 延迟了两秒执行所以在后面输出（如果 p2 延时小于 p1，那么应该先输出 p2 完成了，然后在是 p1 完成了，p1 失败）\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 1.8 promise.race()和promise.allsettled()\n\n * promise.race()\n\npromise.race() 的状态取决于第一个完成的 promise 实例对象，如果第一个完成的成功了，那么最终就是成功的；如果第一个完成的失败了，那么最终就是失败的。\n\n * promise.allsettled()\n\npromise.allsettled() 的状态与传入的 promise 状态无关。\n\n它永远都是成功的，只会执行 then 的第一个回调函数。\n\n用途：用于记录下各个 promise 的表现。\n\n\n\n\n# 1.9 promise的注意事项\n\n# 1.9.1 resolve或reject执行后的代码\n\nresolve或reject后的代码依旧是会执行的，但是极度不推荐这么做。\n\n为了确保安全，推荐在调用 resolve 或 reject 函数的时候加上 return，不再执行它们后面的代码。\n\nnew promise((resolve, reject) => {\n    resolve();\n    console.log(\'hi\');\t// hi\n});\n\n// 推荐加上 return\nnew promise((resolve, reject) => {\n    return resolve();\n    // console.log(\'hi\');\t// 不输出\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 1.9.2 promise.all/race/allsettled的参数问题\n\n * 参数如果不是 promise 数组，会将不是 promise 数组的元素转变成 promise 对象且是成功态的。\n\n// 举例：\npromise.all([1, 2, 3]).then(datas => {\n    console.log(datas);\n});\n\n// 等价于：\npromise.all([\n    promise.resolve(1),\n    promise.resolve(2),\n    promise.resolve(3)\n]).then(datas => {\n    console.log(datas);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 不只是数组，任何可遍历的类型都可以作为参数\n\n依旧是会将其转变成 promise 对象且是成功态的。\n\n> 原生可遍历：数组、字符串、set、map、nodelist、arguments 非原生可遍历：迭代器\n\n# 1.9.3 promise.all/race/allsettled的错误处理\n\n * 单独处理：在每一个 promise 对象后用 catch() 单独处理\n * 统一处理：在 promise.all/race/allsettled 后用 catch() 统一处理\n\n> 注意：某个错误一但处理过一次，那么就不会在后续再被处理了。\n\n\n# 1.10 promise的应用\n\n【异步加载图片】\n\n异步加载：也称为图片的预加载。利用 js 代码提前加载图片，用户需要时可以直接从本地缓存获取，但是会增加服务器前端的压力。这样做可以提高用户的体验，因为同步加载大图片的时候，图片会一层一层的显示处理，但是经过预加载后，直接显示出整张图片。\n\n <!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8"/>\n    <title>promise 的应用</title>\n    <style>\n        #img {\n            width: 24%;\n            padding: 24px;\n        }\n    </style>\n</head>\n<body>\n\x3c!-- 一般加载图片方式 --\x3e\n\x3c!-- <img src="https://scpic.chinaz.net/files/pic/pic9/202009/apic27858.jpg" alt=""/> --\x3e\n<img src="" alt="" id="img">\n\n<script>\n    // 异步加载图片\n    // 异步加载图片函数（参数：图片路径）\n    const loadimgasync = url => {\n        // promise 实现异步\n        return new promise((resolve, reject) => {\n            // 创建一个图片对象\n            const img = new image();\n\n            // 图片成功加载触发事件\n            img.onload = () => {\n                resolve(img);\n            };\n\n            // 图片加载失败触发事件\n            img.onerror = () => {\n                reject(new error(`could not load image at ${url}`));\n            };\n\n            // 这个放在 onload 与 onerror 之后\n            // 一但给 img.src 赋值，那么便立马开始发送请求加载图片（在后台加载，页面上不会显示）\n            // 注意：这里的 src 是 img 对象的属性，与 html 中 img 的 src 无关\n            img.src = url;\n        });\n    };\n\n    const imgdom = document.getelementbyid(\'img\');\n    loadimgasync(\'https://scpic.chinaz.net/files/pic/pic9/202009/apic27858.jpg\')\n        .then(img => {\n            // 如果加载成功，那么把后台缓存的图片显示到页面上\n            imgdom.src = img.src;\n        })\n        .catch(err => {\n            console.log(err);\n        });\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n\n\n# 二、class类\n\n\n# 2.1 认识class\n\n类：人类、狗类\n\n实例、对象：中国人、藏獒\n\n> 类可以看作是对象的模板，用一个类可以创建出许多不同的对象。\n\n\n# 2.2 class的基本用法\n\nclass person{}\n\n注意：类名 person 后没有 ()，同时 {} 后也不应该加 ;。\n\n每一个类中都包含一个构造方法，这个构造方法可以手动写出来，也可以不写，如果手动不写那么浏览器也会默认自动添加。\n\nclass person {\n    // 实例化时执行构造方法，所以必须有构造方法，但可以不写出来\n    constructor() {\n        console.log("构造方法自动执行");\n    }\n}\n\n// 实例化一个 person 对象（必须采用 new 语法）\nconst p = new person();\t\t// 构造方法自动执行\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n通常情况下，我们会在构造函数中进行对象属性初始化。\n\nclass person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n\nconst zjr = new person(\'jerry\', 18);\nconsole.log(zjr.name);\t\t// jerry\nconsole.log(zjr.age);\t\t// 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在构造函数中，我们确实可以添加方法，但是不建议这么做，因为这样的处理方式会导致每一个实例的对象中都单独保存了一份该方法，造成内存的浪费。\n\n我们应该将方法写在 class 类中，这样所有的对象都共享同一个方法。\n\nclass person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n        this.speak = () => {\n            console.log(this.name + " say hi!");\n        }\n    }\n}\n\nconst zjr = new person(\'jerry\', 18);\nzjr.speak();\t// jerry say hi!\n\nconst lxy = new person(\'dragon\', 18);\nlxy.speak();\t// dragon say hi!\n\nconsole.log(zjr.speak === lxy.speak);\t// false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// 一般我们把属性定义在构造方法中，把方法定义在类中\nclass person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // 方法定义在类中的写法\n    speak() {\n        console.log(this.name + " say hi!");\n    }\n}\n\nconst zjr = new person(\'jerry\', 18);\nzjr.speak();\t// jerry say hi!\n\nconst lxy = new person(\'dragon\', 18);\nlxy.speak();\t// dragon say hi!\n\nconsole.log(zjr.speak === lxy.speak);\t// true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.3 class与构造函数\n\n将上述的 class 改造为之前学习过的构造函数：\n\nfunction person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nperson.prototype.speak = function() {\n    console.log(this.name + " sya hi!");\n}\n\nconst zjr = new person(\'jarry\', 18);\nzjr.speak();\t// jerry say hi!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> class 与 构造函数 的关系：\n> \n> 在 es6 之前，要在 javascript 中实现面向对象编程，便要借助于构造函数。\n> \n> 在 es6 之后，实现面向对象编程便可以使用 class。\n> \n> 推荐：以后的面向对象编程请优先使用 class。\n> \n> > class 的底层实现机制还是 构造函数 的再次封装！\n> > \n> > 例如：console.log(typeof person); 结果为：function，所以 class 的底层实际上还是构造函数。\n> > \n> > 例如：console.log(person.prototype.speak); 结果可以得到 speak 函数，所以 class 底层实际上是构造函数，且依旧有原型。\n> > \n> > 甚至，我们可以给 person 的原型上添加方法，依旧可以达到相应的效果，但是极不推荐这样做！\n\n\n# 2.4 class的两种定义形式\n\n# 2.4.1 声明形式\n\nclass person {\n    constructor() {\n        ...\n    }\n    speak() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 2.4.2 表达式形式\n\n// 匿名 class 赋给一个变量\nconst person = class {\n    constructor() {\n        ...\n    }\n    speak() {\n        ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n由于匿名函数可以实现立即执行函数，所以我们模仿立即执行函数的方式也可以实现立即执行类。\n\nnew (class {\n    constructor() {\n        console.log("constructor");\t\t// constructor\n    }\n})();\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.5 实例属性、静态方法和静态属性\n\n# 2.5.1 实例属性\n\n我们之前将类的属性利用 this 的方式写在了构造方法里，把类的方法写在了 class 里。\n\n现在我们还可以把类的属性和方法写在 class 里，然后在构造方法里进行值的修改，或者是提供一个 get set 方法来间接控制变量。\n\nclass person {\n    _age = 0;        // 类属性之前不能加 var 或 let\n    _sex = \'male\';   // 类属性被赋予的值相当于就是属性的默认值\n    \n    /*\n    // get、set 还可以用这样的格式来写\n    // 这里其实本质上就是定义一个类属性，只不过这个属性指向一个函数而已\n    getsex = function() {\n        return this._age;\n    };\n    */\n\n    get age() {\n        return this._age;\n    }\n\n    set age(value) {\n        this._age = value;\n    }\n\n    get sex() {\n        return this._sex;\n    }\n\n    set sex(value) {\n        this._sex = value;\n    }\n\n    constructor(age, sex) {\n        this._age = age;\n        this._sex = sex;\n    }\n\n    // 类的方法不能用 function 关键字\n    speak() {\n        console.log(this._age + " " + this._sex);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n# 2.5.2 静态方法\n\n对于类的普通方法，我们要调用它，必须先实例化对象，然后再用对象来 “打点” 调用。\n\n如果我们要想直接利用类来调用，那么就要在类中创建静态方法。\n\nclass person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n    \n    // 除了类的静态方法之外，是可以定义类的同名普通方法的\n    speak() {\n        console.log("说话");\n    }\n    \n    static speak() {\n        console.log("人类可以说话")\n    }\n}\n\n// 一个是类的方法（静态方法），一个是实例对象的方法（普通方法），所以不会冲突\nperson.speak();\t\t// 人类可以说话\nconst p = new person(\'alex\', 18);\np.speak();\t\t\t// 说话\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n静态方法的 this 指向问题：静态方法的 this 指向这个类本身。\n\n注意：普通方法 this 指向具体的对象，而静态方法的 this 指向类本身。\n\nclass person {\n    // 静态属性\n    static _name = "user";\n    static _age = 18;\n\n    constructor(name, age) {\n        this._name = name;\n        this._age = age;\n    }\n\n    static test() {\n        console.log("静态方法");\n    }\n\n    // 静态方法\n    static readme() {\n        // 静态方法中的 this 指向 person 类本身\n        // 并且静态方法的 this 只能引用到类的静态属性及静态方法\n        console.log(this._name + " " + this._age);\n        this.test();\n    }\n}\n\nperson.readme();\nconsole.log(person._name);\n/*\nuser 18\n静态方法\nuser\n*/\n\n/*\n再次注意：静态方法中只能使用类的静态属性与静态方法\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.5.3 静态属性\n\n静态属性也就是类的属性，依旧使用 static 关键字。\n\n注意：静态属性 static 的定义方法目前只是一个提案，目前不推荐这样写！某些浏览器不支持。\n\nclass person {\n    constructor(name) {\n        this.name = name;\n    }\n    \n    // 目前不推荐 static 这种写法，因为还只是一个提案\n    // static version = "1.0";\n    \n    // 推荐利用静态方法来间接实现静态属性\n    static getversion() {\n        return "1.0";\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.6 私有属性和方法\n\njavascript 本身没有私有属性和方法，所以我们利用其它方式来实现私有化。\n\n// 方式一：在属性开头加上 _ 表示私有\nclass person {\n    constructor(name) {\n        this._name = name;\n    }\n    \n    _speak() {\n        console.log("speak");\n    }\n    \n    getname() {\n        return this._name;\n    }\n}\n\nconst p = new person(\'alex\');\nconsole.log(p.name);\t// 报错！\n// console.log(p._name);\t// alex，但是这样做就无意义了，违背了私有化的初衷\n\n/*\n注意：加下划线的方式实际上只是行业中约定俗成的一种方法，\n我们依旧可以通过 p._name，来访问，但是这样做就无意义了！所以这种方法的使用纯靠程序员自觉。\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8"/>\n    <title>class私有属性</title>\n</head>\n<body>\n<script>\n    // 方式二：将私有属性和方法移出类（使用模块）\n    // 由于我们还没有学习过模块，所以我们目前用立即执行函数（闭包原理）来模拟\n    (function () {\n        let name = "";\n        let speak = function () {\n            console.log("speak");\n        }\n\n        class person {\n            constructor(username) {\n                name = username;\n            }\n\n            getname() {\n                return name;\n            }\n\n            runspeak() {\n                speak();\n            }\n        }\n\n        // 将类添加到全局作用域中暴露\n        window.person = person;\n    })();\n\n    const p = new person(\'alex\');\n    console.log(p.name);\t// 报错\n    console.log(p.getname());\t// alex\n    p.runspeak();\t// speak\n<\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 2.7 extends\n\n# 2.7.1 子类继承父类\n\nclass person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n        this.say = function() {\n            console.log("say");\n        };\n    }\n    speak() {\n        console.log("speak");\n    };\n    static speak() {\n        console.log("static speak");\n    };\n}\nperson.version = "1.0";\n\n// 子类继承\nclass programmer extends person {\n    constructor(name, sex) {\n        // 调用父类的构造方法\n        super(name, sex);\n    }\n}\n\n// 测试\nconst zjr = new programmer(\'jerry\', \'男\');\nconsole.log(zjr.name);\t\t\t\t// jerry\nconsole.log(zjr.sex);\t\t\t\t// 男\nzjr.say();\t\t\t\t\t\t   // say\nzjr.speak();\t\t\t\t\t   // speak\nprogrammer.speak();\t\t\t\t    // static speak\nconsole.log(programmer.version);\t // 1.0 \n// 由此可见，子类集成了父类所以属性及方法！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.7.2 改写继承的属性或方法\n\nclass person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n        this.say = function () {\n            console.log("say");\n        };\n    }\n\n    speak() {\n        console.log("speak");\n    };\n\n    static speak() {\n        console.log("static speak");\n    };\n}\n\nperson.version = "1.0";\n\n// 子类继承\nclass programmer extends person {\n    constructor(name, sex, age) {\n        // 调用父类的构造方法，super 必须在子类构造方法第一行写\n        super(name, sex);\n        // 改写父类属性\n        this.name = \'zjr\';\n        // 新增子类属性\n        this.age = age;\n    }\n\n    // 改写父类属性\n    speak() {\n        console.log("子类 speak");\n    }\n\n    // 新增子类属性\n    hi() {\n        console.log("hi!");\n    }\n}\n\nconst zjr = new programmer(\'jerry\', \'男\', 18);\nconsole.log(zjr.name);\t\t// zjr\nconsole.log(zjr.sex);\t\t// 男\nconsole.log(zjr.age);\t\t// 18\nzjr.speak();\t\t\t   // 子类 speak\nzjr.say();\t\t\t\t   // say\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 2.8 super\n\n# 2.8.1 作为函数调用\n\n// super 作为函数使用，代表了父类的构造方法，只能用在子类的构造方法中，用在其他地方就会报错\nclass person {\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n}\n\nclass programmer extends person {\n    constructor(name, sex) {\n        super(name, sex);\n        // super 虽然代表了父类的构造方法，但是内部的 this 指向子类的实例\n        // 当然 super 中的 this 是隐含的，不能显示的写出来，否则会报错！\n    }\n}\n\nconst zjr = new programmer(\'jerry\', \'男\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2.8.2 作为对象使用\n\n// super 作为对象使用，代表了父类的原型对象 person.prototype\n// 所以我们可以通过 super 访问父类的方法了\nclass person {\n    name = "person";\n\n    constructor(name, sex) {\n        this.name = name;\n        this.sex = sex;\n    }\n\n    speak() {\n        console.log("speak");\n    }\n\n    static speak() {\n        console.log("static speak");\n        console.log(this.name);\n    }\n}\n\nclass programmer extends person {\n    name = "programmer";\n\n    constructor(name, sex) {\n        super(name, sex);\n        // 在构造方法中使用\n        super.speak();\n    }\n\n    speak() {\n        // 在一般方法中使用\n        super.speak();\n        console.log("子类 speak");\n    }\n\n    static speak() {\n        // 在静态方法中使用\n        // 指向父类，而不是父类的原型对象\n        // 原因是：我们此时调用的是父类的方法（静态方法属于父类），而不是父类原型对象上的方法\n        super.speak();\n        console.log("重写 static speak");\n        // 通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例\n    }\n}\n\nconst zjr = new programmer(\'jerry\', \'男\');\nzjr.speak();\nprogrammer.speak();\n\n/*\nspeak\nspeak\n子类 speak\nstatic speak\nprogrammer\n重写 static speak\n*/\n\n// 注意：super.name 是 undefined！\n// 因为 super 作为对象是表示父类的原型对象 person.prototype，而原型对象上并没有父类属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n',charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - 常用命令",frontmatter:{title:"Git - 常用命令",date:"2021-02-08T13:22:08.000Z",permalink:"/git/common-commands",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/03.Git%20-%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"40.工具/20.开发管理 - Git/03.Git - 常用命令.md",key:"v-615081d1",path:"/git/common-commands/",headers:[{level:2,title:"Git常用命令",slug:"git常用命令",normalizedTitle:"git常用命令",charIndex:62},{level:3,title:"本地命令",slug:"本地命令",normalizedTitle:"本地命令",charIndex:75},{level:3,title:"远程命令",slug:"远程命令",normalizedTitle:"远程命令",charIndex:85},{level:2,title:"设置用户签名",slug:"设置用户签名",normalizedTitle:"设置用户签名",charIndex:93},{level:3,title:"项目级别/仓库级别",slug:"项目级别-仓库级别",normalizedTitle:"项目级别/仓库级别",charIndex:105},{level:3,title:"系统用户级别",slug:"系统用户级别",normalizedTitle:"系统用户级别",charIndex:120},{level:3,title:"级别优先级",slug:"级别优先级",normalizedTitle:"级别优先级",charIndex:132},{level:3,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:143},{level:2,title:"初始化本地库",slug:"初始化本地库",normalizedTitle:"初始化本地库",charIndex:149},{level:2,title:"查看本地库状态",slug:"查看本地库状态",normalizedTitle:"查看本地库状态",charIndex:159},{level:2,title:"文件增删改操作",slug:"文件增删改操作",normalizedTitle:"文件增删改操作",charIndex:170},{level:3,title:"删除暂存区的文件",slug:"删除暂存区的文件",normalizedTitle:"删除暂存区的文件",charIndex:183},{level:3,title:"添加文件到暂存区",slug:"添加文件到暂存区",normalizedTitle:"添加文件到暂存区",charIndex:197},{level:3,title:"提交文件到本地库",slug:"提交文件到本地库",normalizedTitle:"提交文件到本地库",charIndex:211},{level:2,title:"历史版本操作",slug:"历史版本操作",normalizedTitle:"历史版本操作",charIndex:223},{level:3,title:"查看历史版本",slug:"查看历史版本",normalizedTitle:"查看历史版本",charIndex:235},{level:3,title:"切换历史版本",slug:"切换历史版本",normalizedTitle:"切换历史版本",charIndex:247},{level:2,title:"比较文件操作",slug:"比较文件操作",normalizedTitle:"比较文件操作",charIndex:257},{level:2,title:"分支操作",slug:"分支操作",normalizedTitle:"分支操作",charIndex:267},{level:3,title:"什么是分支？",slug:"什么是分支",normalizedTitle:"什么是分支？",charIndex:277},{level:3,title:"分支的好处？",slug:"分支的好处",normalizedTitle:"分支的好处？",charIndex:289},{level:3,title:"分支操作",slug:"分支操作-2",normalizedTitle:"分支操作",charIndex:267},{level:3,title:"分支冲突",slug:"分支冲突",normalizedTitle:"分支冲突",charIndex:311},{level:3,title:"创建分支和切换分支图解",slug:"创建分支和切换分支图解",normalizedTitle:"创建分支和切换分支图解",charIndex:321},{level:2,title:"分支进阶操作",slug:"分支进阶操作",normalizedTitle:"分支进阶操作",charIndex:336},{level:3,title:"删除所有记录",slug:"删除所有记录",normalizedTitle:"删除所有记录",charIndex:348},{level:3,title:"删除上次记录",slug:"删除上次记录",normalizedTitle:"删除上次记录",charIndex:360},{level:3,title:"同时修改本地分支名和对应的远程分支名",slug:"同时修改本地分支名和对应的远程分支名",normalizedTitle:"同时修改本地分支名和对应的远程分支名",charIndex:372}],headersStr:"Git常用命令 本地命令 远程命令 设置用户签名 项目级别/仓库级别 系统用户级别 级别优先级 说明 初始化本地库 查看本地库状态 文件增删改操作 删除暂存区的文件 添加文件到暂存区 提交文件到本地库 历史版本操作 查看历史版本 切换历史版本 比较文件操作 分支操作 什么是分支？ 分支的好处？ 分支操作 分支冲突 创建分支和切换分支图解 分支进阶操作 删除所有记录 删除上次记录 同时修改本地分支名和对应的远程分支名",content:'笔记\n\n下面我们学习 Git 在本地常用的命令，也是开发经常用到的命令。\n\n2022-02-08 @Du Wu\n\n\n\n * Git常用命令\n   * 本地命令\n   * 远程命令\n * 设置用户签名\n   * 项目级别/仓库级别\n   * 系统用户级别\n   * 级别优先级\n   * 说明\n * 初始化本地库\n * 查看本地库状态\n * 文件增删改操作\n   * 删除暂存区的文件\n   * 添加文件到暂存区\n   * 提交文件到本地库\n * 历史版本操作\n   * 查看历史版本\n   * 切换历史版本\n * 比较文件操作\n * 分支操作\n   * 什么是分支？\n   * 分支的好处？\n   * 分支操作\n   * 分支冲突\n   * 创建分支和切换分支图解\n * 分支进阶操作\n   * 删除所有记录\n   * 删除上次记录\n   * 同时修改本地分支名和对应的远程分支名\n\n\n\n\n# Git常用命令\n\n\n# 本地命令\n\n命令名称                                               作用\ngit config --global user.name 用户名                  设置用户签名\ngit config --global user.email 邮箱                  设置用户签名\ngit init                                           初始化本地库\ngit status                                         查看本地库状态\ngit add 文件名（-A 代表目录及子目录下所有文件名）                     添加到暂存区\ngit commit -m "日志信息" [文件名]（不加文件名，默认所有文件都添加该日志信息）   添加到本地库\ngit reflog                                         查看历史记录（简要）\ngit log                                            查看历史记录（详细）\ngit log --pretty=oneline                           一行显示一个版本信息（版本号完整）\ngit log --oneline                                  一行显示一个版本信息（版本号简写）\ngit reset --hard 版本号                               版本穿梭、跳转\ngit diff [文件名]                                     比较工作区中和暂存区的文件\ngit diff [本地库中历史版本] [文件名]                          比较工作区中的文件和本地库历史记录\ngit branch 分支名                                     创建分支\ngit branch -D 分支名                                  删除分支\ngit branch -m 新的分支名                                将当前分支名改为新的分支名\ngit branch -v                                      查看分支\ngit checkout 分支名                                   切换分支\ngit merge 分支名                                      合并分支\n\n\n# 远程命令\n\n命令名称                     作用\ngit remote -v            查看当前所有远程地址别名\ngit remote add 别名 远程地址   起别名\ngit push 别名 分支           推送本地分支上的内容到远程仓库\ngit clone 远程地址           将远程仓库的内容克隆到本地\ngit pull 远程库地址别名 远程分支名   将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并\n\n如果 git push 不加别名和分支，默认别名是 origin，分支是 master。\n\n我们 clone 项目会自动做如下操作：\n\n * 拉取代码\n * 初始化本地仓库\n * 创建别名，默认是 origin\n\n具体看 Git - SSH免密登录。\n\n\n# 设置用户签名\n\n\n# 项目级别/仓库级别\n\n仅在当前本地库范围内有效。\n\ngit config user.name 用户名\ngit config user.email 邮箱\n\n\n1\n2\n\n\n信息保存位置：./.git/config 文件里。\n\n\n# 系统用户级别\n\n登录当前操作系统的用户范围。\n\ngit config --global user.name 用户名\ngit config --global user.email 邮箱\n\n\n1\n2\n\n\n\n\n信息保存位置：设置了用户签名，会在用户盘下生成 .gitconfig 文件，里面也可以直接修改自己的信息。\n\n\n# 级别优先级\n\n * 就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名\n\n * 如果只有系统用户级别的签名，就以系统用户级别的签名为准\n\n * 二者都没有不允许\n\n\n# 说明\n\n签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。\n\n邮箱可以是虚拟邮箱，Git 不会去识别。\n\n注意：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。\n\n\n# 初始化本地库\n\n基本语法：\n\ngit init\n\n\n1\n\n\n该指令会将目录下的所有子目录以及文件交给 Git 管理，也是我们使用 Git 最重要的一步。\n\n执行该指令后，会在当前目录下生成 .git 目录，该目录默认是隐藏的。\n\n注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改。\n\n\n# 查看本地库状态\n\n查看工作区、暂存区状态。\n\n基本语法：\n\ngit status\n\n\n1\n\n\n\n\n可以看到，我删除了 3 个文件，还没有放到暂存区（红色），存到了暂存区（绿色），存到了本地库（消失）。\n\n\n# 文件增删改操作\n\n\n# 删除暂存区的文件\n\ngit rm --cached 文件名\n\n\n1\n\n\n\n# 添加文件到暂存区\n\ngit add 文件名\ngit add -A  # -A 代表全名文件\n\n\n1\n2\n\n\n\n# 提交文件到本地库\n\ngit commit -m "日志信息" [文件名] # 文件名可不写\n\n\n1\n\n\n\n# 历史版本操作\n\n\n# 查看历史版本\n\ngit log   # 查看详细版本信息\ngit reflog  # 查看简要版本信息\ngit log --pretty=oneline  # 一行显示一个版本信息（版本号完整）\ngit log --oneline  # 一行显示一个版本信息（版本号简写）\n\n\n1\n2\n3\n4\n\n\n多屏显示控制方式：\n\n * 空格向下翻页\n\n * b 向上翻页\n\n * q 退出\n\n\n# 切换历史版本\n\n * 基于索引值操作[推荐]\n   \n   git reset --hard [局部索引值]\n   git reset --hard a6ace91   # 例子\n   \n   \n   1\n   2\n   \n\n * 使用 ^ 符号：只能后退\n   \n   git reset --hard HEAD^\n   \n   \n   1\n   \n   \n   注：一个 ^ 表示后退一步，n 个表示后退。\n\n * 使用 ~ 符号：只能后退\n   \n   git reset --hard HEAD~n\n   \n   \n   1\n   \n   \n   注：表示后退 n 步。\n\n * 使用 HEAD 符号，恢复当前提交本地库的版本\n   \n   git reset --hard HEAD\n   \n   \n   1\n   \n   \n   注：在当前版本中删除了某个文件，可以恢复到当前最初的版本。\n\n> reset 命令的三个参数对比\n\n * --soft 参数\n   \n   * 仅仅在本地库移动 HEAD 指针\n\n * --mixed 参数\n   \n   * 在本地库移动 HEAD 指针\n   * 重置暂存区\n\n * --hard 参数\n   \n   * 在本地库移动 HEAD 指针\n   * 重置暂存区\n   * 重置工作区\n\n\n# 比较文件操作\n\n> 将工作区中的文件和暂存区进行比较\n\ngit diff [文件名]\n\n\n1\n\n\n> 将工作区中的文件和本地库历史记录比较\n\ngit diff [本地库中历史版本] [文件名]\n\n\n1\n\n\n不带文件名则比较多个文件。\n\n如果 [本地库中历史版本] 是 HEAD，则比较当前版本。\n\n\n# 分支操作\n\n\n\n\n# 什么是分支？\n\n在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）\n\n\n\n\n# 分支的好处？\n\n同时并行推进多个功能开发，提高开发效率。\n\n各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。\n\n\n# 分支操作\n\n命令名称                  作用\ngit branch 分支名        创建分支\ngit branch -D 分支名     删除分支\ngit branch -m 新的分支名   将当前分支名改为新的分支名\ngit branch -v         查看分支\ngit checkout 分支名      切换分支\ngit merge 分支名         合并分支\n\n> 创建分支\n\ngit branch [分支名]\n\n\n1\n\n\n> 删除分支\n\ngit branch -D 分支名\n\n\n1\n\n\n> 将当前分支名改为新的分支名\n\ngit branch -m 新的分支名\n\n\n1\n\n\n> 查看分支\n\ngit branch -v\n\n\n1\n\n\n> 切换分支\n\ngit checkout [分支名]\n\n\n1\n\n\n> 合并分支\n\n * 第一步：切换到接受修改的分支（被合并，增加新内容）上\n   \n   git checkout [被合并的分支名]\n   \n   \n   1\n   \n\n * 第二步：执行 merge 命令\n   \n   git merge [有新内容的分支名]\n   \n   \n   1\n   \n\n\n# 分支冲突\n\n> 产生冲突\n\n冲突的表现：后面状态为 MERGING\n\n\n\n冲突产生的原因：合并分支时，两个分支在 同一个文件的同一个位置 有两套完全不同的修改。Git 无法替 我们决定使用哪一个。必须 人为决定 新代码内容。\n\n冲突如图（修改的是同一个位置）：\n\n\n\n> 解决冲突\n\n冲突的解决：\n\n * 第一步：编辑文件，删除特殊符号\n\n * 第二步：把文件修改到满意的程度，保存退出\n\n * 第三步：添加到暂存区，git add [文件名]\n\n * 第四步：执行提交，git commit -m "日志信息"（注意：此时 commit 一定不能带具体文件名）\n\n\n# 创建分支和切换分支图解\n\n\n\nmaster、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。\n\nHEAD 如果指向 master，那么我们现在就在 master 分支上。\n\nHEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。\n\n\n# 分支进阶操作\n\n\n# 删除所有记录\n\n想清空所有 commit 的信息记录，就像形成一个全新的仓库，且代码不变。\n\n 1. 先切换到新的分支\n    \n    git branch kele\n    git checkout kele\n    \n    \n    1\n    2\n    \n\n 2. 添加所有文件到暂存区（除了 .gitignore 中排除的）\n    \n    git add -A\n    \n    \n    1\n    \n\n 3. 提交跟踪过的文件到本地库\n    \n    git commit -am "commit message"\n    \n    \n    1\n    \n\n 4. 删除 master 分支\n    \n    git branch -D master\n    \n    \n    1\n    \n\n 5. 重命名当前分支为 master\n    \n    git branch -m master\n    \n    \n    1\n    \n\n 6. 提交到远程 master 分支\n    \n    git push -f origin master\n    \n    \n    1\n    \n\n\n# 删除上次记录\n\n如果只是想修改上次提交的代码，做一次更完美的 commit，可以这样：\n\n 1. 回到到上个版本(注：不要带 --hard)\n    \n    git reset commitId\n    \n    \n    1\n    \n\n 2. 暂存修改\n    \n    git stash\n    \n    \n    1\n    \n\n 3. 强制 push，这样远程的最新的一次 commit 被删除\n    \n    git push --force\n    \n    \n    1\n    \n\n 4. 释放暂存的修改，开始修改代码\n    \n    git stash pop\n    \n    \n    1\n    \n\n 5. 添加、推送\n    \n    git add\n    git commit -m "massage"\n    git push\n    \n    \n    1\n    2\n    3\n    \n\n\n# 同时修改本地分支名和对应的远程分支名\n\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\n\n 1. 修改本地分支名\n\ngit branch -m oldBranchName newBranchName\n\n\n1\n\n 2. 删除远程分支\n\ngit push origin :oldBranchName\n\n\n1\n\n 3. 改名后的本地分支推送到远程\n\ngit push --set-upstream origin newBranchName\n\n\n1\n',normalizedContent:'笔记\n\n下面我们学习 git 在本地常用的命令，也是开发经常用到的命令。\n\n2022-02-08 @du wu\n\n\n\n * git常用命令\n   * 本地命令\n   * 远程命令\n * 设置用户签名\n   * 项目级别/仓库级别\n   * 系统用户级别\n   * 级别优先级\n   * 说明\n * 初始化本地库\n * 查看本地库状态\n * 文件增删改操作\n   * 删除暂存区的文件\n   * 添加文件到暂存区\n   * 提交文件到本地库\n * 历史版本操作\n   * 查看历史版本\n   * 切换历史版本\n * 比较文件操作\n * 分支操作\n   * 什么是分支？\n   * 分支的好处？\n   * 分支操作\n   * 分支冲突\n   * 创建分支和切换分支图解\n * 分支进阶操作\n   * 删除所有记录\n   * 删除上次记录\n   * 同时修改本地分支名和对应的远程分支名\n\n\n\n\n# git常用命令\n\n\n# 本地命令\n\n命令名称                                               作用\ngit config --global user.name 用户名                  设置用户签名\ngit config --global user.email 邮箱                  设置用户签名\ngit init                                           初始化本地库\ngit status                                         查看本地库状态\ngit add 文件名（-a 代表目录及子目录下所有文件名）                     添加到暂存区\ngit commit -m "日志信息" [文件名]（不加文件名，默认所有文件都添加该日志信息）   添加到本地库\ngit reflog                                         查看历史记录（简要）\ngit log                                            查看历史记录（详细）\ngit log --pretty=oneline                           一行显示一个版本信息（版本号完整）\ngit log --oneline                                  一行显示一个版本信息（版本号简写）\ngit reset --hard 版本号                               版本穿梭、跳转\ngit diff [文件名]                                     比较工作区中和暂存区的文件\ngit diff [本地库中历史版本] [文件名]                          比较工作区中的文件和本地库历史记录\ngit branch 分支名                                     创建分支\ngit branch -d 分支名                                  删除分支\ngit branch -m 新的分支名                                将当前分支名改为新的分支名\ngit branch -v                                      查看分支\ngit checkout 分支名                                   切换分支\ngit merge 分支名                                      合并分支\n\n\n# 远程命令\n\n命令名称                     作用\ngit remote -v            查看当前所有远程地址别名\ngit remote add 别名 远程地址   起别名\ngit push 别名 分支           推送本地分支上的内容到远程仓库\ngit clone 远程地址           将远程仓库的内容克隆到本地\ngit pull 远程库地址别名 远程分支名   将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并\n\n如果 git push 不加别名和分支，默认别名是 origin，分支是 master。\n\n我们 clone 项目会自动做如下操作：\n\n * 拉取代码\n * 初始化本地仓库\n * 创建别名，默认是 origin\n\n具体看 git - ssh免密登录。\n\n\n# 设置用户签名\n\n\n# 项目级别/仓库级别\n\n仅在当前本地库范围内有效。\n\ngit config user.name 用户名\ngit config user.email 邮箱\n\n\n1\n2\n\n\n信息保存位置：./.git/config 文件里。\n\n\n# 系统用户级别\n\n登录当前操作系统的用户范围。\n\ngit config --global user.name 用户名\ngit config --global user.email 邮箱\n\n\n1\n2\n\n\n\n\n信息保存位置：设置了用户签名，会在用户盘下生成 .gitconfig 文件，里面也可以直接修改自己的信息。\n\n\n# 级别优先级\n\n * 就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别的签名\n\n * 如果只有系统用户级别的签名，就以系统用户级别的签名为准\n\n * 二者都没有不允许\n\n\n# 说明\n\n签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。git 首次安装必须设置一下用户签名，否则无法提交代码。\n\n邮箱可以是虚拟邮箱，git 不会去识别。\n\n注意：这里设置用户签名和将来登录 github（或其他代码托管中心）的账号没有任何关系。\n\n\n# 初始化本地库\n\n基本语法：\n\ngit init\n\n\n1\n\n\n该指令会将目录下的所有子目录以及文件交给 git 管理，也是我们使用 git 最重要的一步。\n\n执行该指令后，会在当前目录下生成 .git 目录，该目录默认是隐藏的。\n\n注意：.git 目录中存放的是本地库相关的子目录和文件，不要删除，也不要胡乱修改。\n\n\n# 查看本地库状态\n\n查看工作区、暂存区状态。\n\n基本语法：\n\ngit status\n\n\n1\n\n\n\n\n可以看到，我删除了 3 个文件，还没有放到暂存区（红色），存到了暂存区（绿色），存到了本地库（消失）。\n\n\n# 文件增删改操作\n\n\n# 删除暂存区的文件\n\ngit rm --cached 文件名\n\n\n1\n\n\n\n# 添加文件到暂存区\n\ngit add 文件名\ngit add -a  # -a 代表全名文件\n\n\n1\n2\n\n\n\n# 提交文件到本地库\n\ngit commit -m "日志信息" [文件名] # 文件名可不写\n\n\n1\n\n\n\n# 历史版本操作\n\n\n# 查看历史版本\n\ngit log   # 查看详细版本信息\ngit reflog  # 查看简要版本信息\ngit log --pretty=oneline  # 一行显示一个版本信息（版本号完整）\ngit log --oneline  # 一行显示一个版本信息（版本号简写）\n\n\n1\n2\n3\n4\n\n\n多屏显示控制方式：\n\n * 空格向下翻页\n\n * b 向上翻页\n\n * q 退出\n\n\n# 切换历史版本\n\n * 基于索引值操作[推荐]\n   \n   git reset --hard [局部索引值]\n   git reset --hard a6ace91   # 例子\n   \n   \n   1\n   2\n   \n\n * 使用 ^ 符号：只能后退\n   \n   git reset --hard head^\n   \n   \n   1\n   \n   \n   注：一个 ^ 表示后退一步，n 个表示后退。\n\n * 使用 ~ 符号：只能后退\n   \n   git reset --hard head~n\n   \n   \n   1\n   \n   \n   注：表示后退 n 步。\n\n * 使用 head 符号，恢复当前提交本地库的版本\n   \n   git reset --hard head\n   \n   \n   1\n   \n   \n   注：在当前版本中删除了某个文件，可以恢复到当前最初的版本。\n\n> reset 命令的三个参数对比\n\n * --soft 参数\n   \n   * 仅仅在本地库移动 head 指针\n\n * --mixed 参数\n   \n   * 在本地库移动 head 指针\n   * 重置暂存区\n\n * --hard 参数\n   \n   * 在本地库移动 head 指针\n   * 重置暂存区\n   * 重置工作区\n\n\n# 比较文件操作\n\n> 将工作区中的文件和暂存区进行比较\n\ngit diff [文件名]\n\n\n1\n\n\n> 将工作区中的文件和本地库历史记录比较\n\ngit diff [本地库中历史版本] [文件名]\n\n\n1\n\n\n不带文件名则比较多个文件。\n\n如果 [本地库中历史版本] 是 head，则比较当前版本。\n\n\n# 分支操作\n\n\n\n\n# 什么是分支？\n\n在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）\n\n\n\n\n# 分支的好处？\n\n同时并行推进多个功能开发，提高开发效率。\n\n各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。\n\n\n# 分支操作\n\n命令名称                  作用\ngit branch 分支名        创建分支\ngit branch -d 分支名     删除分支\ngit branch -m 新的分支名   将当前分支名改为新的分支名\ngit branch -v         查看分支\ngit checkout 分支名      切换分支\ngit merge 分支名         合并分支\n\n> 创建分支\n\ngit branch [分支名]\n\n\n1\n\n\n> 删除分支\n\ngit branch -d 分支名\n\n\n1\n\n\n> 将当前分支名改为新的分支名\n\ngit branch -m 新的分支名\n\n\n1\n\n\n> 查看分支\n\ngit branch -v\n\n\n1\n\n\n> 切换分支\n\ngit checkout [分支名]\n\n\n1\n\n\n> 合并分支\n\n * 第一步：切换到接受修改的分支（被合并，增加新内容）上\n   \n   git checkout [被合并的分支名]\n   \n   \n   1\n   \n\n * 第二步：执行 merge 命令\n   \n   git merge [有新内容的分支名]\n   \n   \n   1\n   \n\n\n# 分支冲突\n\n> 产生冲突\n\n冲突的表现：后面状态为 merging\n\n\n\n冲突产生的原因：合并分支时，两个分支在 同一个文件的同一个位置 有两套完全不同的修改。git 无法替 我们决定使用哪一个。必须 人为决定 新代码内容。\n\n冲突如图（修改的是同一个位置）：\n\n\n\n> 解决冲突\n\n冲突的解决：\n\n * 第一步：编辑文件，删除特殊符号\n\n * 第二步：把文件修改到满意的程度，保存退出\n\n * 第三步：添加到暂存区，git add [文件名]\n\n * 第四步：执行提交，git commit -m "日志信息"（注意：此时 commit 一定不能带具体文件名）\n\n\n# 创建分支和切换分支图解\n\n\n\nmaster、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 head 决定的。所以创建分支的本质就是多创建一个指针。\n\nhead 如果指向 master，那么我们现在就在 master 分支上。\n\nhead 如果执行 hotfix，那么我们现在就在 hotfix 分支上。\n\n\n# 分支进阶操作\n\n\n# 删除所有记录\n\n想清空所有 commit 的信息记录，就像形成一个全新的仓库，且代码不变。\n\n 1. 先切换到新的分支\n    \n    git branch kele\n    git checkout kele\n    \n    \n    1\n    2\n    \n\n 2. 添加所有文件到暂存区（除了 .gitignore 中排除的）\n    \n    git add -a\n    \n    \n    1\n    \n\n 3. 提交跟踪过的文件到本地库\n    \n    git commit -am "commit message"\n    \n    \n    1\n    \n\n 4. 删除 master 分支\n    \n    git branch -d master\n    \n    \n    1\n    \n\n 5. 重命名当前分支为 master\n    \n    git branch -m master\n    \n    \n    1\n    \n\n 6. 提交到远程 master 分支\n    \n    git push -f origin master\n    \n    \n    1\n    \n\n\n# 删除上次记录\n\n如果只是想修改上次提交的代码，做一次更完美的 commit，可以这样：\n\n 1. 回到到上个版本(注：不要带 --hard)\n    \n    git reset commitid\n    \n    \n    1\n    \n\n 2. 暂存修改\n    \n    git stash\n    \n    \n    1\n    \n\n 3. 强制 push，这样远程的最新的一次 commit 被删除\n    \n    git push --force\n    \n    \n    1\n    \n\n 4. 释放暂存的修改，开始修改代码\n    \n    git stash pop\n    \n    \n    1\n    \n\n 5. 添加、推送\n    \n    git add\n    git commit -m "massage"\n    git push\n    \n    \n    1\n    2\n    3\n    \n\n\n# 同时修改本地分支名和对应的远程分支名\n\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\n\n 1. 修改本地分支名\n\ngit branch -m oldbranchname newbranchname\n\n\n1\n\n 2. 删除远程分支\n\ngit push origin :oldbranchname\n\n\n1\n\n 3. 改名后的本地分支推送到远程\n\ngit push --set-upstream origin newbranchname\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - 基本原理",frontmatter:{title:"Git - 基本原理",date:"2021-02-08T21:01:48.000Z",permalink:"/git/basic-principles/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/05.Git%20-%20%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"40.工具/20.开发管理 - Git/05.Git - 基本原理.md",key:"v-2882db09",path:"/git/basic-principles/",headers:[{level:2,title:"哈希法",slug:"哈希法",normalizedTitle:"哈希法",charIndex:50},{level:2,title:"Git保存版本的机制",slug:"git保存版本的机制",normalizedTitle:"git保存版本的机制",charIndex:57},{level:3,title:"集中式版本控制工具的文件管理机制",slug:"集中式版本控制工具的文件管理机制",normalizedTitle:"集中式版本控制工具的文件管理机制",charIndex:73},{level:3,title:"Git文件管理机制",slug:"git文件管理机制",normalizedTitle:"git文件管理机制",charIndex:95},{level:3,title:"Git文件管理机制细节",slug:"git文件管理机制细节",normalizedTitle:"git文件管理机制细节",charIndex:110},{level:2,title:"Git分支管理机制",slug:"git分支管理机制",normalizedTitle:"git分支管理机制",charIndex:125},{level:3,title:"分支的创建",slug:"分支的创建",normalizedTitle:"分支的创建",charIndex:140},{level:3,title:"分支的切换",slug:"分支的切换",normalizedTitle:"分支的切换",charIndex:151}],headersStr:"哈希法 Git保存版本的机制 集中式版本控制工具的文件管理机制 Git文件管理机制 Git文件管理机制细节 Git分支管理机制 分支的创建 分支的切换",content:"笔记\n\n简单了解 Git 的基本原理和哈希算法。\n\n2022-02-08 @Du Wu\n\n\n\n * 哈希法\n * Git保存版本的机制\n   * 集中式版本控制工具的文件管理机制\n   * Git文件管理机制\n   * Git文件管理机制细节\n * Git分支管理机制\n   * 分支的创建\n   * 分支的切换\n\n\n\n\n# 哈希法\n\n\n\n哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点：\n\n * 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。\n\n * 哈希算法确定，输入数据确定，输出数据能够保证不变\n\n * 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大\n\n * 哈希算法不可逆\n\nGit 底层采用的是 SHA-1 算法。\n\n哈希算法可以被用来验证文件。原理如下图所示：\n\n\n\nGit 就是靠这种机制来从根本上保证数据完整性的。\n\n\n# Git保存版本的机制\n\n\n# 集中式版本控制工具的文件管理机制\n\n以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本 文件和每个文件随时间逐步累积的差异。\n\n\n\n\n# Git文件管理机制\n\nGit 把数据看作是小型文件系统的一组快照。每次提交更新时 Git 都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 的工作方式可以称之为快照流。\n\n\n\n\n# Git文件管理机制细节\n\nGit 的「提交对象」（每个文件对应的 hash 值）\n\n\n\n提交对象及其父对象形成的链条\n\n\n\n\n# Git分支管理机制\n\n\n# 分支的创建\n\n新建一个指针\n\n\n\n\n# 分支的切换\n\nHEAD 指向\n\n\n\nHEAD 指向 testing 时提交了内容\n\n\n\n切换回 master\n\n\n\nHEAD 指向 master 时 提交了数据\n\n",normalizedContent:"笔记\n\n简单了解 git 的基本原理和哈希算法。\n\n2022-02-08 @du wu\n\n\n\n * 哈希法\n * git保存版本的机制\n   * 集中式版本控制工具的文件管理机制\n   * git文件管理机制\n   * git文件管理机制细节\n * git分支管理机制\n   * 分支的创建\n   * 分支的切换\n\n\n\n\n# 哈希法\n\n\n\n哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点：\n\n * 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。\n\n * 哈希算法确定，输入数据确定，输出数据能够保证不变\n\n * 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大\n\n * 哈希算法不可逆\n\ngit 底层采用的是 sha-1 算法。\n\n哈希算法可以被用来验证文件。原理如下图所示：\n\n\n\ngit 就是靠这种机制来从根本上保证数据完整性的。\n\n\n# git保存版本的机制\n\n\n# 集中式版本控制工具的文件管理机制\n\n以文件变更列表的方式存储信息。这类系统将它们保存的信息看作是一组基本 文件和每个文件随时间逐步累积的差异。\n\n\n\n\n# git文件管理机制\n\ngit 把数据看作是小型文件系统的一组快照。每次提交更新时 git 都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 git 的工作方式可以称之为快照流。\n\n\n\n\n# git文件管理机制细节\n\ngit 的「提交对象」（每个文件对应的 hash 值）\n\n\n\n提交对象及其父对象形成的链条\n\n\n\n\n# git分支管理机制\n\n\n# 分支的创建\n\n新建一个指针\n\n\n\n\n# 分支的切换\n\nhead 指向\n\n\n\nhead 指向 testing 时提交了内容\n\n\n\n切换回 master\n\n\n\nhead 指向 master 时 提交了数据\n\n",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - SSH免密登录",frontmatter:{title:"Git - SSH免密登录",date:"2021-02-08T16:49:21.000Z",permalink:"/git/ssh-login/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/07.Git%20-%20SSH%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95.html",relativePath:"40.工具/20.开发管理 - Git/07.Git - SSH免密登录.md",key:"v-6de5f26a",path:"/git/ssh-login/",headers:[{level:2,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:87},{level:2,title:"好处",slug:"好处",normalizedTitle:"好处",charIndex:93},{level:2,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:99}],headersStr:"步骤 好处 别名",content:"笔记\n\n每次我们 push 项目到远程库，都需要登录，那么有没有方法不需要登录也能 push 项目呢？需要 SSH 密钥。\n\n2022-02-08 @Du Wu\n\n\n\n * 步骤\n * 好处\n * 别名\n\n\n\n\n# 步骤\n\n我们可以看到远程仓库中还有一个 SSH 的地址，因此我们也可以使用 SSH 实现免密码登录。\n\n进入 C:/Users/用户名/.ssh 目录生成公钥（没有 .ssh 目录则创建）。\n\n右键打开 Git Bash Here。\n\nssh-keygen -t rsa -C GitHub注册邮箱\n\n\n1\n\n\n执行并回车三次后会在 .ssh 目录生成两个文件：\n\n * id_rsa：私钥\n * id_rsa.pub：公钥，给 GitHub，这样 GitHub 才能自动访问私钥所在的电脑，无需重新登录\n\n> 把公钥交给 GitHub\n\n * 复制 id_rsa.pub 文件内容\n\n * 前往 GitHub：点击用户头像，点击 Settings，找到 SSH and GPG keys，然后 New SSH，粘贴进去\n\n * Gitee：点击设置，找到 SSH 公钥，粘贴进去\n\n公钥可以多个平台同时设置 SSH。\n\n> GitHub 设置公钥图\n\n\n\n\n\n\n\n\n# 好处\n\n接下来再往远程仓库 push 东西的时候使用 SSH 连接就不需要登录了，因为 GitHub在国外，登录容易失败。\n\n\n# 别名\n\n对于用 https 已经克隆在本地的仓库，我们可以加个「别名」来进行 SSH 连接。\n\n基本语法\n\ngit remote -v：查看当前所有远程地址别名。\n\ngit remote add：别名 远程地址。\n\n案例\n\n我们提交到远程仓库的指令是：\n\ngit push 远程仓库地址 分支\n\n\n1\n\n\n这个地址可以是 HTTPS 也可以是 SSH。\n\n但由于地址太长了，可以用「别名」代替地址。\n\n添加别名：\n\ngit remote add kele git@github.com:Kele-Bingtang/Kele-Bingtang.github.io.git\n\n\n1\n\n\n推送到远程仓库：\n\ngit push kele master\n\n\n1\n\n\n我们 clone 项目会做如下操作：\n\n * 拉取代码\n * 初始化本地仓库\n * 创建别名，默认是 origin",normalizedContent:"笔记\n\n每次我们 push 项目到远程库，都需要登录，那么有没有方法不需要登录也能 push 项目呢？需要 ssh 密钥。\n\n2022-02-08 @du wu\n\n\n\n * 步骤\n * 好处\n * 别名\n\n\n\n\n# 步骤\n\n我们可以看到远程仓库中还有一个 ssh 的地址，因此我们也可以使用 ssh 实现免密码登录。\n\n进入 c:/users/用户名/.ssh 目录生成公钥（没有 .ssh 目录则创建）。\n\n右键打开 git bash here。\n\nssh-keygen -t rsa -c github注册邮箱\n\n\n1\n\n\n执行并回车三次后会在 .ssh 目录生成两个文件：\n\n * id_rsa：私钥\n * id_rsa.pub：公钥，给 github，这样 github 才能自动访问私钥所在的电脑，无需重新登录\n\n> 把公钥交给 github\n\n * 复制 id_rsa.pub 文件内容\n\n * 前往 github：点击用户头像，点击 settings，找到 ssh and gpg keys，然后 new ssh，粘贴进去\n\n * gitee：点击设置，找到 ssh 公钥，粘贴进去\n\n公钥可以多个平台同时设置 ssh。\n\n> github 设置公钥图\n\n\n\n\n\n\n\n\n# 好处\n\n接下来再往远程仓库 push 东西的时候使用 ssh 连接就不需要登录了，因为 github在国外，登录容易失败。\n\n\n# 别名\n\n对于用 https 已经克隆在本地的仓库，我们可以加个「别名」来进行 ssh 连接。\n\n基本语法\n\ngit remote -v：查看当前所有远程地址别名。\n\ngit remote add：别名 远程地址。\n\n案例\n\n我们提交到远程仓库的指令是：\n\ngit push 远程仓库地址 分支\n\n\n1\n\n\n这个地址可以是 https 也可以是 ssh。\n\n但由于地址太长了，可以用「别名」代替地址。\n\n添加别名：\n\ngit remote add kele git@github.com:kele-bingtang/kele-bingtang.github.io.git\n\n\n1\n\n\n推送到远程仓库：\n\ngit push kele master\n\n\n1\n\n\n我们 clone 项目会做如下操作：\n\n * 拉取代码\n * 初始化本地仓库\n * 创建别名，默认是 origin",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - IDEA集成",frontmatter:{title:"Git - IDEA集成",date:"2021-02-08T18:16:29.000Z",permalink:"/git/idea/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/09.Git%20-%20IDEA%E9%9B%86%E6%88%90.html",relativePath:"40.工具/20.开发管理 - Git/09.Git - IDEA集成.md",key:"v-715f666a",path:"/git/idea/",headers:[{level:2,title:"IDEA集成Git",slug:"idea集成git",normalizedTitle:"idea集成git",charIndex:67},{level:3,title:"配置Git忽略文件",slug:"配置git忽略文件",normalizedTitle:"配置git忽略文件",charIndex:82},{level:3,title:"定位Git程序",slug:"定位git程序",normalizedTitle:"定位git程序",charIndex:97},{level:3,title:"初始化本地库",slug:"初始化本地库",normalizedTitle:"初始化本地库",charIndex:110},{level:3,title:"添加到暂存区",slug:"添加到暂存区",normalizedTitle:"添加到暂存区",charIndex:122},{level:3,title:"提交到本地库",slug:"提交到本地库",normalizedTitle:"提交到本地库",charIndex:134},{level:3,title:"切换版本",slug:"切换版本",normalizedTitle:"切换版本",charIndex:146},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:156},{level:3,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:166},{level:3,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:176},{level:3,title:"解决冲突",slug:"解决冲突",normalizedTitle:"解决冲突",charIndex:186},{level:2,title:"IDEA集成GitHub",slug:"idea集成github",normalizedTitle:"idea集成github",charIndex:194},{level:3,title:"设置GitHub账号",slug:"设置github账号",normalizedTitle:"设置github账号",charIndex:212},{level:3,title:"分享工程到GitHub",slug:"分享工程到github",normalizedTitle:"分享工程到github",charIndex:228},{level:3,title:"推送本地库到远程库",slug:"推送本地库到远程库",normalizedTitle:"推送本地库到远程库",charIndex:245},{level:3,title:"拉取远程库到本地库",slug:"拉取远程库到本地库",normalizedTitle:"拉取远程库到本地库",charIndex:260},{level:3,title:"克隆远程库到本地",slug:"克隆远程库到本地",normalizedTitle:"克隆远程库到本地",charIndex:275},{level:2,title:"IDEA集成Gitee",slug:"idea集成gitee",normalizedTitle:"idea集成gitee",charIndex:287},{level:3,title:"IDEA安装Gitee插件",slug:"idea安装gitee插件",normalizedTitle:"idea安装gitee插件",charIndex:304},{level:3,title:"本地库推送到远程库",slug:"本地库推送到远程库",normalizedTitle:"本地库推送到远程库",charIndex:323},{level:3,title:"码云复制GitHub项目",slug:"码云复制github项目",normalizedTitle:"码云复制github项目",charIndex:338}],headersStr:"IDEA集成Git 配置Git忽略文件 定位Git程序 初始化本地库 添加到暂存区 提交到本地库 切换版本 创建分支 切换分支 合并分支 解决冲突 IDEA集成GitHub 设置GitHub账号 分享工程到GitHub 推送本地库到远程库 拉取远程库到本地库 克隆远程库到本地 IDEA集成Gitee IDEA安装Gitee插件 本地库推送到远程库 码云复制GitHub项目",content:"笔记\n\n实际开发上，我们更愿意利用图形化界面如 IDEA 来进行 Git 的操作。\n\n2022-02-08 @Du Wu\n\n\n\n * IDEA集成Git\n   * 配置Git忽略文件\n   * 定位Git程序\n   * 初始化本地库\n   * 添加到暂存区\n   * 提交到本地库\n   * 切换版本\n   * 创建分支\n   * 切换分支\n   * 合并分支\n   * 解决冲突\n * IDEA集成GitHub\n   * 设置GitHub账号\n   * 分享工程到GitHub\n   * 推送本地库到远程库\n   * 拉取远程库到本地库\n   * 克隆远程库到本地\n * IDEA集成Gitee\n   * IDEA安装Gitee插件\n   * 本地库推送到远程库\n   * 码云复制GitHub项目\n\n\n\n\n# IDEA集成Git\n\n\n# 配置Git忽略文件\n\n有些文件如 .class、.war、.jar 等与项目的实际功能无关，不参与服务器上部署运行，那么我们需要忽略他们。\n\n忽略文件有两种：\n\n * 电脑全局忽略，即只要在本电脑创建的 Git 项目，都会忽略特点文件\n * 项目局部忽略，即配置只有该项目的特点文件被忽略\n\n建议先配置电脑全局忽略，因为一些固定的文件是不需要上传 Git 的，而局部忽略可以选择性得进行文件忽略。\n\n> 全局忽略\n\n创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）\n\n这个文件的存放位置原则上在哪里都可以，为了便于让 ~/.gitconfig 文件引用，建议也放在用户家目录下（C/Users/用户名）。\n\n 1. git.ignore 文件模版内容如下：\n    \n    # Compiled class file\n    *.class\n    \n    # Log file\n    *.log\n    \n    # BlueJ files\n    *.ctxt\n    \n    # Mobile Tools for Java (J2ME)\n    .mtj.tmp/\n    \n    # Package Files #\n    *.jar\n    *.war\n    *.nar\n    *.ear\n    *.zip\n    *.tar.gz\n    *.rar\n    \n    # virtual machine crash logs, see \n    http://www.java.com/en/download/help/error_hotspot.xml\n    hs_err_pid*\n    .classpath\n    .project\n    .settings\n    target\n    .idea\n    *.iml\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    \n\n 2. 在 .gitconfig 文件中引用忽略配置文件（此文件在 Windows 的家目录中）\n    \n    [user]\n    \tname = 【git config user.name 的用户名】\n    \temail = 【git config user.email 的邮箱】\n    [core]\n    \texcludesfile = C:/Users/asus/git.ignore\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    注意：这里要使用正斜线（/），不要使用反斜线（\\）。\n\n> 局部忽略\n\n在项目的根目录下创建 .gitignore 文件，模板如下：\n\nHELP.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**/target/\n!**/src/test/**/target/\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n!**/src/main/**/build/\n!**/src/test/**/build/\n\n### VS Code ###\n.vscode/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 定位Git程序\n\n\n\n\n# 初始化本地库\n\n\n\n选择要创建 Git 本地仓库的工程\n\n\n\n\n# 添加到暂存区\n\n右键点击项目选择 Git -> Add 将项目添加到暂存区\n\n\n\n\n# 提交到本地库\n\n\n\n\n\n\n# 切换版本\n\n在 IDEA 的左下角，点击 Version Control（新版是 Git），然后点击 Log 查看版本\n\n\n\n右键选择要切换的版本，然后在菜单里点击 Checkout Revision\n\n\n\n\n# 创建分支\n\n选择 Git，在 Repository 里面，点击 Branches 按钮\n\n\n\n在弹出的 Git Branches 框里，点击 New Branch 按钮\n\n\n\n填写分支名称，创建 hot-fix 分支\n\n\n\n然后再 IDEA 的右下角看到 hot-fix，说明分支创建成功，并且当前已经切换成 hot-fix 分支\n\n\n\n\n# 切换分支\n\n在 IDEA 窗口的右下角，切换到 master 分支\n\n\n\n然后在 IDEA 窗口的右下角看到了 master，说明 master 分支切换成功\n\n\n\n\n# 合并分支\n\n在 IDEA 窗口的右下角，将 hot-fix 分支合并到当前 master 分支\n\n\n\n如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。\n\n\n# 解决冲突\n\n如图所示，如果 master 分支和 hot-fix 分支都修改了代码，在合并分支的时候就会发生冲突\n\n\n\n\n\n我们现在站在 master 分支上合并 hot-fix 分支，就会发生代码冲突\n\n\n\n点击 Conflicts 框里的 Merge 按钮，进行手动合并代码\n\n\n\n手动合并完代码以后，点击右下角的 Apply 按钮\n\n\n\n代码冲突解决，自动提交本地库\n\n\n\n\n# IDEA集成GitHub\n\n\n# 设置GitHub账号\n\n\n\n如果出现 401 等情况连接不上的，是因为网络原因，可以使用以下方式连接：\n\n\n\n然后去 GitHub 账户上设置 token\n\n\n\n\n\n\n\n\n\n点击生成 token\n\n\n\n复制红框中的字符串到 idea 中\n\n\n\n点击登录\n\n\n\n\n# 分享工程到GitHub\n\n\n\n\n\n来到 GitHub 中发现已经帮我们创建好了 gitTest 的远程仓库\n\n\n\n\n# 推送本地库到远程库\n\n右键点击项目，可以将当前分支的内容 push 到 GitHub 的远程仓库中\n\n\n\n\n\n\n\n\n\n\n\n注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高。\n\n因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别。如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送。\n\n\n# 拉取远程库到本地库\n\n右键点击项目，可以将远程仓库的内容 pull 到本地仓库\n\n\n\n\n\n注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。\n\n\n# 克隆远程库到本地\n\n\n\n\n\n为 clone 下来的项目创建一个工程，然后点击 Next\n\n\n\n\n\n\n\n\n\n\n# IDEA集成Gitee\n\n众所周知，GitHub 服务器在国外，使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况，可以使用国内的项目托管网站：码云（Gitee）。\n\n码云是开源中国推出的基于 Git 的代码托管服务中心，网址是 https://gitee.com/，使用方式跟 GitHub 一样，而且它还是一个中文网站，如果你英文不是很好它是最好的选择。\n\n\n# IDEA安装Gitee插件\n\nIDEA 默认不带码云插件，我们第一步要安装 Gitee 插件。\n\n如图所示，在 IDEA 插件商店搜索 Gitee，然后点击右侧的 Install 按钮。\n\n\n\nIDEA 链接码云和链接 GitHub 几乎一样，安装成功后，重启 IDEA\n\n\n\nIDEA 重启以后在 Version Control 设置里面看到 Gitee，说明码云插件安装成功\n\n\n\n然后在码云插件里面添加码云帐号，我们就可以用 IDEA 连接码云了\n\n\n\n\n# 本地库推送到远程库\n\nIDEA 连接码云和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 Git 工程，然后将代码添加到暂存区，提交到本地库，这些步骤上面已经讲过，此处不再赘述。\n\n\n\n自定义远程库链接\n\n\n\n给远程库链接定义个 name，然后再 URL 里面填入码云远程库的 HTTPS 链接即可。码云服务器在国内，用 HTTPS 链接即可，没必要用 SSH 免密链接\n\n\n\n然后选择定义好的远程链接，点击 Push 即可\n\n\n\n看到提示就说明 Push 远程库成功。\n\n只要码云远程库链接定义好以后，对码云远程库进行 pull 和 clone 的操作和 Github 一致，此处不再赘述。\n\n\n# 码云复制GitHub项目\n\n码云提供了直接复制 GitHub 项目的功能，方便我们做项目的迁移和下载。\n\n具体操作如下：\n\n\n\n将 GitHub 的远程库 HTTPS 链接复制过来，点击创建按钮即可\n\n\n\n如果 GitHub 项目更新了以后，在码云项目端可以手动重新同步，进行更新\n\n\n\n",normalizedContent:"笔记\n\n实际开发上，我们更愿意利用图形化界面如 idea 来进行 git 的操作。\n\n2022-02-08 @du wu\n\n\n\n * idea集成git\n   * 配置git忽略文件\n   * 定位git程序\n   * 初始化本地库\n   * 添加到暂存区\n   * 提交到本地库\n   * 切换版本\n   * 创建分支\n   * 切换分支\n   * 合并分支\n   * 解决冲突\n * idea集成github\n   * 设置github账号\n   * 分享工程到github\n   * 推送本地库到远程库\n   * 拉取远程库到本地库\n   * 克隆远程库到本地\n * idea集成gitee\n   * idea安装gitee插件\n   * 本地库推送到远程库\n   * 码云复制github项目\n\n\n\n\n# idea集成git\n\n\n# 配置git忽略文件\n\n有些文件如 .class、.war、.jar 等与项目的实际功能无关，不参与服务器上部署运行，那么我们需要忽略他们。\n\n忽略文件有两种：\n\n * 电脑全局忽略，即只要在本电脑创建的 git 项目，都会忽略特点文件\n * 项目局部忽略，即配置只有该项目的特点文件被忽略\n\n建议先配置电脑全局忽略，因为一些固定的文件是不需要上传 git 的，而局部忽略可以选择性得进行文件忽略。\n\n> 全局忽略\n\n创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）\n\n这个文件的存放位置原则上在哪里都可以，为了便于让 ~/.gitconfig 文件引用，建议也放在用户家目录下（c/users/用户名）。\n\n 1. git.ignore 文件模版内容如下：\n    \n    # compiled class file\n    *.class\n    \n    # log file\n    *.log\n    \n    # bluej files\n    *.ctxt\n    \n    # mobile tools for java (j2me)\n    .mtj.tmp/\n    \n    # package files #\n    *.jar\n    *.war\n    *.nar\n    *.ear\n    *.zip\n    *.tar.gz\n    *.rar\n    \n    # virtual machine crash logs, see \n    http://www.java.com/en/download/help/error_hotspot.xml\n    hs_err_pid*\n    .classpath\n    .project\n    .settings\n    target\n    .idea\n    *.iml\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    \n\n 2. 在 .gitconfig 文件中引用忽略配置文件（此文件在 windows 的家目录中）\n    \n    [user]\n    \tname = 【git config user.name 的用户名】\n    \temail = 【git config user.email 的邮箱】\n    [core]\n    \texcludesfile = c:/users/asus/git.ignore\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    注意：这里要使用正斜线（/），不要使用反斜线（\\）。\n\n> 局部忽略\n\n在项目的根目录下创建 .gitignore 文件，模板如下：\n\nhelp.md\ntarget/\n!.mvn/wrapper/maven-wrapper.jar\n!**/src/main/**/target/\n!**/src/test/**/target/\n\n### sts ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springbeans\n.sts4-cache\n\n### intellij idea ###\n.idea\n*.iws\n*.iml\n*.ipr\n\n### netbeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\nbuild/\n!**/src/main/**/build/\n!**/src/test/**/build/\n\n### vs code ###\n.vscode/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 定位git程序\n\n\n\n\n# 初始化本地库\n\n\n\n选择要创建 git 本地仓库的工程\n\n\n\n\n# 添加到暂存区\n\n右键点击项目选择 git -> add 将项目添加到暂存区\n\n\n\n\n# 提交到本地库\n\n\n\n\n\n\n# 切换版本\n\n在 idea 的左下角，点击 version control（新版是 git），然后点击 log 查看版本\n\n\n\n右键选择要切换的版本，然后在菜单里点击 checkout revision\n\n\n\n\n# 创建分支\n\n选择 git，在 repository 里面，点击 branches 按钮\n\n\n\n在弹出的 git branches 框里，点击 new branch 按钮\n\n\n\n填写分支名称，创建 hot-fix 分支\n\n\n\n然后再 idea 的右下角看到 hot-fix，说明分支创建成功，并且当前已经切换成 hot-fix 分支\n\n\n\n\n# 切换分支\n\n在 idea 窗口的右下角，切换到 master 分支\n\n\n\n然后在 idea 窗口的右下角看到了 master，说明 master 分支切换成功\n\n\n\n\n# 合并分支\n\n在 idea 窗口的右下角，将 hot-fix 分支合并到当前 master 分支\n\n\n\n如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。\n\n\n# 解决冲突\n\n如图所示，如果 master 分支和 hot-fix 分支都修改了代码，在合并分支的时候就会发生冲突\n\n\n\n\n\n我们现在站在 master 分支上合并 hot-fix 分支，就会发生代码冲突\n\n\n\n点击 conflicts 框里的 merge 按钮，进行手动合并代码\n\n\n\n手动合并完代码以后，点击右下角的 apply 按钮\n\n\n\n代码冲突解决，自动提交本地库\n\n\n\n\n# idea集成github\n\n\n# 设置github账号\n\n\n\n如果出现 401 等情况连接不上的，是因为网络原因，可以使用以下方式连接：\n\n\n\n然后去 github 账户上设置 token\n\n\n\n\n\n\n\n\n\n点击生成 token\n\n\n\n复制红框中的字符串到 idea 中\n\n\n\n点击登录\n\n\n\n\n# 分享工程到github\n\n\n\n\n\n来到 github 中发现已经帮我们创建好了 gittest 的远程仓库\n\n\n\n\n# 推送本地库到远程库\n\n右键点击项目，可以将当前分支的内容 push 到 github 的远程仓库中\n\n\n\n\n\n\n\n\n\n\n\n注意：push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说，要想 push 成功，一定要保证本地库的版本要比远程库的版本高。\n\n因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别。如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送。\n\n\n# 拉取远程库到本地库\n\n右键点击项目，可以将远程仓库的内容 pull 到本地仓库\n\n\n\n\n\n注意：pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。\n\n\n# 克隆远程库到本地\n\n\n\n\n\n为 clone 下来的项目创建一个工程，然后点击 next\n\n\n\n\n\n\n\n\n\n\n# idea集成gitee\n\n众所周知，github 服务器在国外，使用 github 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况，可以使用国内的项目托管网站：码云（gitee）。\n\n码云是开源中国推出的基于 git 的代码托管服务中心，网址是 https://gitee.com/，使用方式跟 github 一样，而且它还是一个中文网站，如果你英文不是很好它是最好的选择。\n\n\n# idea安装gitee插件\n\nidea 默认不带码云插件，我们第一步要安装 gitee 插件。\n\n如图所示，在 idea 插件商店搜索 gitee，然后点击右侧的 install 按钮。\n\n\n\nidea 链接码云和链接 github 几乎一样，安装成功后，重启 idea\n\n\n\nidea 重启以后在 version control 设置里面看到 gitee，说明码云插件安装成功\n\n\n\n然后在码云插件里面添加码云帐号，我们就可以用 idea 连接码云了\n\n\n\n\n# 本地库推送到远程库\n\nidea 连接码云和连接 github 几乎一样，首先在 idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库，这些步骤上面已经讲过，此处不再赘述。\n\n\n\n自定义远程库链接\n\n\n\n给远程库链接定义个 name，然后再 url 里面填入码云远程库的 https 链接即可。码云服务器在国内，用 https 链接即可，没必要用 ssh 免密链接\n\n\n\n然后选择定义好的远程链接，点击 push 即可\n\n\n\n看到提示就说明 push 远程库成功。\n\n只要码云远程库链接定义好以后，对码云远程库进行 pull 和 clone 的操作和 github 一致，此处不再赘述。\n\n\n# 码云复制github项目\n\n码云提供了直接复制 github 项目的功能，方便我们做项目的迁移和下载。\n\n具体操作如下：\n\n\n\n将 github 的远程库 https 链接复制过来，点击创建按钮即可\n\n\n\n如果 github 项目更新了以后，在码云项目端可以手动重新同步，进行更新\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Git - Commit常用表情",frontmatter:{title:"Git - Commit常用表情",date:"2021-02-08T21:15:54.000Z",permalink:"/git/commit-emo/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/15.Git%20-%20Commit%E5%B8%B8%E7%94%A8%E8%A1%A8%E6%83%85.html",relativePath:"40.工具/20.开发管理 - Git/15.Git - Commit常用表情.md",key:"v-313dd5d4",path:"/git/commit-emo/",headers:[{level:2,title:"Git常用表情",slug:"git常用表情",normalizedTitle:"git常用表情",charIndex:71},{level:2,title:"MarkDown 常用表情",slug:"markdown-常用表情",normalizedTitle:"markdown 常用表情",charIndex:82},{level:3,title:"People",slug:"people",normalizedTitle:"people",charIndex:101},{level:3,title:"Nature",slug:"nature",normalizedTitle:"nature",charIndex:113},{level:3,title:"Objects",slug:"objects",normalizedTitle:"objects",charIndex:125},{level:3,title:"Places",slug:"places",normalizedTitle:"places",charIndex:138},{level:3,title:"Symbols",slug:"symbols",normalizedTitle:"symbols",charIndex:150},{level:2,title:"参考链接",slug:"参考链接",normalizedTitle:"参考链接",charIndex:161}],headersStr:"Git常用表情 MarkDown 常用表情 People Nature Objects Places Symbols 参考链接",content:"笔记\n\nGit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n2022-02-08 @Du Wu\n\n\n\n * Git常用表情\n * MarkDown 常用表情\n   * People\n   * Nature\n   * Objects\n   * Places\n   * Symbols\n * 参考链接\n\n\n\n\n# Git常用表情\n\nGit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n常用表情符号如下：\n\nEMOJI        EMOJI代码                      COMMIT说明\n🎨 (调色板)     :art:                        改进代码结构/代码格式\n⚡️ (闪电)      :zap:                        提升性能\n🐎 (赛马)      :racehorse:                  提升性能\n🔥 (火焰)      :fire:                       移除代码或文件\n🐛 (bug)     :bug:                        修复 bug\n🚑 (急救车)     :ambulance:                  重要补丁\n✨ (火花)       :sparkles:                   引入新功能\n📝 (铅笔)      :pencil:                     撰写文档\n🚀 (火箭)      :rocket:                     部署功能\n💄 (口红)      :lipstick:                   更新 UI 和样式文件\n🎉 (庆祝)      :tada:                       初次提交\n✅ (白色复选框)    :white_check_mark:           增加测试\n🔒 (锁)       :lock:                       修复安全问题\n🍎 (苹果)      :apple:                      修复 macOS 下的问题\n🐧 (企鹅)      :penguin:                    修复 Linux 下的问题\n🏁 (旗帜)      :checked_flag:               修复 Windows 下的问题\n🔖 (书签)      :bookmark:                   发行/版本标签\n🚨 (警车灯)     :rotating_light:             移除 linter 警告\n🚧 (施工)      :construction:               工作进行中\n💚 (绿心)      :green_heart:                修复 CI 构建问题\n⬇️ (下降箭头)    :arrow_down:                 降级依赖\n⬆️ (上升箭头)    :arrow_up:                   升级依赖\n👷 (工人)      :construction_worker:        添加 CI 构建系统\n📈 (上升趋势图)   :chart_with_upwards_trend:   添加分析或跟踪代码\n🔨 (锤子)      :hammer:                     重大重构\n➖ (减号)       :heavy_minus_sign:           减少一个依赖\n🐳 (鲸鱼)      :whale:                      Docker 相关工作\n➕ (加号)       :heavy_plus_sign:            增加一个依赖\n🔧 (扳手)      :wrench:                     修改配置文件\n🌐 (地球)      :globe_with_meridians:       国际化与本地化\n✏️ (铅笔)      :pencil2:                    修复 typo\n\n\n# MarkDown 常用表情\n\n\n# People\n\n😄 :SMILE:                          😆 :LAUGHING:                       \n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😱 :scream:                         👿 :imp:                            😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n😎 :sunglasses:                     😵 :dizzy_face:                     \n\n                                                               \n😈 :smiling_imp:                😐 :neutral_face:              😶 :no_mouth:\n😇 :innocent:                   👽 :alien:                     💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💏 :couplekiss:                 💑 :couple_with_heart:         💆 :massage:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💧 :droplet:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💬 :speech_balloon:            💭 :thought_balloon:\n\n\n# Nature\n\n☀️ :SUNNY:                          ☔️ :UMBRELLA:               ☁️ :CLOUD:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# Objects\n\n🎍 :BAMBOO:                           💝 :GIFT_HEART:                   🎎 :DOLLS:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# Places\n\n🏠 :HOUSE:                 🏡 :HOUSE_WITH_GARDEN:         🏫 :SCHOOL:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# Symbols\n\n1️⃣ :ONE:                             2️⃣ :TWO:                        3️⃣ :THREE:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  Ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n✅ :white_check_mark:                  🔲 :black_square_button:         🔳 :white_square_button:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:          🔱 :trident:                     \n\n\n# 参考链接\n\n * https://www.kuangstudy.com/bbs/1363014604904587265\n * https://blog.csdn.net/u011583927/article/details/104094284\n * https://note.oddfar.com/pages/fe0004/",normalizedContent:"笔记\n\ngit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n2022-02-08 @du wu\n\n\n\n * git常用表情\n * markdown 常用表情\n   * people\n   * nature\n   * objects\n   * places\n   * symbols\n * 参考链接\n\n\n\n\n# git常用表情\n\ngit commit 的时候，添加表情符号可以更好的表明本次提交的性质，也更有趣。\n\n常用表情符号如下：\n\nemoji        emoji代码                      commit说明\n🎨 (调色板)     :art:                        改进代码结构/代码格式\n⚡️ (闪电)      :zap:                        提升性能\n🐎 (赛马)      :racehorse:                  提升性能\n🔥 (火焰)      :fire:                       移除代码或文件\n🐛 (bug)     :bug:                        修复 bug\n🚑 (急救车)     :ambulance:                  重要补丁\n✨ (火花)       :sparkles:                   引入新功能\n📝 (铅笔)      :pencil:                     撰写文档\n🚀 (火箭)      :rocket:                     部署功能\n💄 (口红)      :lipstick:                   更新 ui 和样式文件\n🎉 (庆祝)      :tada:                       初次提交\n✅ (白色复选框)    :white_check_mark:           增加测试\n🔒 (锁)       :lock:                       修复安全问题\n🍎 (苹果)      :apple:                      修复 macos 下的问题\n🐧 (企鹅)      :penguin:                    修复 linux 下的问题\n🏁 (旗帜)      :checked_flag:               修复 windows 下的问题\n🔖 (书签)      :bookmark:                   发行/版本标签\n🚨 (警车灯)     :rotating_light:             移除 linter 警告\n🚧 (施工)      :construction:               工作进行中\n💚 (绿心)      :green_heart:                修复 ci 构建问题\n⬇️ (下降箭头)    :arrow_down:                 降级依赖\n⬆️ (上升箭头)    :arrow_up:                   升级依赖\n👷 (工人)      :construction_worker:        添加 ci 构建系统\n📈 (上升趋势图)   :chart_with_upwards_trend:   添加分析或跟踪代码\n🔨 (锤子)      :hammer:                     重大重构\n➖ (减号)       :heavy_minus_sign:           减少一个依赖\n🐳 (鲸鱼)      :whale:                      docker 相关工作\n➕ (加号)       :heavy_plus_sign:            增加一个依赖\n🔧 (扳手)      :wrench:                     修改配置文件\n🌐 (地球)      :globe_with_meridians:       国际化与本地化\n✏️ (铅笔)      :pencil2:                    修复 typo\n\n\n# markdown 常用表情\n\n\n# people\n\n😄 :smile:                          😆 :laughing:                       \n😊 :blush:                          😃 :smiley:                         ☺️ :relaxed:\n😏 :smirk:                          😍 :heart_eyes:                     😘 :kissing_heart:\n😚 :kissing_closed_eyes:            😳 :flushed:                        😌 :relieved:\n😆 :satisfied:                      😁 :grin:                           😉 :wink:\n😜 :stuck_out_tongue_winking_eye:   😝 :stuck_out_tongue_closed_eyes:   😀 :grinning:\n😗 :kissing:                        😙 :kissing_smiling_eyes:           😛 :stuck_out_tongue:\n😴 :sleeping:                       😟 :worried:                        😦 :frowning:\n😧 :anguished:                      😮 :open_mouth:                     😬 :grimacing:\n😕 :confused:                       😯 :hushed:                         😑 :expressionless:\n😒 :unamused:                       😅 :sweat_smile:                    😓 :sweat:\n😥 :disappointed_relieved:          😩 :weary:                          😔 :pensive:\n😞 :disappointed:                   😖 :confounded:                     😨 :fearful:\n😰 :cold_sweat:                     😣 :persevere:                      😢 :cry:\n😭 :sob:                            😂 :joy:                            😲 :astonished:\n😱 :scream:                         👿 :imp:                            😫 :tired_face:\n😠 :angry:                          😡 :rage:                           😤 :triumph:\n😪 :sleepy:                         😋 :yum:                            😷 :mask:\n😎 :sunglasses:                     😵 :dizzy_face:                     \n\n                                                               \n😈 :smiling_imp:                😐 :neutral_face:              😶 :no_mouth:\n😇 :innocent:                   👽 :alien:                     💛 :yellow_heart:\n💙 :blue_heart:                 💜 :purple_heart:              ❤️ :heart:\n💚 :green_heart:                💔 :broken_heart:              💓 :heartbeat:\n💗 :heartpulse:                 💕 :two_hearts:                💞 :revolving_hearts:\n💘 :cupid:                      💖 :sparkling_heart:           ✨ :sparkles:\n⭐️ :star:                       🌟 :star2:                     💫 :dizzy:\n💥 :boom:                       💥 :collision:                 💢 :anger:\n❗️ :exclamation:                ❓ :question:                   ❕ :grey_exclamation:\n❔ :grey_question:               💤 :zzz:                       💨 :dash:\n💦 :sweat_drops:                🎶 :notes:                     🎵 :musical_note:\n🔥 :fire:                       💩 :hankey:                    💩 :poop:\n💩 :shit:                       👍 :+1:                        👍 :thumbsup:\n👎 :-1:                         👎 :thumbsdown:                👌 :ok_hand:\n👊 :punch:                      👊 :facepunch:                 ✊ :fist:\n✌️ :v:                          👋 :wave:                      ✋ :hand:\n✋ :raised_hand:                 👐 :open_hands:                ☝️ :point_up:\n👇 :point_down:                 👈 :point_left:                👉 :point_right:\n🙌 :raised_hands:               🙏 :pray:                      👆 :point_up_2:\n👏 :clap:                       💪 :muscle:                    🤘 :metal:\n🖕 :fu:                         🚶 :walking:                   🏃 :runner:\n🏃 :running:                    👫 :couple:                    👪 :family:\n👬 :two_men_holding_hands:      👭 :two_women_holding_hands:   💃 :dancer:\n👯 :dancers:                    🙆 :ok_woman:                  🙅 :no_good:\n💁 :information_desk_person:    🙋 :raising_hand:              👰 :bride_with_veil:\n🙎 :person_with_pouting_face:   🙍 :person_frowning:           🙇 :bow:\n💏 :couplekiss:                 💑 :couple_with_heart:         💆 :massage:\n💇 :haircut:                    💅 :nail_care:                 👦 :boy:\n👧 :girl:                       👩 :woman:                     👨 :man:\n👶 :baby:                       👵 :older_woman:               👴 :older_man:\n👱 :person_with_blond_hair:     👲 :man_with_gua_pi_mao:       👳 :man_with_turban:\n👷 :construction_worker:        👮 :cop:                       👼 :angel:\n👸 :princess:                   😺 :smiley_cat:                😸 :smile_cat:\n😻 :heart_eyes_cat:             😽 :kissing_cat:               😼 :smirk_cat:\n🙀 :scream_cat:                 😿 :crying_cat_face:           😹 :joy_cat:\n😾 :pouting_cat:                👹 :japanese_ogre:             👺 :japanese_goblin:\n🙈 :see_no_evil:                🙉 :hear_no_evil:              🙊 :speak_no_evil:\n💂 :guardsman:                  💀 :skull:                     🐾 :feet:\n👄 :lips:                       💋 :kiss:                      💧 :droplet:\n👂 :ear:                        👀 :eyes:                      👃 :nose:\n👅 :tongue:                     💌 :love_letter:               👤 :bust_in_silhouette:\n👥 :busts_in_silhouette:        💬 :speech_balloon:            💭 :thought_balloon:\n\n\n# nature\n\n☀️ :sunny:                          ☔️ :umbrella:               ☁️ :cloud:\n❄️ :snowflake:                      ⛄️ :snowman:                ⚡️ :zap:\n🌀 :cyclone:                        🌁 :foggy:                  🌊 :ocean:\n🐱 :cat:                            🐶 :dog:                    🐭 :mouse:\n🐹 :hamster:                        🐰 :rabbit:                 🐺 :wolf:\n🐸 :frog:                           🐯 :tiger:                  🐨 :koala:\n🐻 :bear:                           🐷 :pig:                    🐽 :pig_nose:\n🐮 :cow:                            🐗 :boar:                   🐵 :monkey_face:\n🐒 :monkey:                         🐴 :horse:                  🐎 :racehorse:\n🐫 :camel:                          🐑 :sheep:                  🐘 :elephant:\n🐼 :panda_face:                     🐍 :snake:                  🐦 :bird:\n🐤 :baby_chick:                     🐥 :hatched_chick:          🐣 :hatching_chick:\n🐔 :chicken:                        🐧 :penguin:                🐢 :turtle:\n🐛 :bug:                            🐝 :honeybee:               🐜 :ant:\n🐞 :beetle:                         🐌 :snail:                  🐙 :octopus:\n🐠 :tropical_fish:                  🐟 :fish:                   🐳 :whale:\n🐋 :whale2:                         🐬 :dolphin:                🐄 :cow2:\n🐏 :ram:                            🐀 :rat:                    🐃 :water_buffalo:\n🐅 :tiger2:                         🐇 :rabbit2:                🐉 :dragon:\n🐐 :goat:                           🐓 :rooster:                🐕 :dog2:\n🐖 :pig2:                           🐁 :mouse2:                 🐂 :ox:\n🐲 :dragon_face:                    🐡 :blowfish:               🐊 :crocodile:\n🐪 :dromedary_camel:                🐆 :leopard:                🐈 :cat2:\n🐩 :poodle:                         🐾 :paw_prints:             💐 :bouquet:\n🌸 :cherry_blossom:                 🌷 :tulip:                  🍀 :four_leaf_clover:\n🌹 :rose:                           🌻 :sunflower:              🌺 :hibiscus:\n🍁 :maple_leaf:                     🍃 :leaves:                 🍂 :fallen_leaf:\n🌿 :herb:                           🍄 :mushroom:               🌵 :cactus:\n🌴 :palm_tree:                      🌲 :evergreen_tree:         🌳 :deciduous_tree:\n🌰 :chestnut:                       🌱 :seedling:               🌼 :blossom:\n🌾 :ear_of_rice:                    🐚 :shell:                  🌐 :globe_with_meridians:\n🌞 :sun_with_face:                  🌝 :full_moon_with_face:    🌚 :new_moon_with_face:\n🌑 :new_moon:                       🌒 :waxing_crescent_moon:   🌓 :first_quarter_moon:\n🌔 :waxing_gibbous_moon:            🌕 :full_moon:              🌖 :waning_gibbous_moon:\n🌗 :last_quarter_moon:              🌘 :waning_crescent_moon:   🌜 :last_quarter_moon_with_face:\n🌛 :first_quarter_moon_with_face:   🌔 :moon:                   🌍 :earth_africa:\n🌎 :earth_americas:                 🌏 :earth_asia:             🌋 :volcano:\n🌌 :milky_way:                      ⛅️ :partly_sunny:           \n\n\n# objects\n\n🎍 :bamboo:                           💝 :gift_heart:                   🎎 :dolls:\n🎒 :school_satchel:                   🎓 :mortar_board:                 🎏 :flags:\n🎆 :fireworks:                        🎇 :sparkler:                     🎐 :wind_chime:\n🎑 :rice_scene:                       🎃 :jack_o_lantern:               👻 :ghost:\n🎅 :santa:                            🎄 :christmas_tree:               🎁 :gift:\n🔔 :bell:                             🔕 :no_bell:                      🎋 :tanabata_tree:\n🎉 :tada:                             🎊 :confetti_ball:                🎈 :balloon:\n🔮 :crystal_ball:                     💿 :cd:                           📀 :dvd:\n💾 :floppy_disk:                      📷 :camera:                       📹 :video_camera:\n🎥 :movie_camera:                     💻 :computer:                     📺 :tv:\n📱 :iphone:                           ☎️ :phone:                        ☎️ :telephone:\n📞 :telephone_receiver:               📟 :pager:                        📠 :fax:\n💽 :minidisc:                         📼 :vhs:                          🔉 :sound:\n🔈 :speaker:                          🔇 :mute:                         📢 :loudspeaker:\n📣 :mega:                             ⌛️ :hourglass:                    ⏳ :hourglass_flowing_sand:\n⏰ :alarm_clock:                       ⌚️ :watch:                        📻 :radio:\n📡 :satellite:                        ➿ :loop:                          🔍 :mag:\n🔎 :mag_right:                        🔓 :unlock:                       🔒 :lock:\n🔏 :lock_with_ink_pen:                🔐 :closed_lock_with_key:         🔑 :key:\n💡 :bulb:                             🔦 :flashlight:                   🔆 :high_brightness:\n🔅 :low_brightness:                   🔌 :electric_plug:                🔋 :battery:\n📲 :calling:                          ✉️ :email:                        📫 :mailbox:\n📮 :postbox:                          🛀 :bath:                         🛁 :bathtub:\n🚿 :shower:                           🚽 :toilet:                       🔧 :wrench:\n🔩 :nut_and_bolt:                     🔨 :hammer:                       💺 :seat:\n💰 :moneybag:                         💴 :yen:                          💵 :dollar:\n💷 :pound:                            💶 :euro:                         💳 :credit_card:\n💸 :money_with_wings:                 📧 :e-mail:                       📥 :inbox_tray:\n📤 :outbox_tray:                      ✉️ :envelope:                     📨 :incoming_envelope:\n📯 :postal_horn:                      📪 :mailbox_closed:               📬 :mailbox_with_mail:\n📭 :mailbox_with_no_mail:             🚪 :door:                         🚬 :smoking:\n💣 :bomb:                             🔫 :gun:                          🔪 :hocho:\n💊 :pill:                             💉 :syringe:                      📄 :page_facing_up:\n📃 :page_with_curl:                   📑 :bookmark_tabs:                📊 :bar_chart:\n📈 :chart_with_upwards_trend:         📉 :chart_with_downwards_trend:   📜 :scroll:\n📋 :clipboard:                        📆 :calendar:                     📅 :date:\n📇 :card_index:                       📁 :file_folder:                  📂 :open_file_folder:\n✂️ :scissors:                         📌 :pushpin:                      📎 :paperclip:\n✒️ :black_nib:                        ✏️ :pencil2:                      📏 :straight_ruler:\n📐 :triangular_ruler:                 📕 :closed_book:                  📗 :green_book:\n📘 :blue_book:                        📙 :orange_book:                  📓 :notebook:\n📔 :notebook_with_decorative_cover:   📒 :ledger:                       📚 :books:\n🔖 :bookmark:                         📛 :name_badge:                   🔬 :microscope:\n🔭 :telescope:                        📰 :newspaper:                    🏈 :football:\n🏀 :basketball:                       ⚽️ :soccer:                       ⚾️ :baseball:\n🎾 :tennis:                           🎱 :8ball:                        🏉 :rugby_football:\n🎳 :bowling:                          ⛳️ :golf:                         🚵 :mountain_bicyclist:\n🚴 :bicyclist:                        🏇 :horse_racing:                 🏂 :snowboarder:\n🏊 :swimmer:                          🏄 :surfer:                       🎿 :ski:\n♠️ :spades:                           ♥️ :hearts:                       ♣️ :clubs:\n♦️ :diamonds:                         💎 :gem:                          💍 :ring:\n🏆 :trophy:                           🎼 :musical_score:                🎹 :musical_keyboard:\n🎻 :violin:                           👾 :space_invader:                🎮 :video_game:\n🃏 :black_joker:                      🎴 :flower_playing_cards:         🎲 :game_die:\n🎯 :dart:                             🀄️ :mahjong:                     🎬 :clapper:\n📝 :memo:                             📝 :pencil:                       📖 :book:\n🎨 :art:                              🎤 :microphone:                   🎧 :headphones:\n🎺 :trumpet:                          🎷 :saxophone:                    🎸 :guitar:\n👞 :shoe:                             👡 :sandal:                       👠 :high_heel:\n💄 :lipstick:                         👢 :boot:                         👕 :shirt:\n👕 :tshirt:                           👔 :necktie:                      👚 :womans_clothes:\n👗 :dress:                            🎽 :running_shirt_with_sash:      👖 :jeans:\n👘 :kimono:                           👙 :bikini:                       🎀 :ribbon:\n🎩 :tophat:                           👑 :crown:                        👒 :womans_hat:\n👞 :mans_shoe:                        🌂 :closed_umbrella:              💼 :briefcase:\n👜 :handbag:                          👝 :pouch:                        👛 :purse:\n👓 :eyeglasses:                       🎣 :fishing_pole_and_fish:        ☕️ :coffee:\n🍵 :tea:                              🍶 :sake:                         🍼 :baby_bottle:\n🍺 :beer:                             🍻 :beers:                        🍸 :cocktail:\n🍹 :tropical_drink:                   🍷 :wine_glass:                   🍴 :fork_and_knife:\n🍕 :pizza:                            🍔 :hamburger:                    🍟 :fries:\n🍗 :poultry_leg:                      🍖 :meat_on_bone:                 🍝 :spaghetti:\n🍛 :curry:                            🍤 :fried_shrimp:                 🍱 :bento:\n🍣 :sushi:                            🍥 :fish_cake:                    🍙 :rice_ball:\n🍘 :rice_cracker:                     🍚 :rice:                         🍜 :ramen:\n🍲 :stew:                             🍢 :oden:                         🍡 :dango:\n🥚 :egg:                              🍞 :bread:                        🍩 :doughnut:\n🍮 :custard:                          🍦 :icecream:                     🍨 :ice_cream:\n🍧 :shaved_ice:                       🎂 :birthday:                     🍰 :cake:\n🍪 :cookie:                           🍫 :chocolate_bar:                🍬 :candy:\n🍭 :lollipop:                         🍯 :honey_pot:                    🍎 :apple:\n🍏 :green_apple:                      🍊 :tangerine:                    🍋 :lemon:\n🍒 :cherries:                         🍇 :grapes:                       🍉 :watermelon:\n🍓 :strawberry:                       🍑 :peach:                        🍈 :melon:\n🍌 :banana:                           🍐 :pear:                         🍍 :pineapple:\n🍠 :sweet_potato:                     🍆 :eggplant:                     🍅 :tomato:\n🌽 :corn:                                                               \n\n\n# places\n\n🏠 :house:                 🏡 :house_with_garden:         🏫 :school:\n🏢 :office:                🏣 :post_office:               🏥 :hospital:\n🏦 :bank:                  🏪 :convenience_store:         🏩 :love_hotel:\n🏨 :hotel:                 💒 :wedding:                   ⛪️ :church:\n🏬 :department_store:      🏤 :european_post_office:      🌇 :city_sunrise:\n🌆 :city_sunset:           🏯 :japanese_castle:           🏰 :european_castle:\n⛺️ :tent:                  🏭 :factory:                   🗼 :tokyo_tower:\n🗾 :japan:                 🗻 :mount_fuji:                🌄 :sunrise_over_mountains:\n🌅 :sunrise:               🌠 :stars:                     🗽 :statue_of_liberty:\n🌉 :bridge_at_night:       🎠 :carousel_horse:            🌈 :rainbow:\n🎡 :ferris_wheel:          ⛲️ :fountain:                  🎢 :roller_coaster:\n🚢 :ship:                  🚤 :speedboat:                 ⛵️ :boat:\n⛵️ :sailboat:              🚣 :rowboat:                   ⚓️ :anchor:\n🚀 :rocket:                ✈️ :airplane:                  🚁 :helicopter:\n🚂 :steam_locomotive:      🚊 :tram:                      🚞 :mountain_railway:\n🚲 :bike:                  🚡 :aerial_tramway:            🚟 :suspension_railway:\n🚠 :mountain_cableway:     🚜 :tractor:                   🚙 :blue_car:\n🚘 :oncoming_automobile:   🚗 :car:                       🚗 :red_car:\n🚕 :taxi:                  🚖 :oncoming_taxi:             🚛 :articulated_lorry:\n🚌 :bus:                   🚍 :oncoming_bus:              🚨 :rotating_light:\n🚓 :police_car:            🚔 :oncoming_police_car:       🚒 :fire_engine:\n🚑 :ambulance:             🚐 :minibus:                   🚚 :truck:\n🚋 :train:                 🚉 :station:                   🚆 :train2:\n🚅 :bullettrain_front:     🚄 :bullettrain_side:          🚈 :light_rail:\n🚝 :monorail:              🚃 :railway_car:               🚎 :trolleybus:\n🎫 :ticket:                ⛽️ :fuelpump:                  🚦 :vertical_traffic_light:\n🚥 :traffic_light:         ⚠️ :warning:                   🚧 :construction:\n🔰 :beginner:              🏧 :atm:                       🎰 :slot_machine:\n🚏 :busstop:               💈 :barber:                    ♨️ :hotsprings:\n🏁 :checkered_flag:        🎌 :crossed_flags:             🏮 :izakaya_lantern:\n🗿 :moyai:                 🎪 :circus_tent:               🎭 :performing_arts:\n📍 :round_pushpin:         🚩 :triangular_flag_on_post:   🇯🇵 :jp:\n🇰🇷 :kr:                  🇨🇳 :cn:                      🇺🇸 :us:\n🇫🇷 :fr:                  🇪🇸 :es:                      🇮🇹 :it:\n🇷🇺 :ru:                  🇬🇧 :gb:                      🇬🇧 :uk:\n🇩🇪 :de:                                                 \n\n\n# symbols\n\n1️⃣ :one:                             2️⃣ :two:                        3️⃣ :three:\n4️⃣ :four:                            5️⃣ :five:                       6️⃣ :six:\n7️⃣ :seven:                           8️⃣ :eight:                      9️⃣ :nine:\n🔟 :keycap_ten:                       🔢 :1234:                        0️⃣ :zero:\n#️⃣ :hash:                            🔣 :symbols:                     ◀️ :arrow_backward:\n⬇️ :arrow_down:                       ▶️ :arrow_forward:               ⬅️ :arrow_left:\n🔠 :capital_abcd:                     🔡 :abcd:                        🔤 :abc:\n↙️ :arrow_lower_left:                 ↘️ :arrow_lower_right:           ➡️ :arrow_right:\n⬆️ :arrow_up:                         ↖️ :arrow_upper_left:            ↗️ :arrow_upper_right:\n⏬ :arrow_double_down:                 ⏫ :arrow_double_up:              🔽 :arrow_down_small:\n⤵️ :arrow_heading_down:               ⤴️ :arrow_heading_up:            ↩️:leftwards_arrow_with_hook:\n↪️ :arrow_right_hook:                 ↔️ :left_right_arrow:            ↕️ :arrow_up_down:\n🔼 :arrow_up_small:                   🔃 :arrows_clockwise:            🔄 :arrows_counterclockwise:\n⏪ :rewind:                            ⏩ :fast_forward:                 ℹ️ :information_source:\n🆗 :ok:                               🔀 :twisted_rightwards_arrows:   🔁 :repeat:\n🔂 :repeat_one:                       🆕 :new:                         🔝 :top:\n🆙 :up:                               🆒 :cool:                        🆓 :free:\n🆖 :ng:                               🎦 :cinema:                      🈁 :koko:\n📶 :signal_strength:                  🈹 :u5272:                       🈴 :u5408:\n🈺 :u55b6:                            🈯️ :u6307:                      🈷️ :u6708:\n🈶 :u6709:                            🈵 :u6e80:                       🈚️ :u7121:\n🈸 :u7533:                            🈳 :u7a7a:                       🈲 :u7981:\n🈂️ :sa:                              🚻 :restroom:                    🚹 :mens:\n🚺 :womens:                           🚼 :baby_symbol:                 🚭 :no_smoking:\n🅿️ :parking:                         ♿️ :wheelchair:                  🚇 :metro:\n🛄 :baggage_claim:                    🉑 :accept:                      🚾 :wc:\n🚰 :potable_water:                    🚮 :put_litter_in_its_place:     ㊙️ :secret:\n㊗️ :congratulations:                  ⓜ️ :m:                           🛂 :passport_control:\n🛅 :left_luggage:                     🛃 :customs:                     🉐 :ideograph_advantage:\n🆑 :cl:                               🆘 :sos:                         🆔 :id:\n🚫 :no_entry_sign:                    🔞 :underage:                    📵 :no_mobile_phones:\n🚯 :do_not_litter:                    🚱 :non-potable_water:           🚳 :no_bicycles:\n🚷 :no_pedestrians:                   🚸 :children_crossing:           ⛔️ :no_entry:\n✳️ :eight_spoked_asterisk:            ✴️ :eight_pointed_black_star:    💟 :heart_decoration:\n🆚 :vs:                               📳 :vibration_mode:              📴 :mobile_phone_off:\n💹 :chart:                            💱 :currency_exchange:           ♈️ :aries:\n♉️ :taurus:                           ♊️ :gemini:                      ♋️ :cancer:\n♌️ :leo:                              ♍️ :virgo:                       ♎️ :libra:\n♏️ :scorpius:                         ♐️ :sagittarius:                 ♑️ :capricorn:\n♒️ :aquarius:                         ♓️ :pisces:                      ⛎ :ophiuchus:\n🔯 :six_pointed_star:                 ❎:negative_squared_cross_mark:   🅰️ :a:\n🅱️ :b:                               🆎 :ab:                          🅾️ :o2:\n💠:diamond_shape_with_a_dot_inside:   ♻️ :recycle:                     🔚 :end:\n🔛 :on:                               🔜 :soon:                        🕐 :clock1:\n🕜 :clock130:                         🕙 :clock10:                     🕥 :clock1030:\n🕚 :clock11:                          🕦 :clock1130:                   🕛 :clock12:\n🕧 :clock1230:                        🕑 :clock2:                      🕝 :clock230:\n🕒 :clock3:                           🕞 :clock330:                    🕓 :clock4:\n🕟 :clock430:                         🕔 :clock5:                      🕠 :clock530:\n🕕 :clock6:                           🕡 :clock630:                    🕖 :clock7:\n🕢 :clock730:                         🕗 :clock8:                      🕣 :clock830:\n🕘 :clock9:                           🕤 :clock930:                    💲 :heavy_dollar_sign:\n©️ :copyright:                        ®️ :registered:                  ™️ :tm:\n❌ :x:                                 ❗️ :heavy_exclamation_mark:      ‼️ :bangbang:\n⁉️ :interrobang:                      ⭕️ :o:                           ✖️ :heavy_multiplication_x:\n➕ :heavy_plus_sign:                   ➖ :heavy_minus_sign:             ➗ :heavy_division_sign:\n💮 :white_flower:                     💯 :100:                         ✔️ :heavy_check_mark:\n☑️ :ballot_box_with_check:            🔘 :radio_button:                🔗 :link:\n➰ :curly_loop:                        〰️ :wavy_dash:                   〽️ :part_alternation_mark:\n✅ :white_check_mark:                  🔲 :black_square_button:         🔳 :white_square_button:\n⚫️ :black_circle:                     ⚪️ :white_circle:                🔴 :red_circle:\n🔵 :large_blue_circle:                🔷 :large_blue_diamond:          🔶 :large_orange_diamond:\n🔹 :small_blue_diamond:               🔸 :small_orange_diamond:        🔺 :small_red_triangle:\n🔻 :small_red_triangle_down:          🔱 :trident:                     \n\n\n# 参考链接\n\n * https://www.kuangstudy.com/bbs/1363014604904587265\n * https://blog.csdn.net/u011583927/article/details/104094284\n * https://note.oddfar.com/pages/fe0004/",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"变更Git作者邮箱信息",frontmatter:{title:"变更Git作者邮箱信息",date:"2025-02-11T03:56:22.000Z",permalink:"/pages/c87550/",categories:["工具","开发管理 - Git"],tags:[null],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/16.%E5%8F%98%E6%9B%B4Git%E4%BD%9C%E8%80%85%E9%82%AE%E7%AE%B1%E4%BF%A1%E6%81%AF.html",relativePath:"40.工具/20.开发管理 - Git/16.变更Git作者邮箱信息.md",key:"v-3e18e141",path:"/pages/c87550/",headersStr:null,content:' 1. 给你的repo创建一个全新的clone git clone --bare https://github.com/user/repo.git\n    \n    cd repo.git\n\n 2. 复制粘贴脚本，并根据你的信息修改以下变量：旧的Email地址，正确的用户名，正确的邮件地址\n    \n    #!/bin/sh\n    git filter-branch --env-filter \'\n    OLD_EMAIL="旧的Email地址"\n    CORRECT_NAME="正确的用户名"\n    CORRECT_EMAIL="正确的邮件地址"\n    if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]\n    then\n        export GIT_COMMITTER_NAME="$CORRECT_NAME"\n        export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"\n    fi\n    if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]\n    then\n        export GIT_AUTHOR_NAME="$CORRECT_NAME"\n        export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"\n    fi\n    \' --tag-name-filter cat -- --branches --tags\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 3. xx\n    \n    #!/bin/sh                    \n    git filter-branch --env-filter \'\n    OLD_EMAIL="“wuwanming0405@163.com”"\n    CORRECT_NAME="Ming-D-W"\n    CORRECT_EMAIL="wuwanming0405@163.com"\n    if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]\n    then\n        export GIT_COMMITTER_NAME="$CORRECT_NAME"\n        export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"\n    fi\n    if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]\n    then\n        export GIT_AUTHOR_NAME="$CORRECT_NAME"\n        export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"\n    fi\n    \' --tag-name-filter cat -- --branches --tags\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n     git filter-branch --env-filter \'   \n    OLD_NAME="吴万明"\n    CORRECT_NAME="Ming-D-W"\n    CORRECT_EMAIL="wuwanming0405@163.com"\n    if [ "$GIT_COMMITTER_NAME" = "$OLD_NAME" ]\n    then\n        export GIT_COMMITTER_NAME="$CORRECT_NAME"\n        export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"\n    fi\n    if [ "$GIT_AUTHOR_NAME" = "$OLD_NAME" ]\n    then\n        export GIT_AUTHOR_NAME="$CORRECT_NAME"\n        export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"\n    fi\n    \' --tag-name-filter cat -- --branches --tags;\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. 按 Enter键 执行脚本。\n\n 5. 用git log命令看看新 Git 历史有没有错误\n\n 6. 把正确历史 push 到 Github\n    \n    git push --force --tags origin \'refs/heads/*\'\n    \n    \n    1\n    \n\n 7. 删掉刚刚临时创建的 clone\n    \n    cd ..\n    rm -rf repo.git\n    \n    \n    1\n    2\n    \n\n 8. 将本地仓库强制同步为远程仓库的 master 分支状态\n    \n    git fetch --all && git reset --hard origin/master \n    \n    \n    1\n    \n    \n    具体含义如下：\n    \n    1. git fetch --all：\n       * 从所有远程仓库获取最新的分支和提交信息，但不会自动合并或修改本地代码。\n       * 这确保本地仓库知道远程仓库的最新状态。\n    2. git reset --hard origin/master：\n       * 将本地当前分支强制重置为 origin/master 的状态。\n       * --hard 选项会丢弃所有本地未提交的更改和工作目录中的修改，确保本地与远程完全一致。',normalizedContent:' 1. 给你的repo创建一个全新的clone git clone --bare https://github.com/user/repo.git\n    \n    cd repo.git\n\n 2. 复制粘贴脚本，并根据你的信息修改以下变量：旧的email地址，正确的用户名，正确的邮件地址\n    \n    #!/bin/sh\n    git filter-branch --env-filter \'\n    old_email="旧的email地址"\n    correct_name="正确的用户名"\n    correct_email="正确的邮件地址"\n    if [ "$git_committer_email" = "$old_email" ]\n    then\n        export git_committer_name="$correct_name"\n        export git_committer_email="$correct_email"\n    fi\n    if [ "$git_author_email" = "$old_email" ]\n    then\n        export git_author_name="$correct_name"\n        export git_author_email="$correct_email"\n    fi\n    \' --tag-name-filter cat -- --branches --tags\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 3. xx\n    \n    #!/bin/sh                    \n    git filter-branch --env-filter \'\n    old_email="“wuwanming0405@163.com”"\n    correct_name="ming-d-w"\n    correct_email="wuwanming0405@163.com"\n    if [ "$git_committer_email" = "$old_email" ]\n    then\n        export git_committer_name="$correct_name"\n        export git_committer_email="$correct_email"\n    fi\n    if [ "$git_author_email" = "$old_email" ]\n    then\n        export git_author_name="$correct_name"\n        export git_author_email="$correct_email"\n    fi\n    \' --tag-name-filter cat -- --branches --tags\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n    \n     git filter-branch --env-filter \'   \n    old_name="吴万明"\n    correct_name="ming-d-w"\n    correct_email="wuwanming0405@163.com"\n    if [ "$git_committer_name" = "$old_name" ]\n    then\n        export git_committer_name="$correct_name"\n        export git_committer_email="$correct_email"\n    fi\n    if [ "$git_author_name" = "$old_name" ]\n    then\n        export git_author_name="$correct_name"\n        export git_committer_email="$correct_email"\n    fi\n    \' --tag-name-filter cat -- --branches --tags;\n    \n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. 按 enter键 执行脚本。\n\n 5. 用git log命令看看新 git 历史有没有错误\n\n 6. 把正确历史 push 到 github\n    \n    git push --force --tags origin \'refs/heads/*\'\n    \n    \n    1\n    \n\n 7. 删掉刚刚临时创建的 clone\n    \n    cd ..\n    rm -rf repo.git\n    \n    \n    1\n    2\n    \n\n 8. 将本地仓库强制同步为远程仓库的 master 分支状态\n    \n    git fetch --all && git reset --hard origin/master \n    \n    \n    1\n    \n    \n    具体含义如下：\n    \n    1. git fetch --all：\n       * 从所有远程仓库获取最新的分支和提交信息，但不会自动合并或修改本地代码。\n       * 这确保本地仓库知道远程仓库的最新状态。\n    2. git reset --hard origin/master：\n       * 将本地当前分支强制重置为 origin/master 的状态。\n       * --hard 选项会丢弃所有本地未提交的更改和工作目录中的修改，确保本地与远程完全一致。',charsets:{cjk:!0},lastUpdated:"2025/03/04, 10:43:57",lastUpdatedTimestamp:1741056237e3},{title:"Git - 自建代码托管平台",frontmatter:{title:"Git - 自建代码托管平台",date:"2021-02-08T18:52:23.000Z",permalink:"/git/built-code-platform/",categories:["Git"],tags:["Git"],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/20.%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%20-%20Git/11.Git%20-%20%E8%87%AA%E5%BB%BA%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0.html",relativePath:"40.工具/20.开发管理 - Git/11.Git - 自建代码托管平台.md",key:"v-0e1882ae",path:"/git/built-code-platform/",headers:[{level:2,title:"GitLab简介",slug:"gitlab简介",normalizedTitle:"gitlab简介",charIndex:104},{level:2,title:"GitLab安装",slug:"gitlab安装",normalizedTitle:"gitlab安装",charIndex:116},{level:3,title:"服务器准备",slug:"服务器准备",normalizedTitle:"服务器准备",charIndex:130},{level:3,title:"安装包准备",slug:"安装包准备",normalizedTitle:"安装包准备",charIndex:141},{level:3,title:"编写安装脚本",slug:"编写安装脚本",normalizedTitle:"编写安装脚本",charIndex:152},{level:2,title:"GitLab使用",slug:"gitlab使用",normalizedTitle:"gitlab使用",charIndex:162},{level:3,title:"初始化GitLab服务",slug:"初始化gitlab服务",normalizedTitle:"初始化gitlab服务",charIndex:176},{level:3,title:"启动GitLab服务",slug:"启动gitlab服务",normalizedTitle:"启动gitlab服务",charIndex:193},{level:3,title:"使用浏览器访问GitLab",slug:"使用浏览器访问gitlab",normalizedTitle:"使用浏览器访问gitlab",charIndex:209},{level:3,title:"GitLab创建远程库",slug:"gitlab创建远程库",normalizedTitle:"gitlab创建远程库",charIndex:228},{level:2,title:"IDEA集成GitLab",slug:"idea集成gitlab",normalizedTitle:"idea集成gitlab",charIndex:243},{level:3,title:"安装GitLab插件",slug:"安装gitlab插件",normalizedTitle:"安装gitlab插件",charIndex:261}],headersStr:"GitLab简介 GitLab安装 服务器准备 安装包准备 编写安装脚本 GitLab使用 初始化GitLab服务 启动GitLab服务 使用浏览器访问GitLab GitLab创建远程库 IDEA集成GitLab 安装GitLab插件",content:'笔记\n\nGitHub 或 Gitee 平台的私有库只能免费 5 个人，当公司里多人开发一个项目，又不希望公开出去，那么就可以自建代码托管平台：GitLab。\n\n2022-02-08 @Du Wu\n\n\n\n * GitLab简介\n * GitLab安装\n   * 服务器准备\n   * 安装包准备\n   * 编写安装脚本\n * GitLab使用\n   * 初始化GitLab服务\n   * 启动GitLab服务\n   * 使用浏览器访问GitLab\n   * GitLab创建远程库\n * IDEA集成GitLab\n   * 安装GitLab插件\n\n\n\n\n# GitLab简介\n\nGitLab 是由 GitLabInc 开发，使用 MIT 许可证的基于网络的 Git 仓库管理工具，且具有 wiki 和 issue 跟踪功能。使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务。\n\nGitLab 由乌克兰程序员 DmitriyZaporozhets 和 ValerySizov 开发，它使用 Ruby 语言写成。后来，一些部分用 Go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。GitLab 被 IBM，Sony，JülichResearchCenter，NASA，Alibaba，Invincea，O’ReillyMedia，Leibniz-Rechenzentrum(LRZ)，CERN，SpaceX 等组织使用。\n\n> 官网地址：https://about.gitlab.com/\n> \n> 安装说明：https://about.gitlab.com/installation/\n\n\n# GitLab安装\n\n\n# 服务器准备\n\n准备一个系统为 CentOS7 以上版本的服务器，要求内存 4G，磁盘 50G。\n\n关闭防火墙，并且配置好主机名和 IP，保证服务器可以上网。\n\n本内容使用虚拟机：\n\n * 主机名：gitlab-server\n\n * IP 地址：192.168.6.200\n\n\n# 安装包准备\n\nYum 在线安装 gitlab- ce 时，需要下载几百 M 的安装文件，非常耗时，所以最好提前把所需 RPM 包下载到本地，然后使用离线 rpm 的方式安装。\n\n> 下载地址：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\n\n\n# 编写安装脚本\n\n安装 GitLab 步骤比较繁琐，因此我们可以参考官网编写 GitLab 的安装脚本\n\nvim gitlab-install.sh\n# 内容\nsudo rpm -ivh /opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\nsudo yum install -y curl policycoreutils-python openssh-server cronie\nsudo lokkit -s http -s ssh\nsudo yum install -y postfix\nsudo service postfix start\nsudo chkconfig postfix on\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\nsudo EXTERNAL_URL="http://gitlab.example.com" yum -y install gitlab-ce\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n给脚本增加执行权限\n\nchmod +x gitlab-install.sh\n\n\n1\n\n\n然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网\n\n./gitlab-install.sh\n\n\n1\n\n\n\n# GitLab使用\n\n\n# 初始化GitLab服务\n\n执行以下命令初始化 GitLab 服务，过程大概需要几分钟，耐心等待 ...\n\ngitlab-ctl reconfigure\n\n\n1\n\n\n\n# 启动GitLab服务\n\n执行 itlab-ctl stop 命令启动 GitLab 服务，如需停止，执行 gitlab-ctl stop 命令\n\ngitlab-ctl start  # 开启服务\n\ngitlab-ctl stop # 停止服务\n\n\n1\n2\n3\n\n\n\n# 使用浏览器访问GitLab\n\n使用主机名或者 IP 地址即可访问 GitLab 服务。如果使用主机名访问，则需要提前配一下 Windows 的 hosts 文件\n\n\n\n\n\n或者通过 IP 地址访问\n\n\n\n首次登陆之前，需要修改下 GitLab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。\n\n然后使用修改后的密码登录 GitLab\n\n\n\nGitLab 登录成功\n\n\n\n\n# GitLab创建远程库\n\n\n\n\n\n\n\n\n# IDEA集成GitLab\n\n\n# 安装GitLab插件\n\n\n\n设置 GitLab 插件\n\n\n\n\n\n\n\npush 本地代码到 GitLab 远程库\n\n\n\n自定义远程连接\n\n\n\n注意：GitLab 网页上复制过来的连接是：http://gitlab.example.com/root/git-test.git，需要手动修改为：http://gitlab-server/root/git-test.git。\n\n选择 GitLab 远程连接，进行 push\n\n\n\n首次向连接 GitLab，需要登录帐号和密码，用 root 帐号和我们修改的密码登录即可\n\n\n\n代码 push 成功\n\n\n\n只要 GitLab 的远程库连接定义好以后，对 GitLab 远程库进行 pull 和 clone 的操作和 Github 和码云一致，此处不再赘述。',normalizedContent:'笔记\n\ngithub 或 gitee 平台的私有库只能免费 5 个人，当公司里多人开发一个项目，又不希望公开出去，那么就可以自建代码托管平台：gitlab。\n\n2022-02-08 @du wu\n\n\n\n * gitlab简介\n * gitlab安装\n   * 服务器准备\n   * 安装包准备\n   * 编写安装脚本\n * gitlab使用\n   * 初始化gitlab服务\n   * 启动gitlab服务\n   * 使用浏览器访问gitlab\n   * gitlab创建远程库\n * idea集成gitlab\n   * 安装gitlab插件\n\n\n\n\n# gitlab简介\n\ngitlab 是由 gitlabinc 开发，使用 mit 许可证的基于网络的 git 仓库管理工具，且具有 wiki 和 issue 跟踪功能。使用 git 作为代码管理工具，并在此基础上搭建起来的 web 服务。\n\ngitlab 由乌克兰程序员 dmitriyzaporozhets 和 valerysizov 开发，它使用 ruby 语言写成。后来，一些部分用 go 语言重写。截止 2018 年 5 月，该公司约有 290 名团队成员，以及 2000 多名开源贡献者。gitlab 被 ibm，sony，julichresearchcenter，nasa，alibaba，invincea，o’reillymedia，leibniz-rechenzentrum(lrz)，cern，spacex 等组织使用。\n\n> 官网地址：https://about.gitlab.com/\n> \n> 安装说明：https://about.gitlab.com/installation/\n\n\n# gitlab安装\n\n\n# 服务器准备\n\n准备一个系统为 centos7 以上版本的服务器，要求内存 4g，磁盘 50g。\n\n关闭防火墙，并且配置好主机名和 ip，保证服务器可以上网。\n\n本内容使用虚拟机：\n\n * 主机名：gitlab-server\n\n * ip 地址：192.168.6.200\n\n\n# 安装包准备\n\nyum 在线安装 gitlab- ce 时，需要下载几百 m 的安装文件，非常耗时，所以最好提前把所需 rpm 包下载到本地，然后使用离线 rpm 的方式安装。\n\n> 下载地址：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\n\n\n# 编写安装脚本\n\n安装 gitlab 步骤比较繁琐，因此我们可以参考官网编写 gitlab 的安装脚本\n\nvim gitlab-install.sh\n# 内容\nsudo rpm -ivh /opt/module/gitlab-ce-13.10.2-ce.0.el7.x86_64.rpm\nsudo yum install -y curl policycoreutils-python openssh-server cronie\nsudo lokkit -s http -s ssh\nsudo yum install -y postfix\nsudo service postfix start\nsudo chkconfig postfix on\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\nsudo external_url="http://gitlab.example.com" yum -y install gitlab-ce\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n给脚本增加执行权限\n\nchmod +x gitlab-install.sh\n\n\n1\n\n\n然后执行该脚本，开始安装 gitlab-ce。注意一定要保证服务器可以上网\n\n./gitlab-install.sh\n\n\n1\n\n\n\n# gitlab使用\n\n\n# 初始化gitlab服务\n\n执行以下命令初始化 gitlab 服务，过程大概需要几分钟，耐心等待 ...\n\ngitlab-ctl reconfigure\n\n\n1\n\n\n\n# 启动gitlab服务\n\n执行 itlab-ctl stop 命令启动 gitlab 服务，如需停止，执行 gitlab-ctl stop 命令\n\ngitlab-ctl start  # 开启服务\n\ngitlab-ctl stop # 停止服务\n\n\n1\n2\n3\n\n\n\n# 使用浏览器访问gitlab\n\n使用主机名或者 ip 地址即可访问 gitlab 服务。如果使用主机名访问，则需要提前配一下 windows 的 hosts 文件\n\n\n\n\n\n或者通过 ip 地址访问\n\n\n\n首次登陆之前，需要修改下 gitlab 提供的 root 账户的密码，要求 8 位以上，包含大小写子母和特殊符号。\n\n然后使用修改后的密码登录 gitlab\n\n\n\ngitlab 登录成功\n\n\n\n\n# gitlab创建远程库\n\n\n\n\n\n\n\n\n# idea集成gitlab\n\n\n# 安装gitlab插件\n\n\n\n设置 gitlab 插件\n\n\n\n\n\n\n\npush 本地代码到 gitlab 远程库\n\n\n\n自定义远程连接\n\n\n\n注意：gitlab 网页上复制过来的连接是：http://gitlab.example.com/root/git-test.git，需要手动修改为：http://gitlab-server/root/git-test.git。\n\n选择 gitlab 远程连接，进行 push\n\n\n\n首次向连接 gitlab，需要登录帐号和密码，用 root 帐号和我们修改的密码登录即可\n\n\n\n代码 push 成功\n\n\n\n只要 gitlab 的远程库连接定义好以后，对 gitlab 远程库进行 pull 和 clone 的操作和 github 和码云一致，此处不再赘述。',charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:26:04",lastUpdatedTimestamp:1682357164e3},{title:"Babel与webpack",frontmatter:{title:"Babel与webpack",date:"2021-05-25T00:58:24.000Z",permalink:"/pages/c955d9/",categories:["工具","webpack"],tags:[null],readingShow:"top"},regularPath:"/40.%E5%B7%A5%E5%85%B7/30.%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7-webpack/01.Babel%E4%B8%8Ewebpack.html",relativePath:"40.工具/30.构建工具-webpack/01.Babel与webpack.md",key:"v-77cb82b4",path:"/pages/c955d9/",headers:[{level:2,title:"一、Babel与webpack",slug:"一、babel与webpack",normalizedTitle:"一、babel与webpack",charIndex:2},{level:3,title:"1.1 认识Babel",slug:"_1-1-认识babel",normalizedTitle:"1.1 认识babel",charIndex:22},{level:3,title:"1.2 Babel的使用方式",slug:"_1-2-babel的使用方式",normalizedTitle:"1.2 babel的使用方式",charIndex:438},{level:3,title:"1.3 使用Babel前的准备工作",slug:"_1-3-使用babel前的准备工作",normalizedTitle:"1.3 使用babel前的准备工作",charIndex:716},{level:4,title:"1.3.1 什么是Node.js和npm",slug:"_1-3-1-什么是node-js和npm",normalizedTitle:"1.3.1 什么是node.js和npm",charIndex:737},{level:4,title:"1.3.2 安装Node.js",slug:"_1-3-2-安装node-js",normalizedTitle:"1.3.2 安装node.js",charIndex:1234},{level:4,title:"1.3.3 初始化项目",slug:"_1-3-3-初始化项目",normalizedTitle:"1.3.3 初始化项目",charIndex:1370},{level:4,title:"1.3.4 安装Babel需要的包",slug:"_1-3-4-安装babel需要的包",normalizedTitle:"1.3.4 安装babel需要的包",charIndex:1920},{level:4,title:"1.3.5 使用Babel编译ES6代码",slug:"_1-3-5-使用babel编译es6代码",normalizedTitle:"1.3.5 使用babel编译es6代码",charIndex:2629},{level:3,title:"1.4 Webpack是什么",slug:"_1-4-webpack是什么",normalizedTitle:"1.4 webpack是什么",charIndex:3408},{level:3,title:"1.5 Webpack初体验",slug:"_1-5-webpack初体验",normalizedTitle:"1.5 webpack初体验",charIndex:3693},{level:3,title:"1.6 entry和output",slug:"_1-6-entry和output",normalizedTitle:"1.6 entry和output",charIndex:12934},{level:3,title:"1.7 loader",slug:"_1-7-loader",normalizedTitle:"1.7 loader",charIndex:14267},{level:3,title:"1.8 plugins",slug:"_1-8-plugins",normalizedTitle:"1.8 plugins",charIndex:16255},{level:3,title:"1.9 处理CSS",slug:"_1-9-处理css",normalizedTitle:"1.9 处理css",charIndex:19749},{level:3,title:"1.10 处理CSS图片",slug:"_1-10-处理css图片",normalizedTitle:"1.10 处理css图片",charIndex:22970},{level:3,title:"1.11 处理HTML图片",slug:"_1-11-处理html图片",normalizedTitle:"1.11 处理html图片",charIndex:29325},{level:3,title:"1.12 处理JS图片",slug:"_1-12-处理js图片",normalizedTitle:"1.12 处理js图片",charIndex:31943},{level:3,title:"1.13 url-loader处理图片",slug:"_1-13-url-loader处理图片",normalizedTitle:"1.13 url-loader处理图片",charIndex:32196},{level:3,title:"1.14 webpack-dev-server",slug:"_1-14-webpack-dev-server",normalizedTitle:"1.14 webpack-dev-server",charIndex:34665}],headersStr:"一、Babel与webpack 1.1 认识Babel 1.2 Babel的使用方式 1.3 使用Babel前的准备工作 1.3.1 什么是Node.js和npm 1.3.2 安装Node.js 1.3.3 初始化项目 1.3.4 安装Babel需要的包 1.3.5 使用Babel编译ES6代码 1.4 Webpack是什么 1.5 Webpack初体验 1.6 entry和output 1.7 loader 1.8 plugins 1.9 处理CSS 1.10 处理CSS图片 1.11 处理HTML图片 1.12 处理JS图片 1.13 url-loader处理图片 1.14 webpack-dev-server",content:"# 一、Babel与webpack\n\n\n# 1.1 认识Babel\n\n官网：Babel · The compiler for next generation JavaScript https://babel.dev/\n\n在线编译：Babel · The compiler for next generation JavaScript https://babel.dev/repl\n\nBabel 是 JavaScript 的编译器，用来将 ES6 代码转换成 ES6 之前的代码。\n\nBabel 本身可以编译 ES6 的大部分语法，比如：let、const、箭头函数、class，……，但是对于 ES6 新增的 API，比如：Set、Map、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign/Array.from）都不能直接编译，需要借助其它的模块，Babel 一般需要配合 Webpack 来编译 Module 模块语法。\n\n\n# 1.2 Babel的使用方式\n\n使用方式说明：Babel · The compiler for next generation JavaScript https://babel.dev/setup\n\n目前，我们主要关注：CLI 及 Webpack。\n\n注意：我们一般不考虑 In the browser 方式，因为此种方式代码每次被浏览器执行时都要先转换为 ES6 之前的代码，这样的转换影响了性能，而 CLI 及 Webpack 的方式是提前就将 ES6 代码转化为 ES6 之前的代码，浏览器在运行时已经是 ES6 之前的代码了，不影响性能。\n\n\n# 1.3 使用Babel前的准备工作\n\n# 1.3.1 什么是Node.js和npm\n\n简单的说 Node.js 就是运行在服务端的 JavaScript。\n\nNode.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。\n\nNode.js 是一个事件驱动 I/O 服务端 JavaScript 环境，基于 Google 的 V8 引擎，V8 引擎执行 Javascript 的速度非常快，性能非常好。\n\n后端的 JavaScript = ECMAScript + IO + File + ...服务器端的操作。\n\nnpm 是随同 Node.js 一起安装的包管理工具，能解决 Node.js 代码部署上的很多问题，常见的使用场景有以下几种：\n\n * 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。\n * 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。\n\n由于新版的 Node.js 已经集成了 npm，所以之前 npm 也一并安装好了。同样可以通过输入 \"npm -v\" 来测试是否成功安装。\n\n# 1.3.2 安装Node.js\n\nNode.js 中文官网：Node.js (nodejs.org)\n\n我们下载长期支持版，并双击安装包根据提示进行安装即可。\n\n可以通过在终端中依次输入：node -v 及 npm -v 来查看版本，如果查看成功，即表明安装成功。\n\n# 1.3.3 初始化项目\n\n * 初始化项目：npm init\n\n * 进行项目配置\n\n * 确认配置并正式生成项目\n\n\n\n> 当依次正确完成以上步骤后，项目路径下就会生成一个 package.json 文件，里面最初记录了我们 npm 项目的初始化配置信息，往后我们利用 npm 安装的依赖及包都会记录在这个文件中。\n> \n> 往后当我们需要迁移项目时，我们只需要拷贝这个 package.json 文件，然后在新的项目中使用相应的命令，便可恢复文件中的环境、依赖及包。\n> \n> 【初始时的 package.json】\n> \n> {\n>    \"name\": \"demo\",\n>    \"version\": \"1.0.0\",\n>    \"description\": \"\",\n>    \"main\": \"index.js\",\n>    \"scripts\": {\n>     \t\"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n>    },\n>    \"author\": \"\",\n>    \"license\": \"ISC\"\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n# 1.3.4 安装Babel需要的包\n\n安装命令：npm install --save-dev @babel/core @babel/cli\n\n注意：--save-dev 表示这是一个开发环境的依赖，即上线之后是用不到的。\n\n当我们安装成功后，会得到一个依赖及包代码的放置目录和两个 json 文件，其中 package.json 文件会新增一个 devDependencies （开发依赖）属性，并记录下我们的安装记录。\n\n\n\n * @babel/cli：CLI 中使用 Babel 必须的包，实现了命令行中 Babel 命令的识别与执行等\n * @babel/core：Babel 中用于完成 “发号施令” 的包，即：指挥控制其它 Babel 包的行为\n\n> 注意：我们在安装时，要特别注意一下依赖及包的版本号，不能随意的依赖最新版本，因为最新版本可能会不兼容某些旧版本。\n\n> 当我们迁移了项目环境时，也许项目的依赖及包代码（node_modules 文件夹）已经不在了或者错误了，那么只要 package.json 文件还在，那么我们只需要执行 npm install 命令，即可根据 package.json 内容重新生成项目的依赖及包代码（node_modules 文件夹）。\n> \n> 注意：npm install 可以简写为：npm i\n> \n> 注意：在平时的项目开发中，我们在拷贝项目或者迁移项目时，通常不会把 node_modules 文件夹一同拷贝或迁移，因为该文件夹的文件数量级太大了，所以拷贝或迁移的时间会特别长，而且还容易出错，我们一般都是通过 npm install 来重新生成。\n\n# 1.3.5 使用Babel编译ES6代码\n\n首先，我们需要手动在 package.json 文件中添加以下代码：\n\n\"scripts\": {\n    \"build\": \"babel src -d lib\"\n}\n\n\n1\n2\n3\n\n\n其中 \"build\": \"babel src -d lib\" 表示：通过 babel 命令将 src 下的文件编译并输出到 lib 目录下。\n\n附：-d 实际表示的就是：--out-dir 的缩写，其实就是输出目录的意思。\n\n注意：由于我们通常不放在 lib 目录下，而是放在 dist 目录下，所以我们把 package.json 文件中添加的代码修改为：\n\n\"scripts\": {\n    \"build\": \"babel src -d dist\"\n}\n\n\n1\n2\n3\n\n\n（1）编译的命令\n\n当配置好上述步骤后，我们即可通过命令进行编译。\n\n编译命令：npm run build\n\n当我们编译成功后，便会多出一个 dist 目录，里面便放置有编译后的文件。\n\n> 当我们把编译好的文件打开后，发现里面的代码依旧是 ES6 版本的，这是因为我们在正式编译代码之前还需要设置一个 Babel 的配置文件。\n\n（2）Babel的配置文件\n\n首先，我们需要额外安装一个包：npm install @babel/preset-env --save-dev，这个包能告诉编译器具体如何转换编译 ES6 的语法。\n\n安装成功后，在项目目录下，创建一个 .babelrc。\n\n在文件中写入：\n\n{\n    \"presets\": [\"@babel/preset-env\"]\n}\n\n\n1\n2\n3\n\n\n> 配置之后，我们再次执行 npm run build 命令，那么 dist 目录中的文件就是编译完成的 ES6 之前版本的代码了！\n\n\n# 1.4 Webpack是什么\n\n（1）认识 Webpack\n\nWebpack 是静态模块打包器，当 Webpack 处理应用程序时，会将所有这些模块打包成一个或多个文件。\n\n（2）什么是 Webpack 模块？\n\n除了 JavaScript 外，还有 CSS、图片、图标字体等。\n\n（3）什么是静态？\n\n开发过程中存在于本地的 js/css/图片/图标字体 等文件，就是静态的；而从远程服务器获取的就是动态的。\n\nWebpack 没办法处理动态的部分，只能处理静态的部分。\n\nwebpack 中文文档 | webpack 中文网 (webpackjs.com)\n\n\n# 1.5 Webpack初体验\n\n（1）初始化项目\n\nnpm init，注意：项目名请不要取 webpack，因为这个项目名与 webpack 包名冲突了。\n\n（2）安装Webpack需要的包\n\nnpm install --save-dev webpack-cli@3.3.12 webpack@4.44.1，此处以某个版本作为演示。\n\n（3）配置Webpack\n\n * 创建配置文件 webpack.config.js\n\n * 编辑配置内容：\n   \n   // 导入模块（Node 方式）\n   const path = require('path');\n   \n   // 以模块方式导出配置\n   module.exports = {\n     // 入口\n     entry: './src/index.js',\n     // 出口\n     output: {\n       path: path.resolve(__dirname, 'dist'),\n       filename: 'bundle.js',\n     },\n   };\n   \n   // Webpack 的配置文件的内容也是以模块的方式导出，但是这里的模块不是 JS 模块，而是 Node 模块\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   与此同时，还需要在 package.json 中添加：\n   \n   \"scripts\": {\n       // 执行 webpack 命令就相当于去执行 webpack 配置文件\n       // (会去默认执行 webpack.config.js 配置文件)\n       // \"webpack\": \"webpack\"\n       //（去执行指定的配置文件，这个配置文件是可以自由指定的）\n       \"webpack\": \"webpack --config webpack.config.js\"\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 举例代码\n   \n   * index.html\n   \n   <!DOCTYPE html>\n   <html lang=\"en\">\n   \n   <head>\n       <meta charset=\"UTF-8\" />\n       <title>Webpack 初体验</title>\n   </head>\n   \n   <body>\n       <script src=\"./src/index.js\" type=\"module\"><\/script>\n   </body>\n   \n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   * src/index.js\n   \n   import age from './module.js';\n   \n   console.log('index.js', age);\n   \n   \n   1\n   2\n   3\n   \n   * src/module.js\n   \n   export default 18;\n   \n   console.log('module.js');\n   \n   \n   1\n   2\n   3\n   \n\n * 编译并测试\n   \n   * npm run webpack\n   \n   执行后，便会生成一个 dist 目录，并有一个 bundle.js 文件：\n   \n   !function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=0)}([function(e,t,n){\"use strict\";n.r(t);console.log(\"module.js\"),console.log(\"index.js\",18)}]);\n   \n   \n   1\n   \n   \n   可以看见，默认通过 webpack 打包后的文件是压缩版的，我们可以通过在 webpack.config.js 配置文件中设置成开发版：\n   \n   const path = require('path');\n   \n   module.exports = {\n       // 开发模式\n       mode: 'development',\n       entry: './src/index.js',\n       output: {\n           path: path.resolve(__dirname, 'dist'),\n           filename: 'bundle.js',\n       },\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   再次执行 npm run webpack，查看 dist/bundle.js 文件：\n   \n   /******/ (function(modules) { // webpackBootstrap\n   /******/ \t// The module cache\n   /******/ \tvar installedModules = {};\n   /******/\n   /******/ \t// The require function\n   /******/ \tfunction __webpack_require__(moduleId) {\n   /******/\n   /******/ \t\t// Check if module is in cache\n   /******/ \t\tif(installedModules[moduleId]) {\n   /******/ \t\t\treturn installedModules[moduleId].exports;\n   /******/ \t\t}\n   /******/ \t\t// Create a new module (and put it into the cache)\n   /******/ \t\tvar module = installedModules[moduleId] = {\n   /******/ \t\t\ti: moduleId,\n   /******/ \t\t\tl: false,\n   /******/ \t\t\texports: {}\n   /******/ \t\t};\n   /******/\n   /******/ \t\t// Execute the module function\n   /******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n   /******/\n   /******/ \t\t// Flag the module as loaded\n   /******/ \t\tmodule.l = true;\n   /******/\n   /******/ \t\t// Return the exports of the module\n   /******/ \t\treturn module.exports;\n   /******/ \t}\n   /******/\n   /******/\n   /******/ \t// expose the modules object (__webpack_modules__)\n   /******/ \t__webpack_require__.m = modules;\n   /******/\n   /******/ \t// expose the module cache\n   /******/ \t__webpack_require__.c = installedModules;\n   /******/\n   /******/ \t// define getter function for harmony exports\n   /******/ \t__webpack_require__.d = function(exports, name, getter) {\n   /******/ \t\tif(!__webpack_require__.o(exports, name)) {\n   /******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n   /******/ \t\t}\n   /******/ \t};\n   /******/\n   /******/ \t// define __esModule on exports\n   /******/ \t__webpack_require__.r = function(exports) {\n   /******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n   /******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n   /******/ \t\t}\n   /******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n   /******/ \t};\n   /******/\n   /******/ \t// create a fake namespace object\n   /******/ \t// mode & 1: value is a module id, require it\n   /******/ \t// mode & 2: merge all properties of value into the ns\n   /******/ \t// mode & 4: return value when already ns object\n   /******/ \t// mode & 8|1: behave like require\n   /******/ \t__webpack_require__.t = function(value, mode) {\n   /******/ \t\tif(mode & 1) value = __webpack_require__(value);\n   /******/ \t\tif(mode & 8) return value;\n   /******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n   /******/ \t\tvar ns = Object.create(null);\n   /******/ \t\t__webpack_require__.r(ns);\n   /******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n   /******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n   /******/ \t\treturn ns;\n   /******/ \t};\n   /******/\n   /******/ \t// getDefaultExport function for compatibility with non-harmony modules\n   /******/ \t__webpack_require__.n = function(module) {\n   /******/ \t\tvar getter = module && module.__esModule ?\n   /******/ \t\t\tfunction getDefault() { return module['default']; } :\n   /******/ \t\t\tfunction getModuleExports() { return module; };\n   /******/ \t\t__webpack_require__.d(getter, 'a', getter);\n   /******/ \t\treturn getter;\n   /******/ \t};\n   /******/\n   /******/ \t// Object.prototype.hasOwnProperty.call\n   /******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n   /******/\n   /******/ \t// __webpack_public_path__\n   /******/ \t__webpack_require__.p = \"\";\n   /******/\n   /******/\n   /******/ \t// Load entry module and return exports\n   /******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n   /******/ })\n   /************************************************************************/\n   /******/ ({\n   \n   /***/ \"./src/index.js\":\n   /*!**********************!*\\\n     !*** ./src/index.js ***!\n     \\**********************/\n   /*! no exports provided */\n   /***/ (function(module, __webpack_exports__, __webpack_require__) {\n   \n   \"use strict\";\n   eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _module_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./module.js */ \\\"./src/module.js\\\");\\n\\r\\n\\r\\nconsole.log('index.js', _module_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]);\\n\\n//# sourceURL=webpack:///./src/index.js?\");\n   \n   /***/ }),\n   \n   /***/ \"./src/module.js\":\n   /*!***********************!*\\\n     !*** ./src/module.js ***!\n     \\***********************/\n   /*! exports provided: default */\n   /***/ (function(module, __webpack_exports__, __webpack_require__) {\n   \n   \"use strict\";\n   eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (18);\\r\\n\\r\\nconsole.log('module.js');\\n\\n//# sourceURL=webpack:///./src/module.js?\");\n   \n   /***/ })\n   \n   /******/ });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   92\n   93\n   94\n   95\n   96\n   97\n   98\n   99\n   100\n   101\n   102\n   103\n   104\n   105\n   106\n   107\n   108\n   109\n   110\n   111\n   112\n   113\n   \n   \n   可见，Webpack 将我们的代码打包为一个文件了。同时可以发现，文件中已经没有 import 及 export 关键字了，webpack 帮我们实现了导入导出的代码并合并到一个文件中。\n   \n   * 接下来，我们就可以直接在 HTML 中引入打包后的文件\n   \n   <!DOCTYPE html>\n   <html lang=\"en\">\n   \n   <head>\n       <meta charset=\"UTF-8\" />\n       <title>Webpack 初体验</title>\n   </head>\n   \n   <body>\n       \x3c!-- <script src=\"./src/index.js\" type=\"module\"><\/script> --\x3e\n       <script src=\"./dist/bundle.js\"><\/script>\n   </body>\n   \n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 1.6 entry和output\n\n【entry】\n\n在 webpack.config.js 中 entry 指定了 webpack 打包时的入口文件！\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    // 入口文件\n    // 写法一（单文件入口）\n    // entry: './src/index.js',\n    // 写法二（单文件或多文件入口）\n    // 多个页面，一般都对应独立的 js 文件，都需要多个入口\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n【output】\n\n在 webpack.config.js 中 entry 指定了 webpack 打包时的出口文件！\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: './src/index.js',\n    output: {\n        // __dirname，表示当前所在路径\n        // path.resolve，可以拼接路径\n        // path: 当前路径/dist\n        path: path.resolve(__dirname, 'dist'),\n        // 输出的文件名（单出口）\n        filename: 'bundle.js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以上是单入口的情况，如果不是单入口，就有多个出口，那么就需要这样写：\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        // 输出的文件名（多出口）\n        // name 会自动替换为对应的入口文件，针对不同的入口有不同的输出\n        filename: '[name].js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1.7 loader\n\nloader：加载器\n\nwebpack 本身是用来打包 js 的（主要就是来解决 JS 模块化问题），如果需要用到其他模块的功能，那么就需要各种各样的 loader。\n\nloaders | webpack 中文网 (webpackjs.com)\n\n【babel-loader】\n\n在 webpack 中使用 babel 就需要借助 babel-loader。\n\n安装：babel-loader + babel/core + babel/preset-env\n\nnpm install --save-dev babel-loader@8.1.0 @babel/core@7.11.0 @babel/preset-env@7.11.0\n\n\n1\n\n\n记得配置 babel，.babelrc\n\n{\n    \"presets\": [\"@babel/preset-env\"]\n}\n\n\n1\n2\n3\n\n\n在 webpack.config.js 中配置 babel-loader\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        // 可以配置多个 loader，所以是一个数组\n        rules: [\n            // 每个 loader 用一个对象来配置内容\n            //（注意：不同的 loader 的配置规则不同，可以在 www.webpackjs.com/loaders/ 中查看）\n            {\n                // 正则表达式匹配需要被该 loader 处理的文件（此处是所有的 js 文件）\n                test: /\\.js$/,\n                // node_modules 也包含 js 文件，但不需要处理，所以我们将其排除\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n之后，当我们 npm run webpack 后，会先处理 loader，再 webpack 打包！\n\n最后，我们查看打包后的 dist/index.js 文件，会发现里面的 let 等 ES6 语法都已经转为 var 等之前版本的语法了！说明 babel 确实生效了！\n\n但是！细心观察会发现，babel 只是会将一些 ES6 的基本语法进行转换，但是诸如：Object、Set、Map、Promise 等 ES6 提供的 API，babel 是无法直接转换的，所以我们需要再借助其它的模块，而这些第三方模块可以帮我们实现 ES6 中的 API。\n\n安装 core-js：\n\nnpm install --save-dev core-js@3.6.5\n\n\n1\n\n\n之后，我们只需要在我们 js 文件的开头都写上 import 'core-js/stable'; 便可以了！\n\n例如：index.js\n\nimport 'core-js/stable';\n\nlet name = 'Alex';\nconst age = 18;\n\nconst add = (x, y) => x + y;\n\nnew Promise((resolve, reject) => {\n    resolve('成功');\n}).then(value => {\n    console.log(value);\n});\n\nArray.from([1, 2]);\n\nclass Person {\n    constructor(name, age) {\n        Object.assign(this, {name, age});\n    }\n}\n\nnew Person('Alex', 18);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1.8 plugins\n\nplugins：插件\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。\n\nPlugins | webpack 中文网 (webpackjs.com)\n\n【html-webpack-plugin】\n\n插件功能：将 html 文件也同时进行打包！\n\n安装：\n\nnpm install --save-dev html-webpack-plugin@4.3.0\n\n\n1\n\n\n配置 webpack.config.js\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    // 可以配置多个 plugin，所以是一个数组\n    plugins: [\n        // 每个 plugin 通过实例化对象来配置\n        // 配置信息在参数中，具体用法每个 plugin 不同，可以在 www.webpackjs.com/plugins/ 中查看\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            // 指定该 html 要引入哪个 js 文件（如果不指定，那么 dist 中打包得到了几个 js 都会引入进来）\n            chunks: [\n                'index'\n            ]\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上是单入口的情况，下面展示多入口：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    plugins: [\n        // 多入口：有几个入口就实例化几次\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            // 多个对象要加上名字进行区分\n            filename: 'index.html',\n            chunks: [\n                'index'\n            ]\n        }),\n        new HtmlWebpackPlugin({\n            template: './search.html',\n            filename: 'search.html',\n            chunks: [\n                'search'\n            ]\n        }) \n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n其它配置：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    // 可以配置多个 plugin，所以是一个数组\n    plugins: [\n        // 每个 plugin 通过实例化对象来配置\n        // 配置信息在参数中，具体用法每个 plugin 不同，可以在 www.webpackjs.com/plugins/ 中查看\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            // 指定该 html 要引入哪个 js 文件（如果不指定，那么 dist 中打包得到了几个 js 都会引入进来）\n            chunks: [\n                'index'\n            ],\n            minify: {\n                // 删除 index.html 中的注释\n                removeComments: true,\n                // 删除 index.html 中的空格\n                collapseWhitespace: true,\n                // 删除各种 html 标签属性值的双引号\n                removeAttributeQuotes: true\n            }\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 1.9 处理CSS\n\n安装 css-loader：\n\nnpm install --save-dev css-loader@4.1.1\t\t\t# 识别 css \nnpm install --save-dev style-loader@1.1.1\t\t# 将 css 引入到 html 的 style\n\n\n1\n2\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                // 多个 loader，要用 use[] 或 use{}\n                use: [\n                    // 注意：必须先 style-loader 再 css-loader，因为执行顺序是从后往前\n                    'style-loader',\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n此时，我们就可以在 index.js 文件开头写入：import '../css/index.css';。\n\n * /src/index.js\n\nimport '../css/index.css';\n\n\n1\n\n * /css/index.css\n\nbody {\n    background-color: red;\n}\n\n\n1\n2\n3\n\n * index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>处理CSS</title>\n</head>\n\n<body>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * npm run webpack\n\n\n\n可见，css 以 <style> 的方式引入了 HTML 中！\n\n当然，在实际场景中，我们更倾向于将 css 以 <link> 的方式来引入：\n\n安装 mini-css-extract-plugin：\n\nnpm install --save-dev mini-css-extract-plugin@0.9.0\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    MiniCssExtractPlugin.loader,\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n再次 npm run webpack：\n\n\n\n\n# 1.10 处理CSS图片\n\n * /css/index.css\n\nbody {\n    background-image: url(https://tse2-mm.cn.bing.net/th/id/OIP-C.rq2KVURH2gEGBq9pjDz1nAHaQB?pid=ImgDet&rs=1);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n * npm run webpack\n\n\n\n乍一看，一切正常啊！确实默认可以处理 CSS 图片啊！为什么还要单独讲解如何处理 CSS 图片呢？这是因为上面的例子中 CSS 的图片是一个网络地址的图片，而 webpack 本身就不会处理网络的内容，只会对本地的内容进行处理，网络的内容没有任何的影响，所以当我们把图片地址换成一个本地图片时：\n\n * /css/index.css\n\nbody {\n    background-image: url(../img/yyds.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n\n\nwebpack 直接报错！因为 webpack 当处理网络内容时直接跳过，而对于本地内容时就要处理，可 webpack 本身并不能处理 css 图片。\n\n安装：file-loader\n\nnpm install --save-dev file-loader@6.0.0\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    MiniCssExtractPlugin.loader,\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                loader: 'file-loader' \n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * npm run webpack\n\n * /dist/css/index.css\n\nbody {\n    background-image: url(3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n\n\n发现图片并没有成功引入，那是因为路径有问题。\n\n/* 打包得到的 */\nbody {\n    background-image: url(3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n/* 正确的 */\nbody {\n    background-image: url(../3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之所以会发生上述原因，和 mini-css-extract-plugin 与 file-loader 没有协调好有关，解决办法是：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        // 解决 CSS 图片路径问题\n                        options: {\n                            publicPath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                loader: 'file-loader' \n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n * npm run webpack 再次打包查看 dist/css/index.css，便正确了！\n\nbody {\n    background-image: url(../3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n上述步骤得到的 css 图片是放在 dist 目录的根目录下的，如果我们想打包后的图片放在 dist/img 中，那么我们可以：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        // 解决 CSS 图片路径问题\n                        options: {\n                            publicPath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    loader: 'file-loader',\n                    // 解决图片路径及名称问题\n                    options: {\n                        name: 'img/[name].[ext]'\n                    }\n                }\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n\n> 注意：file-loader 的本质是把文件直接进行拷贝并重设地址，不只是对图片有用，对其它文件也有用！\n\n\n# 1.11 处理HTML图片\n\n例如：\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>处理HTML图片</title>\n</head>\n\n<body>\n    <img src=\"img/yyds.jpg\" alt=\"\">\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n安装：html-withimg-loader\n\nnpm install --save-dev html-withimg-loader@0.1.16\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    loader: 'file-loader',\n                    options: {\n                        name: 'img/[name].[ext]',\n                        // html-withimg-loader 处理 HTML 图片是依赖于 file-loader 的\n                        esModule: false\n                    }\n                }\n            },\n            {\n                test: /\\.(htm|html)$/,\n                loader: 'html-withimg-loader'\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n打包后的 html：\n\n<!DOCTYPE html>\n<html lang=en>\n\n<head>\n    <meta charset=UTF-8>\n    <title>处理HTML图片</title>\n    <link href=css/index.css rel=stylesheet>\n</head>\n\n<body>\n    <img src=img/yyds.jpg alt=\"\">\n    <script src=index.js><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1.12 处理JS图片\n\n依旧是使用 file-loader，我们直接在 js 文件中导入图片即可使用。\n\n * index.js\n\nimport '../css/index.css';\nimport yydsimg from '../img/yyds.jpg';\n\nconst imgEl = document.createElement('img');\nimgEl.src = yydsimg;\ndocument.body.appendChild(imgEl);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.13 url-loader处理图片\n\n一般在网站项目中会有许许多多的小图标（<=10k），如果把这些小图标都以图片文件的方式打包在一起是比较臃肿且不科学的，一般可以把这些小图标以 base64 编码的方式打包（将图片的 url 地址替换为该图片的 base64 编码），这种打包后，小图标就不再以实体图片的形式存在了，而是以编码的形式存在。\n\n安装：url-loader\n\n注意：url-loader 是依赖于 file-loader 的，所以前提是已经安装了 file-loader。\n\nnpm install --save-dev url-loader@4.1.0\n\n\n1\n\n\n安装了 url-loader 后，就可以不用 file-loader 了，只用配置 url-loader：\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: MiniCssExtractPlugin.loader,\n                        options: {\n                            publicPath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    // 将 file-loader 改为 url-loader\n                    loader: 'url-loader',\n                    options: {\n                        name: 'img/[name].[ext]',\n                        esModule: false,\n                        // 限制：小于 10k 的文件，用 base64 编码，其它的与 file-loader 相同处理\n                        limit: 10000\n                    }\n                }\n            },\n            {\n                test: /\\.(htm|html)$/,\n                loader: 'html-withimg-loader'\n            }\n        ]\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removeComments: true,\n                collapseWhitespace: true,\n                removeAttributeQuotes: true\n            }\n        }),\n        new MiniCssExtractPlugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n执行 npm run webpack：\n\n\n\n\n\n\n# 1.14 webpack-dev-server\n\n为什么需要 webpack-dev-server？\n\n答案：自动打包！（每次修改都会自动打包）\n\n安装：\n\nnpm install --save-dev webpack-dev-server@3.11.0\n\n\n1\n\n\n修改 package.json，增加 \"dev\": \"webpack-dev-server\"：\n\n> \"dev\"*:* \"webpack-dev-server --open chrome\" 自动打包后打开 chrome 浏览器\n\n{\n  \"name\": \"webpack0\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"babel src -d dist\",\n    \"webpack\": \"webpack --config webpack.config.js\",\n    \"dev\": \"webpack-dev-server\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.18.6\",\n    \"@babel/core\": \"^7.11.0\",\n    \"@babel/preset-env\": \"^7.11.0\",\n    \"babel-loader\": \"^8.1.0\",\n    \"core-js\": \"^3.6.5\",\n    \"css-loader\": \"^4.1.1\",\n    \"file-loader\": \"^6.0.0\",\n    \"html-webpack-plugin\": \"^4.3.0\",\n    \"html-withimg-loader\": \"^0.1.16\",\n    \"mini-css-extract-plugin\": \"^0.9.0\",\n    \"style-loader\": \"^1.1.1\",\n    \"url-loader\": \"^4.1.0\",\n    \"webpack\": \"^4.44.1\",\n    \"webpack-cli\": \"^3.3.12\",\n    \"webpack-dev-server\": \"^3.11.0\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n注意：npm run dev 会在内存中生成打包后的文件，但在项目中是不可见的！如果在开发完后需要生成 dist 目录，那么最后 npm run webpack 即可。",normalizedContent:"# 一、babel与webpack\n\n\n# 1.1 认识babel\n\n官网：babel · the compiler for next generation javascript https://babel.dev/\n\n在线编译：babel · the compiler for next generation javascript https://babel.dev/repl\n\nbabel 是 javascript 的编译器，用来将 es6 代码转换成 es6 之前的代码。\n\nbabel 本身可以编译 es6 的大部分语法，比如：let、const、箭头函数、class，……，但是对于 es6 新增的 api，比如：set、map、promise 等全局对象，以及一些定义在全局对象上的方法（比如 object.assign/array.from）都不能直接编译，需要借助其它的模块，babel 一般需要配合 webpack 来编译 module 模块语法。\n\n\n# 1.2 babel的使用方式\n\n使用方式说明：babel · the compiler for next generation javascript https://babel.dev/setup\n\n目前，我们主要关注：cli 及 webpack。\n\n注意：我们一般不考虑 in the browser 方式，因为此种方式代码每次被浏览器执行时都要先转换为 es6 之前的代码，这样的转换影响了性能，而 cli 及 webpack 的方式是提前就将 es6 代码转化为 es6 之前的代码，浏览器在运行时已经是 es6 之前的代码了，不影响性能。\n\n\n# 1.3 使用babel前的准备工作\n\n# 1.3.1 什么是node.js和npm\n\n简单的说 node.js 就是运行在服务端的 javascript。\n\nnode.js 是一个基于 chrome javascript 运行时建立的一个平台。\n\nnode.js 是一个事件驱动 i/o 服务端 javascript 环境，基于 google 的 v8 引擎，v8 引擎执行 javascript 的速度非常快，性能非常好。\n\n后端的 javascript = ecmascript + io + file + ...服务器端的操作。\n\nnpm 是随同 node.js 一起安装的包管理工具，能解决 node.js 代码部署上的很多问题，常见的使用场景有以下几种：\n\n * 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。\n * 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。\n\n由于新版的 node.js 已经集成了 npm，所以之前 npm 也一并安装好了。同样可以通过输入 \"npm -v\" 来测试是否成功安装。\n\n# 1.3.2 安装node.js\n\nnode.js 中文官网：node.js (nodejs.org)\n\n我们下载长期支持版，并双击安装包根据提示进行安装即可。\n\n可以通过在终端中依次输入：node -v 及 npm -v 来查看版本，如果查看成功，即表明安装成功。\n\n# 1.3.3 初始化项目\n\n * 初始化项目：npm init\n\n * 进行项目配置\n\n * 确认配置并正式生成项目\n\n\n\n> 当依次正确完成以上步骤后，项目路径下就会生成一个 package.json 文件，里面最初记录了我们 npm 项目的初始化配置信息，往后我们利用 npm 安装的依赖及包都会记录在这个文件中。\n> \n> 往后当我们需要迁移项目时，我们只需要拷贝这个 package.json 文件，然后在新的项目中使用相应的命令，便可恢复文件中的环境、依赖及包。\n> \n> 【初始时的 package.json】\n> \n> {\n>    \"name\": \"demo\",\n>    \"version\": \"1.0.0\",\n>    \"description\": \"\",\n>    \"main\": \"index.js\",\n>    \"scripts\": {\n>     \t\"test\": \"echo \\\"error: no test specified\\\" && exit 1\"\n>    },\n>    \"author\": \"\",\n>    \"license\": \"isc\"\n> }\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n\n# 1.3.4 安装babel需要的包\n\n安装命令：npm install --save-dev @babel/core @babel/cli\n\n注意：--save-dev 表示这是一个开发环境的依赖，即上线之后是用不到的。\n\n当我们安装成功后，会得到一个依赖及包代码的放置目录和两个 json 文件，其中 package.json 文件会新增一个 devdependencies （开发依赖）属性，并记录下我们的安装记录。\n\n\n\n * @babel/cli：cli 中使用 babel 必须的包，实现了命令行中 babel 命令的识别与执行等\n * @babel/core：babel 中用于完成 “发号施令” 的包，即：指挥控制其它 babel 包的行为\n\n> 注意：我们在安装时，要特别注意一下依赖及包的版本号，不能随意的依赖最新版本，因为最新版本可能会不兼容某些旧版本。\n\n> 当我们迁移了项目环境时，也许项目的依赖及包代码（node_modules 文件夹）已经不在了或者错误了，那么只要 package.json 文件还在，那么我们只需要执行 npm install 命令，即可根据 package.json 内容重新生成项目的依赖及包代码（node_modules 文件夹）。\n> \n> 注意：npm install 可以简写为：npm i\n> \n> 注意：在平时的项目开发中，我们在拷贝项目或者迁移项目时，通常不会把 node_modules 文件夹一同拷贝或迁移，因为该文件夹的文件数量级太大了，所以拷贝或迁移的时间会特别长，而且还容易出错，我们一般都是通过 npm install 来重新生成。\n\n# 1.3.5 使用babel编译es6代码\n\n首先，我们需要手动在 package.json 文件中添加以下代码：\n\n\"scripts\": {\n    \"build\": \"babel src -d lib\"\n}\n\n\n1\n2\n3\n\n\n其中 \"build\": \"babel src -d lib\" 表示：通过 babel 命令将 src 下的文件编译并输出到 lib 目录下。\n\n附：-d 实际表示的就是：--out-dir 的缩写，其实就是输出目录的意思。\n\n注意：由于我们通常不放在 lib 目录下，而是放在 dist 目录下，所以我们把 package.json 文件中添加的代码修改为：\n\n\"scripts\": {\n    \"build\": \"babel src -d dist\"\n}\n\n\n1\n2\n3\n\n\n（1）编译的命令\n\n当配置好上述步骤后，我们即可通过命令进行编译。\n\n编译命令：npm run build\n\n当我们编译成功后，便会多出一个 dist 目录，里面便放置有编译后的文件。\n\n> 当我们把编译好的文件打开后，发现里面的代码依旧是 es6 版本的，这是因为我们在正式编译代码之前还需要设置一个 babel 的配置文件。\n\n（2）babel的配置文件\n\n首先，我们需要额外安装一个包：npm install @babel/preset-env --save-dev，这个包能告诉编译器具体如何转换编译 es6 的语法。\n\n安装成功后，在项目目录下，创建一个 .babelrc。\n\n在文件中写入：\n\n{\n    \"presets\": [\"@babel/preset-env\"]\n}\n\n\n1\n2\n3\n\n\n> 配置之后，我们再次执行 npm run build 命令，那么 dist 目录中的文件就是编译完成的 es6 之前版本的代码了！\n\n\n# 1.4 webpack是什么\n\n（1）认识 webpack\n\nwebpack 是静态模块打包器，当 webpack 处理应用程序时，会将所有这些模块打包成一个或多个文件。\n\n（2）什么是 webpack 模块？\n\n除了 javascript 外，还有 css、图片、图标字体等。\n\n（3）什么是静态？\n\n开发过程中存在于本地的 js/css/图片/图标字体 等文件，就是静态的；而从远程服务器获取的就是动态的。\n\nwebpack 没办法处理动态的部分，只能处理静态的部分。\n\nwebpack 中文文档 | webpack 中文网 (webpackjs.com)\n\n\n# 1.5 webpack初体验\n\n（1）初始化项目\n\nnpm init，注意：项目名请不要取 webpack，因为这个项目名与 webpack 包名冲突了。\n\n（2）安装webpack需要的包\n\nnpm install --save-dev webpack-cli@3.3.12 webpack@4.44.1，此处以某个版本作为演示。\n\n（3）配置webpack\n\n * 创建配置文件 webpack.config.js\n\n * 编辑配置内容：\n   \n   // 导入模块（node 方式）\n   const path = require('path');\n   \n   // 以模块方式导出配置\n   module.exports = {\n     // 入口\n     entry: './src/index.js',\n     // 出口\n     output: {\n       path: path.resolve(__dirname, 'dist'),\n       filename: 'bundle.js',\n     },\n   };\n   \n   // webpack 的配置文件的内容也是以模块的方式导出，但是这里的模块不是 js 模块，而是 node 模块\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   与此同时，还需要在 package.json 中添加：\n   \n   \"scripts\": {\n       // 执行 webpack 命令就相当于去执行 webpack 配置文件\n       // (会去默认执行 webpack.config.js 配置文件)\n       // \"webpack\": \"webpack\"\n       //（去执行指定的配置文件，这个配置文件是可以自由指定的）\n       \"webpack\": \"webpack --config webpack.config.js\"\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 举例代码\n   \n   * index.html\n   \n   <!doctype html>\n   <html lang=\"en\">\n   \n   <head>\n       <meta charset=\"utf-8\" />\n       <title>webpack 初体验</title>\n   </head>\n   \n   <body>\n       <script src=\"./src/index.js\" type=\"module\"><\/script>\n   </body>\n   \n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n   * src/index.js\n   \n   import age from './module.js';\n   \n   console.log('index.js', age);\n   \n   \n   1\n   2\n   3\n   \n   * src/module.js\n   \n   export default 18;\n   \n   console.log('module.js');\n   \n   \n   1\n   2\n   3\n   \n\n * 编译并测试\n   \n   * npm run webpack\n   \n   执行后，便会生成一个 dist 目录，并有一个 bundle.js 文件：\n   \n   !function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||object.defineproperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof symbol&&symbol.tostringtag&&object.defineproperty(e,symbol.tostringtag,{value:\"module\"}),object.defineproperty(e,\"__esmodule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esmodule)return e;var r=object.create(null);if(n.r(r),object.defineproperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esmodule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return object.prototype.hasownproperty.call(e,t)},n.p=\"\",n(n.s=0)}([function(e,t,n){\"use strict\";n.r(t);console.log(\"module.js\"),console.log(\"index.js\",18)}]);\n   \n   \n   1\n   \n   \n   可以看见，默认通过 webpack 打包后的文件是压缩版的，我们可以通过在 webpack.config.js 配置文件中设置成开发版：\n   \n   const path = require('path');\n   \n   module.exports = {\n       // 开发模式\n       mode: 'development',\n       entry: './src/index.js',\n       output: {\n           path: path.resolve(__dirname, 'dist'),\n           filename: 'bundle.js',\n       },\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   再次执行 npm run webpack，查看 dist/bundle.js 文件：\n   \n   /******/ (function(modules) { // webpackbootstrap\n   /******/ \t// the module cache\n   /******/ \tvar installedmodules = {};\n   /******/\n   /******/ \t// the require function\n   /******/ \tfunction __webpack_require__(moduleid) {\n   /******/\n   /******/ \t\t// check if module is in cache\n   /******/ \t\tif(installedmodules[moduleid]) {\n   /******/ \t\t\treturn installedmodules[moduleid].exports;\n   /******/ \t\t}\n   /******/ \t\t// create a new module (and put it into the cache)\n   /******/ \t\tvar module = installedmodules[moduleid] = {\n   /******/ \t\t\ti: moduleid,\n   /******/ \t\t\tl: false,\n   /******/ \t\t\texports: {}\n   /******/ \t\t};\n   /******/\n   /******/ \t\t// execute the module function\n   /******/ \t\tmodules[moduleid].call(module.exports, module, module.exports, __webpack_require__);\n   /******/\n   /******/ \t\t// flag the module as loaded\n   /******/ \t\tmodule.l = true;\n   /******/\n   /******/ \t\t// return the exports of the module\n   /******/ \t\treturn module.exports;\n   /******/ \t}\n   /******/\n   /******/\n   /******/ \t// expose the modules object (__webpack_modules__)\n   /******/ \t__webpack_require__.m = modules;\n   /******/\n   /******/ \t// expose the module cache\n   /******/ \t__webpack_require__.c = installedmodules;\n   /******/\n   /******/ \t// define getter function for harmony exports\n   /******/ \t__webpack_require__.d = function(exports, name, getter) {\n   /******/ \t\tif(!__webpack_require__.o(exports, name)) {\n   /******/ \t\t\tobject.defineproperty(exports, name, { enumerable: true, get: getter });\n   /******/ \t\t}\n   /******/ \t};\n   /******/\n   /******/ \t// define __esmodule on exports\n   /******/ \t__webpack_require__.r = function(exports) {\n   /******/ \t\tif(typeof symbol !== 'undefined' && symbol.tostringtag) {\n   /******/ \t\t\tobject.defineproperty(exports, symbol.tostringtag, { value: 'module' });\n   /******/ \t\t}\n   /******/ \t\tobject.defineproperty(exports, '__esmodule', { value: true });\n   /******/ \t};\n   /******/\n   /******/ \t// create a fake namespace object\n   /******/ \t// mode & 1: value is a module id, require it\n   /******/ \t// mode & 2: merge all properties of value into the ns\n   /******/ \t// mode & 4: return value when already ns object\n   /******/ \t// mode & 8|1: behave like require\n   /******/ \t__webpack_require__.t = function(value, mode) {\n   /******/ \t\tif(mode & 1) value = __webpack_require__(value);\n   /******/ \t\tif(mode & 8) return value;\n   /******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esmodule) return value;\n   /******/ \t\tvar ns = object.create(null);\n   /******/ \t\t__webpack_require__.r(ns);\n   /******/ \t\tobject.defineproperty(ns, 'default', { enumerable: true, value: value });\n   /******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n   /******/ \t\treturn ns;\n   /******/ \t};\n   /******/\n   /******/ \t// getdefaultexport function for compatibility with non-harmony modules\n   /******/ \t__webpack_require__.n = function(module) {\n   /******/ \t\tvar getter = module && module.__esmodule ?\n   /******/ \t\t\tfunction getdefault() { return module['default']; } :\n   /******/ \t\t\tfunction getmoduleexports() { return module; };\n   /******/ \t\t__webpack_require__.d(getter, 'a', getter);\n   /******/ \t\treturn getter;\n   /******/ \t};\n   /******/\n   /******/ \t// object.prototype.hasownproperty.call\n   /******/ \t__webpack_require__.o = function(object, property) { return object.prototype.hasownproperty.call(object, property); };\n   /******/\n   /******/ \t// __webpack_public_path__\n   /******/ \t__webpack_require__.p = \"\";\n   /******/\n   /******/\n   /******/ \t// load entry module and return exports\n   /******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n   /******/ })\n   /************************************************************************/\n   /******/ ({\n   \n   /***/ \"./src/index.js\":\n   /*!**********************!*\\\n     !*** ./src/index.js ***!\n     \\**********************/\n   /*! no exports provided */\n   /***/ (function(module, __webpack_exports__, __webpack_require__) {\n   \n   \"use strict\";\n   eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _module_js__webpack_imported_module_0__ = __webpack_require__(/*! ./module.js */ \\\"./src/module.js\\\");\\n\\r\\n\\r\\nconsole.log('index.js', _module_js__webpack_imported_module_0__[\\\"default\\\"]);\\n\\n//# sourceurl=webpack:///./src/index.js?\");\n   \n   /***/ }),\n   \n   /***/ \"./src/module.js\":\n   /*!***********************!*\\\n     !*** ./src/module.js ***!\n     \\***********************/\n   /*! exports provided: default */\n   /***/ (function(module, __webpack_exports__, __webpack_require__) {\n   \n   \"use strict\";\n   eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (18);\\r\\n\\r\\nconsole.log('module.js');\\n\\n//# sourceurl=webpack:///./src/module.js?\");\n   \n   /***/ })\n   \n   /******/ });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   92\n   93\n   94\n   95\n   96\n   97\n   98\n   99\n   100\n   101\n   102\n   103\n   104\n   105\n   106\n   107\n   108\n   109\n   110\n   111\n   112\n   113\n   \n   \n   可见，webpack 将我们的代码打包为一个文件了。同时可以发现，文件中已经没有 import 及 export 关键字了，webpack 帮我们实现了导入导出的代码并合并到一个文件中。\n   \n   * 接下来，我们就可以直接在 html 中引入打包后的文件\n   \n   <!doctype html>\n   <html lang=\"en\">\n   \n   <head>\n       <meta charset=\"utf-8\" />\n       <title>webpack 初体验</title>\n   </head>\n   \n   <body>\n       \x3c!-- <script src=\"./src/index.js\" type=\"module\"><\/script> --\x3e\n       <script src=\"./dist/bundle.js\"><\/script>\n   </body>\n   \n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n\n# 1.6 entry和output\n\n【entry】\n\n在 webpack.config.js 中 entry 指定了 webpack 打包时的入口文件！\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    // 入口文件\n    // 写法一（单文件入口）\n    // entry: './src/index.js',\n    // 写法二（单文件或多文件入口）\n    // 多个页面，一般都对应独立的 js 文件，都需要多个入口\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n【output】\n\n在 webpack.config.js 中 entry 指定了 webpack 打包时的出口文件！\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: './src/index.js',\n    output: {\n        // __dirname，表示当前所在路径\n        // path.resolve，可以拼接路径\n        // path: 当前路径/dist\n        path: path.resolve(__dirname, 'dist'),\n        // 输出的文件名（单出口）\n        filename: 'bundle.js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以上是单入口的情况，如果不是单入口，就有多个出口，那么就需要这样写：\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        // 输出的文件名（多出口）\n        // name 会自动替换为对应的入口文件，针对不同的入口有不同的输出\n        filename: '[name].js',\n    },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1.7 loader\n\nloader：加载器\n\nwebpack 本身是用来打包 js 的（主要就是来解决 js 模块化问题），如果需要用到其他模块的功能，那么就需要各种各样的 loader。\n\nloaders | webpack 中文网 (webpackjs.com)\n\n【babel-loader】\n\n在 webpack 中使用 babel 就需要借助 babel-loader。\n\n安装：babel-loader + babel/core + babel/preset-env\n\nnpm install --save-dev babel-loader@8.1.0 @babel/core@7.11.0 @babel/preset-env@7.11.0\n\n\n1\n\n\n记得配置 babel，.babelrc\n\n{\n    \"presets\": [\"@babel/preset-env\"]\n}\n\n\n1\n2\n3\n\n\n在 webpack.config.js 中配置 babel-loader\n\nconst path = require('path');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        // 可以配置多个 loader，所以是一个数组\n        rules: [\n            // 每个 loader 用一个对象来配置内容\n            //（注意：不同的 loader 的配置规则不同，可以在 www.webpackjs.com/loaders/ 中查看）\n            {\n                // 正则表达式匹配需要被该 loader 处理的文件（此处是所有的 js 文件）\n                test: /\\.js$/,\n                // node_modules 也包含 js 文件，但不需要处理，所以我们将其排除\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n之后，当我们 npm run webpack 后，会先处理 loader，再 webpack 打包！\n\n最后，我们查看打包后的 dist/index.js 文件，会发现里面的 let 等 es6 语法都已经转为 var 等之前版本的语法了！说明 babel 确实生效了！\n\n但是！细心观察会发现，babel 只是会将一些 es6 的基本语法进行转换，但是诸如：object、set、map、promise 等 es6 提供的 api，babel 是无法直接转换的，所以我们需要再借助其它的模块，而这些第三方模块可以帮我们实现 es6 中的 api。\n\n安装 core-js：\n\nnpm install --save-dev core-js@3.6.5\n\n\n1\n\n\n之后，我们只需要在我们 js 文件的开头都写上 import 'core-js/stable'; 便可以了！\n\n例如：index.js\n\nimport 'core-js/stable';\n\nlet name = 'alex';\nconst age = 18;\n\nconst add = (x, y) => x + y;\n\nnew promise((resolve, reject) => {\n    resolve('成功');\n}).then(value => {\n    console.log(value);\n});\n\narray.from([1, 2]);\n\nclass person {\n    constructor(name, age) {\n        object.assign(this, {name, age});\n    }\n}\n\nnew person('alex', 18);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1.8 plugins\n\nplugins：插件\n\nloader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。\n\nplugins | webpack 中文网 (webpackjs.com)\n\n【html-webpack-plugin】\n\n插件功能：将 html 文件也同时进行打包！\n\n安装：\n\nnpm install --save-dev html-webpack-plugin@4.3.0\n\n\n1\n\n\n配置 webpack.config.js\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    // 可以配置多个 plugin，所以是一个数组\n    plugins: [\n        // 每个 plugin 通过实例化对象来配置\n        // 配置信息在参数中，具体用法每个 plugin 不同，可以在 www.webpackjs.com/plugins/ 中查看\n        new htmlwebpackplugin({\n            template: './index.html',\n            // 指定该 html 要引入哪个 js 文件（如果不指定，那么 dist 中打包得到了几个 js 都会引入进来）\n            chunks: [\n                'index'\n            ]\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上是单入口的情况，下面展示多入口：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        main: './src/index.js',\n        search: './src/search.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    plugins: [\n        // 多入口：有几个入口就实例化几次\n        new htmlwebpackplugin({\n            template: './index.html',\n            // 多个对象要加上名字进行区分\n            filename: 'index.html',\n            chunks: [\n                'index'\n            ]\n        }),\n        new htmlwebpackplugin({\n            template: './search.html',\n            filename: 'search.html',\n            chunks: [\n                'search'\n            ]\n        }) \n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n其它配置：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            }\n        ]\n    },\n    // 可以配置多个 plugin，所以是一个数组\n    plugins: [\n        // 每个 plugin 通过实例化对象来配置\n        // 配置信息在参数中，具体用法每个 plugin 不同，可以在 www.webpackjs.com/plugins/ 中查看\n        new htmlwebpackplugin({\n            template: './index.html',\n            // 指定该 html 要引入哪个 js 文件（如果不指定，那么 dist 中打包得到了几个 js 都会引入进来）\n            chunks: [\n                'index'\n            ],\n            minify: {\n                // 删除 index.html 中的注释\n                removecomments: true,\n                // 删除 index.html 中的空格\n                collapsewhitespace: true,\n                // 删除各种 html 标签属性值的双引号\n                removeattributequotes: true\n            }\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 1.9 处理css\n\n安装 css-loader：\n\nnpm install --save-dev css-loader@4.1.1\t\t\t# 识别 css \nnpm install --save-dev style-loader@1.1.1\t\t# 将 css 引入到 html 的 style\n\n\n1\n2\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                // 多个 loader，要用 use[] 或 use{}\n                use: [\n                    // 注意：必须先 style-loader 再 css-loader，因为执行顺序是从后往前\n                    'style-loader',\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n此时，我们就可以在 index.js 文件开头写入：import '../css/index.css';。\n\n * /src/index.js\n\nimport '../css/index.css';\n\n\n1\n\n * /css/index.css\n\nbody {\n    background-color: red;\n}\n\n\n1\n2\n3\n\n * index.html\n\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\" />\n    <title>处理css</title>\n</head>\n\n<body>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n * npm run webpack\n\n\n\n可见，css 以 <style> 的方式引入了 html 中！\n\n当然，在实际场景中，我们更倾向于将 css 以 <link> 的方式来引入：\n\n安装 mini-css-extract-plugin：\n\nnpm install --save-dev mini-css-extract-plugin@0.9.0\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    minicssextractplugin.loader,\n                    'css-loader'\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n再次 npm run webpack：\n\n\n\n\n# 1.10 处理css图片\n\n * /css/index.css\n\nbody {\n    background-image: url(https://tse2-mm.cn.bing.net/th/id/oip-c.rq2kvurh2gegbq9pjdz1nahaqb?pid=imgdet&rs=1);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n * npm run webpack\n\n\n\n乍一看，一切正常啊！确实默认可以处理 css 图片啊！为什么还要单独讲解如何处理 css 图片呢？这是因为上面的例子中 css 的图片是一个网络地址的图片，而 webpack 本身就不会处理网络的内容，只会对本地的内容进行处理，网络的内容没有任何的影响，所以当我们把图片地址换成一个本地图片时：\n\n * /css/index.css\n\nbody {\n    background-image: url(../img/yyds.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n\n\nwebpack 直接报错！因为 webpack 当处理网络内容时直接跳过，而对于本地内容时就要处理，可 webpack 本身并不能处理 css 图片。\n\n安装：file-loader\n\nnpm install --save-dev file-loader@6.0.0\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    minicssextractplugin.loader,\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                loader: 'file-loader' \n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n * npm run webpack\n\n * /dist/css/index.css\n\nbody {\n    background-image: url(3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n\n\n发现图片并没有成功引入，那是因为路径有问题。\n\n/* 打包得到的 */\nbody {\n    background-image: url(3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n/* 正确的 */\nbody {\n    background-image: url(../3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n之所以会发生上述原因，和 mini-css-extract-plugin 与 file-loader 没有协调好有关，解决办法是：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: minicssextractplugin.loader,\n                        // 解决 css 图片路径问题\n                        options: {\n                            publicpath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                loader: 'file-loader' \n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n * npm run webpack 再次打包查看 dist/css/index.css，便正确了！\n\nbody {\n    background-image: url(../3060ad5b4948915d21a87eef6e04a080.jpg);\n    background-repeat: no-repeat;\n}\n\n\n1\n2\n3\n4\n\n\n上述步骤得到的 css 图片是放在 dist 目录的根目录下的，如果我们想打包后的图片放在 dist/img 中，那么我们可以：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: minicssextractplugin.loader,\n                        // 解决 css 图片路径问题\n                        options: {\n                            publicpath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    loader: 'file-loader',\n                    // 解决图片路径及名称问题\n                    options: {\n                        name: 'img/[name].[ext]'\n                    }\n                }\n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n\n> 注意：file-loader 的本质是把文件直接进行拷贝并重设地址，不只是对图片有用，对其它文件也有用！\n\n\n# 1.11 处理html图片\n\n例如：\n\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\" />\n    <title>处理html图片</title>\n</head>\n\n<body>\n    <img src=\"img/yyds.jpg\" alt=\"\">\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n安装：html-withimg-loader\n\nnpm install --save-dev html-withimg-loader@0.1.16\n\n\n1\n\n\n配置 webpack.config.js：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: minicssextractplugin.loader,\n                        options: {\n                            publicpath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    loader: 'file-loader',\n                    options: {\n                        name: 'img/[name].[ext]',\n                        // html-withimg-loader 处理 html 图片是依赖于 file-loader 的\n                        esmodule: false\n                    }\n                }\n            },\n            {\n                test: /\\.(htm|html)$/,\n                loader: 'html-withimg-loader'\n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n打包后的 html：\n\n<!doctype html>\n<html lang=en>\n\n<head>\n    <meta charset=utf-8>\n    <title>处理html图片</title>\n    <link href=css/index.css rel=stylesheet>\n</head>\n\n<body>\n    <img src=img/yyds.jpg alt=\"\">\n    <script src=index.js><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 1.12 处理js图片\n\n依旧是使用 file-loader，我们直接在 js 文件中导入图片即可使用。\n\n * index.js\n\nimport '../css/index.css';\nimport yydsimg from '../img/yyds.jpg';\n\nconst imgel = document.createelement('img');\nimgel.src = yydsimg;\ndocument.body.appendchild(imgel);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 1.13 url-loader处理图片\n\n一般在网站项目中会有许许多多的小图标（<=10k），如果把这些小图标都以图片文件的方式打包在一起是比较臃肿且不科学的，一般可以把这些小图标以 base64 编码的方式打包（将图片的 url 地址替换为该图片的 base64 编码），这种打包后，小图标就不再以实体图片的形式存在了，而是以编码的形式存在。\n\n安装：url-loader\n\n注意：url-loader 是依赖于 file-loader 的，所以前提是已经安装了 file-loader。\n\nnpm install --save-dev url-loader@4.1.0\n\n\n1\n\n\n安装了 url-loader 后，就可以不用 file-loader 了，只用配置 url-loader：\n\nconst path = require('path');\nconst htmlwebpackplugin = require('html-webpack-plugin');\nconst minicssextractplugin = require('mini-css-extract-plugin');\n\nmodule.exports = {\n    mode: 'development',\n    entry: {\n        index: './src/index.js'\n    },\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: '[name].js'\n    },\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                loader: 'babel-loader'\n            },\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: minicssextractplugin.loader,\n                        options: {\n                            publicpath: '../'\n                        }\n                    },\n                    'css-loader'\n                ]\n            },\n            {\n                test: /\\.(jpg|jpeg|png|apng|gif|tif|svg|bmp|webp)$/,\n                use: {\n                    // 将 file-loader 改为 url-loader\n                    loader: 'url-loader',\n                    options: {\n                        name: 'img/[name].[ext]',\n                        esmodule: false,\n                        // 限制：小于 10k 的文件，用 base64 编码，其它的与 file-loader 相同处理\n                        limit: 10000\n                    }\n                }\n            },\n            {\n                test: /\\.(htm|html)$/,\n                loader: 'html-withimg-loader'\n            }\n        ]\n    },\n    plugins: [\n        new htmlwebpackplugin({\n            template: './index.html',\n            chunks: [\n                'index'\n            ],\n            minify: {\n                removecomments: true,\n                collapsewhitespace: true,\n                removeattributequotes: true\n            }\n        }),\n        new minicssextractplugin({\n        \tfilename: 'css/[name].css'\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n执行 npm run webpack：\n\n\n\n\n\n\n# 1.14 webpack-dev-server\n\n为什么需要 webpack-dev-server？\n\n答案：自动打包！（每次修改都会自动打包）\n\n安装：\n\nnpm install --save-dev webpack-dev-server@3.11.0\n\n\n1\n\n\n修改 package.json，增加 \"dev\": \"webpack-dev-server\"：\n\n> \"dev\"*:* \"webpack-dev-server --open chrome\" 自动打包后打开 chrome 浏览器\n\n{\n  \"name\": \"webpack0\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"error: no test specified\\\" && exit 1\",\n    \"build\": \"babel src -d dist\",\n    \"webpack\": \"webpack --config webpack.config.js\",\n    \"dev\": \"webpack-dev-server\"\n  },\n  \"author\": \"\",\n  \"license\": \"isc\",\n  \"devdependencies\": {\n    \"@babel/cli\": \"^7.18.6\",\n    \"@babel/core\": \"^7.11.0\",\n    \"@babel/preset-env\": \"^7.11.0\",\n    \"babel-loader\": \"^8.1.0\",\n    \"core-js\": \"^3.6.5\",\n    \"css-loader\": \"^4.1.1\",\n    \"file-loader\": \"^6.0.0\",\n    \"html-webpack-plugin\": \"^4.3.0\",\n    \"html-withimg-loader\": \"^0.1.16\",\n    \"mini-css-extract-plugin\": \"^0.9.0\",\n    \"style-loader\": \"^1.1.1\",\n    \"url-loader\": \"^4.1.0\",\n    \"webpack\": \"^4.44.1\",\n    \"webpack-cli\": \"^3.3.12\",\n    \"webpack-dev-server\": \"^3.11.0\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n注意：npm run dev 会在内存中生成打包后的文件，但在项目中是不可见的！如果在开发完后需要生成 dist 目录，那么最后 npm run webpack 即可。",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:33:08",lastUpdatedTimestamp:1682357588e3},{title:"费曼学习法",frontmatter:{title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/more/feynmanLearningMethod/",categories:["更多","学习"],tags:["学习方法"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html",relativePath:"55.更多/01.学习/00.费曼学习法.md",key:"v-66522d6e",path:"/more/feynmanLearningMethod/",headers:[{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:102}],headersStr:"步骤",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",normalizedContent:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"笔记方法",frontmatter:{title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/pages/e60c81/",categories:["更多","学习"],tags:["笔记方法"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html",relativePath:"55.更多/01.学习/01.笔记方法.md",key:"v-ccbc51b8",path:"/pages/e60c81/",headers:[{level:2,title:"康奈尔笔记法",slug:"康奈尔笔记法",normalizedTitle:"康奈尔笔记法",charIndex:2},{level:2,title:"思维导图法",slug:"思维导图法",normalizedTitle:"思维导图法",charIndex:15},{level:2,title:"金三角笔记法",slug:"金三角笔记法",normalizedTitle:"金三角笔记法",charIndex:27},{level:2,title:"曼陀罗九宫格笔记法",slug:"曼陀罗九宫格笔记法",normalizedTitle:"曼陀罗九宫格笔记法",charIndex:40},{level:2,title:"记号记录法",slug:"记号记录法",normalizedTitle:"记号记录法",charIndex:56},{level:2,title:"六色笔记法",slug:"六色笔记法",normalizedTitle:"六色笔记法",charIndex:68},{level:2,title:"加工笔记法",slug:"加工笔记法",normalizedTitle:"加工笔记法",charIndex:80},{level:2,title:"整理笔记要点1-科学标记重点",slug:"整理笔记要点1-科学标记重点",normalizedTitle:"整理笔记要点1-科学标记重点",charIndex:92},{level:2,title:"整理笔记要点2-修改不涂改",slug:"整理笔记要点2-修改不涂改",normalizedTitle:"整理笔记要点2-修改不涂改",charIndex:113}],headersStr:"康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改",content:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",normalizedContent:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"提高学习效率的策略",frontmatter:{title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/pages/a8692ab3bdcb4588",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html",relativePath:"55.更多/01.学习/02.提高学习效率的策略.md",key:"v-d19a1a44",path:"/pages/a8692ab3bdcb4588/",headers:[{level:3,title:"检索式学习",slug:"检索式学习",normalizedTitle:"检索式学习",charIndex:222},{level:3,title:"频繁的集中练习只会产生短期记忆",slug:"频繁的集中练习只会产生短期记忆",normalizedTitle:"频繁的集中练习只会产生短期记忆",charIndex:634},{level:3,title:"间隔练习使知识存储更牢固",slug:"间隔练习使知识存储更牢固",normalizedTitle:"间隔练习使知识存储更牢固",charIndex:958},{level:3,title:"穿插练习有助于长期记忆",slug:"穿插练习有助于长期记忆",normalizedTitle:"穿插练习有助于长期记忆",charIndex:1346},{level:3,title:"多样化练习促进知识的活学活用",slug:"多样化练习促进知识的活学活用",normalizedTitle:"多样化练习促进知识的活学活用",charIndex:1728},{level:3,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:1918},{level:3,title:"知识的“滚雪球”效应",slug:"知识的-滚雪球-效应",normalizedTitle:"知识的“滚雪球”效应",charIndex:2183}],excerpt:'<h1 id="提高学习效率的策略"><a class="header-anchor" href="#提高学习效率的策略">#</a> 提高学习效率的策略</h1>\n<p>推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的<strong>检索练习</strong>——例如小的测试和自测，<strong>间隔练习</strong>、<strong>穿插</strong>不同但相关科目或技能的练习（<strong>多样化练习</strong>），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。</p>\n',headersStr:"检索式学习 频繁的集中练习只会产生短期记忆 间隔练习使知识存储更牢固 穿插练习有助于长期记忆 多样化练习促进知识的活学活用 小总结 知识的“滚雪球”效应",content:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",normalizedContent:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"提高记忆的技巧",frontmatter:{title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/pages/996822b2a2ca6e3b",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html",relativePath:"55.更多/01.学习/03.提高记忆的技巧.md",key:"v-2dafa1e7",path:"/pages/996822b2a2ca6e3b/",excerpt:'<h1 id="提高记忆的技巧"><a class="header-anchor" href="#提高记忆的技巧">#</a> 提高记忆的技巧</h1>\n<ol>\n<li><strong>多个感官并用</strong>\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\n</ol>\n',headersStr:null,content:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",normalizedContent:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"自律小建议",frontmatter:{title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/pages/c3f302a03c8daf79",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html",relativePath:"55.更多/01.学习/04.自律小建议.md",key:"v-cb6ea65e",path:"/pages/c3f302a03c8daf79/",excerpt:'<h1 id="自律小建议"><a class="header-anchor" href="#自律小建议">#</a> 自律小建议</h1>\n<ul>\n<li><strong>培养专注</strong>\n<ul>\n<li>练习冥想、瑜伽等</li>\n</ul>\n</li>\n<li><strong>排除外界干扰</strong>\n<ul>\n<li>手机调到勿扰，在图书馆学习等</li>\n</ul>\n</li>\n</ul>\n',headersStr:null,content:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",normalizedContent:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>b站某位up主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"搜索引擎使用技巧",frontmatter:{title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/pages/ce818a",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"55.更多/01.学习/10.搜索引擎使用技巧.md",key:"v-1c9909ea",path:"/pages/ce818a/",headers:[{level:3,title:"技巧1：排除干扰项",slug:"技巧1-排除干扰项",normalizedTitle:"技巧1：排除干扰项",charIndex:117},{level:3,title:"技巧2：精确搜索",slug:"技巧2-精确搜索",normalizedTitle:"技巧2：精确搜索",charIndex:263},{level:3,title:"技巧3：指定网站内搜索",slug:"技巧3-指定网站内搜索",normalizedTitle:"技巧3：指定网站内搜索",charIndex:354},{level:3,title:"技巧4：指定文件格式",slug:"技巧4-指定文件格式",normalizedTitle:"技巧4：指定文件格式",charIndex:458},{level:3,title:"技巧5：指定在标题搜索",slug:"技巧5-指定在标题搜索",normalizedTitle:"技巧5：指定在标题搜索",charIndex:544},{level:3,title:"技巧6：指定在内容中搜索",slug:"技巧6-指定在内容中搜索",normalizedTitle:"技巧6：指定在内容中搜索",charIndex:595},{level:3,title:"技巧7：多种搜索技巧叠加使用",slug:"技巧7-多种搜索技巧叠加使用",normalizedTitle:"技巧7：多种搜索技巧叠加使用",charIndex:658},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:739}],headersStr:"技巧1：排除干扰项 技巧2：精确搜索 技巧3：指定网站内搜索 技巧4：指定文件格式 技巧5：指定在标题搜索 技巧6：指定在内容中搜索 技巧7：多种搜索技巧叠加使用 注意事项",content:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',normalizedContent:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"JavaScript 的三座大山",frontmatter:{title:"JavaScript 的三座大山",date:"2021-10-27T00:58:18.000Z",permalink:"/advanced/4b2339/",categories:["更多","进阶"],tags:["Javascript"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/01.JavaScript%20%E7%9A%84%E4%B8%89%E5%BA%A7%E5%A4%A7%E5%B1%B1.html",relativePath:"55.更多/02.进阶/01.JavaScript 的三座大山.md",key:"v-3d06597e",path:"/advanced/4b2339/",headers:[{level:2,title:"1️⃣ 作用域和闭包",slug:"_1️⃣-作用域和闭包",normalizedTitle:"1️⃣ 作用域和闭包",charIndex:47},{level:2,title:"2️⃣ 原型和原型链",slug:"_2️⃣-原型和原型链",normalizedTitle:"2️⃣ 原型和原型链",charIndex:3810},{level:2,title:"3️⃣ 异步和单线程",slug:"_3️⃣-异步和单线程",normalizedTitle:"3️⃣ 异步和单线程",charIndex:4801}],headersStr:"1️⃣ 作用域和闭包 2️⃣ 原型和原型链 3️⃣ 异步和单线程",content:"js 作为前端的中坚力量。那么 javascript 三座大山，你知道是哪些呢？\n\n\n\n\n# 1️⃣ 作用域和闭包\n\n作用域 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。\n\n作用域链 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。\n\n作用域可以堆叠成层次结构，子作用域可以访问父作用域，反之则不行。\n\n作用域具体可细分为四种：全局作用域、模块作用域、函数作用域、块级作用域\n\n全局作用域： 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。\n\n模块作用域： 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（AMD、CommonJS、UMD、ES6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。\n\n函数作用域： 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。\n\n块级作用域： 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。\n\n// var demo\nfor(var i=0; i<10; i++) {\n    console.log(i);\n}\nconsole.log(i); // 10\n\n// let demo\nfor(let i=0; i<10; i++) {\n    console.log(i);\n}\nconsole.log(i); //ReferenceError：i is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n了解完作用域再来谈谈 闭包： 函数A里包含了函数B，而函数B使用了函数A的变量，那么函数B被称为闭包或者闭包就是能够读取函数A内部变量的函数。\n\n可以看出闭包是函数作用域下的产物，闭包会随着外层函数的执行而被同时创建，它是一个函数以及其捆绑的周边环境状态的引用的组合。换而言之，闭包是内层函数对外层函数变量的不释放。\n\n闭包的特征：\n\n * 函数中存在函数；\n * 内部函数可以访问外层函数的作用域；\n * 参数和变量不会被 GC，始终驻留在内存中；\n * 有内存地方才有闭包。\n\n所以使用闭包会消耗内存、不正当使用会造成内存溢出的问题，在退出函数之前，需要将不使用的局部变量全部删除。如果不是某些特定需求，在函数中创建函数是不明智的，闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n\n以下整理了闭包的应用场景：\n\n// demo1 输出 3 3 3\nfor(var i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n} \n// demo2 输出 0 1 2\nfor(let i = 0; i < 3; i++) {\n    setTimeout(function() {\n        console.log(i);\n    }, 1000);\n}\n// demo3 输出 0 1 2\nfor(let i = 0; i < 3; i++) {\n    (function(i){\n        setTimeout(function() {\n        console.log(i);\n        }, 1000);\n    })(i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n/* 模拟私有方法 */\n// 模拟对象的get与set方法\nvar Counter = (function() {\nvar privateCounter = 0;\nfunction changeBy(val) {\n    privateCounter += val;\n}\nreturn {\n    increment: function() {\n    changeBy(1);\n    },\n    decrement: function() {\n    changeBy(-1);\n    },\n    value: function() {\n    return privateCounter;\n    }\n}\n})();\nconsole.log(Counter.value()); /* logs 0 */\nCounter.increment();\nCounter.increment();\nconsole.log(Counter.value()); /* logs 2 */\nCounter.decrement();\nconsole.log(Counter.value()); /* logs 1 */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n/* setTimeout中使用 */\n// setTimeout(fn, number): fn 是不能带参数的。使用闭包绑定一个上下文可以在闭包中获取这个上下文的数据。\nfunction func(param){ return function(){ alert(param) }}\nconst f1 = func(1);setTimeout(f1,1000);\n\n\n1\n2\n3\n4\n\n\n/* 生产者/消费者模型 */\n// 不使用闭包\n// 生产者\nfunction producer(){\n    const data = new（...）\n    return data\n}\n// 消费者\nfunction consumer(data){\n    // do consume...\n}\nconst data = producer()\n\n// 使用闭包\nfunction process(){\n    var data = new (...)\n    return function consumer(){\n        // do consume data ...\n    }\n}\nconst processer = process()\nprocesser()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n/* 实现继承 */\n// 以下两种方式都可以实现继承，但是闭包方式每次构造器都会被调用且重新赋值一次所以，所以实现继承原型优于闭包\n// 闭包\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n  this.getName = function() {\n    return this.name;\n  };\n\n  this.getMessage = function() {\n    return this.message;\n  };\n}\n// 原型\nfunction MyObject(name, message) {\n  this.name = name.toString();\n  this.message = message.toString();\n}\nMyObject.prototype.getName = function() {\n  return this.name;\n};\nMyObject.prototype.getMessage = function() {\n  return this.message;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对于闭包的概念好像懂了但又好像缺少了啥？意犹未尽。我也曾也闭包中迷失，但是看完闭包的生命周期让我重新找回自己。\n\n\n\n学完就来一波牛刀小试\n\nfunction test(a, b){\n  console.log(b);\n  return {\n    test: function(c) {\n      return test(c,a);\n    }\n  }\n}\n\nvar a = test(100);a.test(101);a.test(102);\nvar b = test(200).test(201).test(202);\nvar c = test(300).test(301);c.test(302);\n\n// undefined  100  100\n// undefined  200 201\n// undefined  300 301\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2️⃣ 原型和原型链\n\n有对象的地方就有 原型，每个对象都会在其内部初始化一个属性，就是prototype(原型)，原型中存储共享的属性和方法。当我们访问一个对象的属性时，js引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。这么一个寻找的过程就形成了 原型链 的概念。\n\n理解原型最关键的是理清楚__proto__、prototype、constructor三者的关系，我们先看看几个概念：\n\n * __proto__属性在所有对象中都存在，指向其构造函数的prototype对象；prototype对象只存在（构造）函数中，用于存储共享属性和方法；constructor属性只存在于（构造）函数的prototype中，指向（构造）函数本身。\n * 一个对象或者构造函数中的隐式原型__proto__的属性值指向其构造函数的显式原型 prototype 属性值，关系表示为：instance.__proto__ === instance.constructor.prototype\n * 除了 Object，所有对象或构造函数的 prototype 均继承自 Object.prototype，原型链的顶层指向 null：Object.prototype.__proto__ === null\n * Object.prototype 中也有 constructor：Object.prototype.constructor === Object\n * 构造函数创建的对象（Object、Function、Array、普通对象等）都是 Function 的实例，它们的 proto 均指向 Function.prototype。\n\n看起来是不是有点乱？？别慌！！一张图帮你整理它们之间的关系\n\n\n\n相同的配方再来一刀\n\nconst arr = [1, 2, 3];\narr.__proto__ === Array.prototype; // true\narr.__proto__.__proto__ === Object.prototype; // true\nArray.__proto__ === Function.prototype; // true\n\n\n1\n2\n3\n4\n\n\n\n# 3️⃣ 异步和单线程\n\nJavaScript 是 单线程 语言，意味着只有单独的一个调用栈，同一时间只能处理一个任务或一段代码。队列、堆、栈、事件循环构成了 js 的并发模型，事件循环 是 JavaScript 的执行机制。\n\n为什么js是一门单线程语言呢？最初设计JS是用来在浏览器验证表单以及操控DOM元素，为了避免同一时间对同一个DOM元素进行操作从而导致不可预知的问题，JavaScript从一诞生就是单线程。\n\n既然是单线程也就意味着不存在异步，只能自上而下执行，如果代码阻塞只能一直等下去，这样导致很差的用户体验，所以事件循环的出现让 js 拥有异步的能力。\n\n\n\n原文： JavaScript 的三座大山",normalizedContent:"js 作为前端的中坚力量。那么 javascript 三座大山，你知道是哪些呢？\n\n\n\n\n# 1️⃣ 作用域和闭包\n\n作用域 指代码当前上下文，控制着变量和函数的可见性和生命周期。最大的作用是隔离变量，不同作用域下同名变量不会冲突。\n\n作用域链 指如果在当前作用域中没有查到值，就会向上级作用域查询，直到全局作用域，这样一个查找过程所形成的链条就被称之为作用域链。\n\n作用域可以堆叠成层次结构，子作用域可以访问父作用域，反之则不行。\n\n作用域具体可细分为四种：全局作用域、模块作用域、函数作用域、块级作用域\n\n全局作用域： 代码在程序的任何地方都能被访问，例如 window 对象。但全局变量会污染全局命名空间，容易引起命名冲突。\n\n模块作用域： 早期 js 语法中没有模块的定义，因为最初的脚本小而简单。后来随着脚本越来越复杂，就出现了模块化方案（amd、commonjs、umd、es6模块等）。通常一个模块就是一个文件或者一段脚本，而这个模块拥有自己独立的作用域。\n\n函数作用域： 顾名思义由函数创建的作用域。闭包就是在该作用域下产生，后面我们会单独介绍。\n\n块级作用域： 由于 js 变量提升存在变量覆盖、变量污染等设计缺陷，所以 es6 引入了块级作用域关键字来解决这些问题。典型的案例就是 let 的 for 循环和 var 的 for 循环。\n\n// var demo\nfor(var i=0; i<10; i++) {\n    console.log(i);\n}\nconsole.log(i); // 10\n\n// let demo\nfor(let i=0; i<10; i++) {\n    console.log(i);\n}\nconsole.log(i); //referenceerror：i is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n了解完作用域再来谈谈 闭包： 函数a里包含了函数b，而函数b使用了函数a的变量，那么函数b被称为闭包或者闭包就是能够读取函数a内部变量的函数。\n\n可以看出闭包是函数作用域下的产物，闭包会随着外层函数的执行而被同时创建，它是一个函数以及其捆绑的周边环境状态的引用的组合。换而言之，闭包是内层函数对外层函数变量的不释放。\n\n闭包的特征：\n\n * 函数中存在函数；\n * 内部函数可以访问外层函数的作用域；\n * 参数和变量不会被 gc，始终驻留在内存中；\n * 有内存地方才有闭包。\n\n所以使用闭包会消耗内存、不正当使用会造成内存溢出的问题，在退出函数之前，需要将不使用的局部变量全部删除。如果不是某些特定需求，在函数中创建函数是不明智的，闭包在处理速度和内存消耗方面对脚本性能具有负面影响。\n\n以下整理了闭包的应用场景：\n\n// demo1 输出 3 3 3\nfor(var i = 0; i < 3; i++) {\n    settimeout(function() {\n        console.log(i);\n    }, 1000);\n} \n// demo2 输出 0 1 2\nfor(let i = 0; i < 3; i++) {\n    settimeout(function() {\n        console.log(i);\n    }, 1000);\n}\n// demo3 输出 0 1 2\nfor(let i = 0; i < 3; i++) {\n    (function(i){\n        settimeout(function() {\n        console.log(i);\n        }, 1000);\n    })(i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n/* 模拟私有方法 */\n// 模拟对象的get与set方法\nvar counter = (function() {\nvar privatecounter = 0;\nfunction changeby(val) {\n    privatecounter += val;\n}\nreturn {\n    increment: function() {\n    changeby(1);\n    },\n    decrement: function() {\n    changeby(-1);\n    },\n    value: function() {\n    return privatecounter;\n    }\n}\n})();\nconsole.log(counter.value()); /* logs 0 */\ncounter.increment();\ncounter.increment();\nconsole.log(counter.value()); /* logs 2 */\ncounter.decrement();\nconsole.log(counter.value()); /* logs 1 */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n/* settimeout中使用 */\n// settimeout(fn, number): fn 是不能带参数的。使用闭包绑定一个上下文可以在闭包中获取这个上下文的数据。\nfunction func(param){ return function(){ alert(param) }}\nconst f1 = func(1);settimeout(f1,1000);\n\n\n1\n2\n3\n4\n\n\n/* 生产者/消费者模型 */\n// 不使用闭包\n// 生产者\nfunction producer(){\n    const data = new（...）\n    return data\n}\n// 消费者\nfunction consumer(data){\n    // do consume...\n}\nconst data = producer()\n\n// 使用闭包\nfunction process(){\n    var data = new (...)\n    return function consumer(){\n        // do consume data ...\n    }\n}\nconst processer = process()\nprocesser()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n/* 实现继承 */\n// 以下两种方式都可以实现继承，但是闭包方式每次构造器都会被调用且重新赋值一次所以，所以实现继承原型优于闭包\n// 闭包\nfunction myobject(name, message) {\n  this.name = name.tostring();\n  this.message = message.tostring();\n  this.getname = function() {\n    return this.name;\n  };\n\n  this.getmessage = function() {\n    return this.message;\n  };\n}\n// 原型\nfunction myobject(name, message) {\n  this.name = name.tostring();\n  this.message = message.tostring();\n}\nmyobject.prototype.getname = function() {\n  return this.name;\n};\nmyobject.prototype.getmessage = function() {\n  return this.message;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n对于闭包的概念好像懂了但又好像缺少了啥？意犹未尽。我也曾也闭包中迷失，但是看完闭包的生命周期让我重新找回自己。\n\n\n\n学完就来一波牛刀小试\n\nfunction test(a, b){\n  console.log(b);\n  return {\n    test: function(c) {\n      return test(c,a);\n    }\n  }\n}\n\nvar a = test(100);a.test(101);a.test(102);\nvar b = test(200).test(201).test(202);\nvar c = test(300).test(301);c.test(302);\n\n// undefined  100  100\n// undefined  200 201\n// undefined  300 301\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2️⃣ 原型和原型链\n\n有对象的地方就有 原型，每个对象都会在其内部初始化一个属性，就是prototype(原型)，原型中存储共享的属性和方法。当我们访问一个对象的属性时，js引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的prototype对象是否有这个属性，如此递推下去，一直检索到 object 内建对象。这么一个寻找的过程就形成了 原型链 的概念。\n\n理解原型最关键的是理清楚__proto__、prototype、constructor三者的关系，我们先看看几个概念：\n\n * __proto__属性在所有对象中都存在，指向其构造函数的prototype对象；prototype对象只存在（构造）函数中，用于存储共享属性和方法；constructor属性只存在于（构造）函数的prototype中，指向（构造）函数本身。\n * 一个对象或者构造函数中的隐式原型__proto__的属性值指向其构造函数的显式原型 prototype 属性值，关系表示为：instance.__proto__ === instance.constructor.prototype\n * 除了 object，所有对象或构造函数的 prototype 均继承自 object.prototype，原型链的顶层指向 null：object.prototype.__proto__ === null\n * object.prototype 中也有 constructor：object.prototype.constructor === object\n * 构造函数创建的对象（object、function、array、普通对象等）都是 function 的实例，它们的 proto 均指向 function.prototype。\n\n看起来是不是有点乱？？别慌！！一张图帮你整理它们之间的关系\n\n\n\n相同的配方再来一刀\n\nconst arr = [1, 2, 3];\narr.__proto__ === array.prototype; // true\narr.__proto__.__proto__ === object.prototype; // true\narray.__proto__ === function.prototype; // true\n\n\n1\n2\n3\n4\n\n\n\n# 3️⃣ 异步和单线程\n\njavascript 是 单线程 语言，意味着只有单独的一个调用栈，同一时间只能处理一个任务或一段代码。队列、堆、栈、事件循环构成了 js 的并发模型，事件循环 是 javascript 的执行机制。\n\n为什么js是一门单线程语言呢？最初设计js是用来在浏览器验证表单以及操控dom元素，为了避免同一时间对同一个dom元素进行操作从而导致不可预知的问题，javascript从一诞生就是单线程。\n\n既然是单线程也就意味着不存在异步，只能自上而下执行，如果代码阻塞只能一直等下去，这样导致很差的用户体验，所以事件循环的出现让 js 拥有异步的能力。\n\n\n\n原文： javascript 的三座大山",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"处理问题的思路",frontmatter:{title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/pages/9ba2b8fb13de1957",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html",relativePath:"55.更多/01.学习/05.处理问题的思路.md",key:"v-f6eeff0a",path:"/pages/9ba2b8fb13de1957/",headers:[{level:2,title:"工作中遇到问题？",slug:"工作中遇到问题",normalizedTitle:"工作中遇到问题？",charIndex:14},{level:2,title:"这个问题我该怎么解决呢？",slug:"这个问题我该怎么解决呢",normalizedTitle:"这个问题我该怎么解决呢？",charIndex:86}],headersStr:"工作中遇到问题？ 这个问题我该怎么解决呢？",content:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找Boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",normalizedContent:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"「硬核JS」垃圾回收机制",frontmatter:{title:"「硬核JS」垃圾回收机制",date:"2021-07-06T22:44:44.000Z",permalink:"/pages/ed7042/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/07.%E3%80%8C%E7%A1%AC%E6%A0%B8JS%E3%80%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html",relativePath:"55.更多/02.进阶/07.「硬核JS」垃圾回收机制.md",key:"v-1641573c",path:"/pages/ed7042/",headers:[{level:2,title:"写在前面",slug:"写在前面",normalizedTitle:"写在前面",charIndex:2},{level:2,title:"GC是什么",slug:"gc是什么",normalizedTitle:"gc是什么",charIndex:493},{level:2,title:"垃圾产生&为何回收",slug:"垃圾产生-为何回收",normalizedTitle:"垃圾产生&amp;为何回收",charIndex:null},{level:2,title:"垃圾回收策略",slug:"垃圾回收策略",normalizedTitle:"垃圾回收策略",charIndex:1425},{level:3,title:"标记清除算法",slug:"标记清除算法",normalizedTitle:"标记清除算法",charIndex:1712},{level:3,title:"引用计数算法",slug:"引用计数算法",normalizedTitle:"引用计数算法",charIndex:1722},{level:2,title:"V8对GC的优化",slug:"v8对gc的优化",normalizedTitle:"v8对gc的优化",charIndex:5132},{level:3,title:"分代式垃圾回收",slug:"分代式垃圾回收",normalizedTitle:"分代式垃圾回收",charIndex:5230},{level:4,title:"新老生代",slug:"新老生代",normalizedTitle:"新老生代",charIndex:5372},{level:4,title:"新生代垃圾回收",slug:"新生代垃圾回收",normalizedTitle:"新生代垃圾回收",charIndex:5526},{level:4,title:"老生代垃圾回收",slug:"老生代垃圾回收",normalizedTitle:"老生代垃圾回收",charIndex:5666},{level:4,title:"为什么需要分代式？",slug:"为什么需要分代式",normalizedTitle:"为什么需要分代式？",charIndex:6572},{level:3,title:"并行回收(Parallel)",slug:"并行回收-parallel",normalizedTitle:"并行回收(parallel)",charIndex:6768},{level:3,title:"增量标记与懒性清理",slug:"增量标记与懒性清理",normalizedTitle:"增量标记与懒性清理",charIndex:7559},{level:4,title:"什么是增量",slug:"什么是增量",normalizedTitle:"什么是增量",charIndex:7752},{level:4,title:"三色标记法(暂停与恢复)",slug:"三色标记法-暂停与恢复",normalizedTitle:"三色标记法(暂停与恢复)",charIndex:7996},{level:4,title:"写屏障(增量中修改引用)",slug:"写屏障-增量中修改引用",normalizedTitle:"写屏障(增量中修改引用)",charIndex:8851},{level:4,title:"懒性清理",slug:"懒性清理",normalizedTitle:"懒性清理",charIndex:7564},{level:4,title:"增量标记与惰性清理的优缺？",slug:"增量标记与惰性清理的优缺",normalizedTitle:"增量标记与惰性清理的优缺？",charIndex:9685},{level:3,title:"并发回收(Concurrent)",slug:"并发回收-concurrent",normalizedTitle:"并发回收(concurrent)",charIndex:9907},{level:3,title:"再说V8中GC优化",slug:"再说v8中gc优化",normalizedTitle:"再说v8中gc优化",charIndex:10277},{level:2,title:"最后",slug:"最后",normalizedTitle:"最后",charIndex:306}],headersStr:"写在前面 GC是什么 垃圾产生&为何回收 垃圾回收策略 标记清除算法 引用计数算法 V8对GC的优化 分代式垃圾回收 新老生代 新生代垃圾回收 老生代垃圾回收 为什么需要分代式？ 并行回收(Parallel) 增量标记与懒性清理 什么是增量 三色标记法(暂停与恢复) 写屏障(增量中修改引用) 懒性清理 增量标记与惰性清理的优缺？ 并发回收(Concurrent) 再说V8中GC优化 最后",content:'# 写在前面\n\n我们知道垃圾回收机制是引擎来做的，JS引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 V8 引擎发展至今对该机制的优化为例（为什么以 V8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化\n\nJavaScript 是门魅力无限的语言，关于它的 GC（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获\n\n什么是垃圾回收机制？\n\n垃圾是怎样产生的？\n\n为什么要进行垃圾回收？\n\n垃圾回收是怎样进行的？\n\nV8 引擎对垃圾回收进行了哪些优化？\n\n当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 GC！假如你对其中某块内容不太理解，不要着急，先读完整篇文章了解内容再回过头来仔细看一遍就会清晰很多，干货满满，先赞后看哦\n\n\n\n\n# GC是什么\n\nGC 即 Garbage Collection ，程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了\n\n当然也不是所有语言都有 GC，一般的高级语言里面会自带 GC，比如 Java、Python、JavaScript 等，也有无 GC 的语言，比如 C、C++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦\n\n\n# 垃圾产生&为何回收\n\n我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存\n\n但是，你有没有想过，当我们不再需要某个东西时会发生什么？JavaScript 引擎又是如何发现并清理它的呢？\n\n我们举个简单的例子\n\nlet test = {\n  name: "isboyjc"\n};\ntest = [1,2,3,4,5]\n\n\n1\n2\n3\n4\n\n\n如上所示，我们假设它是一个完整的程序代码\n\n我们知道 JavaScript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，JavaScript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的\n\n那上面代码首先我们声明了一个变量 test，它引用了对象 {name: \'isboyjc\'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图\n\n\n\n没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）\n\n用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃\n\n\n# 垃圾回收策略\n\n在 JavaScript 内存管理中有一个概念叫做 可达性，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收\n\n至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， JavaScript 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存\n\n你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了\n\n我们都可以 Get 到这之中的重点，那就是怎样找出所谓的垃圾？\n\n这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的\n\n * 标记清除算法\n * 引用计数算法\n\n\n# 标记清除算法\n\n策略\n\n标记清除（Mark-Sweep），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异\n\n就像它的名字一样，此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁\n\n你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略\n\n引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树 等\n\n整个标记清除算法大致过程就像下面这样\n\n * 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\n * 然后从各个根对象开始遍历，把不是垃圾的节点改成1\n * 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\n * 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n优点\n\n标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单\n\n缺点\n\n标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题\n\n\n\n假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配（如下图）\n\n\n\n那如何找到合适的块呢？我们可以采取下面三种分配策略\n\n * First-fit，找到大于等于 size 的块立即返回\n * Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块\n * Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回\n\n这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择\n\n综上所述，标记清除算法或者说策略就有两个很明显的缺点\n\n * 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块\n * 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢\n\nPS：标记清除算法的缺点补充\n\n归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了\n\n而 标记整理（Mark-Compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）\n\n\n\n\n# 引用计数算法\n\n策略\n\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下\n\n它的策略是跟踪记录每个变量值被使用的次数\n\n * 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n * 如果同一个值又被赋给另一个变量，那么引用数加 1\n * 如果该变量的值被其他的值覆盖了，则引用次数减 1\n * 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\n\n如下例\n\nlet a = new Object() \t// 此对象的引用计数为 1（a引用）\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\na = null  \t\t// 此对象的引用计数为 1（b引用）\nb = null \t \t// 此对象的引用计数为 0（无引用）\n...\t\t\t// GC 回收此对象\n\n\n1\n2\n3\n4\n5\n\n\n这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A ，如下面这个例子\n\nfunction test(){\n  let A = new Object()\n  let B = new Object()\n  \n  A.b = B\n  B.a = A\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如上所示，对象 A 和 B 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 A 和 B 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放\n\n我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，A 和 B 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一\n\n> 在 IE8 以及更早版本的 IE 中，BOM 和 DOM 对象并非是原生 JavaScript 对象，它是由 C++ 实现的 组件对象模型对象（COM，Component Object Model），而 COM 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 COM 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 DOM 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系，如下\n> \n> // COM对象\n> let ele = document.getElementById("xxx")\n> let obj = new Object()\n> \n> // 造成循环引用\n> obj.ele = ele\n> ele.obj = obj\n> \n> // 切断引用关系\n> obj.ele = null\n> ele.obj = null\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 不过在 IE9 及以后的 BOM 与 DOM 对象都改成了 JavaScript 对象，也就避免了上面的问题\n> \n> 此处参考 JavaScript高级程序设计 第四版 4.3.2 小节\n\n优点\n\n引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾\n\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了\n\n缺点\n\n引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的\n\n\n# V8对GC的优化\n\n我们在上面也说过，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化\n\n\n# 分代式垃圾回收\n\n试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了\n\n# 新老生代\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收\n\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大\n\nV8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\n\n\n\n对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了\n\n# 新生代垃圾回收\n\n新生代对象是通过一个名为 Scavenge 的算法进行垃圾回收，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法 ，我们细细道来\n\nCheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示\n\n\n\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\n\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\n\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\n\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配\n\n# 老生代垃圾回收\n\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了\n\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象\n\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉\n\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间\n\n# 为什么需要分代式？\n\n正如小标题，为什么需要分代式？这个机制有什么优点又解决了什么问题呢？\n\n其实，它并不能说是解决了什么问题，可以说是一个优化点吧\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率\n\n\n# 并行回收(Parallel)\n\n在介绍并行之前，我们先要了解一个概念 全停顿（Stop-The-World），我们都知道 JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 JavaScript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿\n\n比如一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题\n\n既然存在执行一次 GC 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人...呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 V8 团队引入了并行回收机制\n\n所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作\n\n\n\n简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了\n\n不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单\n\n新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收\n\n\n# 增量标记与懒性清理\n\n我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间\n\n所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记\n\n# 什么是增量\n\n增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记（如下图）\n\n\n\n试想一下，将一次完整的 GC 标记分次执行，那在每一小次 GC 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？\n\n可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障\n\n# 三色标记法(暂停与恢复)\n\n我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 GC 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象\n\n如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了\n\n为了解决这个问题，V8 团队采用了一种特殊方式： 三色标记法\n\n三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑\n\n * 白色指的是未被标记的对象\n * 灰色指自身被标记，成员变量（该对象的引用对象）未被标记\n * 黑色指自身和成员变量皆被标记\n\n\n\n如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色\n\n就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 C、E 将要等待回收）\n\n采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以\n\n三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间\n\n# 写屏障(增量中修改引用)\n\n一次完整的 GC 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）\n\n\n\n假如我们有 A、B、C 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 JavaScript 脚本，在脚本中我们将对象 B 的指向由对象 C 改为了对象 D ，接着恢复执行下一次增量分段\n\n这时其实对象 C 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 GC 是不会清理 C 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 GC 也会清理，这对我们程序运行并没有太大影响\n\n我们再看新的对象 D 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 D 将在次轮 GC 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 D 呢，这肯定是不对的\n\n为了解决这个问题，V8 增量回收使用 写屏障 (Write-barrier) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 GC 标记阶段可以正确标记，这个机制也被称作 强三色不变性\n\n那在我们上图的例子中，将对象 B 的指向由对象 C 改为对象 D 后，白色对象 D 会被强制改为灰色\n\n# 懒性清理\n\n增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 V8 采用的是惰性清理(Lazy Sweeping)\n\n增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\n\n# 增量标记与惰性清理的优缺？\n\n增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 JavaScript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：\n\n首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是啥总不用说了吧）\n\n\n# 并发回收(Concurrent)\n\n前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？\n\n这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）\n\n\n\n辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说\n\n\n# 再说V8中GC优化\n\nV8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “\n\n其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的\n\n老生代主要使用并发标记，主线程在开始执行 JavaScript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）\n\n标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）\n\n同时，清理的任务会采用增量的方式分批在各个 JavaScript 任务之间执行\n\n\n# 最后\n\n那上面就是 V8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 内存泄漏',normalizedContent:'# 写在前面\n\n我们知道垃圾回收机制是引擎来做的，js引擎有很多种（各个浏览器都不同），其垃圾回收机制在一些细节及优化上略有不同，本文我们以一些通用的回收算法作为切入，再由 v8 引擎发展至今对该机制的优化为例（为什么以 v8 为例？因为它市场占有率大 😄 ），一步一步深入来助我们了解垃圾回收机制，因为只有真正了解垃圾回收机制，后面才能理解内存泄漏的问题以及手动预防和优化\n\njavascript 是门魅力无限的语言，关于它的 gc（垃圾回收）方面，你了解多少呢？想来大部分人是因为面试才去看一些面试题从而了解的垃圾回收，那在正式开始之前，给大家列几个小问题，大家可以先想一下答案，带着问题及答案再去看文章，最后读完此文如果你的答案可以优化，即有收获\n\n什么是垃圾回收机制？\n\n垃圾是怎样产生的？\n\n为什么要进行垃圾回收？\n\n垃圾回收是怎样进行的？\n\nv8 引擎对垃圾回收进行了哪些优化？\n\n当然，我们可不仅仅是为了面试，其目的是一次性彻底搞懂 gc！假如你对其中某块内容不太理解，不要着急，先读完整篇文章了解内容再回过头来仔细看一遍就会清晰很多，干货满满，先赞后看哦\n\n\n\n\n# gc是什么\n\ngc 即 garbage collection ，程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 gc 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，gc 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了\n\n当然也不是所有语言都有 gc，一般的高级语言里面会自带 gc，比如 java、python、javascript 等，也有无 gc 的语言，比如 c、c++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦\n\n\n# 垃圾产生&为何回收\n\n我们知道写代码时创建一个基本类型、对象、函数……都是需要占用内存的，但是我们并不关注这些，因为这是引擎为我们分配的，我们不需要显式手动的去分配内存\n\n但是，你有没有想过，当我们不再需要某个东西时会发生什么？javascript 引擎又是如何发现并清理它的呢？\n\n我们举个简单的例子\n\nlet test = {\n  name: "isboyjc"\n};\ntest = [1,2,3,4,5]\n\n\n1\n2\n3\n4\n\n\n如上所示，我们假设它是一个完整的程序代码\n\n我们知道 javascript 的引用数据类型是保存在堆内存中的，然后在栈内存中保存一个对堆内存中实际对象的引用，所以，javascript 中对引用数据类型的操作都是操作对象的引用而不是实际的对象。可以简单理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的\n\n那上面代码首先我们声明了一个变量 test，它引用了对象 {name: \'isboyjc\'}，接着我们把这个变量重新赋值了一个数组对象，也就变成了该变量引用了一个数组，那么之前的对象引用关系就没有了，如下图\n\n\n\n没有了引用关系，也就是无用的对象，这个时候假如任由它搁置，一个两个还好，多了的话内存也会受不了，所以就需要被清理（回收）\n\n用官方一点的话说，程序的运行需要内存，只要程序提出要求，操作系统或者运行时就必须提供内存，那么对于持续运行的服务进程，必须要及时释放内存，否则，内存占用越来越高，轻则影响系统性能，重则就会导致进程崩溃\n\n\n# 垃圾回收策略\n\n在 javascript 内存管理中有一个概念叫做 可达性，就是那些以某种方式可访问或者说可用的值，它们被保证存储在内存中，反之不可访问则需回收\n\n至于如何回收，其实就是怎样发现这些不可达的对象（垃圾）它并给予清理的问题， javascript 垃圾回收机制的原理说白了也就是定期找出那些不再用到的内存（变量），然后释放其内存\n\n你可能还会好奇为什么不是实时的找出无用内存并释放呢？其实很简单，实时开销太大了\n\n我们都可以 get 到这之中的重点，那就是怎样找出所谓的垃圾？\n\n这个流程就涉及到了一些算法策略，有很多种方式，我们简单介绍两个最常见的\n\n * 标记清除算法\n * 引用计数算法\n\n\n# 标记清除算法\n\n策略\n\n标记清除（mark-sweep），目前在 javascript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 javascript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 javascript引擎 在运行垃圾回收的频率上有所差异\n\n就像它的名字一样，此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁\n\n你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略\n\n引擎在执行 gc（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 根 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局window对象、文档dom树 等\n\n整个标记清除算法大致过程就像下面这样\n\n * 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\n * 然后从各个根对象开始遍历，把不是垃圾的节点改成1\n * 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\n * 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n优点\n\n标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单\n\n缺点\n\n标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题\n\n\n\n假设我们新建对象分配内存时需要大小为 size，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 size 的块才能为其分配（如下图）\n\n\n\n那如何找到合适的块呢？我们可以采取下面三种分配策略\n\n * first-fit，找到大于等于 size 的块立即返回\n * best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块\n * worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回\n\n这三种策略里面 worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 first-fit 和 best-fit 来说，考虑到分配的速度和效率 first-fit 是更为明智的选择\n\n综上所述，标记清除算法或者说策略就有两个很明显的缺点\n\n * 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块\n * 分配速度慢，因为即便是使用 first-fit 策略，其操作仍是一个 o(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢\n\nps：标记清除算法的缺点补充\n\n归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了\n\n而 标记整理（mark-compact）算法 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）\n\n\n\n\n# 引用计数算法\n\n策略\n\n引用计数（reference counting），这其实是早先的一种垃圾回收算法，它把 对象是否不再需要 简化定义为 对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多，不过我们还是需要了解一下\n\n它的策略是跟踪记录每个变量值被使用的次数\n\n * 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n * 如果同一个值又被赋给另一个变量，那么引用数加 1\n * 如果该变量的值被其他的值覆盖了，则引用次数减 1\n * 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\n\n如下例\n\nlet a = new object() \t// 此对象的引用计数为 1（a引用）\nlet b = a \t\t// 此对象的引用计数是 2（a,b引用）\na = null  \t\t// 此对象的引用计数为 1（b引用）\nb = null \t \t// 此对象的引用计数为 0（无引用）\n...\t\t\t// gc 回收此对象\n\n\n1\n2\n3\n4\n5\n\n\n这种方式是不是很简单？确实很简单，不过在引用计数这种算法出现没多久，就遇到了一个很严重的问题——循环引用，即对象 a 有一个指针指向对象 b，而对象 b 也引用了对象 a ，如下面这个例子\n\nfunction test(){\n  let a = new object()\n  let b = new object()\n  \n  a.b = b\n  b.a = a\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如上所示，对象 a 和 b 通过各自的属性相互引用着，按照上文的引用计数策略，它们的引用数量都是 2，但是，在函数 test 执行完成之后，对象 a 和 b 是要被清理的，但使用引用计数则不会被清理，因为它们的引用数量不会变成 0，假如此函数在程序中被多次调用，那么就会造成大量的内存不会被释放\n\n我们再用标记清除的角度看一下，当函数结束后，两个对象都不在作用域中，a 和 b 都会被当作非活动对象来清除掉，相比之下，引用计数则不会释放，也就会造成大量无用内存占用，这也是后来放弃引用计数，使用标记清除的原因之一\n\n> 在 ie8 以及更早版本的 ie 中，bom 和 dom 对象并非是原生 javascript 对象，它是由 c++ 实现的 组件对象模型对象（com，component object model），而 com 对象使用 引用计数算法来实现垃圾回收，所以即使浏览器使用的是标记清除算法，只要涉及到 com 对象的循环引用，就还是无法被回收掉，就比如两个互相引用的 dom 对象等等，而想要解决循环引用，需要将引用地址置为 null 来切断变量与之前引用值的关系，如下\n> \n> // com对象\n> let ele = document.getelementbyid("xxx")\n> let obj = new object()\n> \n> // 造成循环引用\n> obj.ele = ele\n> ele.obj = obj\n> \n> // 切断引用关系\n> obj.ele = null\n> ele.obj = null\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> \n> \n> 不过在 ie9 及以后的 bom 与 dom 对象都改成了 javascript 对象，也就避免了上面的问题\n> \n> 此处参考 javascript高级程序设计 第四版 4.3.2 小节\n\n优点\n\n引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾\n\n而标记清除算法需要每隔一段时间进行一次，那在应用程序（js脚本）运行过程中线程就必须要暂停去执行一段时间的 gc，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了\n\n缺点\n\n引用计数的缺点想必大家也都很明朗了，首先它需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限，还有就是无法解决循环引用无法回收的问题，这也是最严重的\n\n\n# v8对gc的优化\n\n我们在上面也说过，现在大多数浏览器都是基于标记清除算法，v8 亦是，当然 v8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 v8 中对垃圾回收机制的优化\n\n\n# 分代式垃圾回收\n\n试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了\n\n# 新老生代\n\nv8 的垃圾回收策略主要基于分代式垃圾回收机制，v8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收\n\n新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8m 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大\n\nv8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）\n\n\n\n对于新老两块内存区域的垃圾回收，v8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了\n\n# 新生代垃圾回收\n\n新生代对象是通过一个名为 scavenge 的算法进行垃圾回收，在 scavenge算法 的具体实现中，主要采用了一种复制式的方法即 cheney算法 ，我们细细道来\n\ncheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 使用区，一个是处于闲置状态的空间我们称之为 空闲区，如下图所示\n\n\n\n新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作\n\n当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区\n\n当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理\n\n另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配\n\n# 老生代垃圾回收\n\n相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了\n\n首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象\n\n清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉\n\n前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 v8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间\n\n# 为什么需要分代式？\n\n正如小标题，为什么需要分代式？这个机制有什么优点又解决了什么问题呢？\n\n其实，它并不能说是解决了什么问题，可以说是一个优化点吧\n\n分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率\n\n\n# 并行回收(parallel)\n\n在介绍并行之前，我们先要了解一个概念 全停顿（stop-the-world），我们都知道 javascript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 javascript 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 全停顿\n\n比如一次 gc 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 gc 的时间过长，对用户来说就可能造成页面卡顿等问题\n\n既然存在执行一次 gc 比较耗时的情况，考虑到一个人盖房子难，那两个人、十个人...呢？切换到程序这边，那我们可不可以引入多个辅助线程来同时处理，这样是不是就会加速垃圾回收的执行速度呢？因此 v8 团队引入了并行回收机制\n\n所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作\n\n\n\n简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了\n\n不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单\n\n新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收\n\n\n# 增量标记与懒性清理\n\n我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 gc 时哪怕我们使用并行策略依然可能会消耗大量时间\n\n所以为了减少全停顿的时间，在 2011 年，v8 对老生代的标记进行了优化，从全停顿标记切换到增量标记\n\n# 什么是增量\n\n增量就是将一次 gc 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 gc 标记（如下图）\n\n\n\n试想一下，将一次完整的 gc 标记分次执行，那在每一小次 gc 标记执行完之后如何暂停下来去执行任务程序，而后又怎么恢复呢？那假如我们在一次完整的 gc 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了又怎么办呢？\n\n可以看出增量的实现要比并行复杂一点，v8 对这两个问题对应的解决方案分别是三色标记法与写屏障\n\n# 三色标记法(暂停与恢复)\n\n我们知道老生代是采用标记清理算法，而上文的标记清理中我们说过，也就是在没有采用增量算法之前，单纯使用黑色和白色来标记数据就可以了，其标记流程即在执行一次完整的 gc 标记前，垃圾回收器会将所有的数据置为白色，然后垃圾回收器在会从一组跟对象出发，将所有能访问到的数据标记为黑色，遍历结束之后，标记为黑色的数据对象就是活动对象，剩余的白色数据对象也就是待清理的垃圾对象\n\n如果采用非黑即白的标记策略，那在垃圾回收器执行了一段增量回收后，暂停后启用主线程去执行了应用程序中的一段 javascript 代码，随后当垃圾回收器再次被启动，这时候内存中黑白色都有，我们无法得知下一步走到哪里了\n\n为了解决这个问题，v8 团队采用了一种特殊方式： 三色标记法\n\n三色标记法即使用每个对象的两个标记位和一个标记工作表来实现标记，两个标记位编码三种颜色：白、灰、黑\n\n * 白色指的是未被标记的对象\n * 灰色指自身被标记，成员变量（该对象的引用对象）未被标记\n * 黑色指自身和成员变量皆被标记\n\n\n\n如上图所示，我们用最简单的表达方式来解释这一过程，最初所有的对象都是白色，意味着回收器没有标记它们，从一组根对象开始，先将这组根对象标记为灰色并推入到标记工作表中，当回收器从标记工作表中弹出对象并访问它的引用对象时，将其自身由灰色转变成黑色，并将自身的下一个引用对象转为灰色\n\n就这样一直往下走，直到没有可标记灰色的对象时，也就是无可达（无引用到）的对象了，那么剩下的所有白色对象都是无法到达的，即等待回收（如上图中的 c、e 将要等待回收）\n\n采用三色标记法后我们在恢复执行时就好办多了，可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成，如没有灰色节点，直接进入清理阶段，如还有灰色标记，恢复时直接从灰色的节点开始继续执行就可以\n\n三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间，可以很好的配合增量回收进行暂停恢复的一些操作，从而减少 全停顿 的时间\n\n# 写屏障(增量中修改引用)\n\n一次完整的 gc 标记分块暂停后，执行任务程序时内存中标记好的对象引用关系被修改了，增量中修改引用，可能不太好理解，我们举个例子（如图）\n\n\n\n假如我们有 a、b、c 三个对象依次引用，在第一次增量分段中全部标记为黑色（活动对象），而后暂停开始执行应用程序也就是 javascript 脚本，在脚本中我们将对象 b 的指向由对象 c 改为了对象 d ，接着恢复执行下一次增量分段\n\n这时其实对象 c 已经无引用关系了，但是目前它是黑色（代表活动对象）此一整轮 gc 是不会清理 c 的，不过我们可以不考虑这个，因为就算此轮不清理等下一轮 gc 也会清理，这对我们程序运行并没有太大影响\n\n我们再看新的对象 d 是初始的白色，按照我们上面所说，已经没有灰色对象了，也就是全部标记完毕接下来要进行清理了，新修改的白色对象 d 将在次轮 gc 的清理阶段被回收，还有引用关系就被回收，后面我们程序里可能还会用到对象 d 呢，这肯定是不对的\n\n为了解决这个问题，v8 增量回收使用 写屏障 (write-barrier) 机制，即一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色，从而保证下一次增量 gc 标记阶段可以正确标记，这个机制也被称作 强三色不变性\n\n那在我们上图的例子中，将对象 b 的指向由对象 c 改为对象 d 后，白色对象 d 会被强制改为灰色\n\n# 懒性清理\n\n增量标记其实只是对活动对象和非活动对象进行标记，对于真正的清理释放内存 v8 采用的是惰性清理(lazy sweeping)\n\n增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 javascript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记\n\n# 增量标记与惰性清理的优缺？\n\n增量标记与惰性清理的出现，使得主线程的停顿时间大大减少了，让用户与浏览器交互的过程变得更加流畅。但是由于每个小的增量标记之间执行了 javascript 代码，堆中的对象指针可能发生了变化，需要使用写屏障技术来记录这些引用关系的变化，所以增量标记缺点也很明显：\n\n首先是并没有减少主线程的总暂停的时间，甚至会略微增加，其次由于写屏障机制的成本，增量标记可能会降低应用程序的吞吐量（吞吐量是啥总不用说了吧）\n\n\n# 并发回收(concurrent)\n\n前面我们说并行回收依然会阻塞主线程，增量标记同样有增加了总暂停时间、降低应用程序吞吐量两个缺点，那么怎么才能在不阻塞主线程的情况下执行垃圾回收并且与增量相比更高效呢？\n\n这就要说到并发回收了，它指的是主线程在执行 javascript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起（如下图）\n\n\n\n辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 javascript时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说\n\n\n# 再说v8中gc优化\n\nv8 的垃圾回收策略主要基于分代式垃圾回收机制，这我们说过，关于新生代垃圾回收器，我们说使用并行回收可以很好的增加垃圾回收的效率，那老生代垃圾回收器用的哪个策略呢？我上面说了并行回收、增量标记与惰性清理、并发回收这几种回收方式来提高效率、优化体验，看着一个比一个好，那老生代垃圾回收器到底用的哪个策略？难道是并发？？内心独白：” 好像。。貌似。。并发回收效率最高 “\n\n其实，这三种方式各有优缺点，所以在老生代垃圾回收器中这几种策略都是融合使用的\n\n老生代主要使用并发标记，主线程在开始执行 javascript 时，辅助线程也同时执行标记操作（标记操作全都由辅助线程完成）\n\n标记完成之后，再执行并行清理操作（主线程在执行清理操作时，多个辅助线程也同时执行清理操作）\n\n同时，清理的任务会采用增量的方式分批在各个 javascript 任务之间执行\n\n\n# 最后\n\n那上面就是 v8 引擎为我们的垃圾回收所做的一些主要优化了，虽然引擎有优化，但并不是说我们就可以完全不用关心垃圾回收这块了，我们的代码中依然要主动避免一些不利于引擎做垃圾回收操作，因为不是所有无用对象内存都可以被回收的，那当不再用到的内存，没有及时回收时，我们叫它 内存泄漏',charsets:{cjk:!0},lastUpdated:"2023/05/03, 10:00:58",lastUpdatedTimestamp:1683079258e3},{title:"Javascript 定时器应用技巧讲解",frontmatter:{title:"Javascript 定时器应用技巧讲解",date:"2022-01-24T18:04:49.000Z",permalink:"/advanced/55c2e0/",categories:["更多","进阶"],tags:["Javascript"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/10.Javascript%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7%E8%AE%B2%E8%A7%A3.html",relativePath:"55.更多/02.进阶/10.Javascript 定时器应用技巧讲解.md",key:"v-79fd1563",path:"/advanced/55c2e0/",headers:[{level:3,title:"Javascript 定时器应用技巧讲解",slug:"javascript-定时器应用技巧讲解",normalizedTitle:"javascript 定时器应用技巧讲解",charIndex:2}],headersStr:"Javascript 定时器应用技巧讲解",content:"# Javascript 定时器应用技巧讲解\n\nJavascript有两个定时器函数，分别是setTimeout和setInterval，区别定时执行一次与无数次，常使用的场景于倒计时，一分一秒的跳动的数字，刺激着用户的反应神经，活跃在商品抢购、秒杀等环节，组成现代网购不可缺少用户互动。\n\n定时器触发时间数字1000兑换现实时间的1秒，单纯使用setinterval进行倒计时，往往发现时间未到，提前触发下一步。反复观察，页面长时间停留，定时器触发的频率变快。可以得出结论：定时器的触发时间间隔不是恒定的。\n\n对于商业上需要精确的秒的活动，不能依靠定时器自身时间间隔，需要实时判断当前的时间做比较。\n\nvar endTime = new Date('2022/2/15 12:00').getTime();\nvar timer = setInterval(function(){\n    var nowTime = new Date().getTime();\n    if(nowTime >= endTime) {\n        clearInterval(timer);\n        console.log('倒计时已结束')\n    } else {\n        console.log('倒计时进行中...')\n    }\n},1000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于定时器触发间隔「不守规则」，容易造成时间逆差。老实人苦守着抢购按钮尚未激活，活动的商品早给别人抢先一步秒完，自己抢了个寂寞。\n\n移动端使用定时器倒计时，需要注意息屏场景。手机长时间不操作，自动息屏，定时器进入后台停止执行。再次进入页面，定时器激活，不过倒计时的显示的时分秒变得异常。这时需要中止定时器，再次激活定器。\n\nclearInterval(timer);\n\n\n1\n\n\n直接使用clearInterval中止定时器，有一定机率中止失败。\n\nvar timer = null;\nvar stuats = true;\nvar endTime = new Date('2022/2/15 12:00').getTime();\n\n/**\n * 执行定时器\n * method playTimer\n */\nvar playTimer = function() {\n    timer = setInterval(function(){\n        if(stuats == false) { //防止清除定时器失效\n            clearInterval(timer);\n            return false;\n        }\n\n        var nowTime = new Date().getTime();\n        if(nowTime >= endTime) {\n            clearInterval(timer);\n            console.log('倒计时已结束')\n        } else {\n            console.log('倒计时进行中...')\n        }\n    },1000)\n}\n\n\n/**\n * 重设定时器\n * method resetTimer\n */\nvar resetTimer= function() {\n    stuats = false;\n    setTimeout(function(){ //延迟执行中止，防止执行失败\n        clearInterval(timer);\n        stuats = true;\n        playTimer()\n    },1000);\n}\n\n\nplayTimer();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n移动端通过监听visibilitychange事件，判断document.visibilityState的值为visible进行重设定时器。\n\nJSdocument.addEventListener('visibilitychange',function() {\n    if(document.visibilityState == 'hidden') {\n        return false;\n    }\n    \n    resetTimer(); \n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n※ 使用到定时器，要多观察定时进程，避免开启多重定时器任务。",normalizedContent:"# javascript 定时器应用技巧讲解\n\njavascript有两个定时器函数，分别是settimeout和setinterval，区别定时执行一次与无数次，常使用的场景于倒计时，一分一秒的跳动的数字，刺激着用户的反应神经，活跃在商品抢购、秒杀等环节，组成现代网购不可缺少用户互动。\n\n定时器触发时间数字1000兑换现实时间的1秒，单纯使用setinterval进行倒计时，往往发现时间未到，提前触发下一步。反复观察，页面长时间停留，定时器触发的频率变快。可以得出结论：定时器的触发时间间隔不是恒定的。\n\n对于商业上需要精确的秒的活动，不能依靠定时器自身时间间隔，需要实时判断当前的时间做比较。\n\nvar endtime = new date('2022/2/15 12:00').gettime();\nvar timer = setinterval(function(){\n    var nowtime = new date().gettime();\n    if(nowtime >= endtime) {\n        clearinterval(timer);\n        console.log('倒计时已结束')\n    } else {\n        console.log('倒计时进行中...')\n    }\n},1000)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于定时器触发间隔「不守规则」，容易造成时间逆差。老实人苦守着抢购按钮尚未激活，活动的商品早给别人抢先一步秒完，自己抢了个寂寞。\n\n移动端使用定时器倒计时，需要注意息屏场景。手机长时间不操作，自动息屏，定时器进入后台停止执行。再次进入页面，定时器激活，不过倒计时的显示的时分秒变得异常。这时需要中止定时器，再次激活定器。\n\nclearinterval(timer);\n\n\n1\n\n\n直接使用clearinterval中止定时器，有一定机率中止失败。\n\nvar timer = null;\nvar stuats = true;\nvar endtime = new date('2022/2/15 12:00').gettime();\n\n/**\n * 执行定时器\n * method playtimer\n */\nvar playtimer = function() {\n    timer = setinterval(function(){\n        if(stuats == false) { //防止清除定时器失效\n            clearinterval(timer);\n            return false;\n        }\n\n        var nowtime = new date().gettime();\n        if(nowtime >= endtime) {\n            clearinterval(timer);\n            console.log('倒计时已结束')\n        } else {\n            console.log('倒计时进行中...')\n        }\n    },1000)\n}\n\n\n/**\n * 重设定时器\n * method resettimer\n */\nvar resettimer= function() {\n    stuats = false;\n    settimeout(function(){ //延迟执行中止，防止执行失败\n        clearinterval(timer);\n        stuats = true;\n        playtimer()\n    },1000);\n}\n\n\nplaytimer();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n移动端通过监听visibilitychange事件，判断document.visibilitystate的值为visible进行重设定时器。\n\njsdocument.addeventlistener('visibilitychange',function() {\n    if(document.visibilitystate == 'hidden') {\n        return false;\n    }\n    \n    resettimer(); \n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n※ 使用到定时器，要多观察定时进程，避免开启多重定时器任务。",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"FormData 配合 ajax 异步无刷新上传表格数据",frontmatter:{title:"FormData 配合 ajax 异步无刷新上传表格数据",date:"2022-05-24T17:56:34.000Z",permalink:"/advanced/0735ac/",categories:["更多","进阶"],tags:["ajax"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/20.FormData%20%E9%85%8D%E5%90%88%20ajax%20%E5%BC%82%E6%AD%A5%E6%97%A0%E5%88%B7%E6%96%B0%E4%B8%8A%E4%BC%A0%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE.html",relativePath:"55.更多/02.进阶/20.FormData 配合 ajax 异步无刷新上传表格数据.md",key:"v-104cfd4b",path:"/advanced/0735ac/",headers:[{level:3,title:"FormData 配合 ajax 异步无刷新上传表格数据",slug:"formdata-配合-ajax-异步无刷新上传表格数据",normalizedTitle:"formdata 配合 ajax 异步无刷新上传表格数据",charIndex:2},{level:3,title:"HTML 代码：",slug:"html-代码",normalizedTitle:"html 代码：",charIndex:351},{level:3,title:"JavaScript 代码：",slug:"javascript-代码",normalizedTitle:"javascript 代码：",charIndex:520}],headersStr:"FormData 配合 ajax 异步无刷新上传表格数据 HTML 代码： JavaScript 代码：",content:'# FormData 配合 ajax 异步无刷新上传表格数据\n\n在制作上传图片功能时，被告知要将图片改成上传到阿里云图片服务器，base64图片上传方式作废。项目都进入调试阶段，心里有句话不知该不该讲：TMD。日常改需求，习惯就好。心态要稳，静心，继续改代码。\n\n程序员其实是很苦逼的群体，项目不能自主，只能听从指挥。脾气不好的人，干这行真干不了长久。扯远了，生活还得继续。由于立项时没有考虑到，采用原生的写法。图片上传到阿里的oss，需要将表单的数据提交，如何保证无刷新的情况下，异步提交数据呢？\n\n对于额外引入第三方JS库，实现会很简单，比如：Vue.js+Element UI或插件。项目99%的都用原生写，总不能因为这点，额外增加JS体积。经过一翻搜索，成功锁定了 FormData。\n\n\n# HTML 代码：\n\n<form id="uploadForm" method="post" action="" enctype="multipart/form-data" >\n    <input type="file" name="files"  onchange="upload()" />\n</form>\n\n\n1\n2\n3\n\n\n\n# JavaScript 代码：\n\nvar upload = function() {\n    var form = document.getElementById("uploadForm");\n    var formData = new FormData(form);\n    formData.append(\'files\', formData.get("files"));\n    \n    $.ajax({\n        url:\'/upload/image\', \n        type: \'post\', \n       dataType: "json",\n       data: formData, \n       processData: false, \n       contentType: false, \n       success: function(result){\n            console.log(\'result:\',result)\n       }\n   });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n声明FormData后，使用get（）函数获取值，获得的数据与form使用post方式提交后的数据一致。有人问了，**FormData这么简单实现无刷新数据，为什么以前没有推扩使用？**这还得从浏览器的发展吏说起，win操作系统随着盗版进入国内，默认安装的是IE6浏览器。\n\n那些年，国内会使用电脑的用户不多，很多都是小白用户，你就别指望用户会主动升级浏览器。IE6浏览器在特殊时间，一直霸占浏览器入口。企业为了使用户正常浏览网站，兼容早已被淘汰的IE6浏览器。现今大名鼎鼎的淘宝，也曾忍受多年IE6的毒打，随着win 7普及才“硬”起来，不再兼容IE6浏览器。\n\n使FormData，需要考虑用户的浏览器，不是所有的浏览都支持。恰好项目只需支持 Chrome 浏览器，无需考虑兼容。',normalizedContent:'# formdata 配合 ajax 异步无刷新上传表格数据\n\n在制作上传图片功能时，被告知要将图片改成上传到阿里云图片服务器，base64图片上传方式作废。项目都进入调试阶段，心里有句话不知该不该讲：tmd。日常改需求，习惯就好。心态要稳，静心，继续改代码。\n\n程序员其实是很苦逼的群体，项目不能自主，只能听从指挥。脾气不好的人，干这行真干不了长久。扯远了，生活还得继续。由于立项时没有考虑到，采用原生的写法。图片上传到阿里的oss，需要将表单的数据提交，如何保证无刷新的情况下，异步提交数据呢？\n\n对于额外引入第三方js库，实现会很简单，比如：vue.js+element ui或插件。项目99%的都用原生写，总不能因为这点，额外增加js体积。经过一翻搜索，成功锁定了 formdata。\n\n\n# html 代码：\n\n<form id="uploadform" method="post" action="" enctype="multipart/form-data" >\n    <input type="file" name="files"  onchange="upload()" />\n</form>\n\n\n1\n2\n3\n\n\n\n# javascript 代码：\n\nvar upload = function() {\n    var form = document.getelementbyid("uploadform");\n    var formdata = new formdata(form);\n    formdata.append(\'files\', formdata.get("files"));\n    \n    $.ajax({\n        url:\'/upload/image\', \n        type: \'post\', \n       datatype: "json",\n       data: formdata, \n       processdata: false, \n       contenttype: false, \n       success: function(result){\n            console.log(\'result:\',result)\n       }\n   });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n声明formdata后，使用get（）函数获取值，获得的数据与form使用post方式提交后的数据一致。有人问了，**formdata这么简单实现无刷新数据，为什么以前没有推扩使用？**这还得从浏览器的发展吏说起，win操作系统随着盗版进入国内，默认安装的是ie6浏览器。\n\n那些年，国内会使用电脑的用户不多，很多都是小白用户，你就别指望用户会主动升级浏览器。ie6浏览器在特殊时间，一直霸占浏览器入口。企业为了使用户正常浏览网站，兼容早已被淘汰的ie6浏览器。现今大名鼎鼎的淘宝，也曾忍受多年ie6的毒打，随着win 7普及才“硬”起来，不再兼容ie6浏览器。\n\n使formdata，需要考虑用户的浏览器，不是所有的浏览都支持。恰好项目只需支持 chrome 浏览器，无需考虑兼容。',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"使用git命令行，删除远程分支上的文件or文件夹",frontmatter:{title:"使用git命令行，删除远程分支上的文件or文件夹",date:"2022-01-25T16:39:04.000Z",permalink:"/advanced/39134a/",categories:["更多","进阶"],tags:["Git"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/30.%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E8%A1%8C%EF%BC%8C%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E4%B8%8A%E7%9A%84%E6%96%87%E4%BB%B6or%E6%96%87%E4%BB%B6%E5%A4%B9.html",relativePath:"55.更多/02.进阶/30.使用git命令行，删除远程分支上的文件or文件夹.md",key:"v-499dee9f",path:"/advanced/39134a/",headersStr:null,content:"当我们错误的将不需要版本控制的文件提交到远程分支上后，需要删除远程分支上的文件，可以使用如下操作：\n\n【删除远程分支上的文件】\n\ngit rm -r --cached dirname    // 删除远程文件夹，但保留本地文件夹\n\ngit status  // 查看下状态\n\ngit commit -m 'delete a file or dir'   // 提交操作，并添加描述\n\ngit push origin dev    // 推送\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当我们再次去远程上查看的时候，想要被删除的文件就已经被删除啦。\n\n【删除暂存区、分支上的文件及工作区上的】\n\n当我们想要删除暂存区或分支上的文件，同时工作区也不需要这个问价了，可以使用如下操作：\n\ngit rm file_path\n\n\n1\n\n\n【删除暂存区、分支上，但是本地的不删除】\n\n当我们想要删除暂存区或分支上的文件，但本地又不需要删除，可以使用如下操作：\n\ngit rm --cached file_path\n\n\n1\n\n\n----ღ( ´･ᴗ･` )❤完。",normalizedContent:"当我们错误的将不需要版本控制的文件提交到远程分支上后，需要删除远程分支上的文件，可以使用如下操作：\n\n【删除远程分支上的文件】\n\ngit rm -r --cached dirname    // 删除远程文件夹，但保留本地文件夹\n\ngit status  // 查看下状态\n\ngit commit -m 'delete a file or dir'   // 提交操作，并添加描述\n\ngit push origin dev    // 推送\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当我们再次去远程上查看的时候，想要被删除的文件就已经被删除啦。\n\n【删除暂存区、分支上的文件及工作区上的】\n\n当我们想要删除暂存区或分支上的文件，同时工作区也不需要这个问价了，可以使用如下操作：\n\ngit rm file_path\n\n\n1\n\n\n【删除暂存区、分支上，但是本地的不删除】\n\n当我们想要删除暂存区或分支上的文件，但本地又不需要删除，可以使用如下操作：\n\ngit rm --cached file_path\n\n\n1\n\n\n----ღ( ´･ᴗ･` )❤完。",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"git push到远程指定分支(git拉取指定分支代码)",frontmatter:{title:"git push到远程指定分支(git拉取指定分支代码)",date:"2022-01-30T23:40:00.000Z",permalink:"/pages/3190e5/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/31.git%20push%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%8C%87%E5%AE%9A%E5%88%86%E6%94%AF(git%E6%8B%89%E5%8F%96%E6%8C%87%E5%AE%9A%E5%88%86%E6%94%AF%E4%BB%A3%E7%A0%81).html",relativePath:"55.更多/02.进阶/31.git push到远程指定分支(git拉取指定分支代码).md",key:"v-c52e6f90",path:"/pages/3190e5/",headers:[{level:3,title:"一、pull操作",slug:"一、pull操作",normalizedTitle:"一、pull操作",charIndex:2},{level:3,title:"二、push操作",slug:"二、push操作",normalizedTitle:"二、push操作",charIndex:301},{level:3,title:"附：",slug:"附",normalizedTitle:"附：",charIndex:552}],headersStr:"一、pull操作 二、push操作 附：",content:"# 一、pull操作\n\n1、将远程指定分支 拉取到 本地指定分支上：\n\ngit pull origin <远程分支名>:<本地分支名>\n\n\n1\n\n\n（注：命令里的尖括号<>只是包裹中文的标识，方便你看的，实际使用时不用写，不过冒号需要）\n\n2、将远程指定分支 拉取到 本地当前分支上：\n\ngit pull origin <远程分支名>\n\n\n1\n\n\n3、将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支，方法见文章末尾，只需关联一次)\n\ngit pull\n\n\n1\n\n\n在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名\n\n\n# 二、push操作\n\n1、将本地当前分支 推送到 远程指定分支上（注意：pull是远程在前本地在后，push相反）：\n\ngit push origin <本地分支名>:<远程分支名>\n\n\n1\n\n\n2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull是远程在前本地在后，push相反）：\n\ngit push origin <本地分支名>\n\n\n1\n\n\n3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见文章末尾)\n\ngit push\n\n\n1\n\n\n\n# 附：\n\n将本地分支与远程同名分支相关联\n\ngit push -u origin <本地分支名>\n\n\n1\n",normalizedContent:"# 一、pull操作\n\n1、将远程指定分支 拉取到 本地指定分支上：\n\ngit pull origin <远程分支名>:<本地分支名>\n\n\n1\n\n\n（注：命令里的尖括号<>只是包裹中文的标识，方便你看的，实际使用时不用写，不过冒号需要）\n\n2、将远程指定分支 拉取到 本地当前分支上：\n\ngit pull origin <远程分支名>\n\n\n1\n\n\n3、将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支，方法见文章末尾，只需关联一次)\n\ngit pull\n\n\n1\n\n\n在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名\n\n\n# 二、push操作\n\n1、将本地当前分支 推送到 远程指定分支上（注意：pull是远程在前本地在后，push相反）：\n\ngit push origin <本地分支名>:<远程分支名>\n\n\n1\n\n\n2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull是远程在前本地在后，push相反）：\n\ngit push origin <本地分支名>\n\n\n1\n\n\n3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见文章末尾)\n\ngit push\n\n\n1\n\n\n\n# 附：\n\n将本地分支与远程同名分支相关联\n\ngit push -u origin <本地分支名>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"如何快速关联及修改Git远程仓库地址",frontmatter:{title:"如何快速关联及修改Git远程仓库地址",date:"2022-02-01T15:39:29.000Z",permalink:"/pages/1130ec/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/32.%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%85%B3%E8%81%94%E5%8F%8A%E4%BF%AE%E6%94%B9Git%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.html",relativePath:"55.更多/02.进阶/32.如何快速关联及修改Git远程仓库地址.md",key:"v-f52fa3a8",path:"/pages/1130ec/",headers:[{level:2,title:"方法一 ：",slug:"方法一",normalizedTitle:"方法一 ：",charIndex:2},{level:2,title:"使用 Git 命令",slug:"使用-git-命令",normalizedTitle:"使用 git 命令",charIndex:12},{level:2,title:"直接修改本地仓库所关联的远程仓库的地址；",slug:"直接修改本地仓库所关联的远程仓库的地址",normalizedTitle:"直接修改本地仓库所关联的远程仓库的地址；",charIndex:26},{level:2,title:"方法二 ：",slug:"方法二",normalizedTitle:"方法二 ：",charIndex:266},{level:2,title:"使用 Git 命令",slug:"使用-git-命令-2",normalizedTitle:"使用 git 命令",charIndex:12},{level:2,title:"先删除本地仓库当前关联的无效远程地址，",slug:"先删除本地仓库当前关联的无效远程地址",normalizedTitle:"先删除本地仓库当前关联的无效远程地址，",charIndex:290},{level:2,title:"再为本地仓库添加新的远程仓库地址",slug:"再为本地仓库添加新的远程仓库地址",normalizedTitle:"再为本地仓库添加新的远程仓库地址",charIndex:314}],headersStr:"方法一 ： 使用 Git 命令 直接修改本地仓库所关联的远程仓库的地址； 方法二 ： 使用 Git 命令 先删除本地仓库当前关联的无效远程地址， 再为本地仓库添加新的远程仓库地址",content:"# 方法一 ：\n\n\n# 使用 Git 命令\n\n\n# 直接修改本地仓库所关联的远程仓库的地址；\n\n 1. 进入本地 Git 仓库根目录下；\n 2. 键入： git remote 查看远程仓库名称：origin ；\n 3. 键入：git remote get-url origin 查看远程仓库地址；\n 4. 键入：git remote set-url origin git@10.1.22.30:LauncherGroup/Launcher.git ( 如果未设置ssh-key，此处仓库地址为 http://... 开头)\n\n\n# 方法二 ：\n\n\n# 使用 Git 命令\n\n\n# 先删除本地仓库当前关联的无效远程地址，\n\n\n# 再为本地仓库添加新的远程仓库地址\n\n 1. 进入本地 Git 仓库根目录下；\n 2. 键入： git remote 查看远程仓库名称：origin ；\n 3. 键入：git remote rm origin 删除本地仓库当前关联的远程仓库；\n 4. 键入：git remote add origin git@10.1.22.30:LauncherGroup/Launcher.git ( 如果未设置ssh-key，此处仓库地址为 http://... 开头)\n\n完结~！",normalizedContent:"# 方法一 ：\n\n\n# 使用 git 命令\n\n\n# 直接修改本地仓库所关联的远程仓库的地址；\n\n 1. 进入本地 git 仓库根目录下；\n 2. 键入： git remote 查看远程仓库名称：origin ；\n 3. 键入：git remote get-url origin 查看远程仓库地址；\n 4. 键入：git remote set-url origin git@10.1.22.30:launchergroup/launcher.git ( 如果未设置ssh-key，此处仓库地址为 http://... 开头)\n\n\n# 方法二 ：\n\n\n# 使用 git 命令\n\n\n# 先删除本地仓库当前关联的无效远程地址，\n\n\n# 再为本地仓库添加新的远程仓库地址\n\n 1. 进入本地 git 仓库根目录下；\n 2. 键入： git remote 查看远程仓库名称：origin ；\n 3. 键入：git remote rm origin 删除本地仓库当前关联的远程仓库；\n 4. 键入：git remote add origin git@10.1.22.30:launchergroup/launcher.git ( 如果未设置ssh-key，此处仓库地址为 http://... 开头)\n\n完结~！",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！",frontmatter:{title:"什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！",date:"2022-11-01T15:56:40.000Z",permalink:"/pages/77f5b4/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/41.%E5%90%8E%E7%AB%AF%E4%B8%80%E6%AC%A1%E6%80%A7%E8%BF%94%E5%9B%9E%E6%88%9110%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E7%9A%848%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"55.更多/02.进阶/41.后端一次性返回我10万条数据的8种解决方案.md",key:"v-2b3bacab",path:"/pages/77f5b4/",headers:[{level:2,title:"问题描述",slug:"问题描述",normalizedTitle:"问题描述",charIndex:2},{level:3,title:"问题考察点",slug:"问题考察点",normalizedTitle:"问题考察点",charIndex:67},{level:3,title:"使用express创建一个十万条数据的接口",slug:"使用express创建一个十万条数据的接口",normalizedTitle:"使用express创建一个十万条数据的接口",charIndex:227},{level:3,title:"点击按钮，发请求，获取数据，渲染到表格上",slug:"点击按钮-发请求-获取数据-渲染到表格上",normalizedTitle:"点击按钮，发请求，获取数据，渲染到表格上",charIndex:704},{level:2,title:"方案一 直接渲染所有数据",slug:"方案一-直接渲染所有数据",normalizedTitle:"方案一 直接渲染所有数据",charIndex:1181},{level:2,title:"方案二 使用定时器分组分批分堆依次渲染（定时加载、分堆思想）",slug:"方案二-使用定时器分组分批分堆依次渲染-定时加载、分堆思想",normalizedTitle:"方案二 使用定时器分组分批分堆依次渲染（定时加载、分堆思想）",charIndex:1428},{level:3,title:"效果图",slug:"效果图",normalizedTitle:"效果图",charIndex:1627},{level:3,title:"分组分批分堆函数",slug:"分组分批分堆函数",normalizedTitle:"分组分批分堆函数",charIndex:1648},{level:3,title:"创建定时器去依次赋值渲染",slug:"创建定时器去依次赋值渲染",normalizedTitle:"创建定时器去依次赋值渲染",charIndex:2270},{level:2,title:"方案三 使用requestAnimationFrame替代定时器去做渲染",slug:"方案三-使用requestanimationframe替代定时器去做渲染",normalizedTitle:"方案三 使用requestanimationframe替代定时器去做渲染",charIndex:2838},{level:2,title:"方案四 搭配分页组件，前端进行分页（每页展示一堆，分堆思想）",slug:"方案四-搭配分页组件-前端进行分页-每页展示一堆-分堆思想",normalizedTitle:"方案四 搭配分页组件，前端进行分页（每页展示一堆，分堆思想）",charIndex:3828},{level:2,title:"方案五 表格滚动触底加载（滚动到底，再加载一堆）",slug:"方案五-表格滚动触底加载-滚动到底-再加载一堆",normalizedTitle:"方案五 表格滚动触底加载（滚动到底，再加载一堆）",charIndex:4450},{level:3,title:"在el-table中使用el-table-infinite-scroll指令步骤",slug:"在el-table中使用el-table-infinite-scroll指令步骤",normalizedTitle:"在el-table中使用el-table-infinite-scroll指令步骤",charIndex:4796},{level:3,title:"案例代码",slug:"案例代码",normalizedTitle:"案例代码",charIndex:4275},{level:3,title:"效果图",slug:"效果图-2",normalizedTitle:"效果图",charIndex:1627},{level:2,title:"方案六 使用无限加载/虚拟列表进行展示",slug:"方案六-使用无限加载-虚拟列表进行展示",normalizedTitle:"方案六 使用无限加载/虚拟列表进行展示",charIndex:7688},{level:3,title:"什么是虚拟列表？",slug:"什么是虚拟列表",normalizedTitle:"什么是虚拟列表？",charIndex:7712},{level:3,title:"写一个简单的虚拟列表",slug:"写一个简单的虚拟列表",normalizedTitle:"写一个简单的虚拟列表",charIndex:8066},{level:4,title:"效果图",slug:"效果图-3",normalizedTitle:"效果图",charIndex:1627},{level:4,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:211},{level:3,title:"使用vxetable插件实现虚拟列表",slug:"使用vxetable插件实现虚拟列表",normalizedTitle:"使用vxetable插件实现虚拟列表",charIndex:11723},{level:4,title:"效果图",slug:"效果图-4",normalizedTitle:"效果图",charIndex:1627},{level:4,title:"安装使用代码",slug:"安装使用代码",normalizedTitle:"安装使用代码",charIndex:11921},{level:2,title:"方案七 开启多线程Web Worker进行操作",slug:"方案七-开启多线程web-worker进行操作",normalizedTitle:"方案七 开启多线程web worker进行操作",charIndex:13146},{level:2,title:"方案八 未雨绸缪，防患于未然",slug:"方案八-未雨绸缪-防患于未然",normalizedTitle:"方案八 未雨绸缪，防患于未然",charIndex:13350},{level:3,title:"场景模拟",slug:"场景模拟",normalizedTitle:"场景模拟",charIndex:13769},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:14934}],headersStr:"问题描述 问题考察点 使用express创建一个十万条数据的接口 点击按钮，发请求，获取数据，渲染到表格上 方案一 直接渲染所有数据 方案二 使用定时器分组分批分堆依次渲染（定时加载、分堆思想） 效果图 分组分批分堆函数 创建定时器去依次赋值渲染 方案三 使用requestAnimationFrame替代定时器去做渲染 方案四 搭配分页组件，前端进行分页（每页展示一堆，分堆思想） 方案五 表格滚动触底加载（滚动到底，再加载一堆） 在el-table中使用el-table-infinite-scroll指令步骤 案例代码 效果图 方案六 使用无限加载/虚拟列表进行展示 什么是虚拟列表？ 写一个简单的虚拟列表 效果图 代码 使用vxetable插件实现虚拟列表 效果图 安装使用代码 方案七 开启多线程Web Worker进行操作 方案八 未雨绸缪，防患于未然 场景模拟 总结",content:'# 问题描述\n\n * 面试官：后端一次性返回10万条数据给你，你如何处理？\n * 我：歪嘴一笑，what the f**k!\n\n\n# 问题考察点\n\n看似无厘头的问题，实际上考查候选人知识的广度和深度，虽然在工作中这种情况很少遇到...\n\n * 考察前端如何处理大量数据\n * 考察候选人对于大量数据的性能优化\n * 考察候选人处理问题的思考方式（关于这一点，文末会说到，大家继续阅读）\n * ......\n\n文末会提供完整代码，供大家更好的理解\n\n\n# 使用express创建一个十万条数据的接口\n\n> 若是道友对express相关不太熟悉的话，有空可以看看笔者的这一篇全栈文章（还有完整代码哦）：《Vue+Express+Mysql全栈项目之增删改查、分页排序导出表格功能》\n\nroute.get("/bigData", (req, res) => {\n  res.header(\'Access-Control-Allow-Origin\', \'*\'); // 允许跨域\n  let arr = [] // 定义数组，存放十万条数据\n  for (let i = 0; i < 100000; i++) { // 循环添加十万条数据\n    arr.push({\n      id: i + 1,\n      name: \'名字\' + (i + 1),\n      value: i + 1,\n    })\n  }\n  res.send({ code: 0, msg: \'成功\', data: arr }) // 将十万条数据返回之\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 点击按钮，发请求，获取数据，渲染到表格上\n\nhtml结构如下：\n\n<el-button :loading="loading" @click="plan">点击请求加载</el-button>\n\n<el-table :data="arr">\n  <el-table-column type="index" label="序" />\n  <el-table-column prop="id" label="ID" />\n  <el-table-column prop="name" label="名字" />\n  <el-table-column prop="value" label="对应值" />\n</el-table>\n\ndata() {\n    return {\n      arr: [],\n      loading: false,\n    };\n},\n\nasync plan() {\n    // 发请求，拿数据，赋值给arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 方案一 直接渲染所有数据\n\n如果请求到10万条数据直接渲染，页面会卡死的，很显然，这种方式是不可取的\n\n async plan() {\n      this.loading = true;\n      const res = await axios.get("http://ashuai.work:10000/bigData");\n      this.arr = res.data.data;\n      this.loading = false;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方案二 使用定时器分组分批分堆依次渲染（定时加载、分堆思想）\n\n * 正常来说，十万条数据请求，需要2秒到10秒之间（有可能更长，取决于数据具体内容）\n * 而这种方式就是，前端请求到10万条数据以后，先不着急渲染，先将10万条数据分堆分批次\n * 比如一堆存放10条数据，那么十万条数据就有一万堆\n * 使用定时器，一次渲染一堆，渲染一万次即可\n * 这样做的话，页面就不会卡死了\n\n用户所看到的效果图是如下\n\n\n# 效果图\n\n\n\n\n# 分组分批分堆函数\n\n * 我们先写一个函数，用于将10万条数据进行分堆\n * 所谓的分堆其实思想就是一次截取一定长度的数据\n * 比如一次截取10条数据，头一次截取0~9，第二次截取10~19等固定长度的截取\n * 举例原来的数据是：[1,2,3,4,5,6,7]\n * 假设我们分堆以后，一堆分3个，那么得到的结果就是二维数组了\n * 即：[ [1,2,3], [4,5,6], [7]]\n * 然后就遍历这个二维数组，得到每一项的数据，即为每一堆的数据\n * 进而使用定时器一点点、一堆堆赋值渲染即可\n\n分组分批分堆函数（一堆分10个）\n\nfunction averageFn(arr) {\n  let i = 0; // 1. 从第0个开始截取\n  let result = []; // 2. 定义结果，结果是二维数组\n  while (i < arr.length) { // 6. 当索引等于或者大于总长度时，即截取完毕\n    // 3. 从原始数组的第一项开始遍历\n    result.push(arr.slice(i, i + 10)); // 4. 在原有十万条数据上，一次截取10个用于分堆\n    i = i + 10; // 5. 这10条数据截取完，再截取下十条数据，以此类推\n  }\n  return result; // 7. 最后把结果丢出去即可\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 创建定时器去依次赋值渲染\n\n比如我们每隔一秒钟去赋值渲染一次\n\n  async plan() {\n      this.loading = true;\n      const res = await axios.get("http://ashuai.work:10000/bigData");\n      this.loading = false;\n      let twoDArr = averageFn(res.data.data);\n      for (let i = 0; i < twoDArr.length; i++) {\n        // 相当于在很短的时间内创建许多个定时任务去处理\n        setTimeout(() => {\n          this.arr = [...this.arr, ...twoDArr[i]]; // 赋值渲染\n        }, 1000 * i); // 17 * i // 注意设定的时间间隔... 17 = 1000 / 60\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种方式，相当于在很短的时间内创建许多个定时任务去处理，定时任务太多了，也耗费资源啊。\n\n实际上，这种方式就有了大数据量分页的思想\n\n\n# 方案三 使用requestAnimationFrame替代定时器去做渲染\n\n关于requestAnimationFrame比定时器的优点，道友们可以看笔者的这篇文章：《性能优化之通俗易懂学习requestAnimationFrame和使用场景举例》\n\n> 反正大家遇到定时器的时候，就可以考虑一下，是否可以使用请求动画帧进行优化执行渲染？\n\n如果使用请求动画帧的话，就要修改一下代码写法了，前面的不变化，plan方法中的写法变一下即可，注意注释：\n\nasync plan() {\n  this.loading = true;\n  const res = await axios.get("http://ashuai.work:10000/bigData");\n  this.loading = false;\n  // 1. 将大数据量分堆\n  let twoDArr = averageFn(res.data.data);\n  // 2. 定义一个函数，专门用来做赋值渲染（使用二维数组中的每一项）\n  const use2DArrItem = (page) => {\n    // 4. 从第一项，取到最后一项\n    if (page > twoDArr.length - 1) {\n      console.log("每一项都获取完了");\n      return;\n    }\n    // 5. 使用请求动画帧的方式\n    requestAnimationFrame(() => {\n      // 6. 取出一项，就拼接一项（concat也行）\n      this.arr = [...this.arr, ...twoDArr[page]];\n      // 7. 这一项搞定，继续下一项\n      page = page + 1;\n      // 8. 直至完毕（递归调用，注意结束条件）\n      use2DArrItem(page);\n    });\n  };\n  // 3. 从二维数组中的第一项，第一堆开始获取并渲染（数组的第一项即索引为0）\n  use2DArrItem(0); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 方案四 搭配分页组件，前端进行分页（每页展示一堆，分堆思想）\n\n这种方式，笔者曾经遇到过，当时的对应场景是数据量也就几十条，后端直接把几十条数据丢给前端，让前端去分页\n\n> 后端不做分页的原因是。他当时临时有事情请假了，所以就前端去做分页了。\n\n * 数据量大的情况下，这种方式，也是一种解决方案\n * 思路也是在所有数据的基础上进行截取\n * 简要代码如下：\n\ngetShowTableData() { \n    // 获取截取开始索引 \n    let begin = (this.pageIndex - 1) * this.pageSize; \n    // 获取截取结束索引\n     let end = this.pageIndex * this.pageSize; \n    // 通过索引去截取，从而展示\n    this.showTableData = this.allTableData.slice(begin, end); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n完整案例代码，请看笔者的这篇文章：《后端一次性返回所有的数据，让前端截取展示做分页》\n\n实际上，这种大任务拆分成许多小任务，这种方式，做法，应用的思想就是分片的方式（时间），在别的场景，比如大文件上传的时候，也有这种思想，比如一个500MB的大文件，拆分成50个小文件，一个是10MB这样...至于大文件上传的文章，那就等笔者有空了再写呗...\n\n\n# 方案五 表格滚动触底加载（滚动到底，再加载一堆）\n\n这里重点就是我们需要去判断，何时滚动条触底。判断方式主要有两种\n\n * scrollTop + clientHeight >= innerHeight\n * 或\n * new MutationObserver()去观测\n\n目前市面上主流的一些插件的原理，大致是这两种。\n\n笔者举例的这是，是使用的插件v-el-table-infinite-scroll，本质上这个插件是一个自定义指令。对应npm地址：www.npmjs.com/package/el-…\n\n当然也有别的插件，如vue-scroller 等：一个意思，不赘述\n\n> 注意，触底加载也是要分堆的，将发请求获取到的十万条数据，进行分好堆，然后每触底一次，就加载一堆即可\n\n\n# 在el-table中使用el-table-infinite-scroll指令步骤\n\n安装，注意版本号（区分vue2和vue3）\n\ncnpm install --save el-table-infinite-scroll@1.0.10\n\n注册使用指令插件\n\n// 使用无限滚动插件\nimport elTableInfiniteScroll from \'el-table-infinite-scroll\';\nVue.use(elTableInfiniteScroll);\n\n\n1\n2\n3\n\n\n因为是一个自定义指令，所以直接写在el-table标签上即可\n\n<el-table\n  v-el-table-infinite-scroll="load"\n  :data="tableData"\n>\n  <el-table-column prop="id" label="ID"></el-table-column>\n  <el-table-column prop="name" label="名字"></el-table-column>\n</el-table>\n\nasync load() {\n    // 触底加载，展示数据...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 案例代码\n\n为了方便大家演示，这里笔者直接附上一个案例代码，注意看其中的步骤注释即可\n\n<template>\n  <div class="box">\n    <el-table\n      v-el-table-infinite-scroll="load"\n      height="600"\n      :data="tableData"\n      border\n      style="width: 80%"\n      v-loading="loading"\n      element-loading-text="数据量太大啦，客官稍后..."\n      element-loading-spinner="el-icon-loading"\n      element-loading-background="rgba(255, 255, 255, 0.5)"\n      :header-cell-style="{\n        height: \'24px\',\n        lineHeight: \'24px\',\n        color: \'#606266\',\n        background: \'#F5F5F5\',\n        fontWeight: \'bold\',\n      }"\n    >\n      <el-table-column type="index" label="序"></el-table-column>\n      <el-table-column prop="id" label="ID"></el-table-column>\n      <el-table-column prop="name" label="名字"></el-table-column>\n      <el-table-column prop="value" label="对应值"></el-table-column>\n    </el-table>\n  </div>\n</template>\n\n<script>\n// 分堆函数\nfunction averageFn(arr) {\n  let i = 0;\n  let result = [];\n  while (i < arr.length) {\n    result.push(arr.slice(i, i + 10)); // 一次截取10个用于分堆\n    i = i + 10; // 这10个截取完，再准备截取下10个\n  }\n  return result;\n}\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      allTableData: [], // 初始发请求获取所有的数据\n      tableData: [], // 要展示的数据\n      loading: false\n    };\n  },\n  // 第一步，发请求，获取大量数据，并转成二维数组，分堆分组分块存储\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigData");\n    this.allTableData = averageFn(res.data.data); // 使用分堆函数，存放二维数组\n    // this.originalAllTableData = this.allTableData // 也可以存一份原始值，留作备用，都行的\n    this.loading = false;\n    // 第二步，操作完毕以后，执行触底加载方法\n    this.load(); \n  },\n  methods: {\n    // 初始会执行一次，当然也可以配置，使其不执行\n    async load() {\n      console.log("自动多次执行之，首次执行会根据高度去计算要执行几次合适");\n      // 第五步，触底加载相当于把二维数组的每一项取出来用，取完用完时return停止即可\n      if (this.allTableData.length == 0) {\n        console.log("没数据啦");\n        return;\n      }\n      // 第三步，加载的时候，把二维数组的第一项取出来，拼接到要展示的表格数据中去\n      let arr = this.allTableData[0];\n      this.tableData = this.tableData.concat(arr);\n      // 第四步，拼接展示以后，再把二维数组的第一项的数据删除即可\n      this.allTableData.shift();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 效果图\n\n\n\n\n# 方案六 使用无限加载/虚拟列表进行展示\n\n\n# 什么是虚拟列表？\n\n * 所谓的虚拟列表实际上是前端障眼法的一种表现形式。\n * 看到的好像所有的数据都渲染了，实际上只渲染可视区域的部分罢了\n * 有点像我们看电影，我们看的话，是在一块电影屏幕上，一秒一秒的看（不停的放映）\n * 但是实际上电影有俩小时，如果把两个小时的电影都铺开的话，那得需要多少块电影屏幕呢？\n * 同理，如果10万条数据都渲染，那得需要多少dom节点元素呢？\n * 所以我们只给用户看，他当下能看到的\n * 如果用户要快进或快退（下拉滚动条或者上拉滚动条）\n * 再把对应的内容呈现在电影屏幕上（呈现在可视区域内）\n * 这样就实现了看着像是所有的dom元素每一条数据都有渲染的障眼法效果了\n\n> 关于前端障眼法，在具体工作中，如果能够巧妙使用，会大大提升我们的开发效率的\n\n\n# 写一个简单的虚拟列表\n\n# 效果图\n\n\n\n这里笔者直接上代码，大家复制粘贴即可使用，笔者写了一些注释，以便于大家理解。当然也可以去笔者的仓库中去瞅瞅哦，GitHub仓库在文末\n\n# 代码\n\n<template>\n  \x3c!-- 虚拟列表容器，类似“窗口”，窗口的高度取决于一次展示几条数据\n            比如窗口只能看到10条数据，一条40像素，10条400像素\n            故，窗口的高度为400像素，注意要开定位和滚动条 --\x3e\n  <div\n    class="virtualListWrap"\n    ref="virtualListWrap"\n    @scroll="handleScroll"\n    :style="{ height: itemHeight * count + \'px\' }"\n  >\n    \x3c!-- 占位dom元素，其高度为所有的数据的总高度 --\x3e\n    <div\n      class="placeholderDom"\n      :style="{ height: allListData.length * itemHeight + \'px\' }"\n    ></div>\n    \x3c!-- 内容区，展示10条数据，注意其定位的top值是变化的 --\x3e\n    <div class="contentList" :style="{ top: topVal }">\n      \x3c!-- 每一条（项）数据 --\x3e\n      <div\n        v-for="(item, index) in showListData"\n        :key="index"\n        class="itemClass"\n        :style="{ height: itemHeight + \'px\' }"\n      >\n        {{ item.name }}\n      </div>\n    </div>\n    \x3c!-- 加载中部分 --\x3e\n    <div class="loadingBox" v-show="loading">\n      <i class="el-icon-loading"></i>\n      &nbsp;&nbsp;<span>loading...</span>\n    </div>\n  </div>\n</template>\n<script>\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      allListData: [], // 所有的数据，比如这个数组存放了十万条数据\n      itemHeight: 40, // 每一条（项）的高度，比如40像素\n      count: 10, // 一屏展示几条数据\n      start: 0, // 开始位置的索引\n      end: 10, // 结束位置的索引\n      topVal: 0, // 父元素滚动条滚动，更改子元素对应top定位的值，确保联动\n      loading: false,\n    };\n  },\n  computed: {\n    // 从所有的数据allListData中截取需要展示的数据showListData\n    showListData: function () {\n      return this.allListData.slice(this.start, this.end);\n    },\n  },\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigData");\n    this.allListData = res.data.data;\n    this.loading = false;\n  },\n  methods: {\n    // 滚动这里可以加上节流，减少触发频次\n    handleScroll() {\n      /**\n       * 获取在垂直方向上，滚动条滚动了多少像素距离Element.scrollTop\n       *\n       * 滚动的距离除以每一项的高度，即为滚动到了多少项，当然，要取个整数\n       * 例：滚动4米，一步长0.8米，滚动到第几步，4/0.8 = 第5步（取整好计算）\n       *\n       * 又因为我们一次要展示10项，所以知道了起始位置项，再加上结束位置项，\n       * 就能得出区间了【起始位置, 起始位置 + size项数】==【起始位置, 结束位置】\n       * */\n      const scrollTop = this.$refs.virtualListWrap.scrollTop;\n      this.start = Math.floor(scrollTop / this.itemHeight);\n      this.end = this.start + this.count;\n      /**\n       * 动态更改定位的top值，确保联动，动态展示相应内容\n       * */\n      this.topVal = this.$refs.virtualListWrap.scrollTop + "px";\n    },\n  },\n};\n<\/script>\n<style scoped lang="less">\n// 虚拟列表容器盒子\n.virtualListWrap {\n  box-sizing: border-box;\n  width: 240px;\n  border: solid 1px #000000;\n  // 开启滚动条\n  overflow-y: auto;\n  // 开启相对定位\n  position: relative;\n  .contentList {\n    width: 100%;\n    height: auto;\n    // 搭配使用绝对定位\n    position: absolute;\n    top: 0;\n    left: 0;\n    .itemClass {\n      box-sizing: border-box;\n      width: 100%;\n      height: 40px;\n      line-height: 40px;\n      text-align: center;\n    }\n    // 奇偶行改一个颜色\n    .itemClass:nth-child(even) {\n      background: #c7edcc;\n    }\n    .itemClass:nth-child(odd) {\n      background: pink;\n    }\n  }\n  .loadingBox {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(255, 255, 255, 0.64);\n    color: green;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n\n# 使用vxetable插件实现虚拟列表\n\n如果不是列表，是table表格的话，笔者这里推荐一个好用的UI组件，vxetable，看名字就知道做的是表格相关的业务。其中就包括虚拟列表。\n\nvue2和vue3版本都支持，性能比较好，官方说：虚拟滚动（最大可以支撑 5w 列、30w 行）\n\n强大！\n\n官方网站地址：vxetable.cn/v3/#/table/…\n\n# 效果图\n\n效果很丝滑\n\n\n\n# 安装使用代码\n\n注意安装版本，笔者使用的版本如下：\n\ncnpm i xe-utils vxe-table@3.6.11 --save\n\n\n1\n\n\nmain.js\n\n// 使用VXETable\nimport VXETable from \'vxe-table\'\nimport \'vxe-table/lib/style.css\'\nVue.use(VXETable)\n\n\n1\n2\n3\n4\n\n\n代码方面也很简单，如下：\n\n<template>\n  <div class="box">\n    <vxe-table\n      border\n      show-overflow\n      ref="xTable1"\n      height="300"\n      :row-config="{ isHover: true }"\n      :loading="loading"\n    >\n      <vxe-column type="seq"></vxe-column>\n      <vxe-column field="id" title="ID"></vxe-column>\n      <vxe-column field="name" title="名字"></vxe-column>\n      <vxe-column field="value" title="对应值"></vxe-column>\n    </vxe-table>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      loading: false,\n    };\n  },\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigData");\n    this.loading = false;\n    this.render(res.data.data);\n  },\n  methods: {\n    render(data) {\n      this.$nextTick(() => {\n        const $table = this.$refs.xTable1;\n        $table.loadData(data);\n      });\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 方案七 开启多线程Web Worker进行操作\n\n本案例中，使用Web Worker另外开启一个线程去操作代码逻辑，收益并不是特别大（假如使用虚拟滚动列表插件的情况下）\n\n不过也算是一个拓展的思路吧，面试的时候，倒是可以说一说，提一提。\n\n对Web Worker不熟悉的道友们，可以看看笔者之前的这篇文章：《性能优化之使用vue-worker插件（基于Web Worker）开启多线程运算提高效率》\n\n\n# 方案八 未雨绸缪，防患于未然\n\n以下为笔者愚见，仅供参考...\n\n * 在上述解决方案都说完以后，并没有结束。\n * 实际上本题目在考查候选人知识的广度和深度以外，更是考查了候选人的处理问题的思考方式，这一点尤其重要！\n * 笔者曾做过候选人去求职，也曾做过面试官去面试。就程序员开发工作而言，技术知识点不熟悉，可以快速学习，如文档、谷歌、百度、技术交流群，相关同事都可提供一定的支持\n * 更重要的是看中候选人的思考方式，思维模式\n * 试想，两个候选人实力水平差不多，但是一个只知道埋头苦干，有活就干，不去斟酌；而另外一个却是在用心工作的时候，也会仰望星空，会分析如何干活能够高性价比地完成任务，注重过程与结果\n * 这样的话，哪个更加受欢迎一些呢？\n\n如果笔者是候选人，笔者在说了上述7种方案以后，会再补充第八种方案：未雨绸缪，防患于未然\n\n----------------------------------------\n\n\n# 场景模拟\n\n面试官随意打量着其手中我的简历，抚须怪叫一声：“小子，后端要一次性返回10万条数据给你，你如何处理？”\n\n我眉毛一挑，歪嘴一笑：“在上述7种方案陈述完以后，我想类似的问题，我们可以从根本上去解决。即第八种方案，要未雨绸缪，防患于未然。”\n\n“哦？”面试官心中疑惑，缓缓放下我的简历：“愿闻其详。”\n\n我不紧不慢地答道：“在具体开发工作中，我们在接到一个需求时，在技术评审期间，我们就要和后端去商量比较合适的技术解决方案。这个问题是后端要一次性返回我10万条数据，重点并不在10万条这么多数据，而在于后端为什么要这样做？”\n\n面试官抬头，认真听了起来。\n\n我一字一顿地说道：“除去业务真正需要这种方案的话（若是客户要求的，那就没啥好说的，干就完了），后端这样做的原因大致有两种，第一种他不太懂sql的limit语句，但这基本不可能，第二种就是他有事情，随便敷衍写了一下。所以，就是要和他沟通，从大数据量接口请求时长过长，以及过多的dom元素渲染导致性能变差，以及项目的可维护性等角度去沟通，我相信只要正确的沟通，就能从根源上去避免这种不太合理的情况发生。”\n\n面试官又突然狡黠地发问：“要是沟通以后，后端死活不给你分页呢？你咋办？你的沟通无效果！你如何处理！人家不听你的！”似乎是觉得这个问题很刁钻，他双臂抱在胸前，靠在椅背上，等待着我脸上即将绽放的的回答不上来地尴尬笑容。\n\n我内心冷哼一声：雕虫小技...\n\n我盯着面试官的眼睛，认真说道：“如果工作中沟通无效果，要么是我自己沟通语言表达的问题，这一点我会注意，不断提升自己的沟通技巧和说话方式，要么就是...”\n\n我声音扬起了三分：“我沟通的这个人有问题！他工作摸鱼偷懒耍滑！固执己见！为难他人！高高在上！自以为是！这种情况下，我会找到我的直属领导去介入，因为这已经不是项目的需求问题了，而是员工的基本素养问题！”\n\n停顿了一秒，我声音又柔和了几分：“但是，但是我相信咱们公司员工中是绝对没有这样的人存在的，各个都是能力强悍，态度端正的优秀员工。毕竟咱们公司在行业中久负盛名，我也是因此慕名而来的。您说对吧？”\n\n面试官眼中闪过震惊之色，他没有想到我居然把皮球又踢给他了，不过他为了维持形象，旋即恢复了镇定，只是面部肌肉在止不住的微微颤抖。\n\n我又补充道：“实际上在工作中，前端作为比较贴近用户的角色而言，需要和各个岗位的同事进行沟通，比如后端、产品、UI、测试等。我们需要通过合理的沟通方式，去提升工作效率，完成项目，实现自己的价值，为公司创造收益，我想这是每一个员工需要做的，也是必须要做到的。”\n\n面试官又抚须怪叫一声：“小子表现还行，你被录用了！一个月工资2200，自带电脑，无社无金，007工作制，不能偷吃公司零食，以及...”\n\n我：阿哒...\n\n\n# 总结\n\n有效的沟通，源自于解决问题的思维模式，在多数情况下，重要性，大于当下所掌握的技术知识点\n\n * 网站效果演示地址：ashuai.work:8888/#/bigData\n * GitHub仓库地址：github.com/shuirongshu…\n * 原文地址：什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！',normalizedContent:'# 问题描述\n\n * 面试官：后端一次性返回10万条数据给你，你如何处理？\n * 我：歪嘴一笑，what the f**k!\n\n\n# 问题考察点\n\n看似无厘头的问题，实际上考查候选人知识的广度和深度，虽然在工作中这种情况很少遇到...\n\n * 考察前端如何处理大量数据\n * 考察候选人对于大量数据的性能优化\n * 考察候选人处理问题的思考方式（关于这一点，文末会说到，大家继续阅读）\n * ......\n\n文末会提供完整代码，供大家更好的理解\n\n\n# 使用express创建一个十万条数据的接口\n\n> 若是道友对express相关不太熟悉的话，有空可以看看笔者的这一篇全栈文章（还有完整代码哦）：《vue+express+mysql全栈项目之增删改查、分页排序导出表格功能》\n\nroute.get("/bigdata", (req, res) => {\n  res.header(\'access-control-allow-origin\', \'*\'); // 允许跨域\n  let arr = [] // 定义数组，存放十万条数据\n  for (let i = 0; i < 100000; i++) { // 循环添加十万条数据\n    arr.push({\n      id: i + 1,\n      name: \'名字\' + (i + 1),\n      value: i + 1,\n    })\n  }\n  res.send({ code: 0, msg: \'成功\', data: arr }) // 将十万条数据返回之\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 点击按钮，发请求，获取数据，渲染到表格上\n\nhtml结构如下：\n\n<el-button :loading="loading" @click="plan">点击请求加载</el-button>\n\n<el-table :data="arr">\n  <el-table-column type="index" label="序" />\n  <el-table-column prop="id" label="id" />\n  <el-table-column prop="name" label="名字" />\n  <el-table-column prop="value" label="对应值" />\n</el-table>\n\ndata() {\n    return {\n      arr: [],\n      loading: false,\n    };\n},\n\nasync plan() {\n    // 发请求，拿数据，赋值给arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 方案一 直接渲染所有数据\n\n如果请求到10万条数据直接渲染，页面会卡死的，很显然，这种方式是不可取的\n\n async plan() {\n      this.loading = true;\n      const res = await axios.get("http://ashuai.work:10000/bigdata");\n      this.arr = res.data.data;\n      this.loading = false;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方案二 使用定时器分组分批分堆依次渲染（定时加载、分堆思想）\n\n * 正常来说，十万条数据请求，需要2秒到10秒之间（有可能更长，取决于数据具体内容）\n * 而这种方式就是，前端请求到10万条数据以后，先不着急渲染，先将10万条数据分堆分批次\n * 比如一堆存放10条数据，那么十万条数据就有一万堆\n * 使用定时器，一次渲染一堆，渲染一万次即可\n * 这样做的话，页面就不会卡死了\n\n用户所看到的效果图是如下\n\n\n# 效果图\n\n\n\n\n# 分组分批分堆函数\n\n * 我们先写一个函数，用于将10万条数据进行分堆\n * 所谓的分堆其实思想就是一次截取一定长度的数据\n * 比如一次截取10条数据，头一次截取0~9，第二次截取10~19等固定长度的截取\n * 举例原来的数据是：[1,2,3,4,5,6,7]\n * 假设我们分堆以后，一堆分3个，那么得到的结果就是二维数组了\n * 即：[ [1,2,3], [4,5,6], [7]]\n * 然后就遍历这个二维数组，得到每一项的数据，即为每一堆的数据\n * 进而使用定时器一点点、一堆堆赋值渲染即可\n\n分组分批分堆函数（一堆分10个）\n\nfunction averagefn(arr) {\n  let i = 0; // 1. 从第0个开始截取\n  let result = []; // 2. 定义结果，结果是二维数组\n  while (i < arr.length) { // 6. 当索引等于或者大于总长度时，即截取完毕\n    // 3. 从原始数组的第一项开始遍历\n    result.push(arr.slice(i, i + 10)); // 4. 在原有十万条数据上，一次截取10个用于分堆\n    i = i + 10; // 5. 这10条数据截取完，再截取下十条数据，以此类推\n  }\n  return result; // 7. 最后把结果丢出去即可\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 创建定时器去依次赋值渲染\n\n比如我们每隔一秒钟去赋值渲染一次\n\n  async plan() {\n      this.loading = true;\n      const res = await axios.get("http://ashuai.work:10000/bigdata");\n      this.loading = false;\n      let twodarr = averagefn(res.data.data);\n      for (let i = 0; i < twodarr.length; i++) {\n        // 相当于在很短的时间内创建许多个定时任务去处理\n        settimeout(() => {\n          this.arr = [...this.arr, ...twodarr[i]]; // 赋值渲染\n        }, 1000 * i); // 17 * i // 注意设定的时间间隔... 17 = 1000 / 60\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这种方式，相当于在很短的时间内创建许多个定时任务去处理，定时任务太多了，也耗费资源啊。\n\n实际上，这种方式就有了大数据量分页的思想\n\n\n# 方案三 使用requestanimationframe替代定时器去做渲染\n\n关于requestanimationframe比定时器的优点，道友们可以看笔者的这篇文章：《性能优化之通俗易懂学习requestanimationframe和使用场景举例》\n\n> 反正大家遇到定时器的时候，就可以考虑一下，是否可以使用请求动画帧进行优化执行渲染？\n\n如果使用请求动画帧的话，就要修改一下代码写法了，前面的不变化，plan方法中的写法变一下即可，注意注释：\n\nasync plan() {\n  this.loading = true;\n  const res = await axios.get("http://ashuai.work:10000/bigdata");\n  this.loading = false;\n  // 1. 将大数据量分堆\n  let twodarr = averagefn(res.data.data);\n  // 2. 定义一个函数，专门用来做赋值渲染（使用二维数组中的每一项）\n  const use2darritem = (page) => {\n    // 4. 从第一项，取到最后一项\n    if (page > twodarr.length - 1) {\n      console.log("每一项都获取完了");\n      return;\n    }\n    // 5. 使用请求动画帧的方式\n    requestanimationframe(() => {\n      // 6. 取出一项，就拼接一项（concat也行）\n      this.arr = [...this.arr, ...twodarr[page]];\n      // 7. 这一项搞定，继续下一项\n      page = page + 1;\n      // 8. 直至完毕（递归调用，注意结束条件）\n      use2darritem(page);\n    });\n  };\n  // 3. 从二维数组中的第一项，第一堆开始获取并渲染（数组的第一项即索引为0）\n  use2darritem(0); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 方案四 搭配分页组件，前端进行分页（每页展示一堆，分堆思想）\n\n这种方式，笔者曾经遇到过，当时的对应场景是数据量也就几十条，后端直接把几十条数据丢给前端，让前端去分页\n\n> 后端不做分页的原因是。他当时临时有事情请假了，所以就前端去做分页了。\n\n * 数据量大的情况下，这种方式，也是一种解决方案\n * 思路也是在所有数据的基础上进行截取\n * 简要代码如下：\n\ngetshowtabledata() { \n    // 获取截取开始索引 \n    let begin = (this.pageindex - 1) * this.pagesize; \n    // 获取截取结束索引\n     let end = this.pageindex * this.pagesize; \n    // 通过索引去截取，从而展示\n    this.showtabledata = this.alltabledata.slice(begin, end); \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n完整案例代码，请看笔者的这篇文章：《后端一次性返回所有的数据，让前端截取展示做分页》\n\n实际上，这种大任务拆分成许多小任务，这种方式，做法，应用的思想就是分片的方式（时间），在别的场景，比如大文件上传的时候，也有这种思想，比如一个500mb的大文件，拆分成50个小文件，一个是10mb这样...至于大文件上传的文章，那就等笔者有空了再写呗...\n\n\n# 方案五 表格滚动触底加载（滚动到底，再加载一堆）\n\n这里重点就是我们需要去判断，何时滚动条触底。判断方式主要有两种\n\n * scrolltop + clientheight >= innerheight\n * 或\n * new mutationobserver()去观测\n\n目前市面上主流的一些插件的原理，大致是这两种。\n\n笔者举例的这是，是使用的插件v-el-table-infinite-scroll，本质上这个插件是一个自定义指令。对应npm地址：www.npmjs.com/package/el-…\n\n当然也有别的插件，如vue-scroller 等：一个意思，不赘述\n\n> 注意，触底加载也是要分堆的，将发请求获取到的十万条数据，进行分好堆，然后每触底一次，就加载一堆即可\n\n\n# 在el-table中使用el-table-infinite-scroll指令步骤\n\n安装，注意版本号（区分vue2和vue3）\n\ncnpm install --save el-table-infinite-scroll@1.0.10\n\n注册使用指令插件\n\n// 使用无限滚动插件\nimport eltableinfinitescroll from \'el-table-infinite-scroll\';\nvue.use(eltableinfinitescroll);\n\n\n1\n2\n3\n\n\n因为是一个自定义指令，所以直接写在el-table标签上即可\n\n<el-table\n  v-el-table-infinite-scroll="load"\n  :data="tabledata"\n>\n  <el-table-column prop="id" label="id"></el-table-column>\n  <el-table-column prop="name" label="名字"></el-table-column>\n</el-table>\n\nasync load() {\n    // 触底加载，展示数据...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 案例代码\n\n为了方便大家演示，这里笔者直接附上一个案例代码，注意看其中的步骤注释即可\n\n<template>\n  <div class="box">\n    <el-table\n      v-el-table-infinite-scroll="load"\n      height="600"\n      :data="tabledata"\n      border\n      style="width: 80%"\n      v-loading="loading"\n      element-loading-text="数据量太大啦，客官稍后..."\n      element-loading-spinner="el-icon-loading"\n      element-loading-background="rgba(255, 255, 255, 0.5)"\n      :header-cell-style="{\n        height: \'24px\',\n        lineheight: \'24px\',\n        color: \'#606266\',\n        background: \'#f5f5f5\',\n        fontweight: \'bold\',\n      }"\n    >\n      <el-table-column type="index" label="序"></el-table-column>\n      <el-table-column prop="id" label="id"></el-table-column>\n      <el-table-column prop="name" label="名字"></el-table-column>\n      <el-table-column prop="value" label="对应值"></el-table-column>\n    </el-table>\n  </div>\n</template>\n\n<script>\n// 分堆函数\nfunction averagefn(arr) {\n  let i = 0;\n  let result = [];\n  while (i < arr.length) {\n    result.push(arr.slice(i, i + 10)); // 一次截取10个用于分堆\n    i = i + 10; // 这10个截取完，再准备截取下10个\n  }\n  return result;\n}\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      alltabledata: [], // 初始发请求获取所有的数据\n      tabledata: [], // 要展示的数据\n      loading: false\n    };\n  },\n  // 第一步，发请求，获取大量数据，并转成二维数组，分堆分组分块存储\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigdata");\n    this.alltabledata = averagefn(res.data.data); // 使用分堆函数，存放二维数组\n    // this.originalalltabledata = this.alltabledata // 也可以存一份原始值，留作备用，都行的\n    this.loading = false;\n    // 第二步，操作完毕以后，执行触底加载方法\n    this.load(); \n  },\n  methods: {\n    // 初始会执行一次，当然也可以配置，使其不执行\n    async load() {\n      console.log("自动多次执行之，首次执行会根据高度去计算要执行几次合适");\n      // 第五步，触底加载相当于把二维数组的每一项取出来用，取完用完时return停止即可\n      if (this.alltabledata.length == 0) {\n        console.log("没数据啦");\n        return;\n      }\n      // 第三步，加载的时候，把二维数组的第一项取出来，拼接到要展示的表格数据中去\n      let arr = this.alltabledata[0];\n      this.tabledata = this.tabledata.concat(arr);\n      // 第四步，拼接展示以后，再把二维数组的第一项的数据删除即可\n      this.alltabledata.shift();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 效果图\n\n\n\n\n# 方案六 使用无限加载/虚拟列表进行展示\n\n\n# 什么是虚拟列表？\n\n * 所谓的虚拟列表实际上是前端障眼法的一种表现形式。\n * 看到的好像所有的数据都渲染了，实际上只渲染可视区域的部分罢了\n * 有点像我们看电影，我们看的话，是在一块电影屏幕上，一秒一秒的看（不停的放映）\n * 但是实际上电影有俩小时，如果把两个小时的电影都铺开的话，那得需要多少块电影屏幕呢？\n * 同理，如果10万条数据都渲染，那得需要多少dom节点元素呢？\n * 所以我们只给用户看，他当下能看到的\n * 如果用户要快进或快退（下拉滚动条或者上拉滚动条）\n * 再把对应的内容呈现在电影屏幕上（呈现在可视区域内）\n * 这样就实现了看着像是所有的dom元素每一条数据都有渲染的障眼法效果了\n\n> 关于前端障眼法，在具体工作中，如果能够巧妙使用，会大大提升我们的开发效率的\n\n\n# 写一个简单的虚拟列表\n\n# 效果图\n\n\n\n这里笔者直接上代码，大家复制粘贴即可使用，笔者写了一些注释，以便于大家理解。当然也可以去笔者的仓库中去瞅瞅哦，github仓库在文末\n\n# 代码\n\n<template>\n  \x3c!-- 虚拟列表容器，类似“窗口”，窗口的高度取决于一次展示几条数据\n            比如窗口只能看到10条数据，一条40像素，10条400像素\n            故，窗口的高度为400像素，注意要开定位和滚动条 --\x3e\n  <div\n    class="virtuallistwrap"\n    ref="virtuallistwrap"\n    @scroll="handlescroll"\n    :style="{ height: itemheight * count + \'px\' }"\n  >\n    \x3c!-- 占位dom元素，其高度为所有的数据的总高度 --\x3e\n    <div\n      class="placeholderdom"\n      :style="{ height: alllistdata.length * itemheight + \'px\' }"\n    ></div>\n    \x3c!-- 内容区，展示10条数据，注意其定位的top值是变化的 --\x3e\n    <div class="contentlist" :style="{ top: topval }">\n      \x3c!-- 每一条（项）数据 --\x3e\n      <div\n        v-for="(item, index) in showlistdata"\n        :key="index"\n        class="itemclass"\n        :style="{ height: itemheight + \'px\' }"\n      >\n        {{ item.name }}\n      </div>\n    </div>\n    \x3c!-- 加载中部分 --\x3e\n    <div class="loadingbox" v-show="loading">\n      <i class="el-icon-loading"></i>\n      &nbsp;&nbsp;<span>loading...</span>\n    </div>\n  </div>\n</template>\n<script>\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      alllistdata: [], // 所有的数据，比如这个数组存放了十万条数据\n      itemheight: 40, // 每一条（项）的高度，比如40像素\n      count: 10, // 一屏展示几条数据\n      start: 0, // 开始位置的索引\n      end: 10, // 结束位置的索引\n      topval: 0, // 父元素滚动条滚动，更改子元素对应top定位的值，确保联动\n      loading: false,\n    };\n  },\n  computed: {\n    // 从所有的数据alllistdata中截取需要展示的数据showlistdata\n    showlistdata: function () {\n      return this.alllistdata.slice(this.start, this.end);\n    },\n  },\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigdata");\n    this.alllistdata = res.data.data;\n    this.loading = false;\n  },\n  methods: {\n    // 滚动这里可以加上节流，减少触发频次\n    handlescroll() {\n      /**\n       * 获取在垂直方向上，滚动条滚动了多少像素距离element.scrolltop\n       *\n       * 滚动的距离除以每一项的高度，即为滚动到了多少项，当然，要取个整数\n       * 例：滚动4米，一步长0.8米，滚动到第几步，4/0.8 = 第5步（取整好计算）\n       *\n       * 又因为我们一次要展示10项，所以知道了起始位置项，再加上结束位置项，\n       * 就能得出区间了【起始位置, 起始位置 + size项数】==【起始位置, 结束位置】\n       * */\n      const scrolltop = this.$refs.virtuallistwrap.scrolltop;\n      this.start = math.floor(scrolltop / this.itemheight);\n      this.end = this.start + this.count;\n      /**\n       * 动态更改定位的top值，确保联动，动态展示相应内容\n       * */\n      this.topval = this.$refs.virtuallistwrap.scrolltop + "px";\n    },\n  },\n};\n<\/script>\n<style scoped lang="less">\n// 虚拟列表容器盒子\n.virtuallistwrap {\n  box-sizing: border-box;\n  width: 240px;\n  border: solid 1px #000000;\n  // 开启滚动条\n  overflow-y: auto;\n  // 开启相对定位\n  position: relative;\n  .contentlist {\n    width: 100%;\n    height: auto;\n    // 搭配使用绝对定位\n    position: absolute;\n    top: 0;\n    left: 0;\n    .itemclass {\n      box-sizing: border-box;\n      width: 100%;\n      height: 40px;\n      line-height: 40px;\n      text-align: center;\n    }\n    // 奇偶行改一个颜色\n    .itemclass:nth-child(even) {\n      background: #c7edcc;\n    }\n    .itemclass:nth-child(odd) {\n      background: pink;\n    }\n  }\n  .loadingbox {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(255, 255, 255, 0.64);\n    color: green;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n\n# 使用vxetable插件实现虚拟列表\n\n如果不是列表，是table表格的话，笔者这里推荐一个好用的ui组件，vxetable，看名字就知道做的是表格相关的业务。其中就包括虚拟列表。\n\nvue2和vue3版本都支持，性能比较好，官方说：虚拟滚动（最大可以支撑 5w 列、30w 行）\n\n强大！\n\n官方网站地址：vxetable.cn/v3/#/table/…\n\n# 效果图\n\n效果很丝滑\n\n\n\n# 安装使用代码\n\n注意安装版本，笔者使用的版本如下：\n\ncnpm i xe-utils vxe-table@3.6.11 --save\n\n\n1\n\n\nmain.js\n\n// 使用vxetable\nimport vxetable from \'vxe-table\'\nimport \'vxe-table/lib/style.css\'\nvue.use(vxetable)\n\n\n1\n2\n3\n4\n\n\n代码方面也很简单，如下：\n\n<template>\n  <div class="box">\n    <vxe-table\n      border\n      show-overflow\n      ref="xtable1"\n      height="300"\n      :row-config="{ ishover: true }"\n      :loading="loading"\n    >\n      <vxe-column type="seq"></vxe-column>\n      <vxe-column field="id" title="id"></vxe-column>\n      <vxe-column field="name" title="名字"></vxe-column>\n      <vxe-column field="value" title="对应值"></vxe-column>\n    </vxe-table>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  data() {\n    return {\n      loading: false,\n    };\n  },\n  async created() {\n    this.loading = true;\n    const res = await axios.get("http://ashuai.work:10000/bigdata");\n    this.loading = false;\n    this.render(res.data.data);\n  },\n  methods: {\n    render(data) {\n      this.$nexttick(() => {\n        const $table = this.$refs.xtable1;\n        $table.loaddata(data);\n      });\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 方案七 开启多线程web worker进行操作\n\n本案例中，使用web worker另外开启一个线程去操作代码逻辑，收益并不是特别大（假如使用虚拟滚动列表插件的情况下）\n\n不过也算是一个拓展的思路吧，面试的时候，倒是可以说一说，提一提。\n\n对web worker不熟悉的道友们，可以看看笔者之前的这篇文章：《性能优化之使用vue-worker插件（基于web worker）开启多线程运算提高效率》\n\n\n# 方案八 未雨绸缪，防患于未然\n\n以下为笔者愚见，仅供参考...\n\n * 在上述解决方案都说完以后，并没有结束。\n * 实际上本题目在考查候选人知识的广度和深度以外，更是考查了候选人的处理问题的思考方式，这一点尤其重要！\n * 笔者曾做过候选人去求职，也曾做过面试官去面试。就程序员开发工作而言，技术知识点不熟悉，可以快速学习，如文档、谷歌、百度、技术交流群，相关同事都可提供一定的支持\n * 更重要的是看中候选人的思考方式，思维模式\n * 试想，两个候选人实力水平差不多，但是一个只知道埋头苦干，有活就干，不去斟酌；而另外一个却是在用心工作的时候，也会仰望星空，会分析如何干活能够高性价比地完成任务，注重过程与结果\n * 这样的话，哪个更加受欢迎一些呢？\n\n如果笔者是候选人，笔者在说了上述7种方案以后，会再补充第八种方案：未雨绸缪，防患于未然\n\n----------------------------------------\n\n\n# 场景模拟\n\n面试官随意打量着其手中我的简历，抚须怪叫一声：“小子，后端要一次性返回10万条数据给你，你如何处理？”\n\n我眉毛一挑，歪嘴一笑：“在上述7种方案陈述完以后，我想类似的问题，我们可以从根本上去解决。即第八种方案，要未雨绸缪，防患于未然。”\n\n“哦？”面试官心中疑惑，缓缓放下我的简历：“愿闻其详。”\n\n我不紧不慢地答道：“在具体开发工作中，我们在接到一个需求时，在技术评审期间，我们就要和后端去商量比较合适的技术解决方案。这个问题是后端要一次性返回我10万条数据，重点并不在10万条这么多数据，而在于后端为什么要这样做？”\n\n面试官抬头，认真听了起来。\n\n我一字一顿地说道：“除去业务真正需要这种方案的话（若是客户要求的，那就没啥好说的，干就完了），后端这样做的原因大致有两种，第一种他不太懂sql的limit语句，但这基本不可能，第二种就是他有事情，随便敷衍写了一下。所以，就是要和他沟通，从大数据量接口请求时长过长，以及过多的dom元素渲染导致性能变差，以及项目的可维护性等角度去沟通，我相信只要正确的沟通，就能从根源上去避免这种不太合理的情况发生。”\n\n面试官又突然狡黠地发问：“要是沟通以后，后端死活不给你分页呢？你咋办？你的沟通无效果！你如何处理！人家不听你的！”似乎是觉得这个问题很刁钻，他双臂抱在胸前，靠在椅背上，等待着我脸上即将绽放的的回答不上来地尴尬笑容。\n\n我内心冷哼一声：雕虫小技...\n\n我盯着面试官的眼睛，认真说道：“如果工作中沟通无效果，要么是我自己沟通语言表达的问题，这一点我会注意，不断提升自己的沟通技巧和说话方式，要么就是...”\n\n我声音扬起了三分：“我沟通的这个人有问题！他工作摸鱼偷懒耍滑！固执己见！为难他人！高高在上！自以为是！这种情况下，我会找到我的直属领导去介入，因为这已经不是项目的需求问题了，而是员工的基本素养问题！”\n\n停顿了一秒，我声音又柔和了几分：“但是，但是我相信咱们公司员工中是绝对没有这样的人存在的，各个都是能力强悍，态度端正的优秀员工。毕竟咱们公司在行业中久负盛名，我也是因此慕名而来的。您说对吧？”\n\n面试官眼中闪过震惊之色，他没有想到我居然把皮球又踢给他了，不过他为了维持形象，旋即恢复了镇定，只是面部肌肉在止不住的微微颤抖。\n\n我又补充道：“实际上在工作中，前端作为比较贴近用户的角色而言，需要和各个岗位的同事进行沟通，比如后端、产品、ui、测试等。我们需要通过合理的沟通方式，去提升工作效率，完成项目，实现自己的价值，为公司创造收益，我想这是每一个员工需要做的，也是必须要做到的。”\n\n面试官又抚须怪叫一声：“小子表现还行，你被录用了！一个月工资2200，自带电脑，无社无金，007工作制，不能偷吃公司零食，以及...”\n\n我：阿哒...\n\n\n# 总结\n\n有效的沟通，源自于解决问题的思维模式，在多数情况下，重要性，大于当下所掌握的技术知识点\n\n * 网站效果演示地址：ashuai.work:8888/#/bigdata\n * github仓库地址：github.com/shuirongshu…\n * 原文地址：什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"虚拟列表，我真的会了！！！",frontmatter:{title:"虚拟列表，我真的会了！！！",date:"2022-02-24T19:29:05.000Z",permalink:"/advanced/6f6d13/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/42.%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%EF%BC%8C%E6%88%91%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81.html",relativePath:"55.更多/02.进阶/42.虚拟列表，我真的会了！！！.md",key:"v-28360899",path:"/advanced/6f6d13/",headers:[{level:2,title:"虚拟列表的使用场景",slug:"虚拟列表的使用场景",normalizedTitle:"虚拟列表的使用场景",charIndex:2},{level:3,title:"1. 传统做法",slug:"_1-传统做法",normalizedTitle:"1. 传统做法",charIndex:159},{level:3,title:"2. 虚拟列表",slug:"_2-虚拟列表",normalizedTitle:"2. 虚拟列表",charIndex:297},{level:2,title:"定高虚拟列表实现步骤",slug:"定高虚拟列表实现步骤",normalizedTitle:"定高虚拟列表实现步骤",charIndex:838},{level:3,title:"计算容器最大容积数量",slug:"计算容器最大容积数量",normalizedTitle:"计算容器最大容积数量",charIndex:1424},{level:3,title:"监听滚动事件动态截取数据&&设置上下滚动缓冲消除快速滚动白屏",slug:"监听滚动事件动态截取数据-设置上下滚动缓冲消除快速滚动白屏",normalizedTitle:"监听滚动事件动态截取数据&amp;&amp;设置上下滚动缓冲消除快速滚动白屏",charIndex:null},{level:3,title:"动态设置上下空白占位",slug:"动态设置上下空白占位",normalizedTitle:"动态设置上下空白占位",charIndex:3940},{level:3,title:"下拉置地自动请求和加载数据",slug:"下拉置地自动请求和加载数据",normalizedTitle:"下拉置地自动请求和加载数据",charIndex:4692},{level:3,title:"滚动事件请求动画帧进行节流优化",slug:"滚动事件请求动画帧进行节流优化",normalizedTitle:"滚动事件请求动画帧进行节流优化",charIndex:5778},{level:2,title:"不定高虚拟列表实现步骤",slug:"不定高虚拟列表实现步骤",normalizedTitle:"不定高虚拟列表实现步骤",charIndex:6696},{level:3,title:"请求到新数据对数据进行初始化（设置预估高度）",slug:"请求到新数据对数据进行初始化-设置预估高度",normalizedTitle:"请求到新数据对数据进行初始化（设置预估高度）",charIndex:7008},{level:3,title:"每次列表更新之后将列表项真实高度更新缓存中的预估高度",slug:"每次列表更新之后将列表项真实高度更新缓存中的预估高度",normalizedTitle:"每次列表更新之后将列表项真实高度更新缓存中的预估高度",charIndex:8808},{level:3,title:"得到可视区域的起始和结束元素索引&&设置上下滚动缓冲区域消除快速滚动白屏",slug:"得到可视区域的起始和结束元素索引-设置上下滚动缓冲区域消除快速滚动白屏",normalizedTitle:"得到可视区域的起始和结束元素索引&amp;&amp;设置上下滚动缓冲区域消除快速滚动白屏",charIndex:null},{level:3,title:"监听滚动事件动态截取数据&&动态设置上下空白占位",slug:"监听滚动事件动态截取数据-动态设置上下空白占位",normalizedTitle:"监听滚动事件动态截取数据&amp;&amp;动态设置上下空白占位",charIndex:null},{level:3,title:"问题思考",slug:"问题思考",normalizedTitle:"问题思考",charIndex:13963}],headersStr:"虚拟列表的使用场景 1. 传统做法 2. 虚拟列表 定高虚拟列表实现步骤 计算容器最大容积数量 监听滚动事件动态截取数据&&设置上下滚动缓冲消除快速滚动白屏 动态设置上下空白占位 下拉置地自动请求和加载数据 滚动事件请求动画帧进行节流优化 不定高虚拟列表实现步骤 请求到新数据对数据进行初始化（设置预估高度） 每次列表更新之后将列表项真实高度更新缓存中的预估高度 得到可视区域的起始和结束元素索引&&设置上下滚动缓冲区域消除快速滚动白屏 监听滚动事件动态截取数据&&动态设置上下空白占位 问题思考",content:"# 虚拟列表的使用场景\n\n如果我想要在网页中放大量的列表项，纯渲染的话，对于浏览器性能将会是个极大的挑战，会造成滚动卡顿，整体体验非常不好，主要有以下问题：\n\n * 页面等待时间极长，用户体验差\n * CPU计算能力不够，滑动会卡顿\n * GPU渲染能力不够，页面会跳屏\n * RAM内存容量不够，浏览器崩溃\n\n\n# 1. 传统做法\n\n对于长列表渲染，传统的方法是使用懒加载的方式，下拉到底部获取新的内容加载进来，其实就相当于是在垂直方向上的分页叠加功能，但随着加载数据越来越多，浏览器的回流和重绘的开销将会越来越大，整个滑动也会造成卡顿，这个时候我们就可以考虑使用虚拟列表来解决问题\n\n\n# 2. 虚拟列表\n\n其核心思想就是在处理用户滚动时，只改变列表在可视区域的渲染部分，具体步骤为：\n\n先计算可见区域起始数据的索引值startIndex和当前可见区域结束数据的索引值endIndex，假如元素的高度是固定的，那么startIndex的算法很简单，即startIndex = Math.floor(scrollTop/itemHeight)，endIndex = startIndex + (clientHeight/itemHeight) - 1，再根据startIndex 和endIndex取相应范围的数据，渲染到可视区域，然后再计算startOffset（上滚动空白区域）和endOffset（下滚动空白区域），这两个偏移量的作用就是来撑开容器元素的内容，从而起到缓冲的作用，使得滚动条保持平滑滚动，并使滚动条处于一个正确的位置\n\n上述的操作可以总结成五步：\n\n * 不把长列表数据一次性全部直接渲染在页面上\n * 截取长列表一部分数据用来填充可视区域\n * 长列表数据不可视部分使用空白占位填充（下图中的startOffset和endOffset区域）\n * 监听滚动事件根据滚动位置动态改变可视列表\n * 监听滚动事件根据滚动位置动态改变空白填充\n\n\n\n\n# 定高虚拟列表实现步骤\n\n> 掘金使用的是传统懒加载的方式加载的哈，用的并不是虚拟列表，这里只是想表达一下什么是定高的列表！\n\n\n\n实现的效果应该是：不论怎么滚动，我们改变的只是滚动条的高度和可视区的元素内容，并没有增加任何多余的元素，下面来看看要怎么实现吧！\n\n// 虚拟列表DOM结构\n<div className='container'>\n  // 监听滚动事件的盒子，该高度继承了父元素的高度\n  <div className='scroll-box' ref={containerRef} onScroll={boxScroll}>\n    // 该盒子的高度一定会超过父元素，要不实现不了滚动的效果，而且还要动态的改变它的padding值用于控制滚动条的状态\n    <div style={topBlankFill.current}>\n      {\n      showList.map(item => <div className='item' key={item.commentId || (Math.random() + item.comments)}>{item.content}</div>)\n      }\n    </div>\n  </div>\n</div>\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 计算容器最大容积数量\n\n简单来说，就是我们必须要知道在可视区域内最多能够容纳多少个列表项，这是我们在截取内容数据渲染到页面之前关键的步骤之一\n\n // 滚动容器高度改变后执行的函数\nconst changeHeight = useCallback(throttle(() => {\n  // 容器高度，通过操作dom元素获取高度是因为它不一定是个定值\n  curContainerHeight.current = containerRef.current.offsetHeight\n  // 列表最大数量，考虑到列表中顶部和底部可能都会出现没有展现完的item\n  curViewNum.current = Math.ceil(curContainerHeight.current / itemHeight) + 1\n}, 500), [])\n\nuseEffect(() => {\n  // 组件第一次挂载需要初始化容器的高度以及最大容纳值\n  changeHeight()\n  // 因为我们的可视窗口和浏览器大小有关系，所以我们需要监听浏览器大小的变化\n  // 当浏览器大小改变之后需要重新执行changeHeight函数计算当前可视窗口对应的最大容纳量是多少\n  window.addEventListener('resize', changeHeight)\n  return () => {\n    window.removeEventListener('resize', changeHeight)\n  }\n}, [changeHeight])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 监听滚动事件动态截取数据&&设置上下滚动缓冲消除快速滚动白屏\n\n这是虚拟列表的核心之处，不将所有我们请求到的元素渲染出来，而是只渲染我们能够看到的元素，大大减少了容器内的dom节点数量。\n\n不过有个隐藏的问题我们需要考虑到，当用户滑动过快的时候，很多用户的设备性能并不是很好，很容易出现屏幕已经滚动过去了，但是列表项还没有及时加载出来的情况，这个时候用户就会看到短暂的白屏，对用户的体验非常不好。所以我们需要设置一段缓冲区域，让用户过快的滚动之后还能看到我们提前渲染好的数据，等到缓冲数据滚动完了，我们新的数据也渲染到页面中去了！\n\nconst scrollHandle = () => {\n  // 注意这个对应的是可视区第一个元素的索引值，而不是第多少个元素\n  let startIndex = Math.floor(containerRef.current.scrollTop / itemHeight) // itemHeight是列表每一项的高度\n  // 优化：如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑\n  if (!isNeedLoad && lastStartIndex.current === startIndex) return\n  isNeedLoad.current = false\n  lastStartIndex.current = startIndex\n  const containerMaxSize = curViewNum.current\n  /**\n   * 解决滑动过快出现的白屏问题：注意endIndex要在startIndex人为改变之前就计算好\n   * 因为我们实际上需要三板的数据用于兼容低性能的设备，用做上下滚动的缓冲区域，避免滑动的时候出现白屏\n   * 现在的startIndex是可视区的第一个元素索引，再加上2倍可视区元素量，刚好在下方就会多出一板来当做缓冲区\n   */\n  // 此处的endIndex是为了在可视区域的下方多出一板数据\n  let endIndex = startIndex + 2 * containerMaxSize - 1\n  // 接近滚动到屏幕底部的时候，就可以请求发送数据了，这个时候触底的并不是可视区的最后一个元素，而是多出那一版的最后一个元素触底了\n  const currLen = dataListRef.current.length\n  if (endIndex > currLen - 1) {\n    // 更新请求参数，发送请求获取新的数据(但是要保证当前不在请求过程中，否则就会重复请求相同的数据)\n    !isRequestRef.current && setOptions(state => ({ offset: state.offset + 1 }))\n    // 如果已经滚动到了底部，那么就设置endIndex为最后一个元素索引即可\n    endIndex = currLen - 1\n  }\n  // 此处的endIndex是为了在可视区域的上方多出一板数据\n  // 这里人为的调整startIndex的值，目的就是为了能够在可视区域上方多出一板来当做缓冲区\n  if (startIndex <= containerMaxSize) { // containerMaxSize是我们之前计算出来的容器容纳量\n    startIndex = 0\n  } else {\n    startIndex = startIndex - containerMaxSize\n  }\n  // 使用slice方法截取数据，但是要记住第二个参数对应的索引元素不会被删除，最多只能删除到它的前一个，所以我们这里的endIndex需要加一\n  setShowList(dataListRef.current.slice(startIndex, endIndex + 1))\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 动态设置上下空白占位\n\n这是虚拟列表的灵魂所在，本质上我们数据量是很少的，一般来说只有几条到十几条数据，如果不对列表做一些附加的操作，连生成滚动条都有点困难，更别说让用户自由操控滚动条滚动了。\n\n我们必须要用某种方法将内容区域撑起来，这样才会出现比较合适的滚动条。我这里采取的方法就是设置paddingTop和paddingBottom的值来动态的撑开内容区域。\n\n为什么要动态的改变呢？举个例子，我们向下滑动的时候会更换页面中要展示的数据列表，如果不改变原先的空白填充区域，那么随着滚动条的滚动，原先展示在可视区的第一条数据就会向上移动，虽然我们更新的数据是正确的，但并没有将它们展示在合适的位置。完美的方案是是不仅要展示正确的数据，而且还要改变空白填充区域高度，使得数据能够正确的展示在浏览器视口当中。\n\n// 以下代码要放在更新列表数据之前，也是在滚动事件boxScroll当中\n// 改变空白填充区域的样式，否则就会出现可视区域的元素与滚动条不匹配的情况，实现不了平滑滚动的效果\ntopBlankFill.current = {\n  // 起始索引就是缓冲区第一个元素的索引，索引为多少就代表前面有多少个元素\n  paddingTop: `${startIndex * itemHeight}px`,\n  // endIndex是缓冲区的最后一个元素，可能不在可视区内；用dataListRef数组最后一个元素的索引与endIndex相减就可以得到还没有渲染元素的数目\n  paddingBottom: `${(dataListRef.current.length - 1 - endIndex) * itemHeight}px`\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 下拉置地自动请求和加载数据\n\n在真实的开发场景中，我们不会一次性请求1w、10w条数据过来，这样请求时间那么长，用户早就把页面关掉了，还优化个屁啊哈哈！\n\n所以真实开发中，我们还是要结合原来的懒加载方式，等到下拉触底的时候去加载新的数据进来，放置到缓存数据当中，然后我们再根据滚动事件决定具体渲染哪一部分的数据到页面上去。\n\n// 组件刚挂载以及下拉触底的时候请求更多数据\nuseEffect(() => {\n  (async () => {\n    try {\n      // 表明当前正处于请求过程中\n      isRequestRef.current = true\n      const { offset } = options\n      let limit = 20\n      if (offset === 1) limit = 40\n      const { data: { comments, more } } = await axios({\n        url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`\n      })\n      isNeedLoad.current = more\n      // 将新请求到的数据添加到存储列表数据的变量当中\n      dataListRef.current = [...dataListRef.current, ...comments]\n      // 必选要在boxScroll之前将isRequestRef设为false，因为boxScroll函数内部会用到这个变量\n      isRequestRef.current = false\n      // 请求完最新数据的时候需要重新触发一下boxScroll函数，因为容器内的数据、空白填充区域可能需要变化\n      boxScroll()\n    } catch (err) {\n      isRequestRef.current = false\n      console.log(err);\n    }\n  })()\n  // 在boxScroll函数里面，一旦发生了触底操作就会去改变optiosn的值\n}, [options])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 滚动事件请求动画帧进行节流优化\n\n虚拟列表很依赖于滚动事件，考虑到用户可能会滑动很快，我们在用节流优化的时候事件必须要设置的够短，否则还是会出现白屏现象。\n\n这里我没有用传统的节流函数，而是用到了请求动画帧帮助我们进行节流，这里我就不做具体介绍了，想了解的可以看我另一篇文章juejin.cn/post/708236…juejin.cn/post/684490…\n\n// 利用请求动画帧做了一个节流优化\nlet then = useRef(0)\nconst boxScroll = () => {\n  const now = Date.now()\n  /**\n   * 这里的等待时间不宜设置过长，不然会出现滑动到空白占位区域的情况\n   * 因为间隔时间过长的话，太久没有触发滚动更新事件，下滑就会到padding-bottom的空白区域\n   * 电脑屏幕的刷新频率一般是60HZ，渲染的间隔时间为16.6ms，我们的时间间隔最好小于两次渲染间隔16.6*2=33.2ms，一般情况下30ms左右，\n   */\n  if (now - then.current > 30) {\n    then.current = now\n    // 重复调用scrollHandle函数，让浏览器在下一次重绘之前执行函数，可以确保不会出现丢帧现象\n    window.requestAnimationFrame(scrollHandle)\n  }\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n当然，填充空白区域、模拟滚动条还有其它的办法，比如根据总数据量让一个盒子撑开父盒子用于生成滚动条，根据startIndex计算出可视区域距离顶部的距离并调节内容区域元素的transform属性，即startOffset = scrollTop - (scrollTop % this.itemSize)，让内容区域一直暴露在可视区域内\n\n目前为止，我们已经实现了固定高度的列表项用虚拟列表来展示的功能！接下里我们将会介绍关于不定高（其高度由内容进行撑开）的列表项如何用虚拟列表进行优化\n\n\n# 不定高虚拟列表实现步骤\n\n> 微博是一个很典型的不定高虚拟列表，大家感兴趣的话可以去看一下哦！\n\n\n\n在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的就能获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本、图片之类的可变内容，会导致列表项的高度并不相同。\n\n我们在列表渲染之前，确实没有办法知道每一项的高度，但是又必须要渲染出来，那怎么办呢？\n\n这里有一个解决方法，就是先给没有渲染出来的列表项设置一个预估高度，等到这些数据渲染成真实dom元素了之后，再获取到他们的真实高度去更新原来设置的预估高度，下面我们来看看跟定高列表有什么不同，具体要怎么实现吧！\n\n\n# 请求到新数据对数据进行初始化（设置预估高度）\n\n预估高度的设置其实是有技巧的，列表项预估高度设置的越大，展现出来的数据就会越少，所以当预估高度比实际高度大很多的时候，很容易出现可视区域数据量太少而引起的可视区域出现部分空白。为了避免这种情况，我们的预估高度应该设置为列表项产生的最小值，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白\n\n// 请求更多的数据\nuseEffect(() => {\n  (async () => {\n    // 只有当前不在请求状态的时候才可以发送新的请求\n    if (!isRequestRef.current) {\n      console.log('发送请求了');\n      try {\n        isRequestRef.current = true\n        const { offset } = options\n        let limit = 20\n        if (offset === 1) limit = 40\n        const { data: { comments, more } } = await axios({\n          url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`\n        })\n        isNeedLoad.current = more\n        // 获取缓存中最后一个数据的索引值，如果没有，则返回-1\n        const lastIndex = dataListRef.current.length ? dataListRef.current[dataListRef.current.length - 1].index : -1\n        // 先将请求到的数据添加到缓存数组中去\n        dataListRef.current = [...dataListRef.current, ...comments]\n        const dataList = dataListRef.current\n        // 将刚刚请求到的新数据做一下处理，为他们添加上对应的索引值、预估高度、以及元素首尾距离容器顶部的距离\n        for (let i = lastIndex + 1, len = dataListRef.current.length; i < len; i++) {\n          dataList[i].index = i\n          // 预估高度是列表项对应的最小高度\n          dataList[i].height = 63\n          // 每一个列表项头部距离容器顶部的距离等于上一个元素尾部距离容器顶部的距离\n          dataList[i].top = dataList[i - 1]?.bottom || 0\n          // 每一个列表项尾部距离容器顶部的距离等于上一个元素头部距离容器顶部的距离加上自身列表项的高度\n          dataList[i].bottom = dataList[i].top + dataList[i].height\n        }\n        isRequestRef.current = false\n        boxScroll()\n      } catch (err) {\n        console.log(err);\n      } finally {\n        isRequestRef.current = false\n      }\n    }\n  })()\n  // eslint-disable-next-line\n}, [options])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 每次列表更新之后将列表项真实高度更新缓存中的预估高度\n\n在React函数式组件中，useEffect只要不传第二个参数，就可以实现类组件componentDidUpdate生命周期函数的作用，只要我们重新渲染一次列表组件，就会重新计算一下当前列表每一项中的真实高度并更新到缓存中去，当下次我们再用到缓存中的这些数据时，使用的就是真实高度了\n\n// 每次组件重新渲染即用户滚动更改了数据之后需要将列表中我们还不知道的列表项高度更新到我们的缓存数据中去，以便下一次更新的时候能够正常渲染\nuseEffect(() => { \n  const doms = containerRef.current.children[0].children\n  const len = doms.length\n  // 因为一开始我们没有请求数据，所以即使组件渲染完了，但是没有列表项，此时不需要执行后续操作\n  if (len) {\n    // 遍历所有的列表结点，根据结点的真实高度去更改缓存中的高度\n    for (let i = 0; i < len; i++) {\n      const realHeight = doms[i].offsetHeight\n      const originHeight = showList[i].height\n      const dValue = realHeight - originHeight\n      // 如果列表项的真实高度就是缓存中的高度，则不需要进行更新\n      if (dValue) {\n        const index = showList[i].index\n        const allData = dataListRef.current\n        /**\n           * 如果列表项的真实高度不是缓存中的高度，那么不仅要更新缓存中这一项的bottom和height属性\n           * 在该列表项后续的所有列表项的top、bottom都会受到它的影响，所以我们又需要一层for循环进行更改缓存中后续的值\n           */\n        allData[index].bottom += dValue\n        allData[index].height = realHeight\n        /**\n           * 注意：这里更改的一定要是缓存数组中对应位置后续的所有值，如果只改变的是showList值的话\n           * 会造成dataList间断性的bottom和下一个top不连续，因为startIndex、endIndex以及空白填充区域都是依据top和bottom值来进行计算的\n           * 所以会导致最后计算的结果出错，滑动得来的startIndex变化幅度大且滚动条不稳定，出现明显抖动问题\n           */\n        for (let j = index + 1, len = allData.length; j < len; j++) {\n          allData[j].top = allData[j - 1].bottom\n          allData[j].bottom += dValue\n        }\n      }\n    }\n  }\n  // eslint-disable-next-line\n})\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 得到可视区域的起始和结束元素索引&&设置上下滚动缓冲区域消除快速滚动白屏\n\n列表项的bottom属性代表的就是该元素尾部到容器顶部的距离，不难发现，可视区的第一个元素的bottom是第一个大于滚动高度的；可视区最后一个元素的bottom是第一个大于（滚动高度+可视高度）的。我们可以利用这条规则遍历缓存数组找到对应的startIndex和endIndex\n\n由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数，减少时间复杂度\n\n// 得到要渲染数据的起始索引和结束索引\nconst getIndex = () => {\n  // 设置缓冲区域的数据量\n  const aboveCount = 5\n  const belowCount = 5\n  // 结果数组，里面包含了起始索引和结束索引\n  const resObj = {\n    startIndex: 0,\n    endIndex: 0,\n  }\n  const scrollTop = containerRef.current.scrollTop\n  const dataList = dataListRef.current\n  const len = dataList.length\n  // 设置上层缓冲区，如果索引值大于缓冲区域，那么就需要减小startIndex的值用于设置顶层缓冲区\n  const startIndex = binarySearch(scrollTop)\n  if (startIndex <= aboveCount) {\n    resObj.startIndex = 0\n  } else {\n    resObj.startIndex = startIndex - aboveCount\n  }\n  /**\n     * 缓冲数据中第一个bottom大于滚动高度加上可视区域高度的元素就是可视区域最后一个元素\n     * 如果没有找到的话就说明当前滚动的幅度过大，缓存中没有数据的bottom大于我们的目标值，所以搜索不到对应的索引，我们只能拿缓存数据中的最后一个元素补充上\n     */\n  const endIndex = binarySearch(scrollTop + curContainerHeight.current) || len - 1\n  // 增大endIndex的索引值用于为滚动区域下方设置一段缓冲区，避免快速滚动所导致的白屏问题\n  resObj.endIndex = endIndex + belowCount\n  return resObj\n}\n\n// 由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数：\nconst binarySearch = (value) => {\n  const list = dataListRef.current\n  let start = 0;\n  let end = list.length - 1;\n  let tempIndex = null;\n  while (start <= end) {\n    let midIndex = parseInt((start + end) / 2);\n    let midValue = list[midIndex].bottom;\n    if (midValue === value) {\n      // 说明当前滚动区域加上可视区域刚好是一个结点的边界，那么我们可以以其下一个结点作为末尾元素\n      return midIndex + 1;\n    } else if (midValue < value) {\n      // 由于当前值与目标值还有一定的差距，所以我们需要增加start值以让下次中点的落点更靠后\n      start = midIndex + 1;\n    } else if (midValue > value) {\n      // 因为我们的目的并不是找到第一个满足条件的值，而是要找到满足条件的最小索引值\n      if (tempIndex === null || tempIndex > midIndex) {\n        tempIndex = midIndex;\n      }\n      // 由于我们要继续找更小的索引，所以需要让end-1以缩小范围，让下次中点的落点更靠前\n      end--\n    }\n  }\n  return tempIndex;\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 监听滚动事件动态截取数据&&动态设置上下空白占位\n\n动态截取数据的操作和定高的虚拟列表几乎一样，区别比较大的地方就在padding值的计算方式上。在定高的列表中，我们可以根据起始索引值和结尾索引值直接计算出空白填充区域的高度。\n\n其实在不定高的列表中，计算方式更加简单，因为startIndex对应元素的top值就是我们需要填充的上空白区域，下空白区域也可以根据整个列表的高度（最后一个元素的bottom值）和endIndex对应元素的bottom值之差得出\n\nconst scrollHandle = () => {\n  // 获取当前要渲染元素的起始索引和结束索引值\n  let { startIndex, endIndex } = getIndex()\n  /**\n     * 如果是用户滚动触发的，而且两次startIndex的值都一样，那么就没有必要执行下面的逻辑，\n     * 除非是用户重新请求了之后需要默认执行一次该函数，这是一种特殊情况，就是startIndex没变，但需要执行后续的操作\n     */\n  if (!isNeedLoad && lastStartIndex.current === startIndex) return\n  // 渲染完一次之后就需要初始化isNeedLoad\n  isNeedLoad.current = false\n  // 用于实时监控lastStartIndex的值\n  lastStartIndex.current = startIndex\n  // 下层缓冲区域最后的元素接触到屏幕底部的时候，就可以请求发送数据了\n  const currLen = dataListRef.current.length\n  if (endIndex >= currLen - 1) {\n    // 当前不在请求状态下时才可以改变请求参数发送获取更多数据的请求\n    !isRequestRef.current && setOptions(state => ({ offset: state.offset + 1 }))\n    // 注意endIndex不可以大于缓存中最后一个元素的索引值\n    endIndex = currLen - 1\n  }\n  // 空白填充区域的样式\n  topBlankFill.current = {\n    // 改变空白填充区域的样式，起始元素的top值就代表起始元素距顶部的距离，可以用来充当paddingTop值\n    paddingTop: `${dataListRef.current[startIndex].top}px`,\n    // 缓存中最后一个元素的bottom值与endIndex对应元素的bottom值的差值可以用来充当paddingBottom的值\n    paddingBottom: `${dataListRef.current[dataListRef.current.length - 1].bottom - dataListRef.current[endIndex].bottom}px`\n  }\n  setShowList(dataListRef.current.slice(startIndex, endIndex + 1))\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 问题思考\n\n我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开。在这种场景下，由于图片会发送网络请求，列表项可能已经渲染到页面中了，但是图片还没有加载出来，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，获取到的高度有无包含图片高度，从而造成计算不准确的情况。\n\n但是这种任意由图片来撑开盒子大小的场景很少见，因为这样会显得整个列表很不规则。大多数展示图片的列表场景，其实都是提前确定要展示图片的尺寸的，比如微博，1张图片的尺寸是多少，2x2，3x3的尺寸是多少都是提前设计好的，只要我们给img标签加了固定高度，这样就算图片还没有加载出来，但是我们也能够准确的知道列表项的高度是多少。\n\n如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定onload事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次，还可以使用ResizeObserver来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度，只不过MDN有说道这只是在实验中的一个功能，所以暂时可能没有办法兼容所有的浏览器！",normalizedContent:"# 虚拟列表的使用场景\n\n如果我想要在网页中放大量的列表项，纯渲染的话，对于浏览器性能将会是个极大的挑战，会造成滚动卡顿，整体体验非常不好，主要有以下问题：\n\n * 页面等待时间极长，用户体验差\n * cpu计算能力不够，滑动会卡顿\n * gpu渲染能力不够，页面会跳屏\n * ram内存容量不够，浏览器崩溃\n\n\n# 1. 传统做法\n\n对于长列表渲染，传统的方法是使用懒加载的方式，下拉到底部获取新的内容加载进来，其实就相当于是在垂直方向上的分页叠加功能，但随着加载数据越来越多，浏览器的回流和重绘的开销将会越来越大，整个滑动也会造成卡顿，这个时候我们就可以考虑使用虚拟列表来解决问题\n\n\n# 2. 虚拟列表\n\n其核心思想就是在处理用户滚动时，只改变列表在可视区域的渲染部分，具体步骤为：\n\n先计算可见区域起始数据的索引值startindex和当前可见区域结束数据的索引值endindex，假如元素的高度是固定的，那么startindex的算法很简单，即startindex = math.floor(scrolltop/itemheight)，endindex = startindex + (clientheight/itemheight) - 1，再根据startindex 和endindex取相应范围的数据，渲染到可视区域，然后再计算startoffset（上滚动空白区域）和endoffset（下滚动空白区域），这两个偏移量的作用就是来撑开容器元素的内容，从而起到缓冲的作用，使得滚动条保持平滑滚动，并使滚动条处于一个正确的位置\n\n上述的操作可以总结成五步：\n\n * 不把长列表数据一次性全部直接渲染在页面上\n * 截取长列表一部分数据用来填充可视区域\n * 长列表数据不可视部分使用空白占位填充（下图中的startoffset和endoffset区域）\n * 监听滚动事件根据滚动位置动态改变可视列表\n * 监听滚动事件根据滚动位置动态改变空白填充\n\n\n\n\n# 定高虚拟列表实现步骤\n\n> 掘金使用的是传统懒加载的方式加载的哈，用的并不是虚拟列表，这里只是想表达一下什么是定高的列表！\n\n\n\n实现的效果应该是：不论怎么滚动，我们改变的只是滚动条的高度和可视区的元素内容，并没有增加任何多余的元素，下面来看看要怎么实现吧！\n\n// 虚拟列表dom结构\n<div classname='container'>\n  // 监听滚动事件的盒子，该高度继承了父元素的高度\n  <div classname='scroll-box' ref={containerref} onscroll={boxscroll}>\n    // 该盒子的高度一定会超过父元素，要不实现不了滚动的效果，而且还要动态的改变它的padding值用于控制滚动条的状态\n    <div style={topblankfill.current}>\n      {\n      showlist.map(item => <div classname='item' key={item.commentid || (math.random() + item.comments)}>{item.content}</div>)\n      }\n    </div>\n  </div>\n</div>\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 计算容器最大容积数量\n\n简单来说，就是我们必须要知道在可视区域内最多能够容纳多少个列表项，这是我们在截取内容数据渲染到页面之前关键的步骤之一\n\n // 滚动容器高度改变后执行的函数\nconst changeheight = usecallback(throttle(() => {\n  // 容器高度，通过操作dom元素获取高度是因为它不一定是个定值\n  curcontainerheight.current = containerref.current.offsetheight\n  // 列表最大数量，考虑到列表中顶部和底部可能都会出现没有展现完的item\n  curviewnum.current = math.ceil(curcontainerheight.current / itemheight) + 1\n}, 500), [])\n\nuseeffect(() => {\n  // 组件第一次挂载需要初始化容器的高度以及最大容纳值\n  changeheight()\n  // 因为我们的可视窗口和浏览器大小有关系，所以我们需要监听浏览器大小的变化\n  // 当浏览器大小改变之后需要重新执行changeheight函数计算当前可视窗口对应的最大容纳量是多少\n  window.addeventlistener('resize', changeheight)\n  return () => {\n    window.removeeventlistener('resize', changeheight)\n  }\n}, [changeheight])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 监听滚动事件动态截取数据&&设置上下滚动缓冲消除快速滚动白屏\n\n这是虚拟列表的核心之处，不将所有我们请求到的元素渲染出来，而是只渲染我们能够看到的元素，大大减少了容器内的dom节点数量。\n\n不过有个隐藏的问题我们需要考虑到，当用户滑动过快的时候，很多用户的设备性能并不是很好，很容易出现屏幕已经滚动过去了，但是列表项还没有及时加载出来的情况，这个时候用户就会看到短暂的白屏，对用户的体验非常不好。所以我们需要设置一段缓冲区域，让用户过快的滚动之后还能看到我们提前渲染好的数据，等到缓冲数据滚动完了，我们新的数据也渲染到页面中去了！\n\nconst scrollhandle = () => {\n  // 注意这个对应的是可视区第一个元素的索引值，而不是第多少个元素\n  let startindex = math.floor(containerref.current.scrolltop / itemheight) // itemheight是列表每一项的高度\n  // 优化：如果是用户滚动触发的，而且两次startindex的值都一样，那么就没有必要执行下面的逻辑\n  if (!isneedload && laststartindex.current === startindex) return\n  isneedload.current = false\n  laststartindex.current = startindex\n  const containermaxsize = curviewnum.current\n  /**\n   * 解决滑动过快出现的白屏问题：注意endindex要在startindex人为改变之前就计算好\n   * 因为我们实际上需要三板的数据用于兼容低性能的设备，用做上下滚动的缓冲区域，避免滑动的时候出现白屏\n   * 现在的startindex是可视区的第一个元素索引，再加上2倍可视区元素量，刚好在下方就会多出一板来当做缓冲区\n   */\n  // 此处的endindex是为了在可视区域的下方多出一板数据\n  let endindex = startindex + 2 * containermaxsize - 1\n  // 接近滚动到屏幕底部的时候，就可以请求发送数据了，这个时候触底的并不是可视区的最后一个元素，而是多出那一版的最后一个元素触底了\n  const currlen = datalistref.current.length\n  if (endindex > currlen - 1) {\n    // 更新请求参数，发送请求获取新的数据(但是要保证当前不在请求过程中，否则就会重复请求相同的数据)\n    !isrequestref.current && setoptions(state => ({ offset: state.offset + 1 }))\n    // 如果已经滚动到了底部，那么就设置endindex为最后一个元素索引即可\n    endindex = currlen - 1\n  }\n  // 此处的endindex是为了在可视区域的上方多出一板数据\n  // 这里人为的调整startindex的值，目的就是为了能够在可视区域上方多出一板来当做缓冲区\n  if (startindex <= containermaxsize) { // containermaxsize是我们之前计算出来的容器容纳量\n    startindex = 0\n  } else {\n    startindex = startindex - containermaxsize\n  }\n  // 使用slice方法截取数据，但是要记住第二个参数对应的索引元素不会被删除，最多只能删除到它的前一个，所以我们这里的endindex需要加一\n  setshowlist(datalistref.current.slice(startindex, endindex + 1))\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 动态设置上下空白占位\n\n这是虚拟列表的灵魂所在，本质上我们数据量是很少的，一般来说只有几条到十几条数据，如果不对列表做一些附加的操作，连生成滚动条都有点困难，更别说让用户自由操控滚动条滚动了。\n\n我们必须要用某种方法将内容区域撑起来，这样才会出现比较合适的滚动条。我这里采取的方法就是设置paddingtop和paddingbottom的值来动态的撑开内容区域。\n\n为什么要动态的改变呢？举个例子，我们向下滑动的时候会更换页面中要展示的数据列表，如果不改变原先的空白填充区域，那么随着滚动条的滚动，原先展示在可视区的第一条数据就会向上移动，虽然我们更新的数据是正确的，但并没有将它们展示在合适的位置。完美的方案是是不仅要展示正确的数据，而且还要改变空白填充区域高度，使得数据能够正确的展示在浏览器视口当中。\n\n// 以下代码要放在更新列表数据之前，也是在滚动事件boxscroll当中\n// 改变空白填充区域的样式，否则就会出现可视区域的元素与滚动条不匹配的情况，实现不了平滑滚动的效果\ntopblankfill.current = {\n  // 起始索引就是缓冲区第一个元素的索引，索引为多少就代表前面有多少个元素\n  paddingtop: `${startindex * itemheight}px`,\n  // endindex是缓冲区的最后一个元素，可能不在可视区内；用datalistref数组最后一个元素的索引与endindex相减就可以得到还没有渲染元素的数目\n  paddingbottom: `${(datalistref.current.length - 1 - endindex) * itemheight}px`\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 下拉置地自动请求和加载数据\n\n在真实的开发场景中，我们不会一次性请求1w、10w条数据过来，这样请求时间那么长，用户早就把页面关掉了，还优化个屁啊哈哈！\n\n所以真实开发中，我们还是要结合原来的懒加载方式，等到下拉触底的时候去加载新的数据进来，放置到缓存数据当中，然后我们再根据滚动事件决定具体渲染哪一部分的数据到页面上去。\n\n// 组件刚挂载以及下拉触底的时候请求更多数据\nuseeffect(() => {\n  (async () => {\n    try {\n      // 表明当前正处于请求过程中\n      isrequestref.current = true\n      const { offset } = options\n      let limit = 20\n      if (offset === 1) limit = 40\n      const { data: { comments, more } } = await axios({\n        url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`\n      })\n      isneedload.current = more\n      // 将新请求到的数据添加到存储列表数据的变量当中\n      datalistref.current = [...datalistref.current, ...comments]\n      // 必选要在boxscroll之前将isrequestref设为false，因为boxscroll函数内部会用到这个变量\n      isrequestref.current = false\n      // 请求完最新数据的时候需要重新触发一下boxscroll函数，因为容器内的数据、空白填充区域可能需要变化\n      boxscroll()\n    } catch (err) {\n      isrequestref.current = false\n      console.log(err);\n    }\n  })()\n  // 在boxscroll函数里面，一旦发生了触底操作就会去改变optiosn的值\n}, [options])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 滚动事件请求动画帧进行节流优化\n\n虚拟列表很依赖于滚动事件，考虑到用户可能会滑动很快，我们在用节流优化的时候事件必须要设置的够短，否则还是会出现白屏现象。\n\n这里我没有用传统的节流函数，而是用到了请求动画帧帮助我们进行节流，这里我就不做具体介绍了，想了解的可以看我另一篇文章juejin.cn/post/708236…juejin.cn/post/684490…\n\n// 利用请求动画帧做了一个节流优化\nlet then = useref(0)\nconst boxscroll = () => {\n  const now = date.now()\n  /**\n   * 这里的等待时间不宜设置过长，不然会出现滑动到空白占位区域的情况\n   * 因为间隔时间过长的话，太久没有触发滚动更新事件，下滑就会到padding-bottom的空白区域\n   * 电脑屏幕的刷新频率一般是60hz，渲染的间隔时间为16.6ms，我们的时间间隔最好小于两次渲染间隔16.6*2=33.2ms，一般情况下30ms左右，\n   */\n  if (now - then.current > 30) {\n    then.current = now\n    // 重复调用scrollhandle函数，让浏览器在下一次重绘之前执行函数，可以确保不会出现丢帧现象\n    window.requestanimationframe(scrollhandle)\n  }\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n当然，填充空白区域、模拟滚动条还有其它的办法，比如根据总数据量让一个盒子撑开父盒子用于生成滚动条，根据startindex计算出可视区域距离顶部的距离并调节内容区域元素的transform属性，即startoffset = scrolltop - (scrolltop % this.itemsize)，让内容区域一直暴露在可视区域内\n\n目前为止，我们已经实现了固定高度的列表项用虚拟列表来展示的功能！接下里我们将会介绍关于不定高（其高度由内容进行撑开）的列表项如何用虚拟列表进行优化\n\n\n# 不定高虚拟列表实现步骤\n\n> 微博是一个很典型的不定高虚拟列表，大家感兴趣的话可以去看一下哦！\n\n\n\n在之前的实现中，列表项的高度是固定的，因为高度固定，所以可以很轻易的就能获取列表项的整体高度以及滚动时的显示数据与对应的偏移量。而实际应用的时候，当列表中包含文本、图片之类的可变内容，会导致列表项的高度并不相同。\n\n我们在列表渲染之前，确实没有办法知道每一项的高度，但是又必须要渲染出来，那怎么办呢？\n\n这里有一个解决方法，就是先给没有渲染出来的列表项设置一个预估高度，等到这些数据渲染成真实dom元素了之后，再获取到他们的真实高度去更新原来设置的预估高度，下面我们来看看跟定高列表有什么不同，具体要怎么实现吧！\n\n\n# 请求到新数据对数据进行初始化（设置预估高度）\n\n预估高度的设置其实是有技巧的，列表项预估高度设置的越大，展现出来的数据就会越少，所以当预估高度比实际高度大很多的时候，很容易出现可视区域数据量太少而引起的可视区域出现部分空白。为了避免这种情况，我们的预估高度应该设置为列表项产生的最小值，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白\n\n// 请求更多的数据\nuseeffect(() => {\n  (async () => {\n    // 只有当前不在请求状态的时候才可以发送新的请求\n    if (!isrequestref.current) {\n      console.log('发送请求了');\n      try {\n        isrequestref.current = true\n        const { offset } = options\n        let limit = 20\n        if (offset === 1) limit = 40\n        const { data: { comments, more } } = await axios({\n          url: `http://localhost:3000/comment/music?id=${186015 - offset}&limit=${limit}&offset=1`\n        })\n        isneedload.current = more\n        // 获取缓存中最后一个数据的索引值，如果没有，则返回-1\n        const lastindex = datalistref.current.length ? datalistref.current[datalistref.current.length - 1].index : -1\n        // 先将请求到的数据添加到缓存数组中去\n        datalistref.current = [...datalistref.current, ...comments]\n        const datalist = datalistref.current\n        // 将刚刚请求到的新数据做一下处理，为他们添加上对应的索引值、预估高度、以及元素首尾距离容器顶部的距离\n        for (let i = lastindex + 1, len = datalistref.current.length; i < len; i++) {\n          datalist[i].index = i\n          // 预估高度是列表项对应的最小高度\n          datalist[i].height = 63\n          // 每一个列表项头部距离容器顶部的距离等于上一个元素尾部距离容器顶部的距离\n          datalist[i].top = datalist[i - 1]?.bottom || 0\n          // 每一个列表项尾部距离容器顶部的距离等于上一个元素头部距离容器顶部的距离加上自身列表项的高度\n          datalist[i].bottom = datalist[i].top + datalist[i].height\n        }\n        isrequestref.current = false\n        boxscroll()\n      } catch (err) {\n        console.log(err);\n      } finally {\n        isrequestref.current = false\n      }\n    }\n  })()\n  // eslint-disable-next-line\n}, [options])\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 每次列表更新之后将列表项真实高度更新缓存中的预估高度\n\n在react函数式组件中，useeffect只要不传第二个参数，就可以实现类组件componentdidupdate生命周期函数的作用，只要我们重新渲染一次列表组件，就会重新计算一下当前列表每一项中的真实高度并更新到缓存中去，当下次我们再用到缓存中的这些数据时，使用的就是真实高度了\n\n// 每次组件重新渲染即用户滚动更改了数据之后需要将列表中我们还不知道的列表项高度更新到我们的缓存数据中去，以便下一次更新的时候能够正常渲染\nuseeffect(() => { \n  const doms = containerref.current.children[0].children\n  const len = doms.length\n  // 因为一开始我们没有请求数据，所以即使组件渲染完了，但是没有列表项，此时不需要执行后续操作\n  if (len) {\n    // 遍历所有的列表结点，根据结点的真实高度去更改缓存中的高度\n    for (let i = 0; i < len; i++) {\n      const realheight = doms[i].offsetheight\n      const originheight = showlist[i].height\n      const dvalue = realheight - originheight\n      // 如果列表项的真实高度就是缓存中的高度，则不需要进行更新\n      if (dvalue) {\n        const index = showlist[i].index\n        const alldata = datalistref.current\n        /**\n           * 如果列表项的真实高度不是缓存中的高度，那么不仅要更新缓存中这一项的bottom和height属性\n           * 在该列表项后续的所有列表项的top、bottom都会受到它的影响，所以我们又需要一层for循环进行更改缓存中后续的值\n           */\n        alldata[index].bottom += dvalue\n        alldata[index].height = realheight\n        /**\n           * 注意：这里更改的一定要是缓存数组中对应位置后续的所有值，如果只改变的是showlist值的话\n           * 会造成datalist间断性的bottom和下一个top不连续，因为startindex、endindex以及空白填充区域都是依据top和bottom值来进行计算的\n           * 所以会导致最后计算的结果出错，滑动得来的startindex变化幅度大且滚动条不稳定，出现明显抖动问题\n           */\n        for (let j = index + 1, len = alldata.length; j < len; j++) {\n          alldata[j].top = alldata[j - 1].bottom\n          alldata[j].bottom += dvalue\n        }\n      }\n    }\n  }\n  // eslint-disable-next-line\n})\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 得到可视区域的起始和结束元素索引&&设置上下滚动缓冲区域消除快速滚动白屏\n\n列表项的bottom属性代表的就是该元素尾部到容器顶部的距离，不难发现，可视区的第一个元素的bottom是第一个大于滚动高度的；可视区最后一个元素的bottom是第一个大于（滚动高度+可视高度）的。我们可以利用这条规则遍历缓存数组找到对应的startindex和endindex\n\n由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数，减少时间复杂度\n\n// 得到要渲染数据的起始索引和结束索引\nconst getindex = () => {\n  // 设置缓冲区域的数据量\n  const abovecount = 5\n  const belowcount = 5\n  // 结果数组，里面包含了起始索引和结束索引\n  const resobj = {\n    startindex: 0,\n    endindex: 0,\n  }\n  const scrolltop = containerref.current.scrolltop\n  const datalist = datalistref.current\n  const len = datalist.length\n  // 设置上层缓冲区，如果索引值大于缓冲区域，那么就需要减小startindex的值用于设置顶层缓冲区\n  const startindex = binarysearch(scrolltop)\n  if (startindex <= abovecount) {\n    resobj.startindex = 0\n  } else {\n    resobj.startindex = startindex - abovecount\n  }\n  /**\n     * 缓冲数据中第一个bottom大于滚动高度加上可视区域高度的元素就是可视区域最后一个元素\n     * 如果没有找到的话就说明当前滚动的幅度过大，缓存中没有数据的bottom大于我们的目标值，所以搜索不到对应的索引，我们只能拿缓存数据中的最后一个元素补充上\n     */\n  const endindex = binarysearch(scrolltop + curcontainerheight.current) || len - 1\n  // 增大endindex的索引值用于为滚动区域下方设置一段缓冲区，避免快速滚动所导致的白屏问题\n  resobj.endindex = endindex + belowcount\n  return resobj\n}\n\n// 由于我们的缓存数据，本身就是有顺序的，所以获取开始索引的方法可以考虑通过二分查找的方式来降低检索次数：\nconst binarysearch = (value) => {\n  const list = datalistref.current\n  let start = 0;\n  let end = list.length - 1;\n  let tempindex = null;\n  while (start <= end) {\n    let midindex = parseint((start + end) / 2);\n    let midvalue = list[midindex].bottom;\n    if (midvalue === value) {\n      // 说明当前滚动区域加上可视区域刚好是一个结点的边界，那么我们可以以其下一个结点作为末尾元素\n      return midindex + 1;\n    } else if (midvalue < value) {\n      // 由于当前值与目标值还有一定的差距，所以我们需要增加start值以让下次中点的落点更靠后\n      start = midindex + 1;\n    } else if (midvalue > value) {\n      // 因为我们的目的并不是找到第一个满足条件的值，而是要找到满足条件的最小索引值\n      if (tempindex === null || tempindex > midindex) {\n        tempindex = midindex;\n      }\n      // 由于我们要继续找更小的索引，所以需要让end-1以缩小范围，让下次中点的落点更靠前\n      end--\n    }\n  }\n  return tempindex;\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n# 监听滚动事件动态截取数据&&动态设置上下空白占位\n\n动态截取数据的操作和定高的虚拟列表几乎一样，区别比较大的地方就在padding值的计算方式上。在定高的列表中，我们可以根据起始索引值和结尾索引值直接计算出空白填充区域的高度。\n\n其实在不定高的列表中，计算方式更加简单，因为startindex对应元素的top值就是我们需要填充的上空白区域，下空白区域也可以根据整个列表的高度（最后一个元素的bottom值）和endindex对应元素的bottom值之差得出\n\nconst scrollhandle = () => {\n  // 获取当前要渲染元素的起始索引和结束索引值\n  let { startindex, endindex } = getindex()\n  /**\n     * 如果是用户滚动触发的，而且两次startindex的值都一样，那么就没有必要执行下面的逻辑，\n     * 除非是用户重新请求了之后需要默认执行一次该函数，这是一种特殊情况，就是startindex没变，但需要执行后续的操作\n     */\n  if (!isneedload && laststartindex.current === startindex) return\n  // 渲染完一次之后就需要初始化isneedload\n  isneedload.current = false\n  // 用于实时监控laststartindex的值\n  laststartindex.current = startindex\n  // 下层缓冲区域最后的元素接触到屏幕底部的时候，就可以请求发送数据了\n  const currlen = datalistref.current.length\n  if (endindex >= currlen - 1) {\n    // 当前不在请求状态下时才可以改变请求参数发送获取更多数据的请求\n    !isrequestref.current && setoptions(state => ({ offset: state.offset + 1 }))\n    // 注意endindex不可以大于缓存中最后一个元素的索引值\n    endindex = currlen - 1\n  }\n  // 空白填充区域的样式\n  topblankfill.current = {\n    // 改变空白填充区域的样式，起始元素的top值就代表起始元素距顶部的距离，可以用来充当paddingtop值\n    paddingtop: `${datalistref.current[startindex].top}px`,\n    // 缓存中最后一个元素的bottom值与endindex对应元素的bottom值的差值可以用来充当paddingbottom的值\n    paddingbottom: `${datalistref.current[datalistref.current.length - 1].bottom - datalistref.current[endindex].bottom}px`\n  }\n  setshowlist(datalistref.current.slice(startindex, endindex + 1))\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 问题思考\n\n我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开。在这种场景下，由于图片会发送网络请求，列表项可能已经渲染到页面中了，但是图片还没有加载出来，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，获取到的高度有无包含图片高度，从而造成计算不准确的情况。\n\n但是这种任意由图片来撑开盒子大小的场景很少见，因为这样会显得整个列表很不规则。大多数展示图片的列表场景，其实都是提前确定要展示图片的尺寸的，比如微博，1张图片的尺寸是多少，2x2，3x3的尺寸是多少都是提前设计好的，只要我们给img标签加了固定高度，这样就算图片还没有加载出来，但是我们也能够准确的知道列表项的高度是多少。\n\n如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定onload事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次，还可以使用resizeobserver来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度，只不过mdn有说道这只是在实验中的一个功能，所以暂时可能没有办法兼容所有的浏览器！",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"Vue中实现右键自定义菜单",frontmatter:{title:"Vue中实现右键自定义菜单",date:"2021-07-13T09:56:28.000Z",permalink:"/pages/39df27/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/43.Vue%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%8F%B3%E9%94%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95.html",relativePath:"55.更多/02.进阶/43.Vue中实现右键自定义菜单.md",key:"v-efaad25e",path:"/pages/39df27/",headers:[{level:2,title:"1. 原生方法",slug:"_1-原生方法",normalizedTitle:"1. 原生方法",charIndex:2},{level:2,title:"2. 使用插件 vue-context-menu",slug:"_2-使用插件-vue-context-menu",normalizedTitle:"2. 使用插件 vue-context-menu",charIndex:2246}],headersStr:"1. 原生方法 2. 使用插件 vue-context-menu",content:'# 1. 原生方法\n\n1.1 完整代码\n\n<template>\n  <div class="home">\n    \x3c!-- 在需要右键菜单的元素，绑定contextmenu事件 --\x3e\n    <div \n        class="test" v-for="item in menus" :key="item" \n        @contextmenu.prevent="openMenu($event,item)">{{item}}</div>\n        \n    \x3c!-- 右键菜单部分 --\x3e\n    <ul v-show="visible" :style="{left:left+\'px\',top:top+\'px\'}" class="contextmenu">\n      <li @click="handleDelete">删除</li>\n      <li @click="handleDownloadFile">下载</li>\n      <li @click="handlePreviewFile">预览</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      menus:[1,2,3], // 模拟数据\n      rightClickItem:\'\',\n      visible: false, // 是否展示右键菜单\n      top:0,\n      left:0,\n    };\n  },\n  methods: {\n    // 打开右键菜单\n    openMenu(e,item){\n      this.visible = true;\n      this.top = e.pageY;\n      this.left = e.pageX;\n      this.rightClickItem = item;\n    },\n    // 关闭右键菜单\n    closeMenu(){\n      this.visible = false;\n    },\n    \n    handleDelete(){},\n    handleDownloadFile(){},\n    handlePreviewFile(){},\n  },\n  watch: {\n    // 监听 visible，来触发关闭右键菜单，调用关闭菜单的方法\n    visible(value) {\n      if (value) {\n        document.body.addEventListener(\'click\', this.closeMenu)\n      } else {\n        document.body.removeEventListener(\'click\', this.closeMenu)\n      }\n    }\n  },\n};\n<\/script>\n\n<style lang="stylus" scoped>\n.home{\n  display: flex;\n  justify-content: space-around;\n  width: 100%;\n  height: 600px;\n  .test{\n    width: 80px;\n    height: 60px;\n    background-color pink;\n    text-align:center;\n    font-size:32px;  \n    color: green;\n  }\n  .contextmenu {\n    margin: 0;\n    background: #fff;\n    z-index: 3000;\n    position: absolute;\n    list-style-type: none;\n    padding: 5px 0;\n    border-radius: 4px;\n    font-size: 12px;\n    font-weight: 400;\n    color: #333;\n    box-shadow: 2px 2px 3px 0 rgba(0, 0, 0, 0.3);\n  }\n  .contextmenu li {\n    margin: 0;\n    padding: 7px 16px;\n    cursor: pointer;\n  }\n  .contextmenu li:hover {\n    background: #eee;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n1.2 效果\n\n\n\n\n# 2. 使用插件 vue-context-menu\n\ndemo演示地址\n\nGitHub地址\n\nnpm 地址\n\n安装\n\nnpm install vue-contextmenu --save\n\n\n1\n\n\n引入\n\nimport VueContextMenu from \'vue-contextmenu\'\nVue.use(VueContextMenu)\n\n\n1\n2\n\n\n2.1 普通列表菜单\n\n2.1.1 完整代码\n\n<template>\n  <div \n    id="app" @contextmenu="showMenu"\n    style="width: 200px;height: 200px;margin-top: 20px;background: pink;">\n    <vue-context-menu \n      :contextMenuData="contextMenuData" @deleteData="deleteData" @newAdd="newAdd">\n    </vue-context-menu>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      // 菜单数据\n      contextMenuData: {\n        menuName: \'demo\',\n        // 菜单显示的位置\n        axis: {\n          x: null,\n          y: null\n        },\n        // 菜单选项\n        menulists: [\n          {\n            fnHandler: \'deleteData\', // 绑定事件\n            icoName: \'el-icon-delete\', // 图标 (本文取自 element-ui)\n            btnName: \'保存\' // 菜单名称\n          },{\n            fnHandler: \'newAdd\',\n            icoName: \'el-icon-plus\',\n            btnName: \'新增\'\n          }\n        ]\n      }\n    };\n  },\n  methods: {\n    showMenu () {\n      event.preventDefault()\n      var x = event.clientX;\n      var y = event.clientY;\n      // 获取当前位置\n      this.contextMenuData.axis = { x, y }\n    },\n    // 删除\n    deleteData () {},\n    // 新增\n    newAdd () {}\n  },\n  watch: {},\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n2.1.2 效果\n\n\n\n2.2 树型菜单\n\n2.2.1 完整代码\n\n<template>\n  <div style="position: fixed; left: 0px; top: 0">\n    <div\n      @contextmenu="showMenu(index)"\n      style="width: 100px; height: 100px; margin-top: 20px; background: red"\n      v-for="(n, index) in 2"\n      :key="n"\n    >\n      <vue-context-menu\n        :contextMenuData="contextMenuData"\n        :transferIndex="transferIndex"\n        @Handler1="Handler_A(index)"\n        @Handler2="Handler_B(index)"\n        @Handler3="Handler_C(index)"\n      ></vue-context-menu>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: "app",\n  data() {\n    return {\n      transferIndex: null,\n      contextMenuData: {\n        menuName: "demo",\n        axis: {\n          x: null,\n          y: null,\n        },\n        menulists: [\n          {\n            btnName: "选项1",\n            icoName: "el-icon-s-tools",\n            children: [\n              {\n                icoName: "el-icon-download",\n                btnName: "选项1-1",\n                // 子菜单\n                children: [\n                  {\n                    icoName: "el-icon-share",\n                    btnName: "选项1-1-1",\n                    children: [\n                      {\n                        icoName: "el-icon-switch-button",\n                        fnHandler: "Handler1",\n                        btnName: "选项1-1-1",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            btnName: "选项2",\n            children: [\n              {\n                fnHandler: "Handler2",\n                btnName: "选项2-1",\n              },\n            ],\n          },\n          {\n            btnName: "选项3",\n            fnHandler: "Handler3",\n          },\n          {\n            btnName: "选项4",\n            disabled: true,\n          },\n        ],\n      },\n    };\n  },\n  methods: {\n    showMenu(index) {\n      this.transferIndex = index; // 将索引转换到子组件\n      event.preventDefault();\n      var x = event.clientX;\n      var y = event.clientY;\n      this.contextMenuData.axis = { x,y };\n    },\n    Handler_A(index) {\n      console.log(index, "选项 1-1-1 绑定事件执行");\n    },\n    Handler_B(index) {\n      console.log(index, "选项 2-1 绑定事件执行");\n    },\n    Handler_C(index) {\n      console.log(index, "选项 3 绑定事件执行");\n    },\n  },\n};\n<\/script>\n\n<style>\n* {\n  margin: 0;\n  padding: 0;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n2.2.2 效果\n\n',normalizedContent:'# 1. 原生方法\n\n1.1 完整代码\n\n<template>\n  <div class="home">\n    \x3c!-- 在需要右键菜单的元素，绑定contextmenu事件 --\x3e\n    <div \n        class="test" v-for="item in menus" :key="item" \n        @contextmenu.prevent="openmenu($event,item)">{{item}}</div>\n        \n    \x3c!-- 右键菜单部分 --\x3e\n    <ul v-show="visible" :style="{left:left+\'px\',top:top+\'px\'}" class="contextmenu">\n      <li @click="handledelete">删除</li>\n      <li @click="handledownloadfile">下载</li>\n      <li @click="handlepreviewfile">预览</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      menus:[1,2,3], // 模拟数据\n      rightclickitem:\'\',\n      visible: false, // 是否展示右键菜单\n      top:0,\n      left:0,\n    };\n  },\n  methods: {\n    // 打开右键菜单\n    openmenu(e,item){\n      this.visible = true;\n      this.top = e.pagey;\n      this.left = e.pagex;\n      this.rightclickitem = item;\n    },\n    // 关闭右键菜单\n    closemenu(){\n      this.visible = false;\n    },\n    \n    handledelete(){},\n    handledownloadfile(){},\n    handlepreviewfile(){},\n  },\n  watch: {\n    // 监听 visible，来触发关闭右键菜单，调用关闭菜单的方法\n    visible(value) {\n      if (value) {\n        document.body.addeventlistener(\'click\', this.closemenu)\n      } else {\n        document.body.removeeventlistener(\'click\', this.closemenu)\n      }\n    }\n  },\n};\n<\/script>\n\n<style lang="stylus" scoped>\n.home{\n  display: flex;\n  justify-content: space-around;\n  width: 100%;\n  height: 600px;\n  .test{\n    width: 80px;\n    height: 60px;\n    background-color pink;\n    text-align:center;\n    font-size:32px;  \n    color: green;\n  }\n  .contextmenu {\n    margin: 0;\n    background: #fff;\n    z-index: 3000;\n    position: absolute;\n    list-style-type: none;\n    padding: 5px 0;\n    border-radius: 4px;\n    font-size: 12px;\n    font-weight: 400;\n    color: #333;\n    box-shadow: 2px 2px 3px 0 rgba(0, 0, 0, 0.3);\n  }\n  .contextmenu li {\n    margin: 0;\n    padding: 7px 16px;\n    cursor: pointer;\n  }\n  .contextmenu li:hover {\n    background: #eee;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n1.2 效果\n\n\n\n\n# 2. 使用插件 vue-context-menu\n\ndemo演示地址\n\ngithub地址\n\nnpm 地址\n\n安装\n\nnpm install vue-contextmenu --save\n\n\n1\n\n\n引入\n\nimport vuecontextmenu from \'vue-contextmenu\'\nvue.use(vuecontextmenu)\n\n\n1\n2\n\n\n2.1 普通列表菜单\n\n2.1.1 完整代码\n\n<template>\n  <div \n    id="app" @contextmenu="showmenu"\n    style="width: 200px;height: 200px;margin-top: 20px;background: pink;">\n    <vue-context-menu \n      :contextmenudata="contextmenudata" @deletedata="deletedata" @newadd="newadd">\n    </vue-context-menu>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      // 菜单数据\n      contextmenudata: {\n        menuname: \'demo\',\n        // 菜单显示的位置\n        axis: {\n          x: null,\n          y: null\n        },\n        // 菜单选项\n        menulists: [\n          {\n            fnhandler: \'deletedata\', // 绑定事件\n            iconame: \'el-icon-delete\', // 图标 (本文取自 element-ui)\n            btnname: \'保存\' // 菜单名称\n          },{\n            fnhandler: \'newadd\',\n            iconame: \'el-icon-plus\',\n            btnname: \'新增\'\n          }\n        ]\n      }\n    };\n  },\n  methods: {\n    showmenu () {\n      event.preventdefault()\n      var x = event.clientx;\n      var y = event.clienty;\n      // 获取当前位置\n      this.contextmenudata.axis = { x, y }\n    },\n    // 删除\n    deletedata () {},\n    // 新增\n    newadd () {}\n  },\n  watch: {},\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n2.1.2 效果\n\n\n\n2.2 树型菜单\n\n2.2.1 完整代码\n\n<template>\n  <div style="position: fixed; left: 0px; top: 0">\n    <div\n      @contextmenu="showmenu(index)"\n      style="width: 100px; height: 100px; margin-top: 20px; background: red"\n      v-for="(n, index) in 2"\n      :key="n"\n    >\n      <vue-context-menu\n        :contextmenudata="contextmenudata"\n        :transferindex="transferindex"\n        @handler1="handler_a(index)"\n        @handler2="handler_b(index)"\n        @handler3="handler_c(index)"\n      ></vue-context-menu>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: "app",\n  data() {\n    return {\n      transferindex: null,\n      contextmenudata: {\n        menuname: "demo",\n        axis: {\n          x: null,\n          y: null,\n        },\n        menulists: [\n          {\n            btnname: "选项1",\n            iconame: "el-icon-s-tools",\n            children: [\n              {\n                iconame: "el-icon-download",\n                btnname: "选项1-1",\n                // 子菜单\n                children: [\n                  {\n                    iconame: "el-icon-share",\n                    btnname: "选项1-1-1",\n                    children: [\n                      {\n                        iconame: "el-icon-switch-button",\n                        fnhandler: "handler1",\n                        btnname: "选项1-1-1",\n                      },\n                    ],\n                  },\n                ],\n              },\n            ],\n          },\n          {\n            btnname: "选项2",\n            children: [\n              {\n                fnhandler: "handler2",\n                btnname: "选项2-1",\n              },\n            ],\n          },\n          {\n            btnname: "选项3",\n            fnhandler: "handler3",\n          },\n          {\n            btnname: "选项4",\n            disabled: true,\n          },\n        ],\n      },\n    };\n  },\n  methods: {\n    showmenu(index) {\n      this.transferindex = index; // 将索引转换到子组件\n      event.preventdefault();\n      var x = event.clientx;\n      var y = event.clienty;\n      this.contextmenudata.axis = { x,y };\n    },\n    handler_a(index) {\n      console.log(index, "选项 1-1-1 绑定事件执行");\n    },\n    handler_b(index) {\n      console.log(index, "选项 2-1 绑定事件执行");\n    },\n    handler_c(index) {\n      console.log(index, "选项 3 绑定事件执行");\n    },\n  },\n};\n<\/script>\n\n<style>\n* {\n  margin: 0;\n  padding: 0;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n\n\n2.2.2 效果\n\n',charsets:{cjk:!0},lastUpdated:"2023/05/03, 10:00:58",lastUpdatedTimestamp:1683079258e3},{title:"面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",frontmatter:{title:"面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",date:"2022-01-27T01:22:05.000Z",permalink:"/advanced/e561b0/",categories:["更多","进阶"],tags:["Vue"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/50.%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91%E6%8C%89%E9%92%AE%E7%BA%A7%E5%88%AB%E6%9D%83%E9%99%90%E6%80%8E%E4%B9%88%E6%8E%A7%E5%88%B6%EF%BC%8C%E6%88%91%E8%AF%B4v-if%EF%BC%8C%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%B4%E5%86%8D%E8%A7%81.html",relativePath:"55.更多/02.进阶/50.面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见.md",key:"v-9bc8aa68",path:"/advanced/e561b0/",headers:[{level:2,title:"获取权限码",slug:"获取权限码",normalizedTitle:"获取权限码",charIndex:188},{level:2,title:"函数方式",slug:"函数方式",normalizedTitle:"函数方式",charIndex:944},{level:2,title:"组件方式",slug:"组件方式",normalizedTitle:"组件方式",charIndex:2012},{level:2,title:"指令方式",slug:"指令方式",normalizedTitle:"指令方式",charIndex:3390}],headersStr:"获取权限码 函数方式 组件方式 指令方式",content:"最近的面试中有一个面试官问我按钮级别的权限怎么控制，我说直接v-if啊，他说不够好，我说我们项目中按钮级别的权限控制情况不多，所以v-if就够了，他说不够通用，最后他对我的评价是做过很多东西，但是都不够深入，好吧，那今天我们就来深入深入。\n\n因为我自己没有相关实践，所以接下来就从这个有16.2k星星的后台管理系统项目Vue vben admin中看看它是如何做的。\n\n\n# 获取权限码\n\n要做权限控制，肯定需要一个code，无论是权限码还是角色码都可以，一般后端会一次性返回，然后全局存储起来就可以了，Vue vben admin是在登录成功以后获取并保存到全局的store中：\n\nimport { defineStore } from 'pinia';\nexport const usePermissionStore = defineStore({\n    state: () => ({\n        // 权限代码列表\n        permCodeList: [],\n    }),\n    getters: {\n        // 获取\n        getPermCodeList(){\n      \t\treturn this.permCodeList;\n    \t},\t\n    },\n    actions: {\n        // 存储\n        setPermCodeList(codeList) {\n            this.permCodeList = codeList;\n        },\n\n        // 请求权限码\n        async changePermissionCode() {\n            const codeList = await getPermCode();\n            this.setPermCodeList(codeList);\n        }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接下来它提供了三种按钮级别的权限控制方式，一一来看。\n\n\n# 函数方式\n\n使用示例如下：\n\n<template>\n  <a-button v-if=\"hasPermission(['20000', '2000010'])\" color=\"error\" class=\"mx-4\">\n    拥有[20000,2000010]code可见\n  </a-button>\n</template>\n\n<script lang=\"ts\">\n  import { usePermission } from '/@/hooks/web/usePermission';\n\n  export default defineComponent({\n    setup() {\n      const { hasPermission } = usePermission();\n      return { hasPermission };\n    },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n本质上就是通过v-if，只不过是通过一个统一的权限判断方法hasPermission：\n\nexport function usePermission() {\n    function hasPermission(value, def = true) {\n        // 默认视为有权限\n        if (!value) {\n            return def;\n        }\n\n        const allCodeList = permissionStore.getPermCodeList;\n        if (!isArray(value)) {\n            return allCodeList.includes(value);\n        }\n        // intersection是lodash提供的一个方法，用于返回一个所有给定数组都存在的元素组成的数组\n        return (intersection(value, allCodeList)).length > 0;\n\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n很简单，从全局store中获取当前用户的权限码列表，然后判断其中是否存在当前按钮需要的权限码，如果有多个权限码，只要满足其中一个就可以。\n\n\n# 组件方式\n\n除了通过函数方式使用，也可以使用组件方式，Vue vben admin提供了一个Authority组件，使用示例如下：\n\n<template>\n  <div>\n    <Authority :value=\"RoleEnum.ADMIN\">\n      <a-button type=\"primary\" block> 只有admin角色可见 </a-button>\n    </Authority>\n  </div>\n</template>\n<script>\n  import { Authority } from '/@/components/Authority';\n  import { defineComponent } from 'vue';\n  export default defineComponent({\n    components: { Authority },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用Authority包裹需要权限控制的按钮即可，该按钮需要的权限码通过value属性传入，接下来看看Authority组件的实现。\n\n<script lang=\"ts\">\n  import { defineComponent } from 'vue';\n  import { usePermission } from '/@/hooks/web/usePermission';\n  import { getSlot } from '/@/utils/helper/tsxHelper';\n\n  export default defineComponent({\n    name: 'Authority',\n    props: {\n      value: {\n        type: [Number, Array, String],\n        default: '',\n      },\n    },\n    setup(props, { slots }) {\n      const { hasPermission } = usePermission();\n\n      function renderAuth() {\n        const { value } = props;\n        if (!value) {\n          return getSlot(slots);\n        }\n        return hasPermission(value) ? getSlot(slots) : null;\n      }\n\n      return () => {\n        return renderAuth();\n      };\n    },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n同样还是使用hasPermission方法，如果当前用户存在按钮需要的权限码时就原封不动渲染Authority包裹的内容，否则就啥也不渲染。\n\n\n# 指令方式\n\n最后一种就是指令方式，使用示例如下：\n\n<a-button v-auth=\"'1000'\" type=\"primary\" class=\"mx-4\"> 拥有code ['1000']权限可见 </a-button>\n\n\n1\n\n\n实现如下：\n\nimport { usePermission } from '/@/hooks/web/usePermission';\n\nfunction isAuth(el, binding) {\n  const { hasPermission } = usePermission();\n\n  const value = binding.value;\n  if (!value) return;\n  if (!hasPermission(value)) {\n    el.parentNode?.removeChild(el);\n  }\n}\n\nconst mounted = (el, binding) => {\n  isAuth(el, binding);\n};\n\nconst authDirective = {\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都挂载完成后调用\n  mounted,\n};\n\n// 注册全局指令\nexport function setupPermissionDirective(app) {\n  app.directive('auth', authDirective);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n只定义了一个mounted钩子，也就是在绑定元素挂载后调用，依旧是使用hasPermission方法，判断当前用户是否存在通过指令插入的按钮需要的权限码，如果不存在，直接移除绑定的元素。\n\n很明显，Vue vben admin的实现有两个问题，一是不能动态更改按钮的权限，二是动态更改当前用户的权限也不会生效。\n\n解决第一个问题很简单，因为上述只有删除元素的逻辑，没有加回来的逻辑，那么增加一个updated钩子：\n\napp.directive(\"auth\", {\n    mounted: (el, binding) => {\n        const value = binding.value\n        if (!value) return\n        if (!hasPermission(value)) {\n            // 挂载的时候没有权限把元素删除\n            removeEl(el)\n        }\n    },\n    updated(el, binding) {\n        // 按钮权限码没有变化，不做处理\n        if (binding.value === binding.oldValue) return\n        // 判断用户本次和上次权限状态是否一样，一样也不用做处理\n        let oldHasPermission = hasPermission(binding.oldValue)\n        let newHasPermission = hasPermission(binding.value)\n        if (oldHasPermission === newHasPermission) return\n        // 如果变成有权限，那么把元素添加回来\n        if (newHasPermission) {\n            addEl(el)\n        } else {\n        // 如果变成没有权限，则把元素删除\n            removeEl(el)\n        }\n    },\n})\n\nconst hasPermission = (value) => {\n    return [1, 2, 3].includes(value)\n}\n\nconst removeEl = (el) => {\n    // 在绑定元素上存储父级元素\n    el._parentNode = el.parentNode\n    // 在绑定元素上存储一个注释节点\n    el._placeholderNode = document.createComment(\"auth\")\n    // 使用注释节点来占位\n    el.parentNode?.replaceChild(el._placeholderNode, el)\n}\n\nconst addEl = (el) => {\n    // 替换掉给自己占位的注释节点\n    el._parentNode?.replaceChild(el, el._placeholderNode)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n主要就是要把父节点保存起来，不然想再添加回去的时候获取不到原来的父节点，另外删除的时候创建一个注释节点给自己占位，这样下次想要回去能知道自己原来在哪。\n\n第二个问题的原因是修改了用户权限数据，但是不会触发按钮的重新渲染，那么我们就需要想办法能让它触发，这个可以使用watchEffect方法，我们可以在updated钩子里通过这个方法将用户权限数据和按钮的更新方法关联起来，这样当用户权限数据改变了，可以自动触发按钮的重新渲染：\n\nimport { createApp, reactive, watchEffect } from \"vue\"\nconst codeList = reactive([1, 2, 3])\n\nconst hasPermission = (value) => {\n    return codeList.includes(value)\n}\n\napp.directive(\"auth\", {\n    updated(el, binding) {\n        let update = () => {\n            let valueNotChange = binding.value === binding.oldValue\n            let oldHasPermission = hasPermission(binding.oldValue)\n            let newHasPermission = hasPermission(binding.value)\n            let permissionNotChange = oldHasPermission === newHasPermission\n            if (valueNotChange && permissionNotChange) return\n            if (newHasPermission) {\n                addEl(el)\n            } else {\n                removeEl(el)\n            }\n        };\n        if (el._watchEffect) {\n            update()\n        } else {\n            el._watchEffect = watchEffect(() => {\n                update()\n            })\n        }\n    },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n将updated钩子里更新的逻辑提取成一个update方法，然后第一次更新在watchEffect中执行，这样用户权限的响应式数据就可以和update方法关联起来，后续用户权限数据改变了，可以自动触发update方法的重新运行。\n\n好了，深入完了，看着似乎也挺简单的，我不确定这些是不是面试官想要的，或者还有其他更高级更优雅的实现呢，知道的朋友能否指点一二，在下感激不尽。\n\n原文： 面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",normalizedContent:"最近的面试中有一个面试官问我按钮级别的权限怎么控制，我说直接v-if啊，他说不够好，我说我们项目中按钮级别的权限控制情况不多，所以v-if就够了，他说不够通用，最后他对我的评价是做过很多东西，但是都不够深入，好吧，那今天我们就来深入深入。\n\n因为我自己没有相关实践，所以接下来就从这个有16.2k星星的后台管理系统项目vue vben admin中看看它是如何做的。\n\n\n# 获取权限码\n\n要做权限控制，肯定需要一个code，无论是权限码还是角色码都可以，一般后端会一次性返回，然后全局存储起来就可以了，vue vben admin是在登录成功以后获取并保存到全局的store中：\n\nimport { definestore } from 'pinia';\nexport const usepermissionstore = definestore({\n    state: () => ({\n        // 权限代码列表\n        permcodelist: [],\n    }),\n    getters: {\n        // 获取\n        getpermcodelist(){\n      \t\treturn this.permcodelist;\n    \t},\t\n    },\n    actions: {\n        // 存储\n        setpermcodelist(codelist) {\n            this.permcodelist = codelist;\n        },\n\n        // 请求权限码\n        async changepermissioncode() {\n            const codelist = await getpermcode();\n            this.setpermcodelist(codelist);\n        }\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n接下来它提供了三种按钮级别的权限控制方式，一一来看。\n\n\n# 函数方式\n\n使用示例如下：\n\n<template>\n  <a-button v-if=\"haspermission(['20000', '2000010'])\" color=\"error\" class=\"mx-4\">\n    拥有[20000,2000010]code可见\n  </a-button>\n</template>\n\n<script lang=\"ts\">\n  import { usepermission } from '/@/hooks/web/usepermission';\n\n  export default definecomponent({\n    setup() {\n      const { haspermission } = usepermission();\n      return { haspermission };\n    },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n本质上就是通过v-if，只不过是通过一个统一的权限判断方法haspermission：\n\nexport function usepermission() {\n    function haspermission(value, def = true) {\n        // 默认视为有权限\n        if (!value) {\n            return def;\n        }\n\n        const allcodelist = permissionstore.getpermcodelist;\n        if (!isarray(value)) {\n            return allcodelist.includes(value);\n        }\n        // intersection是lodash提供的一个方法，用于返回一个所有给定数组都存在的元素组成的数组\n        return (intersection(value, allcodelist)).length > 0;\n\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n很简单，从全局store中获取当前用户的权限码列表，然后判断其中是否存在当前按钮需要的权限码，如果有多个权限码，只要满足其中一个就可以。\n\n\n# 组件方式\n\n除了通过函数方式使用，也可以使用组件方式，vue vben admin提供了一个authority组件，使用示例如下：\n\n<template>\n  <div>\n    <authority :value=\"roleenum.admin\">\n      <a-button type=\"primary\" block> 只有admin角色可见 </a-button>\n    </authority>\n  </div>\n</template>\n<script>\n  import { authority } from '/@/components/authority';\n  import { definecomponent } from 'vue';\n  export default definecomponent({\n    components: { authority },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n使用authority包裹需要权限控制的按钮即可，该按钮需要的权限码通过value属性传入，接下来看看authority组件的实现。\n\n<script lang=\"ts\">\n  import { definecomponent } from 'vue';\n  import { usepermission } from '/@/hooks/web/usepermission';\n  import { getslot } from '/@/utils/helper/tsxhelper';\n\n  export default definecomponent({\n    name: 'authority',\n    props: {\n      value: {\n        type: [number, array, string],\n        default: '',\n      },\n    },\n    setup(props, { slots }) {\n      const { haspermission } = usepermission();\n\n      function renderauth() {\n        const { value } = props;\n        if (!value) {\n          return getslot(slots);\n        }\n        return haspermission(value) ? getslot(slots) : null;\n      }\n\n      return () => {\n        return renderauth();\n      };\n    },\n  });\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n同样还是使用haspermission方法，如果当前用户存在按钮需要的权限码时就原封不动渲染authority包裹的内容，否则就啥也不渲染。\n\n\n# 指令方式\n\n最后一种就是指令方式，使用示例如下：\n\n<a-button v-auth=\"'1000'\" type=\"primary\" class=\"mx-4\"> 拥有code ['1000']权限可见 </a-button>\n\n\n1\n\n\n实现如下：\n\nimport { usepermission } from '/@/hooks/web/usepermission';\n\nfunction isauth(el, binding) {\n  const { haspermission } = usepermission();\n\n  const value = binding.value;\n  if (!value) return;\n  if (!haspermission(value)) {\n    el.parentnode?.removechild(el);\n  }\n}\n\nconst mounted = (el, binding) => {\n  isauth(el, binding);\n};\n\nconst authdirective = {\n  // 在绑定元素的父组件\n  // 及他自己的所有子节点都挂载完成后调用\n  mounted,\n};\n\n// 注册全局指令\nexport function setuppermissiondirective(app) {\n  app.directive('auth', authdirective);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n只定义了一个mounted钩子，也就是在绑定元素挂载后调用，依旧是使用haspermission方法，判断当前用户是否存在通过指令插入的按钮需要的权限码，如果不存在，直接移除绑定的元素。\n\n很明显，vue vben admin的实现有两个问题，一是不能动态更改按钮的权限，二是动态更改当前用户的权限也不会生效。\n\n解决第一个问题很简单，因为上述只有删除元素的逻辑，没有加回来的逻辑，那么增加一个updated钩子：\n\napp.directive(\"auth\", {\n    mounted: (el, binding) => {\n        const value = binding.value\n        if (!value) return\n        if (!haspermission(value)) {\n            // 挂载的时候没有权限把元素删除\n            removeel(el)\n        }\n    },\n    updated(el, binding) {\n        // 按钮权限码没有变化，不做处理\n        if (binding.value === binding.oldvalue) return\n        // 判断用户本次和上次权限状态是否一样，一样也不用做处理\n        let oldhaspermission = haspermission(binding.oldvalue)\n        let newhaspermission = haspermission(binding.value)\n        if (oldhaspermission === newhaspermission) return\n        // 如果变成有权限，那么把元素添加回来\n        if (newhaspermission) {\n            addel(el)\n        } else {\n        // 如果变成没有权限，则把元素删除\n            removeel(el)\n        }\n    },\n})\n\nconst haspermission = (value) => {\n    return [1, 2, 3].includes(value)\n}\n\nconst removeel = (el) => {\n    // 在绑定元素上存储父级元素\n    el._parentnode = el.parentnode\n    // 在绑定元素上存储一个注释节点\n    el._placeholdernode = document.createcomment(\"auth\")\n    // 使用注释节点来占位\n    el.parentnode?.replacechild(el._placeholdernode, el)\n}\n\nconst addel = (el) => {\n    // 替换掉给自己占位的注释节点\n    el._parentnode?.replacechild(el, el._placeholdernode)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n主要就是要把父节点保存起来，不然想再添加回去的时候获取不到原来的父节点，另外删除的时候创建一个注释节点给自己占位，这样下次想要回去能知道自己原来在哪。\n\n第二个问题的原因是修改了用户权限数据，但是不会触发按钮的重新渲染，那么我们就需要想办法能让它触发，这个可以使用watcheffect方法，我们可以在updated钩子里通过这个方法将用户权限数据和按钮的更新方法关联起来，这样当用户权限数据改变了，可以自动触发按钮的重新渲染：\n\nimport { createapp, reactive, watcheffect } from \"vue\"\nconst codelist = reactive([1, 2, 3])\n\nconst haspermission = (value) => {\n    return codelist.includes(value)\n}\n\napp.directive(\"auth\", {\n    updated(el, binding) {\n        let update = () => {\n            let valuenotchange = binding.value === binding.oldvalue\n            let oldhaspermission = haspermission(binding.oldvalue)\n            let newhaspermission = haspermission(binding.value)\n            let permissionnotchange = oldhaspermission === newhaspermission\n            if (valuenotchange && permissionnotchange) return\n            if (newhaspermission) {\n                addel(el)\n            } else {\n                removeel(el)\n            }\n        };\n        if (el._watcheffect) {\n            update()\n        } else {\n            el._watcheffect = watcheffect(() => {\n                update()\n            })\n        }\n    },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n将updated钩子里更新的逻辑提取成一个update方法，然后第一次更新在watcheffect中执行，这样用户权限的响应式数据就可以和update方法关联起来，后续用户权限数据改变了，可以自动触发update方法的重新运行。\n\n好了，深入完了，看着似乎也挺简单的，我不确定这些是不是面试官想要的，或者还有其他更高级更优雅的实现呢，知道的朋友能否指点一二，在下感激不尽。\n\n原文： 面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"大文件上传技术实现",frontmatter:{title:"大文件上传技术实现",date:"2023-05-17T21:39:14.000Z",permalink:"/pages/08929e/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/44.%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0.html",relativePath:"55.更多/02.进阶/44.大文件上传技术实现.md",key:"v-21b79325",path:"/pages/08929e/",headers:[{level:2,title:"需求分析",slug:"需求分析",normalizedTitle:"需求分析",charIndex:16},{level:2,title:"项目架构",slug:"项目架构",normalizedTitle:"项目架构",charIndex:118},{level:3,title:"vite 创建 vue3 项目",slug:"vite-创建-vue3-项目",normalizedTitle:"vite 创建 vue3 项目",charIndex:174},{level:3,title:"koa脚手架 创建后台项目",slug:"koa脚手架-创建后台项目",normalizedTitle:"koa脚手架 创建后台项目",charIndex:392},{level:2,title:"大文件分片上传",slug:"大文件分片上传",normalizedTitle:"大文件分片上传",charIndex:594},{level:3,title:"前端思路",slug:"前端思路",normalizedTitle:"前端思路",charIndex:606},{level:4,title:"文件切片",slug:"文件切片",normalizedTitle:"文件切片",charIndex:614},{level:4,title:"文件唯一值",slug:"文件唯一值",normalizedTitle:"文件唯一值",charIndex:731},{level:4,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:3},{level:4,title:"定义数据结构",slug:"定义数据结构",normalizedTitle:"定义数据结构",charIndex:2090},{level:4,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:2416},{level:3,title:"后端思路",slug:"后端思路",normalizedTitle:"后端思路",charIndex:5231},{level:4,title:"配置 koa-body",slug:"配置-koa-body",normalizedTitle:"配置 koa-body",charIndex:5593},{level:4,title:"upload 路由",slug:"upload-路由",normalizedTitle:"upload 路由",charIndex:5701},{level:3,title:"进度条功能",slug:"进度条功能",normalizedTitle:"进度条功能",charIndex:8094},{level:4,title:"切片进度条",slug:"切片进度条",normalizedTitle:"切片进度条",charIndex:8180},{level:4,title:"文件的进度条",slug:"文件的进度条",normalizedTitle:"文件的进度条",charIndex:8548},{level:3,title:"文件秒传",slug:"文件秒传",normalizedTitle:"文件秒传",charIndex:8990},{level:3,title:"断点续传",slug:"断点续传",normalizedTitle:"断点续传",charIndex:9202},{level:4,title:"暂停上传",slug:"暂停上传",normalizedTitle:"暂停上传",charIndex:9275},{level:4,title:"恢复上传",slug:"恢复上传",normalizedTitle:"恢复上传",charIndex:9532},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:9856},{level:4,title:"提出问题",slug:"提出问题",normalizedTitle:"提出问题",charIndex:9891},{level:2,title:"优化",slug:"优化",normalizedTitle:"优化",charIndex:897},{level:3,title:"超大文件 hash计算时间过长问题",slug:"超大文件-hash计算时间过长问题",normalizedTitle:"超大文件 hash计算时间过长问题",charIndex:10025},{level:3,title:"文件切片过多导致并发http请求过多问题",slug:"文件切片过多导致并发http请求过多问题",normalizedTitle:"文件切片过多导致并发http请求过多问题",charIndex:11819},{level:3,title:"切片上传失败问题",slug:"切片上传失败问题",normalizedTitle:"切片上传失败问题",charIndex:14095},{level:3,title:"chunk定期清理",slug:"chunk定期清理",normalizedTitle:"chunk定期清理",charIndex:16885}],headersStr:"需求分析 项目架构 vite 创建 vue3 项目 koa脚手架 创建后台项目 大文件分片上传 前端思路 文件切片 文件唯一值 文件上传 定义数据结构 代码实现 后端思路 配置 koa-body upload 路由 进度条功能 切片进度条 文件的进度条 文件秒传 断点续传 暂停上传 恢复上传 总结 提出问题 优化 超大文件 hash计算时间过长问题 文件切片过多导致并发http请求过多问题 切片上传失败问题 chunk定期清理",content:"# 大文件上传技术实现\n\n\n# 需求分析\n\n针对大文件上传，我们希望最少做到一下几点\n\n * 大文件切割，分片上传\n * 如果有部分切片上传失败了，我们希望提醒用户重新上传，并且上传成功不需要上传\n * 最好能有上传的进度提示\n\n\n# 项目架构\n\n本次项目前台我们打算使用 vite+vue3+element-plus，后台使用koa框架\n\n\n# vite 创建 vue3 项目\n\n// https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n// 执行下面一条语句就创建完成了 好快啊\nyarn create vite big-upload --template vue\ncd big-upload-ui\n// 安装需要的库\nyarn add element-plus\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# koa脚手架 创建后台项目\n\n// koa2脚手架\nnpm install koa-generator -g\n// 脚手架创建项目\nkoa2 server\ncd server\nyarn\n// 安装对应的库\nyarn add koa-body fs-extra\n// 删去一些不需要使用的文件  全局引入koa-body 并且配置  创建upload路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 大文件分片上传\n\n\n# 前端思路\n\n# 文件切片\n\n我们选择文件是使用的input输入框，获取到选择的值也很简单。不熟悉的同学请补补课，文件切片的核心就是文件对象的slice 方法，类似数组，我们可以调用这个方法获取到文件的某一段，不熟悉file对象的同学请补补课。\n\n# 文件唯一值\n\n现在有一个比较大的问题，我们如何告诉后端，我们上传的两个文件是不是同一个文件，显然，如果使用文件名作为唯一标识肯定不太好。这个时候我们想到可以使用md5对文件加密获取唯一的hash值。\n\n生成hash值的方法我们是调用 spark-md5 这个库，在计算hash的时候是非常消耗计算机的CPU的会造成浏览器的卡顿，为了优化体验我们使用 web-worker 在 worker 线程计算 hash，不熟悉的同学请补补课。其实我也不太熟悉 ╯︿╰\n\n新建hash.js文件用来计算hash\n\n// 导入脚本\nself.importScripts('/spark-md5.js');\n\n// 生成文件 hash\nself.onmessage = (e) => {\n  const { fileChunkList } = e.data;\n  const spark = new self.SparkMD5.ArrayBuffer();\n  let percentage = 0;\n  let count = 0;\n  const loadNext = (index) => {\n    const reader = new FileReader();\n    reader.readAsArrayBuffer(fileChunkList[index].file);\n    reader.onload = (e) => {\n      count++;\n      spark.append(e.target.result);\n      if (count === fileChunkList.length) {\n        self.postMessage({\n          percentage: 100,\n          hash: spark.end(),\n        });\n        self.close();\n      } else {\n        percentage += 100 / fileChunkList.length;\n        self.postMessage({\n          percentage,\n        });\n        // 递归计算下一个切片\n        loadNext(count);\n      }\n    };\n  };\n  loadNext(0);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在 worker 线程中，接受文件切片 fileChunkList，利用 FileReader 读取每个切片的 ArrayBuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postMessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程\n\n# 文件上传\n\n假设我们的文件切片全部是上传成功了，这个时候服务端是不会主动的帮助我们合并切片，我们需要在发送一个合并切片的请求通知服务端帮助我们发送切片。\n\n# 定义数据结构\n\nok，现在我们可以获取到文件也可以分片并且确保文件的唯一性，这个时候为了保证项目的完整性，我们来定义一下数据结构。\n\n文件对象：\n\t+ 我们就使用 原生的File 对象，不做过多的改变\n\t\n切片(chunk)对象：\n\t+ chunk :对应我们file.slice返回的切片\n\t+ size :chunk.size\n\t+ index：当前块是文件中的下标\n\t+ fileHash :文件的hash值\n\t+ chunkHash :分片之后片的hash值--\x3e这里我们使用 `${fileHash}-${index}` 作为块的hash值\n\t+ percentage:当前块上传的进度\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 代码实现\n\n<template>\n  <h1>大文件上传</h1>\n  <input type=\"file\" @change=\"handleFileChange\" />\n  <el-button @click=\"handleUpload\">上传</el-button>\n</template>\n<script>\nconst SIZE = 3 * 1024 * 1024; // 定义切片的大小\nexport default {\n  data() {\n    return {\n      file: null, // 文件\n      hash: '', // 文件的hash\n      chunkList: [], // 切片列表\n    };\n  },\n  methods: {\n    handleFileChange(e) {\n      const [file] = e.target.files;\n      if (!file) {\n        this.file = null;\n        return;\n      }\n      this.file = file;\n    },\n    // 生成文件切片\n    createFileChunk(file, size = SIZE) {\n      const fileChunkList = [];\n      let cur = 0;\n      while (cur < file.size) {\n        // file.slice 返回一个 blob对象\n        fileChunkList.push({ file: file.slice(cur, cur + size) });\n        cur += size;\n      }\n      return fileChunkList;\n    },\n    // 上传文件切片\n    async uploadChunks(uploadedList = []) {\n      // 构造请求列表\n      const requestList = this.chunkList\n        .map(({ chunk, chunkHash, index, fileHash }) => {\n          const formData = new FormData();\n          formData.append('chunk', chunk);\n          formData.append('chunkHash', chunkHash);\n          formData.append('fileHash', fileHash);\n          return { formData, index };\n        })\n        .map(async ({ formData, index }) =>\n          this.request({\n            url: 'http://localhost:8080/upload-chunk',\n            method: 'post',\n            data: formData,\n          })\n        );\n      await Promise.all(requestList); // 并发切片\n      await this.mergeRequest(); // 合并切片\n    },\n    // 通知服务的合并切片\n    async mergeRequest() {\n      await this.request({\n        url: 'http://localhost:8080/merge',\n        method: 'post',\n        headers: { 'content-type': 'application/json' },\n        data: JSON.stringify({ filename: this.file.name, fileSize: this.file.size, size: SIZE, hash: this.hash }),\n      });\n    },\n    //  上传按钮点击事件\n    async handleUpload() {\n      if (!this.file) {\n        console.log('请选择一个文件吧');\n        return;\n      }\n      // 文件分片\n      const fileChunkList = this.createFileChunk(this.file);\n      // 计算文件hash\n      this.hash = await this.calculateHash(fileChunkList);\n      // 构建 chunkList  添加下标以及 上传进度(是每一个chunk的上传进度)\n      this.chunkList = fileChunkList.map(({ file }, index) => ({\n        chunk: file,\n        size: file.size,\n        chunkHash: `${this.hash}-${index}`,\n        fileHash: this.hash,\n        index,\n        percentage: uploadedList.includes(`${this.hash}-${index}`) ? 100 : 0,\n      }));\n      // 上传 chunk\n      await this.uploadChunks(uploadedList);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n# 后端思路\n\n上面的分析可知，我们后端首先是要接受传过来的 chunk 将他们存在指定的目录下，最后在接收到合并请求的时候需要将chunks 合并成一个原始的文件\n\n这里我们规定一个文件上传成功之后的最终目录结构将会是一下结构\n\n+ target\n\t+ fileHash-chunks\n\t\t+ chunkHash\n\tfile\n\n\n1\n2\n3\n4\n\n\n我们将所有的文件保存在 target目录下，以fileHash-chunks命名一个文件加来存放我们一个文件对应的所有的chunk，在合并之后，将所有的 chunk 合并成 以 fileHash命名的文件，(PS:文件夹我们加了一个后缀是因为系统不允许有同名的文件和文件夹，一开始在这踩坑了好久)。如果没看懂我的描述的话，就看下面的代码吧，上面主要是对逻辑的一些约束。\n\n# 配置 koa-body\n\napp.use(koaBody({ multipart: true, formidable: { maxFileSize: 200 * 1024 * 1024 } }));\n\n\n1\n\n\n# upload 路由\n\nconst router = require('koa-router')();\nconst path = require('path');\nconst fse = require('fs-extra');\n\n// 大文件存储目录\nconst UPLOAD_DIR = path.resolve(__dirname, '..', 'target');\n// 提取文件后缀名\nconst extractExt = (filename) => filename.slice(filename.lastIndexOf('.'), filename.length);\n\n/**\n * 针对 path 创建 readStream 并写入 writeStream,写入完成之后删除文件\n * @param {String} path\n * @param {String} writeStream\n */\nconst pipeStream = (path, writeStream) =>\n  new Promise((resolve) => {\n    const readStream = fse.createReadStream(path);\n    readStream.on('end', () => {\n      fse.unlinkSync(path);\n      resolve();\n    });\n    readStream.pipe(writeStream);\n  });\n\n/**\n * 读取所有的 chunk 合并到 filePath 中\n * @param {String} filePath 文件存储路径\n * @param {String} chunkDir chunk存储文件夹名称\n * @param {String} size 每一个chunk的大小\n */\nasync function mergeFileChunk(filePath, chunkDir, size) {\n  // 获取chunk列表\n  const chunkPaths = await fse.readdir(chunkDir);\n  // 根据切片下标进行排序  否则直接读取目录的获得的顺序可能会错乱\n  chunkPaths.sort((a, b) => a.split('-')[1] - b.split('-')[1]);\n  await Promise.all(\n    chunkPaths.map((chunkPath, index) =>\n      pipeStream(\n        path.resolve(chunkDir, chunkPath),\n        // 指定位置创建可写流\n        fse.createWriteStream(filePath, {\n          start: index * size,\n          end: (index + 1) * size,\n        })\n      )\n    )\n  );\n  fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录\n}\n\n// 上传 chunk\nrouter.post('/upload-chunk', async (ctx, next) => {\n  const { chunkHash, fileHash } = ctx.request.body;\n  const { chunk } = ctx.request.files;\n  const chunkDir = path.resolve(UPLOAD_DIR, `${fileHash}-chunks`);\n  // 切片目录不存在，创建切片目录\n  if (!fse.existsSync(chunkDir)) {\n    await fse.mkdirs(chunkDir);\n  }\n  await fse.move(chunk.path, `${chunkDir}/${chunkHash}`);\n  ctx.body = { code: 0, data: '', msg: '上传成功' };\n});\n\n// 合并\nrouter.post('/merge', async (ctx, next) => {\n  const { filename, fileSize, size, hash } = ctx.request.body;\n  const ext = extractExt(filename);\n  const filePath = path.resolve(UPLOAD_DIR, `${hash}${ext}`);\n  const chunkDir = path.resolve(UPLOAD_DIR, `${hash}-chunks`);\n  await mergeFileChunk(filePath, chunkDir, size);\n  ctx.body = { code: 0, data: '', msg: '合并成功' };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n至此一个简单的大文件上传就完成了。\n\n\n# 进度条功能\n\n上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度\n\n# 切片进度条\n\nXMLHttpRequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onProgress 参数，给 XMLHttpRequest 注册监听事件\n\n每一个切片都需要对应一个上传的进度，这个时候应该写一个方法针对切片对象进行进度条的除了，\n\n// item是我们的chunk对象\ncreateProgressHandler(item) {\n  return (e) => {\n    item.percentage = parseInt(String((e.loaded / e.total) * 100));\n  };\n},\n// 在上传切片的时候 给 onProgress参数绑定上这个方法就可以了\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件的进度条\n\n将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 Vue 计算属性\n\ncomputed: {\n  // 针对每一个 chunk的进度 计算出总的上传进度\n  uploadPercentage() {\n    if (!this.file || !this.chunkList.length) return 0;\n    const loaded = this.chunkList.map((item) => item.size * item.percentage).reduce((acc, cur) => acc + cur);\n    return parseInt((loaded / this.file.size).toFixed(2));\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n大文件上传的基本功能就差不多完成了。\n\n之后的功能我就不贴代码了 写一下代码规范和思路，具体代码我之后在贴出来。\n\n\n# 文件秒传\n\n这个功能的意思就是说，我们在文件上传之前，去问一下服务器，你有没有这个文件呀，你没有的话我就开始上传，你要是有的话我就偷个懒，用你有的我就不上传了。\n\n所以需要实现一个检测接口(verify)，去询问服务器有没有这个文件，因为我们之前是计算过文件的 hash的，能保证文件的唯一性。就用这个hash就能唯一的判断这个文件。所以这个接口的思路也很简单，就是判断我们的 target目录下是否存在这个文件。\n\n\n# 断点续传\n\n断点续传的意思就是我们上传的时候如果文件上传失败了，我们之后在上传一次的时候，只上传我们之前失败的文件，成功的文件我们就跳过。\n\n# 暂停上传\n\n我们先自己手动实现一个按钮，点击之后就停止当前的上传情况。模拟了上传失败\n\n这个思路肯定就是要改装我们的 request方法，在改装之前我们需要知道 XMLHttpRequest对象是可以自己主动停止当前的网络连接的，不知道的同学补补课。\n\n这样我们只需要使用一个公共的数组，每一次发请求的时候都保存我们当前的这个XMLHttpRequest对象，当请求成功之后，我们就移除这个对象，当点击暂停按钮的时候我们就遍历这个数组调用每一个XMLHttpRequest的abrot方法就可以取消上传了。\n\n# 恢复上传\n\n恢复上传其实也就是重新开始上传，只不过我们上传的chunk数组需要是服务器中之前没有上传成功的。这就有了两点需求\n\n * 知道服务器上传成功了哪些chunk\n * 上传chunk之前需要将成功的chunk移除\n\n针对需求1我们改装之前的妙传接口，在这个接口不仅要告诉我们服务器是否存在这个文件，还需要告诉我们当前文件的块上传了成功多少。换而言之也就是获取到 target下的 fileHash-chunks 文件夹中的文件名称列表 并返回。\n\n需求2我们只需要在构建chunk数组的时候判断当前chunk是否上传了，上传了的需要修改 进度为100。在上传chunk的时候，只有当前chunk没有上传的时候才发起request。\n\n\n# 总结\n\n至此我们的大文件上传就完成了。\n\n完整代码\n\n参考文章\n\n# 提出问题\n\n * 没有处理切片上传失败的情况\n * 上传文件的时候 切片太多导致发送的网络请求太多的话浏览器可能崩溃\n * 文件太大的话计算hash就会十分十分卡顿 哪怕我们使用了 web worker\n * 能不能做一个反向的（超大文件下载）\n\n\n# 优化\n\n\n# 超大文件 hash计算时间过长问题\n\n一开始是借鉴 React中Fiber的实现，将计算hash值的过程使用requestIdleCallback进行改进，发现文件太大了的话还是会卡顿很久。最终，我们打算使用抽样思路来计算hash，放弃一部的准确度来换取时间\n\n思路：设置一个小一点的大小比如 2M\n\n * 我们在计算hash的时候，将超大文件以2M进行分割获得到另一个chunks数组，\n * 第一个元素(chunks[0])和最后一个元素(chunks[-1])我们全要了\n * 其他的元素(chunks[1,2,3,4....])我们再次进行一个分割，这个时候的分割是一个超小的大小比如2kb，我们取每一个元素的头部，尾部，中间的2kb。\n * 最终将它们组成一个新的文件，我们全量计算这个新的文件的hash值。\n\n\n\n这个时候计算超大文件的hash就不会特别耗时了，注意计算hash是用的抽样计算，但是上传我们还是用的之前的切片方法\n\n改造后计算 hash的方法\n\n// 使用 web-worker 计算 hash\ncalculateHash(fileChunkList) {\nreturn new Promise((resolve) => {\n  // 添加 worker 属性\n  // this.worker = new Worker('/hash.js');\n  // this.worker.postMessage({ fileChunkList });\n  // this.worker.onmessage = (e) => {\n  //   const { percentage, hash } = e.data;\n  //   this.hashPercentage = percentage;\n  //   if (hash) {\n  //     resolve(hash);\n  //   }\n  // };\n  const spark = new SparkMD5.ArrayBuffer();\n  const reader = new FileReader();\n  const file = this.file;\n  // 文件大小\n  const size = this.file.size;\n  let offset = 2 * 1024 * 1024;\n  let chunks = [file.slice(0, offset)];\n  // 前面100K\n  let cur = offset;\n  while (cur < size) {\n    // 最后一块全部加进来\n    if (cur + offset >= size) {\n      chunks.push(file.slice(cur, cur + offset));\n    } else {\n      // 中间的 前中后去两个字节\n      const mid = cur + offset / 2;\n      const end = cur + offset;\n      chunks.push(file.slice(cur, cur + 2));\n      chunks.push(file.slice(mid, mid + 2));\n      chunks.push(file.slice(end - 2, end));\n    }\n    // 前取两个字节\n    cur += offset;\n  }\n  // 拼接\n  reader.readAsArrayBuffer(new Blob(chunks));\n  reader.onload = (e) => {\n    spark.append(e.target.result);\n    this.hashPercentage = 100;\n    resolve(spark.end());\n  };\n});\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 文件切片过多导致并发http请求过多问题\n\n一开始是使用 Promise.all(requestList)，如果有100个网络请求就会导致在那一瞬间浏览器要创建100个网络请求，浏览器就会十分卡顿。\n\n这个时候我们需要控制并发数量，在同一时刻，我们最多只能发送 max个网络请求，用一个while循环，每一个发送一个网络请求max--，只有max大于0 的时候才继续发送，当请求得到响应之后，有两种情况，一个是我们已经发送的请求数量不够，那我们就继续发送网络请求，另一种是需要发送的网络请求发送完了，那我们就直接结束这个while循环了\n\n修改后的代码如下\n\n// 控制并发数量\nasync sendRequest(forms, max = 4) {\n  return new Promise((resolve) => {\n    const len = forms.length;\n    let idx = 0;\n    let counter = 0;\n    const start = async () => {\n      // 有请求，有通道\n      while (idx < len && max > 0) {\n        max--; // 占用通道\n        console.log(idx, 'start');\n        let { formData, index } = forms[idx];\n        idx++;\n        await this.request({\n          url: 'http://localhost:8080/upload-chunk',\n          method: 'post',\n          data: formData,\n          onProgress: this.createProgressHandler(this.chunkList[index]),\n          requestList: this.requestList,\n        }).then(() => {\n          max++; // 释放通道\n          counter++;\n          if (counter === len) {\n            resolve();\n          } else {\n            start();\n          }\n        });\n      }\n    };\n    start();\n  });\n},\n// 上传文件切片\nasync uploadChunks(uploadedList = []) {\n  // 构造请求列表\n  const requestList = this.chunkList\n    .filter((chunk) => !uploadedList.includes(chunk.chunkHash))\n    .map(({ chunk, chunkHash, index, fileHash }) => {\n      const formData = new FormData();\n      formData.append('chunk', chunk);\n      formData.append('chunkHash', chunkHash);\n      formData.append('fileHash', fileHash);\n      return { formData, index };\n    });\n  // .map(async ({ formData, index }) =>\n  //   this.request({\n  //     url: 'http://localhost:8080/upload-chunk',\n  //     method: 'post',\n  //     data: formData,\n  //     onProgress: this.createProgressHandler(this.chunkList[index]),\n  //     requestList: this.requestList,\n  //   })\n  // );\n  // 等待全部发送完成\n  // await Promise.all(requestList); // 并发切片\n  // 控制并发\n  await this.sendRequest(requestList, 4);\n  // chunk 全部发送完成了需要通知后台去合并切片\n  if (uploadedList.length + requestList.length === this.chunkList.length) {\n    await this.mergeRequest();\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 切片上传失败问题\n\n需求：\n\n * 第一次发送错误之后需要有发送失败提示\n * 第一次发送失败之后我们再进行3次的重传--\x3e也就是一个请求最多发送4次\n * 3次重传失败需要有提示\n * 需要将所有的请求都经过上面做法之后才能只能下一步\n\n第一步，我们定义一个状态，每一个请求都对应这下面的4种状态中的一个，一开始所有的请求都是 wait等待状态，发生错误时候变成error状态，3次重传都失败了之后变成fail状态，请求成功变成done完成状态\n\nconst Status = { wait: 1, error: 2, done: 3, fail: 4 };\n\n\n1\n\n\n这里有一个等量关系一定要记牢，所有的请求数 = wait+error+done+fail，而且最终状态只有 done和fail\n\n下面来编写代码，首先改造一下我们的request方法，因为这个方法选择请求失败了并不会给我们错误反馈，请求失败了我们就reject一下\n\nxhr.onreadystatechange = function () {\n  if (xhr.readyState === 4) {\n    if (xhr.status === 200) {\n      // 响应成功\n    } else {\n      // 控制进度\n      onProgress({ loaded: 0, total: 100 });\n      // 错误处理\n      reject(xhr.statusText);\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接下来，我们改造我们的并发请求的方法，让他能够进行重试，因为需要知道重试的次数，我们需要定义一个数组保存请求的重试次数，retryArr[1]=2 表示我们第一个网络请求发送了2次重试，在一开始，我们就不遍历form数组了，我们针对状态进行查找，只要是error和wait状态的请求我们就进行发送，当找不到了就表明我们现在所有的状态已经变成done和fail了，我们就reject，然后我们在 catch中进行捕获并标记重传次数，超过3次就将状态标记成失败状态。\n\nasync sendRequest(forms, max = 4) {\n  return new Promise((resolve, reject) => {\n    const len = forms.length;\n    let counter = 0; // 已经发送成功的请求\n    const retryArr = []; // 记录错误的次数\n    // 一开始将所有的表单状态置为等待\n    forms.forEach((item) => (item.status = Status.wait));\n    const start = async () => {\n      // 有请求，有通道\n      while (counter < len && max > 0) {\n        max--; // 占用通道\n        // 只要是没有完成的我们就重发\n        let idx = forms.findIndex((v) => v.status == Status.wait || v.status == Status.error);\n        if (idx == -1) {\n          // 找不到失败状态和等待状态\n          return reject();\n        }\n        let { formData, index } = forms[idx];\n        await this.request({\n          url: 'http://localhost:8080/upload-chunk',\n          method: 'post',\n          data: formData,\n          onProgress: this.createProgressHandler(this.chunkList[index]),\n          requestList: this.requestList,\n        })\n          .then(() => {\n            forms[idx].status = Status.done;\n            max++; // 释放通道\n            counter++;\n            if (counter === len) {\n              resolve();\n            }\n          })\n          .catch(() => {\n            forms[idx].status = Status.error;\n            if (typeof retryArr[index] !== 'number') {\n              this.$message.info(`第 ${index} 个块上传失败，系统准备重试`);\n              retryArr[index] = 0;\n            }\n            // 次数累加\n            retryArr[index]++;\n            // 一个请求报错3次的\n            if (retryArr[index] > 3) {\n              this.$message.error(`第 ${index} 个块重试多次无效，放弃上传`);\n              forms[idx].status = Status.fail;\n            }\n            max++; // 释放通道\n          });\n      }\n    };\n    start();\n  });\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n整体代码就在上面了，还是十分推荐大家重新自己写一下的，因为我这个菜鸟在写的时候还踩了好多的坑点，写了好久才写完的。\n\n\n# chunk定期清理\n\n很多同学肯定会问，chunk不是合并之后就全部删除掉了吗，为什么还要定期清理了，经过项目的长时间应用之后我们发现，有的同学测试我们这个代码的时候，上传大文件失败了就不管他了，导致这个大文件因为没有完全上传成功就没有进行合并和chunk清理。\n\n所以需求就来了，需要我们检测文件的改动时间，才一段时间没有改动的话我们就认为这个chunk是用户不在需要的，我们就会主动清理他。\n\n整体：定时任务，文件检测，文件操作\n\n直接上代码了，程序是只执行的，只要在app.js中引入一下就行了。\n\nconst fse = require('fs-extra');\nconst path = require('path');\nconst schedule = require('node-schedule');\n// 大文件存储目录\nconst UPLOAD_DIR = path.resolve(__dirname, '..', 'target');\n\n// 空文件删除\nfunction remove(file, stats) {\n  const now = new Date().getTime();\n  const offset = now - stats.ctimeMs;\n  if (offset > 1000 * 60) {\n    // 大于60秒的碎片\n    fse.unlinkSync(file);\n    console.log(file, '文件以过期，删除完毕');\n  }\n}\n\nasync function scan(dir, callback) {\n  const files = fse.readdirSync(dir);\n  files.forEach((filename) => {\n    const fileDir = path.resolve(dir, filename);\n    const stats = fse.statSync(fileDir);\n    if (stats.isDirectory()) {\n      // 删除文件\n      scan(fileDir, remove);\n      // 删除空的文件夹\n      if (fse.readdirSync(fileDir).length == 0) {\n        fse.rmdirSync(fileDir);\n      }\n      return;\n    }\n    if (callback) {\n      callback(fileDir, stats);\n    }\n  });\n}\n\n// * * * * * *\n// ┬ ┬ ┬ ┬ ┬ ┬\n// │ │ │ │ │ │\n// │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)\n// │ │ │ │ └───── month (1 - 12)\n// │ │ │ └────────── day of month (1 - 31)\n// │ │ └─────────────── hour (0 - 23)\n// │ └──────────────────── minute (0 - 59)\n// └───────────────────────── second (0 - 59, OPTIONAL)\nlet start = function () {\n  // 每5秒\n  schedule.scheduleJob('*/5 * * * * *', function () {\n    console.log('定时清理chunks开始');\n    scan(UPLOAD_DIR);\n  });\n};\n\nstart();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",normalizedContent:"# 大文件上传技术实现\n\n\n# 需求分析\n\n针对大文件上传，我们希望最少做到一下几点\n\n * 大文件切割，分片上传\n * 如果有部分切片上传失败了，我们希望提醒用户重新上传，并且上传成功不需要上传\n * 最好能有上传的进度提示\n\n\n# 项目架构\n\n本次项目前台我们打算使用 vite+vue3+element-plus，后台使用koa框架\n\n\n# vite 创建 vue3 项目\n\n// https://cn.vitejs.dev/guide/#scaffolding-your-first-vite-project\n// 执行下面一条语句就创建完成了 好快啊\nyarn create vite big-upload --template vue\ncd big-upload-ui\n// 安装需要的库\nyarn add element-plus\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# koa脚手架 创建后台项目\n\n// koa2脚手架\nnpm install koa-generator -g\n// 脚手架创建项目\nkoa2 server\ncd server\nyarn\n// 安装对应的库\nyarn add koa-body fs-extra\n// 删去一些不需要使用的文件  全局引入koa-body 并且配置  创建upload路由\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 大文件分片上传\n\n\n# 前端思路\n\n# 文件切片\n\n我们选择文件是使用的input输入框，获取到选择的值也很简单。不熟悉的同学请补补课，文件切片的核心就是文件对象的slice 方法，类似数组，我们可以调用这个方法获取到文件的某一段，不熟悉file对象的同学请补补课。\n\n# 文件唯一值\n\n现在有一个比较大的问题，我们如何告诉后端，我们上传的两个文件是不是同一个文件，显然，如果使用文件名作为唯一标识肯定不太好。这个时候我们想到可以使用md5对文件加密获取唯一的hash值。\n\n生成hash值的方法我们是调用 spark-md5 这个库，在计算hash的时候是非常消耗计算机的cpu的会造成浏览器的卡顿，为了优化体验我们使用 web-worker 在 worker 线程计算 hash，不熟悉的同学请补补课。其实我也不太熟悉 ╯︿╰\n\n新建hash.js文件用来计算hash\n\n// 导入脚本\nself.importscripts('/spark-md5.js');\n\n// 生成文件 hash\nself.onmessage = (e) => {\n  const { filechunklist } = e.data;\n  const spark = new self.sparkmd5.arraybuffer();\n  let percentage = 0;\n  let count = 0;\n  const loadnext = (index) => {\n    const reader = new filereader();\n    reader.readasarraybuffer(filechunklist[index].file);\n    reader.onload = (e) => {\n      count++;\n      spark.append(e.target.result);\n      if (count === filechunklist.length) {\n        self.postmessage({\n          percentage: 100,\n          hash: spark.end(),\n        });\n        self.close();\n      } else {\n        percentage += 100 / filechunklist.length;\n        self.postmessage({\n          percentage,\n        });\n        // 递归计算下一个切片\n        loadnext(count);\n      }\n    };\n  };\n  loadnext(0);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在 worker 线程中，接受文件切片 filechunklist，利用 filereader 读取每个切片的 arraybuffer 并不断传入 spark-md5 中，每计算完一个切片通过 postmessage 向主线程发送一个进度事件，全部完成后将最终的 hash 发送给主线程\n\n# 文件上传\n\n假设我们的文件切片全部是上传成功了，这个时候服务端是不会主动的帮助我们合并切片，我们需要在发送一个合并切片的请求通知服务端帮助我们发送切片。\n\n# 定义数据结构\n\nok，现在我们可以获取到文件也可以分片并且确保文件的唯一性，这个时候为了保证项目的完整性，我们来定义一下数据结构。\n\n文件对象：\n\t+ 我们就使用 原生的file 对象，不做过多的改变\n\t\n切片(chunk)对象：\n\t+ chunk :对应我们file.slice返回的切片\n\t+ size :chunk.size\n\t+ index：当前块是文件中的下标\n\t+ filehash :文件的hash值\n\t+ chunkhash :分片之后片的hash值--\x3e这里我们使用 `${filehash}-${index}` 作为块的hash值\n\t+ percentage:当前块上传的进度\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 代码实现\n\n<template>\n  <h1>大文件上传</h1>\n  <input type=\"file\" @change=\"handlefilechange\" />\n  <el-button @click=\"handleupload\">上传</el-button>\n</template>\n<script>\nconst size = 3 * 1024 * 1024; // 定义切片的大小\nexport default {\n  data() {\n    return {\n      file: null, // 文件\n      hash: '', // 文件的hash\n      chunklist: [], // 切片列表\n    };\n  },\n  methods: {\n    handlefilechange(e) {\n      const [file] = e.target.files;\n      if (!file) {\n        this.file = null;\n        return;\n      }\n      this.file = file;\n    },\n    // 生成文件切片\n    createfilechunk(file, size = size) {\n      const filechunklist = [];\n      let cur = 0;\n      while (cur < file.size) {\n        // file.slice 返回一个 blob对象\n        filechunklist.push({ file: file.slice(cur, cur + size) });\n        cur += size;\n      }\n      return filechunklist;\n    },\n    // 上传文件切片\n    async uploadchunks(uploadedlist = []) {\n      // 构造请求列表\n      const requestlist = this.chunklist\n        .map(({ chunk, chunkhash, index, filehash }) => {\n          const formdata = new formdata();\n          formdata.append('chunk', chunk);\n          formdata.append('chunkhash', chunkhash);\n          formdata.append('filehash', filehash);\n          return { formdata, index };\n        })\n        .map(async ({ formdata, index }) =>\n          this.request({\n            url: 'http://localhost:8080/upload-chunk',\n            method: 'post',\n            data: formdata,\n          })\n        );\n      await promise.all(requestlist); // 并发切片\n      await this.mergerequest(); // 合并切片\n    },\n    // 通知服务的合并切片\n    async mergerequest() {\n      await this.request({\n        url: 'http://localhost:8080/merge',\n        method: 'post',\n        headers: { 'content-type': 'application/json' },\n        data: json.stringify({ filename: this.file.name, filesize: this.file.size, size: size, hash: this.hash }),\n      });\n    },\n    //  上传按钮点击事件\n    async handleupload() {\n      if (!this.file) {\n        console.log('请选择一个文件吧');\n        return;\n      }\n      // 文件分片\n      const filechunklist = this.createfilechunk(this.file);\n      // 计算文件hash\n      this.hash = await this.calculatehash(filechunklist);\n      // 构建 chunklist  添加下标以及 上传进度(是每一个chunk的上传进度)\n      this.chunklist = filechunklist.map(({ file }, index) => ({\n        chunk: file,\n        size: file.size,\n        chunkhash: `${this.hash}-${index}`,\n        filehash: this.hash,\n        index,\n        percentage: uploadedlist.includes(`${this.hash}-${index}`) ? 100 : 0,\n      }));\n      // 上传 chunk\n      await this.uploadchunks(uploadedlist);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n\n# 后端思路\n\n上面的分析可知，我们后端首先是要接受传过来的 chunk 将他们存在指定的目录下，最后在接收到合并请求的时候需要将chunks 合并成一个原始的文件\n\n这里我们规定一个文件上传成功之后的最终目录结构将会是一下结构\n\n+ target\n\t+ filehash-chunks\n\t\t+ chunkhash\n\tfile\n\n\n1\n2\n3\n4\n\n\n我们将所有的文件保存在 target目录下，以filehash-chunks命名一个文件加来存放我们一个文件对应的所有的chunk，在合并之后，将所有的 chunk 合并成 以 filehash命名的文件，(ps:文件夹我们加了一个后缀是因为系统不允许有同名的文件和文件夹，一开始在这踩坑了好久)。如果没看懂我的描述的话，就看下面的代码吧，上面主要是对逻辑的一些约束。\n\n# 配置 koa-body\n\napp.use(koabody({ multipart: true, formidable: { maxfilesize: 200 * 1024 * 1024 } }));\n\n\n1\n\n\n# upload 路由\n\nconst router = require('koa-router')();\nconst path = require('path');\nconst fse = require('fs-extra');\n\n// 大文件存储目录\nconst upload_dir = path.resolve(__dirname, '..', 'target');\n// 提取文件后缀名\nconst extractext = (filename) => filename.slice(filename.lastindexof('.'), filename.length);\n\n/**\n * 针对 path 创建 readstream 并写入 writestream,写入完成之后删除文件\n * @param {string} path\n * @param {string} writestream\n */\nconst pipestream = (path, writestream) =>\n  new promise((resolve) => {\n    const readstream = fse.createreadstream(path);\n    readstream.on('end', () => {\n      fse.unlinksync(path);\n      resolve();\n    });\n    readstream.pipe(writestream);\n  });\n\n/**\n * 读取所有的 chunk 合并到 filepath 中\n * @param {string} filepath 文件存储路径\n * @param {string} chunkdir chunk存储文件夹名称\n * @param {string} size 每一个chunk的大小\n */\nasync function mergefilechunk(filepath, chunkdir, size) {\n  // 获取chunk列表\n  const chunkpaths = await fse.readdir(chunkdir);\n  // 根据切片下标进行排序  否则直接读取目录的获得的顺序可能会错乱\n  chunkpaths.sort((a, b) => a.split('-')[1] - b.split('-')[1]);\n  await promise.all(\n    chunkpaths.map((chunkpath, index) =>\n      pipestream(\n        path.resolve(chunkdir, chunkpath),\n        // 指定位置创建可写流\n        fse.createwritestream(filepath, {\n          start: index * size,\n          end: (index + 1) * size,\n        })\n      )\n    )\n  );\n  fse.rmdirsync(chunkdir); // 合并后删除保存切片的目录\n}\n\n// 上传 chunk\nrouter.post('/upload-chunk', async (ctx, next) => {\n  const { chunkhash, filehash } = ctx.request.body;\n  const { chunk } = ctx.request.files;\n  const chunkdir = path.resolve(upload_dir, `${filehash}-chunks`);\n  // 切片目录不存在，创建切片目录\n  if (!fse.existssync(chunkdir)) {\n    await fse.mkdirs(chunkdir);\n  }\n  await fse.move(chunk.path, `${chunkdir}/${chunkhash}`);\n  ctx.body = { code: 0, data: '', msg: '上传成功' };\n});\n\n// 合并\nrouter.post('/merge', async (ctx, next) => {\n  const { filename, filesize, size, hash } = ctx.request.body;\n  const ext = extractext(filename);\n  const filepath = path.resolve(upload_dir, `${hash}${ext}`);\n  const chunkdir = path.resolve(upload_dir, `${hash}-chunks`);\n  await mergefilechunk(filepath, chunkdir, size);\n  ctx.body = { code: 0, data: '', msg: '合并成功' };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n至此一个简单的大文件上传就完成了。\n\n\n# 进度条功能\n\n上传进度分两种，一个是每个切片的上传进度，另一个是整个文件的上传进度，而整个文件的上传进度是基于每个切片上传进度计算而来，所以我们先实现切片的上传进度\n\n# 切片进度条\n\nxmlhttprequest 原生支持上传进度的监听，只需要监听 upload.onprogress 即可，我们在原来的 request 基础上传入 onprogress 参数，给 xmlhttprequest 注册监听事件\n\n每一个切片都需要对应一个上传的进度，这个时候应该写一个方法针对切片对象进行进度条的除了，\n\n// item是我们的chunk对象\ncreateprogresshandler(item) {\n  return (e) => {\n    item.percentage = parseint(string((e.loaded / e.total) * 100));\n  };\n},\n// 在上传切片的时候 给 onprogress参数绑定上这个方法就可以了\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件的进度条\n\n将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件的上传进度，所以这里使用 vue 计算属性\n\ncomputed: {\n  // 针对每一个 chunk的进度 计算出总的上传进度\n  uploadpercentage() {\n    if (!this.file || !this.chunklist.length) return 0;\n    const loaded = this.chunklist.map((item) => item.size * item.percentage).reduce((acc, cur) => acc + cur);\n    return parseint((loaded / this.file.size).tofixed(2));\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n大文件上传的基本功能就差不多完成了。\n\n之后的功能我就不贴代码了 写一下代码规范和思路，具体代码我之后在贴出来。\n\n\n# 文件秒传\n\n这个功能的意思就是说，我们在文件上传之前，去问一下服务器，你有没有这个文件呀，你没有的话我就开始上传，你要是有的话我就偷个懒，用你有的我就不上传了。\n\n所以需要实现一个检测接口(verify)，去询问服务器有没有这个文件，因为我们之前是计算过文件的 hash的，能保证文件的唯一性。就用这个hash就能唯一的判断这个文件。所以这个接口的思路也很简单，就是判断我们的 target目录下是否存在这个文件。\n\n\n# 断点续传\n\n断点续传的意思就是我们上传的时候如果文件上传失败了，我们之后在上传一次的时候，只上传我们之前失败的文件，成功的文件我们就跳过。\n\n# 暂停上传\n\n我们先自己手动实现一个按钮，点击之后就停止当前的上传情况。模拟了上传失败\n\n这个思路肯定就是要改装我们的 request方法，在改装之前我们需要知道 xmlhttprequest对象是可以自己主动停止当前的网络连接的，不知道的同学补补课。\n\n这样我们只需要使用一个公共的数组，每一次发请求的时候都保存我们当前的这个xmlhttprequest对象，当请求成功之后，我们就移除这个对象，当点击暂停按钮的时候我们就遍历这个数组调用每一个xmlhttprequest的abrot方法就可以取消上传了。\n\n# 恢复上传\n\n恢复上传其实也就是重新开始上传，只不过我们上传的chunk数组需要是服务器中之前没有上传成功的。这就有了两点需求\n\n * 知道服务器上传成功了哪些chunk\n * 上传chunk之前需要将成功的chunk移除\n\n针对需求1我们改装之前的妙传接口，在这个接口不仅要告诉我们服务器是否存在这个文件，还需要告诉我们当前文件的块上传了成功多少。换而言之也就是获取到 target下的 filehash-chunks 文件夹中的文件名称列表 并返回。\n\n需求2我们只需要在构建chunk数组的时候判断当前chunk是否上传了，上传了的需要修改 进度为100。在上传chunk的时候，只有当前chunk没有上传的时候才发起request。\n\n\n# 总结\n\n至此我们的大文件上传就完成了。\n\n完整代码\n\n参考文章\n\n# 提出问题\n\n * 没有处理切片上传失败的情况\n * 上传文件的时候 切片太多导致发送的网络请求太多的话浏览器可能崩溃\n * 文件太大的话计算hash就会十分十分卡顿 哪怕我们使用了 web worker\n * 能不能做一个反向的（超大文件下载）\n\n\n# 优化\n\n\n# 超大文件 hash计算时间过长问题\n\n一开始是借鉴 react中fiber的实现，将计算hash值的过程使用requestidlecallback进行改进，发现文件太大了的话还是会卡顿很久。最终，我们打算使用抽样思路来计算hash，放弃一部的准确度来换取时间\n\n思路：设置一个小一点的大小比如 2m\n\n * 我们在计算hash的时候，将超大文件以2m进行分割获得到另一个chunks数组，\n * 第一个元素(chunks[0])和最后一个元素(chunks[-1])我们全要了\n * 其他的元素(chunks[1,2,3,4....])我们再次进行一个分割，这个时候的分割是一个超小的大小比如2kb，我们取每一个元素的头部，尾部，中间的2kb。\n * 最终将它们组成一个新的文件，我们全量计算这个新的文件的hash值。\n\n\n\n这个时候计算超大文件的hash就不会特别耗时了，注意计算hash是用的抽样计算，但是上传我们还是用的之前的切片方法\n\n改造后计算 hash的方法\n\n// 使用 web-worker 计算 hash\ncalculatehash(filechunklist) {\nreturn new promise((resolve) => {\n  // 添加 worker 属性\n  // this.worker = new worker('/hash.js');\n  // this.worker.postmessage({ filechunklist });\n  // this.worker.onmessage = (e) => {\n  //   const { percentage, hash } = e.data;\n  //   this.hashpercentage = percentage;\n  //   if (hash) {\n  //     resolve(hash);\n  //   }\n  // };\n  const spark = new sparkmd5.arraybuffer();\n  const reader = new filereader();\n  const file = this.file;\n  // 文件大小\n  const size = this.file.size;\n  let offset = 2 * 1024 * 1024;\n  let chunks = [file.slice(0, offset)];\n  // 前面100k\n  let cur = offset;\n  while (cur < size) {\n    // 最后一块全部加进来\n    if (cur + offset >= size) {\n      chunks.push(file.slice(cur, cur + offset));\n    } else {\n      // 中间的 前中后去两个字节\n      const mid = cur + offset / 2;\n      const end = cur + offset;\n      chunks.push(file.slice(cur, cur + 2));\n      chunks.push(file.slice(mid, mid + 2));\n      chunks.push(file.slice(end - 2, end));\n    }\n    // 前取两个字节\n    cur += offset;\n  }\n  // 拼接\n  reader.readasarraybuffer(new blob(chunks));\n  reader.onload = (e) => {\n    spark.append(e.target.result);\n    this.hashpercentage = 100;\n    resolve(spark.end());\n  };\n});\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 文件切片过多导致并发http请求过多问题\n\n一开始是使用 promise.all(requestlist)，如果有100个网络请求就会导致在那一瞬间浏览器要创建100个网络请求，浏览器就会十分卡顿。\n\n这个时候我们需要控制并发数量，在同一时刻，我们最多只能发送 max个网络请求，用一个while循环，每一个发送一个网络请求max--，只有max大于0 的时候才继续发送，当请求得到响应之后，有两种情况，一个是我们已经发送的请求数量不够，那我们就继续发送网络请求，另一种是需要发送的网络请求发送完了，那我们就直接结束这个while循环了\n\n修改后的代码如下\n\n// 控制并发数量\nasync sendrequest(forms, max = 4) {\n  return new promise((resolve) => {\n    const len = forms.length;\n    let idx = 0;\n    let counter = 0;\n    const start = async () => {\n      // 有请求，有通道\n      while (idx < len && max > 0) {\n        max--; // 占用通道\n        console.log(idx, 'start');\n        let { formdata, index } = forms[idx];\n        idx++;\n        await this.request({\n          url: 'http://localhost:8080/upload-chunk',\n          method: 'post',\n          data: formdata,\n          onprogress: this.createprogresshandler(this.chunklist[index]),\n          requestlist: this.requestlist,\n        }).then(() => {\n          max++; // 释放通道\n          counter++;\n          if (counter === len) {\n            resolve();\n          } else {\n            start();\n          }\n        });\n      }\n    };\n    start();\n  });\n},\n// 上传文件切片\nasync uploadchunks(uploadedlist = []) {\n  // 构造请求列表\n  const requestlist = this.chunklist\n    .filter((chunk) => !uploadedlist.includes(chunk.chunkhash))\n    .map(({ chunk, chunkhash, index, filehash }) => {\n      const formdata = new formdata();\n      formdata.append('chunk', chunk);\n      formdata.append('chunkhash', chunkhash);\n      formdata.append('filehash', filehash);\n      return { formdata, index };\n    });\n  // .map(async ({ formdata, index }) =>\n  //   this.request({\n  //     url: 'http://localhost:8080/upload-chunk',\n  //     method: 'post',\n  //     data: formdata,\n  //     onprogress: this.createprogresshandler(this.chunklist[index]),\n  //     requestlist: this.requestlist,\n  //   })\n  // );\n  // 等待全部发送完成\n  // await promise.all(requestlist); // 并发切片\n  // 控制并发\n  await this.sendrequest(requestlist, 4);\n  // chunk 全部发送完成了需要通知后台去合并切片\n  if (uploadedlist.length + requestlist.length === this.chunklist.length) {\n    await this.mergerequest();\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 切片上传失败问题\n\n需求：\n\n * 第一次发送错误之后需要有发送失败提示\n * 第一次发送失败之后我们再进行3次的重传--\x3e也就是一个请求最多发送4次\n * 3次重传失败需要有提示\n * 需要将所有的请求都经过上面做法之后才能只能下一步\n\n第一步，我们定义一个状态，每一个请求都对应这下面的4种状态中的一个，一开始所有的请求都是 wait等待状态，发生错误时候变成error状态，3次重传都失败了之后变成fail状态，请求成功变成done完成状态\n\nconst status = { wait: 1, error: 2, done: 3, fail: 4 };\n\n\n1\n\n\n这里有一个等量关系一定要记牢，所有的请求数 = wait+error+done+fail，而且最终状态只有 done和fail\n\n下面来编写代码，首先改造一下我们的request方法，因为这个方法选择请求失败了并不会给我们错误反馈，请求失败了我们就reject一下\n\nxhr.onreadystatechange = function () {\n  if (xhr.readystate === 4) {\n    if (xhr.status === 200) {\n      // 响应成功\n    } else {\n      // 控制进度\n      onprogress({ loaded: 0, total: 100 });\n      // 错误处理\n      reject(xhr.statustext);\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n接下来，我们改造我们的并发请求的方法，让他能够进行重试，因为需要知道重试的次数，我们需要定义一个数组保存请求的重试次数，retryarr[1]=2 表示我们第一个网络请求发送了2次重试，在一开始，我们就不遍历form数组了，我们针对状态进行查找，只要是error和wait状态的请求我们就进行发送，当找不到了就表明我们现在所有的状态已经变成done和fail了，我们就reject，然后我们在 catch中进行捕获并标记重传次数，超过3次就将状态标记成失败状态。\n\nasync sendrequest(forms, max = 4) {\n  return new promise((resolve, reject) => {\n    const len = forms.length;\n    let counter = 0; // 已经发送成功的请求\n    const retryarr = []; // 记录错误的次数\n    // 一开始将所有的表单状态置为等待\n    forms.foreach((item) => (item.status = status.wait));\n    const start = async () => {\n      // 有请求，有通道\n      while (counter < len && max > 0) {\n        max--; // 占用通道\n        // 只要是没有完成的我们就重发\n        let idx = forms.findindex((v) => v.status == status.wait || v.status == status.error);\n        if (idx == -1) {\n          // 找不到失败状态和等待状态\n          return reject();\n        }\n        let { formdata, index } = forms[idx];\n        await this.request({\n          url: 'http://localhost:8080/upload-chunk',\n          method: 'post',\n          data: formdata,\n          onprogress: this.createprogresshandler(this.chunklist[index]),\n          requestlist: this.requestlist,\n        })\n          .then(() => {\n            forms[idx].status = status.done;\n            max++; // 释放通道\n            counter++;\n            if (counter === len) {\n              resolve();\n            }\n          })\n          .catch(() => {\n            forms[idx].status = status.error;\n            if (typeof retryarr[index] !== 'number') {\n              this.$message.info(`第 ${index} 个块上传失败，系统准备重试`);\n              retryarr[index] = 0;\n            }\n            // 次数累加\n            retryarr[index]++;\n            // 一个请求报错3次的\n            if (retryarr[index] > 3) {\n              this.$message.error(`第 ${index} 个块重试多次无效，放弃上传`);\n              forms[idx].status = status.fail;\n            }\n            max++; // 释放通道\n          });\n      }\n    };\n    start();\n  });\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n整体代码就在上面了，还是十分推荐大家重新自己写一下的，因为我这个菜鸟在写的时候还踩了好多的坑点，写了好久才写完的。\n\n\n# chunk定期清理\n\n很多同学肯定会问，chunk不是合并之后就全部删除掉了吗，为什么还要定期清理了，经过项目的长时间应用之后我们发现，有的同学测试我们这个代码的时候，上传大文件失败了就不管他了，导致这个大文件因为没有完全上传成功就没有进行合并和chunk清理。\n\n所以需求就来了，需要我们检测文件的改动时间，才一段时间没有改动的话我们就认为这个chunk是用户不在需要的，我们就会主动清理他。\n\n整体：定时任务，文件检测，文件操作\n\n直接上代码了，程序是只执行的，只要在app.js中引入一下就行了。\n\nconst fse = require('fs-extra');\nconst path = require('path');\nconst schedule = require('node-schedule');\n// 大文件存储目录\nconst upload_dir = path.resolve(__dirname, '..', 'target');\n\n// 空文件删除\nfunction remove(file, stats) {\n  const now = new date().gettime();\n  const offset = now - stats.ctimems;\n  if (offset > 1000 * 60) {\n    // 大于60秒的碎片\n    fse.unlinksync(file);\n    console.log(file, '文件以过期，删除完毕');\n  }\n}\n\nasync function scan(dir, callback) {\n  const files = fse.readdirsync(dir);\n  files.foreach((filename) => {\n    const filedir = path.resolve(dir, filename);\n    const stats = fse.statsync(filedir);\n    if (stats.isdirectory()) {\n      // 删除文件\n      scan(filedir, remove);\n      // 删除空的文件夹\n      if (fse.readdirsync(filedir).length == 0) {\n        fse.rmdirsync(filedir);\n      }\n      return;\n    }\n    if (callback) {\n      callback(filedir, stats);\n    }\n  });\n}\n\n// * * * * * *\n// ┬ ┬ ┬ ┬ ┬ ┬\n// │ │ │ │ │ │\n// │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is sun)\n// │ │ │ │ └───── month (1 - 12)\n// │ │ │ └────────── day of month (1 - 31)\n// │ │ └─────────────── hour (0 - 23)\n// │ └──────────────────── minute (0 - 59)\n// └───────────────────────── second (0 - 59, optional)\nlet start = function () {\n  // 每5秒\n  schedule.schedulejob('*/5 * * * * *', function () {\n    console.log('定时清理chunks开始');\n    scan(upload_dir);\n  });\n};\n\nstart();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n",charsets:{cjk:!0},lastUpdated:"2023/05/17, 21:42:53",lastUpdatedTimestamp:1684330973e3},{title:"移动端H5-iPhone安全距离适配",frontmatter:{title:"移动端H5-iPhone安全距离适配",date:"2022-02-11T23:48:02.000Z",permalink:"/pages/a7d5db/",categories:["更多","进阶"],tags:["CSS"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/61.%E7%A7%BB%E5%8A%A8%E7%AB%AFH5-iPhone%E5%AE%89%E5%85%A8%E8%B7%9D%E7%A6%BB%E9%80%82%E9%85%8D.html",relativePath:"55.更多/02.进阶/61.移动端H5-iPhone安全距离适配.md",key:"v-7be86aa5",path:"/pages/a7d5db/",headers:[{level:3,title:"安全区域？",slug:"安全区域",normalizedTitle:"安全区域？",charIndex:2},{level:3,title:"viewport-fit",slug:"viewport-fit",normalizedTitle:"viewport-fit",charIndex:190},{level:3,title:"env() 和 constant()",slug:"env-和-constant",normalizedTitle:"env() 和 constant()",charIndex:495},{level:3,title:"如何适配",slug:"如何适配",normalizedTitle:"如何适配",charIndex:1131},{level:4,title:"第一步：设置网页在可视窗口的布局方式",slug:"第一步-设置网页在可视窗口的布局方式",normalizedTitle:"第一步：设置网页在可视窗口的布局方式",charIndex:1171},{level:4,title:"第二步：页面主体内容限定在安全区域内",slug:"第二步-页面主体内容限定在安全区域内",normalizedTitle:"第二步：页面主体内容限定在安全区域内",charIndex:1353},{level:4,title:"第三步：fixed 元素的适配",slug:"第三步-fixed-元素的适配",normalizedTitle:"第三步：fixed 元素的适配",charIndex:1536},{level:4,title:"else",slug:"else",normalizedTitle:"else",charIndex:1936}],headersStr:"安全区域？ viewport-fit env() 和 constant() 如何适配 第一步：设置网页在可视窗口的布局方式 第二步：页面主体内容限定在安全区域内 第三步：fixed 元素的适配 else",content:'# 安全区域？\n\n安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（Home Indicator）影响，如下图蓝色区域：\n\n\n\n也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档：Human Interface Guidelines - iPhoneX\n\n\n# viewport-fit\n\niOS11 新增特性，苹果公司为了适配 iPhoneX 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：\n\n * contain: 可视窗口完全包含网页内容（左图）\n * cover：网页内容完全覆盖可视窗口（右图）\n * auto：默认值，跟 contain 表现一致\n\n> 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iPhoneX 必须设置 viewport-fit=cover，这是适配的关键步骤。\n\n更详细说明，参考文档：viewport-fit-descriptor\n\n\n# env() 和 constant()\n\niOS11 新增特性，Webkit 的一个 CSS 函数，用于设定安全区域与边界的距离，有四个预定义的变量：\n\n * safe-area-inset-left：安全区域距离左边边界距离\n * safe-area-inset-right：安全区域距离右边边界距离\n * safe-area-inset-top：安全区域距离顶部边界距离\n * safe-area-inset-bottom：安全区域距离底部边界距离\n\n这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。\n\n> 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。\n\n需要做向后兼容，像这样：\n\npadding-bottom: constant( safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\npadding-bottom: env( safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n\n\n1\n2\n\n\n注意：env() 跟 constant() 需要同时存在，而且顺序不能换。\n\n更详细说明，参考文档：Designing Websites for iPhone X\n\n\n# 如何适配\n\n了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。\n\n# 第一步：设置网页在可视窗口的布局方式\n\n新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：\n\n<meta name="viewport" content="width=device-width, viewport-fit=cover">\n\n\n1\n\n\n前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。\n\n# 第二步：页面主体内容限定在安全区域内\n\n这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。\n\nbody {\npadding-bottom: constant(safe-area-inset-bottom);\npadding-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n# 第三步：fixed 元素的适配\n\n类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：\n\n可以通过加内边距 padding 扩展高度：\n\n{\npadding-bottom: constant(safe-area-inset-bottom);\npadding-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n或者通过计算函数 calc 覆盖原来高度：\n\n{\nheight: calc(60px(假设值) + constant(safe-area-inset-bottom));\nheight: calc(60px(假设值) + env(safe-area-inset-bottom));\n}\n\n\n1\n2\n3\n4\n\n\n> 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。\n\n# else\n\n# 类型一\n\n还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：\n\n{\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n空的颜色块：\n\n{\nposition: fixed;\nbottom: 0;\nwidth: 100%;\nheight: constant(safe-area-inset-bottom);\nheight: env(safe-area-inset-bottom);\nbackground-color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 类型二\n\nfixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等 像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：\n\n{\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：\n\n{\nbottom: calc(50px(假设值) + constant(safe-area-inset-bottom));\nbottom: calc(50px(假设值) + env(safe-area-inset-bottom));\n}\n\n\n1\n2\n3\n4\n\n\n# @supports 隔离兼容样式\n\n写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iPhoneX 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：\n\n@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {\ndiv {\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'# 安全区域？\n\n安全区域指的是一个可视窗口范围，处于安全区域的内容不受圆角（corners）、齐刘海（sensor housing）、小黑条（home indicator）影响，如下图蓝色区域：\n\n\n\n也就是说，我们要做好适配，必须保证页面可视、可操作区域是在安全区域内。 更详细说明，参考文档：human interface guidelines - iphonex\n\n\n# viewport-fit\n\nios11 新增特性，苹果公司为了适配 iphonex 对现有 viewport meta 标签的一个扩展，用于设置网页在可视窗口的布局方式，可设置三个值：\n\n * contain: 可视窗口完全包含网页内容（左图）\n * cover：网页内容完全覆盖可视窗口（右图）\n * auto：默认值，跟 contain 表现一致\n\n> 注意：网页默认不添加扩展的表现是 viewport-fit=contain，需要适配 iphonex 必须设置 viewport-fit=cover，这是适配的关键步骤。\n\n更详细说明，参考文档：viewport-fit-descriptor\n\n\n# env() 和 constant()\n\nios11 新增特性，webkit 的一个 css 函数，用于设定安全区域与边界的距离，有四个预定义的变量：\n\n * safe-area-inset-left：安全区域距离左边边界距离\n * safe-area-inset-right：安全区域距离右边边界距离\n * safe-area-inset-top：安全区域距离顶部边界距离\n * safe-area-inset-bottom：安全区域距离底部边界距离\n\n这里我们只需要关注 safe-area-inset-bottom 这个变量，因为它对应的就是小黑条的高度（横竖屏时值不一样）。\n\n> 注意：当 viewport-fit=contain 时 env() 是不起作用的，必须要配合 viewport-fit=cover 使用。对于不支持env() 的浏览器，浏览器将会忽略它。\n\n需要做向后兼容，像这样：\n\npadding-bottom: constant( safe-area-inset-bottom); /* 兼容 ios < 11.2 */\npadding-bottom: env( safe-area-inset-bottom); /* 兼容 ios >= 11.2 */\n\n\n1\n2\n\n\n注意：env() 跟 constant() 需要同时存在，而且顺序不能换。\n\n更详细说明，参考文档：designing websites for iphone x\n\n\n# 如何适配\n\n了解了以上所说的几个知识点，接下来我们适配的思路就很清晰了。\n\n# 第一步：设置网页在可视窗口的布局方式\n\n新增 viweport-fit 属性，使得页面内容完全覆盖整个窗口：\n\n<meta name="viewport" content="width=device-width, viewport-fit=cover">\n\n\n1\n\n\n前面也有提到过，只有设置了 viewport-fit=cover，才能使用 env()。\n\n# 第二步：页面主体内容限定在安全区域内\n\n这一步根据实际页面场景选择，如果不设置这个值，可能存在小黑条遮挡页面最底部内容的情况。\n\nbody {\npadding-bottom: constant(safe-area-inset-bottom);\npadding-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n# 第三步：fixed 元素的适配\n\n类型一：fixed 完全吸底元素（bottom = 0），比如下图这两种情况：\n\n可以通过加内边距 padding 扩展高度：\n\n{\npadding-bottom: constant(safe-area-inset-bottom);\npadding-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n或者通过计算函数 calc 覆盖原来高度：\n\n{\nheight: calc(60px(假设值) + constant(safe-area-inset-bottom));\nheight: calc(60px(假设值) + env(safe-area-inset-bottom));\n}\n\n\n1\n2\n3\n4\n\n\n> 注意，这个方案需要吸底条必须是有背景色的，因为扩展的部分背景是跟随外容器的，否则出现镂空情况。\n\n# else\n\n# 类型一\n\n还有一种方案就是，可以通过新增一个新的元素（空的颜色块，主要用于小黑条高度的占位），然后吸底元素可以不改变高度只需要调整位置，像这样：\n\n{\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n空的颜色块：\n\n{\nposition: fixed;\nbottom: 0;\nwidth: 100%;\nheight: constant(safe-area-inset-bottom);\nheight: env(safe-area-inset-bottom);\nbackground-color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 类型二\n\nfixed 非完全吸底元素（bottom = 0），比如 “返回顶部”、“侧边广告” 等 像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：\n\n{\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n\n\n1\n2\n3\n4\n\n\n或者，你也可以通过计算函数 calc 覆盖原来 bottom 值：\n\n{\nbottom: calc(50px(假设值) + constant(safe-area-inset-bottom));\nbottom: calc(50px(假设值) + env(safe-area-inset-bottom));\n}\n\n\n1\n2\n3\n4\n\n\n# @supports 隔离兼容样式\n\n写到这里，我们常见的两种类型的 fixed 元素适配方案已经了解了吧。如果我们只希望 iphonex 才需要新增适配样式，我们可以配合 @supports 来隔离兼容样式，当然这个处理对页面展示实际不会有任何影响：\n\n@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {\ndiv {\nmargin-bottom: constant(safe-area-inset-bottom);\nmargin-bottom: env(safe-area-inset-bottom);\n}\n}\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"移动端适配方案",frontmatter:{title:"移动端适配方案",date:"2022-02-02T20:11:49.000Z",permalink:"/pages/4546c7/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/60.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88.html",relativePath:"55.更多/02.进阶/60.移动端适配方案.md",key:"v-45374f90",path:"/pages/4546c7/",headers:[{level:3,title:"媒体查询 @media",slug:"媒体查询-media",normalizedTitle:"媒体查询 @media",charIndex:2},{level:3,title:"rem 适配方案",slug:"rem-适配方案",normalizedTitle:"rem 适配方案",charIndex:496},{level:4,title:"1. 使用 flexible",slug:"_1-使用-flexible",normalizedTitle:"1. 使用 flexible",charIndex:762},{level:4,title:"2. postcss-pxtorem 插件",slug:"_2-postcss-pxtorem-插件",normalizedTitle:"2. postcss-pxtorem 插件",charIndex:1320},{level:3,title:"viewport 适配方案",slug:"viewport-适配方案",normalizedTitle:"viewport 适配方案",charIndex:1390},{level:4,title:"1. 设置 meta 标签",slug:"_1-设置-meta-标签",normalizedTitle:"1. 设置 meta 标签",charIndex:1562},{level:4,title:"2. px 自动转换为 vw",slug:"_2-px-自动转换为-vw",normalizedTitle:"2. px 自动转换为 vw",charIndex:1842},{level:4,title:"3. 标注不需要转换的属性",slug:"_3-标注不需要转换的属性",normalizedTitle:"3. 标注不需要转换的属性",charIndex:3030}],headersStr:"媒体查询 @media rem 适配方案 1. 使用 flexible 2. postcss-pxtorem 插件 viewport 适配方案 1. 设置 meta 标签 2. px 自动转换为 vw 3. 标注不需要转换的属性",content:"# 媒体查询 @media\n\nCSS3 中的媒体查询属性 @media 分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性，示例如下所示：\n\n/* <375px */\n@media screen and (max-width:375px) { \n  .box {\n    width: 100%;\n  }\n}\n/* >=375px and <450px */\n@media screen and (min-width:375px) and (max-width:450px) {\n  .box {\n    width: 90%;\n  }\n}\n/* >=450px */\n@media screen and (min-width:450px) {\n  .col{\n    width: 80%;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n缺点：\n\n>  1. 页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，代价有点高。\n>  2. 如果再多一种屏幕尺寸，就得多写一个 @media 查询块。\n\n\n# rem 适配方案\n\nrem 是 CSS3 新增的一个相对单位，它是一个相对于页面根元素 html 的 font-size 的一个单位。\n\n假如设置了根元素 html 的 font-size 为 18px，那么 1rem 等于 18px，rem 的大小会随着根元素 html 的 font-size 的改变而改变。rem 方案就是利用了这一点，根据不同的屏幕尺寸，来设置不同的根元素 html 的 font-size 的大小，以此来达到适配不同屏幕尺寸的目的。\n\n目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。\n\n# 1. 使用 flexible\n\nflexible 方案是阿里早期开源的一个移动端适配解决方案，引用 flexible 后，我们在页面上统一使用 rem 来布局。我们创建一个 rem.js 文件：\n\n// 封装一个根据屏幕尺寸自动改变 html 的 font-size 大小的函数\nconst init = function () {\n  let clientWidth =\n    document.documentElement.clientWidth || document.body.clientWidth;\n  // 设计图尺寸是 750px，这样 *20 之后，1rem 就等于 20px;\n  const fontSize = (clientWidth / 750 * 20);\n  document.documentElement.style.fontSize = fontSize + \"px\";\n};\n\ninit();\n\nwindow.addEventListener(\"resize\", init);\nexport default init;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 mian.js 中引入就能够使用了，需要自己手动将 px 转换为 rem\n\n# 2. postcss-pxtorem 插件\n\n参考：通过插件postcss-pxtorem轻松实现px到rem转换，完成移动端适配\n\n\n# viewport 适配方案\n\nviewport 是指视窗、视口，即浏览器用来显示网页的那部分区域。\n\nviewport 方案使用 vw/vh 作为样式单位。vw/vh 将 viewport 分成了一百等份，1vw 等于视口 1% 的宽度，1vh 等于视口 1% 的高度。当我们的设计稿宽度是 750px 时，1vw 就等于 7.5px。\n\n# 1. 设置 meta 标签\n\n对于手机浏览器浏览页面，常对 viewport 进行如下设置即可：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes\">\n\n\n1\n\n\ninitial-scale：初始缩放比例，即当浏览器第一次加载页面时的缩放比例。 maximum-scale：允许浏览者缩放到的最大比例，一般设为1.0。 user-scalable：浏览者是否可以手动缩放，yes或no。\n\n# 2. px 自动转换为 vw\n\n使用插件 postcss-px-to-viewport 进行相关配置，就可以帮助我们将 px 自动转化为 vw，提高开发效率。\n\n使用 npm 或 yarn 安装：\n\nnpm install postcss-px-to-viewport --save-dev\n\n\n1\n\n\n或者\n\nyarn add -D postcss-px-to-viewport\n\n\n1\n\n\nwebpack 配置：\n\nmodule.exports = {\n  plugins: {\n    // ...\n    'postcss-px-to-viewport': {\n      // options\n      unitToConvert: 'px',    // 需要转换的单位，默认为\"px\"\n      viewportWidth: 750,     // 设计稿的视窗宽度\n      unitPrecision: 4,       // 单位转换后保留的精度\n      propList: ['*', '!font-size'],        // 能转化为 vw 的属性列表\n      viewportUnit: 'vw',     // 希望使用的视窗单位\n      fontViewportUnit: 'vw', // 字体使用的视窗单位\n      selectorBlackList: [],  // 需要忽略的 CSS 选择器，不会转为视窗单位，使用原有的 px 等单位\n      minPixelValue: 1,       // 设置最小的转换数值，如果为 1 的话，只有大于 1 的值会被转换\n      mediaQuery: false,      // 媒体查询里的单位是否需要转换单位\n      replace: true,          // 是否直接更换属性值，而不添加备用属性\n      exclude: undefined,     // 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件\n      include: /\\/src\\//,     // 如果设置了include，那将只有匹配到的文件才会被转换\n      landscape: false,       // 是否添加根据 landscapeWidth 生成的媒体查询条件\n      landscapeUnit: 'vw',    // 横屏时使用的单位\n      landscapeWidth: 1125,   // 横屏时使用的视窗宽度\n    },\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3. 标注不需要转换的属性\n\n在项目中，如果设计师要求某一场景不做适配，需为固定的宽高或大小，这时我们就需要利用 postcss-px-to-viewport 插件的 ignoring 特性，对不需要转换的属性进行标注，如下所示：\n\n/* example input: */\n.box {\n  /* px-to-viewport-ignore-next */\n  width: 100px;\n  padding: 20px;\n  height: 100px; /* px-to-viewport-ignore */\n}\n\n/* example output: */\n.box {\n  width: 100px; \n  padding: 2.6667vw;\n  height: 100px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当然，viewport 适配方案也有一定的缺陷：px 转换成 vw 不一定能完全整除，因此有一定的像素差。",normalizedContent:"# 媒体查询 @media\n\ncss3 中的媒体查询属性 @media 分别为不同屏幕尺寸的移动设备编写不同尺寸的 css 属性，示例如下所示：\n\n/* <375px */\n@media screen and (max-width:375px) { \n  .box {\n    width: 100%;\n  }\n}\n/* >=375px and <450px */\n@media screen and (min-width:375px) and (max-width:450px) {\n  .box {\n    width: 90%;\n  }\n}\n/* >=450px */\n@media screen and (min-width:450px) {\n  .col{\n    width: 80%;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n缺点：\n\n>  1. 页面上所有的元素都得在不同的 @media 中定义一遍不同的尺寸，代价有点高。\n>  2. 如果再多一种屏幕尺寸，就得多写一个 @media 查询块。\n\n\n# rem 适配方案\n\nrem 是 css3 新增的一个相对单位，它是一个相对于页面根元素 html 的 font-size 的一个单位。\n\n假如设置了根元素 html 的 font-size 为 18px，那么 1rem 等于 18px，rem 的大小会随着根元素 html 的 font-size 的改变而改变。rem 方案就是利用了这一点，根据不同的屏幕尺寸，来设置不同的根元素 html 的 font-size 的大小，以此来达到适配不同屏幕尺寸的目的。\n\n目前，除了 ie8 及更早版本外，所有浏览器均已支持 rem。\n\n# 1. 使用 flexible\n\nflexible 方案是阿里早期开源的一个移动端适配解决方案，引用 flexible 后，我们在页面上统一使用 rem 来布局。我们创建一个 rem.js 文件：\n\n// 封装一个根据屏幕尺寸自动改变 html 的 font-size 大小的函数\nconst init = function () {\n  let clientwidth =\n    document.documentelement.clientwidth || document.body.clientwidth;\n  // 设计图尺寸是 750px，这样 *20 之后，1rem 就等于 20px;\n  const fontsize = (clientwidth / 750 * 20);\n  document.documentelement.style.fontsize = fontsize + \"px\";\n};\n\ninit();\n\nwindow.addeventlistener(\"resize\", init);\nexport default init;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在 mian.js 中引入就能够使用了，需要自己手动将 px 转换为 rem\n\n# 2. postcss-pxtorem 插件\n\n参考：通过插件postcss-pxtorem轻松实现px到rem转换，完成移动端适配\n\n\n# viewport 适配方案\n\nviewport 是指视窗、视口，即浏览器用来显示网页的那部分区域。\n\nviewport 方案使用 vw/vh 作为样式单位。vw/vh 将 viewport 分成了一百等份，1vw 等于视口 1% 的宽度，1vh 等于视口 1% 的高度。当我们的设计稿宽度是 750px 时，1vw 就等于 7.5px。\n\n# 1. 设置 meta 标签\n\n对于手机浏览器浏览页面，常对 viewport 进行如下设置即可：\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=yes\">\n\n\n1\n\n\ninitial-scale：初始缩放比例，即当浏览器第一次加载页面时的缩放比例。 maximum-scale：允许浏览者缩放到的最大比例，一般设为1.0。 user-scalable：浏览者是否可以手动缩放，yes或no。\n\n# 2. px 自动转换为 vw\n\n使用插件 postcss-px-to-viewport 进行相关配置，就可以帮助我们将 px 自动转化为 vw，提高开发效率。\n\n使用 npm 或 yarn 安装：\n\nnpm install postcss-px-to-viewport --save-dev\n\n\n1\n\n\n或者\n\nyarn add -d postcss-px-to-viewport\n\n\n1\n\n\nwebpack 配置：\n\nmodule.exports = {\n  plugins: {\n    // ...\n    'postcss-px-to-viewport': {\n      // options\n      unittoconvert: 'px',    // 需要转换的单位，默认为\"px\"\n      viewportwidth: 750,     // 设计稿的视窗宽度\n      unitprecision: 4,       // 单位转换后保留的精度\n      proplist: ['*', '!font-size'],        // 能转化为 vw 的属性列表\n      viewportunit: 'vw',     // 希望使用的视窗单位\n      fontviewportunit: 'vw', // 字体使用的视窗单位\n      selectorblacklist: [],  // 需要忽略的 css 选择器，不会转为视窗单位，使用原有的 px 等单位\n      minpixelvalue: 1,       // 设置最小的转换数值，如果为 1 的话，只有大于 1 的值会被转换\n      mediaquery: false,      // 媒体查询里的单位是否需要转换单位\n      replace: true,          // 是否直接更换属性值，而不添加备用属性\n      exclude: undefined,     // 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件\n      include: /\\/src\\//,     // 如果设置了include，那将只有匹配到的文件才会被转换\n      landscape: false,       // 是否添加根据 landscapewidth 生成的媒体查询条件\n      landscapeunit: 'vw',    // 横屏时使用的单位\n      landscapewidth: 1125,   // 横屏时使用的视窗宽度\n    },\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 3. 标注不需要转换的属性\n\n在项目中，如果设计师要求某一场景不做适配，需为固定的宽高或大小，这时我们就需要利用 postcss-px-to-viewport 插件的 ignoring 特性，对不需要转换的属性进行标注，如下所示：\n\n/* example input: */\n.box {\n  /* px-to-viewport-ignore-next */\n  width: 100px;\n  padding: 20px;\n  height: 100px; /* px-to-viewport-ignore */\n}\n\n/* example output: */\n.box {\n  width: 100px; \n  padding: 2.6667vw;\n  height: 100px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当然，viewport 适配方案也有一定的缺陷：px 转换成 vw 不一定能完全整除，因此有一定的像素差。",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"H5页面高德定位打卡功能",frontmatter:{title:"H5页面高德定位打卡功能",date:"2022-04-10T02:24:48.000Z",permalink:"/pages/587043/",categories:["更多","进阶"],tags:[null],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/02.%E8%BF%9B%E9%98%B6/62.H5%E9%A1%B5%E9%9D%A2%E9%AB%98%E5%BE%B7%E5%AE%9A%E4%BD%8D%E6%89%93%E5%8D%A1%E5%8A%9F%E8%83%BD.html",relativePath:"55.更多/02.进阶/62.H5页面高德定位打卡功能.md",key:"v-63b092c7",path:"/pages/587043/",headers:[{level:2,title:"首先注册账号并申请Key",slug:"首先注册账号并申请key",normalizedTitle:"首先注册账号并申请key",charIndex:2},{level:2,title:"申请key",slug:"申请key",normalizedTitle:"申请key",charIndex:121},{level:3,title:"进入官网",slug:"进入官网",normalizedTitle:"进入官网",charIndex:131},{level:3,title:"注册账号",slug:"注册账号",normalizedTitle:"注册账号",charIndex:4},{level:3,title:"应用管理",slug:"应用管理",normalizedTitle:"应用管理",charIndex:56},{level:3,title:"新建应用",slug:"新建应用",normalizedTitle:"新建应用",charIndex:164},{level:3,title:"添加key",slug:"添加key",normalizedTitle:"添加key",charIndex:175},{level:3,title:"选择web端 （JS API）",slug:"选择web端-js-api",normalizedTitle:"选择web端 （js api）",charIndex:187},{level:3,title:"获取KEY",slug:"获取key",normalizedTitle:"获取key",charIndex:209},{level:2,title:"准备页面",slug:"准备页面",normalizedTitle:"准备页面",charIndex:221},{level:3,title:"结构代码",slug:"结构代码",normalizedTitle:"结构代码",charIndex:678},{level:3,title:"完整代码",slug:"完整代码",normalizedTitle:"完整代码",charIndex:4879},{level:2,title:"页面效果",slug:"页面效果",normalizedTitle:"页面效果",charIndex:9666}],headersStr:"首先注册账号并申请Key 申请key 进入官网 注册账号 应用管理 新建应用 添加key 选择web端 （JS API） 获取KEY 准备页面 结构代码 完整代码 页面效果",content:'# 首先注册账号并申请Key\n\n 1. 首先，注册开发者账号，成为高德开放平台开发者\n 2. 登陆之后，在进入「应用管理」 页面「创建新应用」\n 3. 为应用添加 Key，「服务平台」一项请选择「 Web 端 ( JSAPI ) 」\n\n\n# 申请key\n\n\n# 进入官网\n\n\n\n\n# 注册账号\n\n\n\n\n# 应用管理\n\n\n\n\n# 新建应用\n\n\n\n\n# 添加key\n\n\n\n\n# 选择web端 （JS API）\n\n\n\n\n# 获取KEY\n\n\n\n\n# 准备页面\n\n 1. 在页面添加 JS API 的入口脚本标签，并将其中「您申请的key值」替换为您刚刚申请的 key；\n\n <script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&key=你的key"><\/script>\n\n\n1\n\n 1. 添加 div 标签作为地图容器，同时为该 div 指定 id 属性；\n\n<div id="container"></div>\n\n\n1\n\n 1. 为地图容器指定高度、宽度；\n\n#container {width:300px; height: 180px; }\n\n\n1\n\n 1. 进行移动端开发时，请在 head 内添加 viewport 设置，以达到最佳的绘制性能；\n\n<meta name="viewport" content="initial-scale=1.0, user-scalable=no">\n\n\n1\n\n 1. 在完成如上准备工作之后便可以开始进行开发工作了。\n\n\n# 结构代码\n\n<template>\n  <div class="main">\n    <div id="container"></div>\n    <div class="info" @click="handleClick">打卡</div>\n  </div>\n</template>\n<script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑代码\n\nexport default {\n  data() {\n    return {\n      signzone: [118.795257, 32.06046],\n      distance: 0,\n      point: [],\n      distanceArr: [],\n      arr: [\n        {\n          lat: 32.06046,\n          lng: 118.795257,\n          r: 300,\n        },\n        {\n          lat: 32.061792,\n          lng: 118.783514,\n          r: 200,\n        },\n        {\n          lat: 32.06361,\n          lng: 118.791325,\n          r: 150,\n        },\n      ],\n    };\n  },\n  created() {},\n  computed: {},\n  mounted() {\n    this.qwe(this.arr);\n  },\n  methods: {\n    // 定位\n    qwe(arr) {\n      let that = this;\n      var map = new AMap.Map("container", {\n        resizeEnable: true,\n      });\n      AMap.plugin("AMap.Geolocation", function () {\n        var geolocation = new AMap.Geolocation({\n          enableHighAccuracy: true, // 是否使用高精度定位，默认:true\n          timeout: 10000, // 超过10秒后停止定位，默认：无穷大\n          maximumAge: 60 * 24 * 60 * 60 * 1000, // 定位结果缓存0毫秒，默认：0\n          convert: true, // 自动偏移坐标，偏移后的坐标为高德坐标，默认：true\n          showButton: true, // 显示定位按钮，默认：true\n          buttonPosition: "LB", // 定位按钮停靠位置，默认：\'LB\'，左下角\n          buttonOffset: new AMap.Pixel(20, 20), // 定位按钮与设置的停靠位置的偏移量，默认：Pixel(10, 20)\n          showMarker: true, // 定位成功后在定位到的位置显示点标记，默认：true\n          showCircle: false, // 定位成功后用圆圈表示定位精度范围，默认：true\n          panToLocation: true, // 定位成功后将定位到的位置作为地图中心点，默认：true\n          zoomToAccuracy: true, // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false\n        });\n        map.addControl(geolocation);\n        geolocation.getCurrentPosition(function (status, result) {\n          if (status == "complete") {\n            that.onComplete(result);\n          } else {\n            that.onError(result);\n          }\n        });\n        arr.forEach((item) => {\n          let circle = new AMap.Circle({\n            center: [item.lng, item.lat],\n            radius: item.r, //签到范围半径\n            borderWeight: 1,\n            strokeOpacity: 1,\n            strokeOpacity: 0.2,\n            fillOpacity: 0.4,\n          });\n          circle.setMap(map);\n          map.setFitView([circle]);\n        });\n\n        map.plugin(["AMap.CircleEditor"], function () {\n          circleEditor = new AMap.CircleEditor(map, circle);\n          circleEditor.open();\n        });\n      });\n    },\n    //解析定位结果\n    onComplete(data) {\n      console.log(data, "定位");\n      this.point = [];\n      var str = [];\n      this.point.push(data.position.lng);\n      this.point.push(data.position.lat);\n      console.log(data.position);\n      str.push("定位结果：" + data.position);\n      str.push("定位类别：" + data.location_type);\n      if (data.accuracy) {\n        str.push("精度：" + data.accuracy + " 米");\n      } //如为IP精确定位结果则没有精度信息\n      str.push("是否经过偏移：" + (data.isConverted ? "是" : "否"));\n      console.log(str);\n    //   alert("定位成功" + str);\n    },\n    //解析定位错误信息\n    onError(data) {\n      console.log("定位失败");\n      console.log(data.message);\n    //   alert("定位失败" + data.message);\n    },\n    handleClick() {\n      this.distanceArr = [];\n      this.arr.forEach((item, i) => {\n        let distance = AMap.GeometryUtil.distance(this.point, [\n          item.lng,\n          item.lat,\n        ]).toFixed(2);\n        this.distanceArr.push(distance);\n      });\n      let flge = this.arr.some((item, index) => {\n        return this.distanceArr[index] <= item.r;\n      });\n\n      if (flge) {\n        this.$message({\n          message: "打卡成功！",\n          type: "success",\n        });\n      } else {\n        this.$message({\n          message: "不在考勤范围内！",\n          type: "warning",\n        });\n      }\n      console.log(this.distanceArr, "this.distanceArr");\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n\n# 完整代码\n\n<template>\n  <div class="main">\n    <div id="container"></div>\n    <div class="info" @click="handleClick">打卡</div>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      signzone: [118.795257, 32.06046],\n      distance: 0,\n      point: [],\n      distanceArr: [],\n      arr: [\n        {\n          lat: 32.06046,\n          lng: 118.795257,\n          r: 300,\n        },\n        {\n          lat: 32.061792,\n          lng: 118.783514,\n          r: 200,\n        },\n        {\n          lat: 32.06361,\n          lng: 118.791325,\n          r: 150,\n        },\n      ],\n    };\n  },\n  created() {},\n  computed: {},\n  mounted() {\n    this.qwe(this.arr);\n  },\n  methods: {\n    // 定位\n    qwe(arr) {\n      let that = this;\n      var map = new AMap.Map("container", {\n        resizeEnable: true,\n      });\n      AMap.plugin("AMap.Geolocation", function () {\n        var geolocation = new AMap.Geolocation({\n          enableHighAccuracy: true, // 是否使用高精度定位，默认:true\n          timeout: 10000, // 超过10秒后停止定位，默认：无穷大\n          maximumAge: 60 * 24 * 60 * 60 * 1000, // 定位结果缓存0毫秒，默认：0\n          convert: true, // 自动偏移坐标，偏移后的坐标为高德坐标，默认：true\n          showButton: true, // 显示定位按钮，默认：true\n          buttonPosition: "LB", // 定位按钮停靠位置，默认：\'LB\'，左下角\n          buttonOffset: new AMap.Pixel(20, 20), // 定位按钮与设置的停靠位置的偏移量，默认：Pixel(10, 20)\n          showMarker: true, // 定位成功后在定位到的位置显示点标记，默认：true\n          showCircle: false, // 定位成功后用圆圈表示定位精度范围，默认：true\n          panToLocation: true, // 定位成功后将定位到的位置作为地图中心点，默认：true\n          zoomToAccuracy: true, // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false\n        });\n        map.addControl(geolocation);\n        geolocation.getCurrentPosition(function (status, result) {\n          if (status == "complete") {\n            that.onComplete(result);\n          } else {\n            that.onError(result);\n          }\n        });\n        arr.forEach((item) => {\n          let circle = new AMap.Circle({\n            center: [item.lng, item.lat],\n            radius: item.r, //签到范围半径\n            borderWeight: 1,\n            strokeOpacity: 1,\n            strokeOpacity: 0.2,\n            fillOpacity: 0.4,\n          });\n          circle.setMap(map);\n          map.setFitView([circle]);\n        });\n\n        map.plugin(["AMap.CircleEditor"], function () {\n          circleEditor = new AMap.CircleEditor(map, circle);\n          circleEditor.open();\n        });\n      });\n    },\n    //解析定位结果\n    onComplete(data) {\n      console.log(data, "定位");\n      this.point = [];\n      var str = [];\n      this.point.push(data.position.lng);\n      this.point.push(data.position.lat);\n      console.log(data.position);\n      str.push("定位结果：" + data.position);\n      str.push("定位类别：" + data.location_type);\n      if (data.accuracy) {\n        str.push("精度：" + data.accuracy + " 米");\n      } //如为IP精确定位结果则没有精度信息\n      str.push("是否经过偏移：" + (data.isConverted ? "是" : "否"));\n      console.log(str);\n    //   alert("定位成功" + str);\n    },\n    //解析定位错误信息\n    onError(data) {\n      console.log("定位失败");\n      console.log(data.message);\n    //   alert("定位失败" + data.message);\n    },\n    handleClick() {\n      this.distanceArr = [];\n      this.arr.forEach((item, i) => {\n        let distance = AMap.GeometryUtil.distance(this.point, [\n          item.lng,\n          item.lat,\n        ]).toFixed(2);\n        this.distanceArr.push(distance);\n      });\n      let flge = this.arr.some((item, index) => {\n        return this.distanceArr[index] <= item.r;\n      });\n\n      if (flge) {\n        this.$message({\n          message: "打卡成功！",\n          type: "success",\n        });\n      } else {\n        this.$message({\n          message: "不在考勤范围内！",\n          type: "warning",\n        });\n      }\n      console.log(this.distanceArr, "this.distanceArr");\n    },\n  },\n};\n<\/script>\n<style lang="less" scoped>\n.main {\n  position: relative;\n  .info {\n    position: absolute;\n    bottom: 20px;\n    left: 50%;\n    transform: translateX(-50%);\n    width: 100px;\n    height: 100px;\n    background-color: rgb(226, 50, 6, 0.2);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 20px;\n    color: aliceblue;\n    z-index: 999;\n  }\n}\n\n#container {\n  width: 100vw;\n  height: 100vh;\n  z-index: 9;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n\n\n\n# 页面效果\n\n\n\n',normalizedContent:'# 首先注册账号并申请key\n\n 1. 首先，注册开发者账号，成为高德开放平台开发者\n 2. 登陆之后，在进入「应用管理」 页面「创建新应用」\n 3. 为应用添加 key，「服务平台」一项请选择「 web 端 ( jsapi ) 」\n\n\n# 申请key\n\n\n# 进入官网\n\n\n\n\n# 注册账号\n\n\n\n\n# 应用管理\n\n\n\n\n# 新建应用\n\n\n\n\n# 添加key\n\n\n\n\n# 选择web端 （js api）\n\n\n\n\n# 获取key\n\n\n\n\n# 准备页面\n\n 1. 在页面添加 js api 的入口脚本标签，并将其中「您申请的key值」替换为您刚刚申请的 key；\n\n <script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&key=你的key"><\/script>\n\n\n1\n\n 1. 添加 div 标签作为地图容器，同时为该 div 指定 id 属性；\n\n<div id="container"></div>\n\n\n1\n\n 1. 为地图容器指定高度、宽度；\n\n#container {width:300px; height: 180px; }\n\n\n1\n\n 1. 进行移动端开发时，请在 head 内添加 viewport 设置，以达到最佳的绘制性能；\n\n<meta name="viewport" content="initial-scale=1.0, user-scalable=no">\n\n\n1\n\n 1. 在完成如上准备工作之后便可以开始进行开发工作了。\n\n\n# 结构代码\n\n<template>\n  <div class="main">\n    <div id="container"></div>\n    <div class="info" @click="handleclick">打卡</div>\n  </div>\n</template>\n<script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n逻辑代码\n\nexport default {\n  data() {\n    return {\n      signzone: [118.795257, 32.06046],\n      distance: 0,\n      point: [],\n      distancearr: [],\n      arr: [\n        {\n          lat: 32.06046,\n          lng: 118.795257,\n          r: 300,\n        },\n        {\n          lat: 32.061792,\n          lng: 118.783514,\n          r: 200,\n        },\n        {\n          lat: 32.06361,\n          lng: 118.791325,\n          r: 150,\n        },\n      ],\n    };\n  },\n  created() {},\n  computed: {},\n  mounted() {\n    this.qwe(this.arr);\n  },\n  methods: {\n    // 定位\n    qwe(arr) {\n      let that = this;\n      var map = new amap.map("container", {\n        resizeenable: true,\n      });\n      amap.plugin("amap.geolocation", function () {\n        var geolocation = new amap.geolocation({\n          enablehighaccuracy: true, // 是否使用高精度定位，默认:true\n          timeout: 10000, // 超过10秒后停止定位，默认：无穷大\n          maximumage: 60 * 24 * 60 * 60 * 1000, // 定位结果缓存0毫秒，默认：0\n          convert: true, // 自动偏移坐标，偏移后的坐标为高德坐标，默认：true\n          showbutton: true, // 显示定位按钮，默认：true\n          buttonposition: "lb", // 定位按钮停靠位置，默认：\'lb\'，左下角\n          buttonoffset: new amap.pixel(20, 20), // 定位按钮与设置的停靠位置的偏移量，默认：pixel(10, 20)\n          showmarker: true, // 定位成功后在定位到的位置显示点标记，默认：true\n          showcircle: false, // 定位成功后用圆圈表示定位精度范围，默认：true\n          pantolocation: true, // 定位成功后将定位到的位置作为地图中心点，默认：true\n          zoomtoaccuracy: true, // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false\n        });\n        map.addcontrol(geolocation);\n        geolocation.getcurrentposition(function (status, result) {\n          if (status == "complete") {\n            that.oncomplete(result);\n          } else {\n            that.onerror(result);\n          }\n        });\n        arr.foreach((item) => {\n          let circle = new amap.circle({\n            center: [item.lng, item.lat],\n            radius: item.r, //签到范围半径\n            borderweight: 1,\n            strokeopacity: 1,\n            strokeopacity: 0.2,\n            fillopacity: 0.4,\n          });\n          circle.setmap(map);\n          map.setfitview([circle]);\n        });\n\n        map.plugin(["amap.circleeditor"], function () {\n          circleeditor = new amap.circleeditor(map, circle);\n          circleeditor.open();\n        });\n      });\n    },\n    //解析定位结果\n    oncomplete(data) {\n      console.log(data, "定位");\n      this.point = [];\n      var str = [];\n      this.point.push(data.position.lng);\n      this.point.push(data.position.lat);\n      console.log(data.position);\n      str.push("定位结果：" + data.position);\n      str.push("定位类别：" + data.location_type);\n      if (data.accuracy) {\n        str.push("精度：" + data.accuracy + " 米");\n      } //如为ip精确定位结果则没有精度信息\n      str.push("是否经过偏移：" + (data.isconverted ? "是" : "否"));\n      console.log(str);\n    //   alert("定位成功" + str);\n    },\n    //解析定位错误信息\n    onerror(data) {\n      console.log("定位失败");\n      console.log(data.message);\n    //   alert("定位失败" + data.message);\n    },\n    handleclick() {\n      this.distancearr = [];\n      this.arr.foreach((item, i) => {\n        let distance = amap.geometryutil.distance(this.point, [\n          item.lng,\n          item.lat,\n        ]).tofixed(2);\n        this.distancearr.push(distance);\n      });\n      let flge = this.arr.some((item, index) => {\n        return this.distancearr[index] <= item.r;\n      });\n\n      if (flge) {\n        this.$message({\n          message: "打卡成功！",\n          type: "success",\n        });\n      } else {\n        this.$message({\n          message: "不在考勤范围内！",\n          type: "warning",\n        });\n      }\n      console.log(this.distancearr, "this.distancearr");\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n\n\n\n# 完整代码\n\n<template>\n  <div class="main">\n    <div id="container"></div>\n    <div class="info" @click="handleclick">打卡</div>\n  </div>\n</template>\n<script>\nexport default {\n  data() {\n    return {\n      signzone: [118.795257, 32.06046],\n      distance: 0,\n      point: [],\n      distancearr: [],\n      arr: [\n        {\n          lat: 32.06046,\n          lng: 118.795257,\n          r: 300,\n        },\n        {\n          lat: 32.061792,\n          lng: 118.783514,\n          r: 200,\n        },\n        {\n          lat: 32.06361,\n          lng: 118.791325,\n          r: 150,\n        },\n      ],\n    };\n  },\n  created() {},\n  computed: {},\n  mounted() {\n    this.qwe(this.arr);\n  },\n  methods: {\n    // 定位\n    qwe(arr) {\n      let that = this;\n      var map = new amap.map("container", {\n        resizeenable: true,\n      });\n      amap.plugin("amap.geolocation", function () {\n        var geolocation = new amap.geolocation({\n          enablehighaccuracy: true, // 是否使用高精度定位，默认:true\n          timeout: 10000, // 超过10秒后停止定位，默认：无穷大\n          maximumage: 60 * 24 * 60 * 60 * 1000, // 定位结果缓存0毫秒，默认：0\n          convert: true, // 自动偏移坐标，偏移后的坐标为高德坐标，默认：true\n          showbutton: true, // 显示定位按钮，默认：true\n          buttonposition: "lb", // 定位按钮停靠位置，默认：\'lb\'，左下角\n          buttonoffset: new amap.pixel(20, 20), // 定位按钮与设置的停靠位置的偏移量，默认：pixel(10, 20)\n          showmarker: true, // 定位成功后在定位到的位置显示点标记，默认：true\n          showcircle: false, // 定位成功后用圆圈表示定位精度范围，默认：true\n          pantolocation: true, // 定位成功后将定位到的位置作为地图中心点，默认：true\n          zoomtoaccuracy: true, // 定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false\n        });\n        map.addcontrol(geolocation);\n        geolocation.getcurrentposition(function (status, result) {\n          if (status == "complete") {\n            that.oncomplete(result);\n          } else {\n            that.onerror(result);\n          }\n        });\n        arr.foreach((item) => {\n          let circle = new amap.circle({\n            center: [item.lng, item.lat],\n            radius: item.r, //签到范围半径\n            borderweight: 1,\n            strokeopacity: 1,\n            strokeopacity: 0.2,\n            fillopacity: 0.4,\n          });\n          circle.setmap(map);\n          map.setfitview([circle]);\n        });\n\n        map.plugin(["amap.circleeditor"], function () {\n          circleeditor = new amap.circleeditor(map, circle);\n          circleeditor.open();\n        });\n      });\n    },\n    //解析定位结果\n    oncomplete(data) {\n      console.log(data, "定位");\n      this.point = [];\n      var str = [];\n      this.point.push(data.position.lng);\n      this.point.push(data.position.lat);\n      console.log(data.position);\n      str.push("定位结果：" + data.position);\n      str.push("定位类别：" + data.location_type);\n      if (data.accuracy) {\n        str.push("精度：" + data.accuracy + " 米");\n      } //如为ip精确定位结果则没有精度信息\n      str.push("是否经过偏移：" + (data.isconverted ? "是" : "否"));\n      console.log(str);\n    //   alert("定位成功" + str);\n    },\n    //解析定位错误信息\n    onerror(data) {\n      console.log("定位失败");\n      console.log(data.message);\n    //   alert("定位失败" + data.message);\n    },\n    handleclick() {\n      this.distancearr = [];\n      this.arr.foreach((item, i) => {\n        let distance = amap.geometryutil.distance(this.point, [\n          item.lng,\n          item.lat,\n        ]).tofixed(2);\n        this.distancearr.push(distance);\n      });\n      let flge = this.arr.some((item, index) => {\n        return this.distancearr[index] <= item.r;\n      });\n\n      if (flge) {\n        this.$message({\n          message: "打卡成功！",\n          type: "success",\n        });\n      } else {\n        this.$message({\n          message: "不在考勤范围内！",\n          type: "warning",\n        });\n      }\n      console.log(this.distancearr, "this.distancearr");\n    },\n  },\n};\n<\/script>\n<style lang="less" scoped>\n.main {\n  position: relative;\n  .info {\n    position: absolute;\n    bottom: 20px;\n    left: 50%;\n    transform: translatex(-50%);\n    width: 100px;\n    height: 100px;\n    background-color: rgb(226, 50, 6, 0.2);\n    border-radius: 50%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 20px;\n    color: aliceblue;\n    z-index: 999;\n  }\n}\n\n#container {\n  width: 100vw;\n  height: 100vh;\n  z-index: 9;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n\n\n\n# 页面效果\n\n\n\n',charsets:{cjk:!0},lastUpdated:"2023/05/10, 14:31:26",lastUpdatedTimestamp:1683700286e3},{title:"CSS",frontmatter:{title:"CSS",date:"2021-10-22T19:17:22.000Z",permalink:"/pages/26cc37/",categories:["更多","技术面"],tags:["CSS","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/02.CSS.html",relativePath:"55.更多/05.技术面/02.CSS.md",key:"v-6369ee9a",path:"/pages/26cc37/",headers:[{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:2},{level:3,title:"移动端适配方案",slug:"移动端适配方案",normalizedTitle:"移动端适配方案",charIndex:10},{level:4,title:"1、rem",slug:"_1、rem",normalizedTitle:"1、rem",charIndex:280},{level:3,title:"flex布局",slug:"flex布局",normalizedTitle:"flex布局",charIndex:742},{level:4,title:"1.更换主轴方向",slug:"_1-更换主轴方向",normalizedTitle:"1.更换主轴方向",charIndex:752},{level:4,title:"2.flex-wrap实现多行排列",slug:"_2-flex-wrap实现多行排列",normalizedTitle:"2.flex-wrap实现多行排列",charIndex:1029},{level:4,title:"3. flex属性",slug:"_3-flex属性",normalizedTitle:"3. flex属性",charIndex:1297},{level:4,title:"flex缩写的等值",slug:"flex缩写的等值",normalizedTitle:"flex缩写的等值",charIndex:1653},{level:3,title:"css3的新属性",slug:"css3的新属性",normalizedTitle:"css3的新属性",charIndex:1936},{level:3,title:"你对less,sass的理解，区别是什么",slug:"你对less-sass的理解-区别是什么",normalizedTitle:"你对less,sass的理解，区别是什么",charIndex:2123},{level:3,title:"回流（重排）和重绘",slug:"回流-重排-和重绘",normalizedTitle:"回流（重排）和重绘",charIndex:2342}],headersStr:"CSS 移动端适配方案 1、rem flex布局 1.更换主轴方向 2.flex-wrap实现多行排列 3. flex属性 flex缩写的等值 css3的新属性 你对less,sass的理解，区别是什么 回流（重排）和重绘",content:"# CSS\n\n\n# 移动端适配方案\n\n我们在项目中通常用到的方案有两种，分别是rem适配和vw适配。\n\n * rem适配方案实际上是通过媒体查询判断当前屏幕的大小动态的修改html根节点字体的大小。使用媒体查询需要单独设置机型，我们通常直接引入lib-flexible.js\n\n再使用：post-loader 加 postcss-pxtorem 对css文件进行转换\n\n * 使用插件 postcss-px-to-viewport 进行相关配置，就可以帮助我们将 px 自动转化为 vw\n   \n   ignoring 特性，对不需要转换的属性进行标注\n\n# 1、rem\n\nrem适配方案实际上是根据当前设备的屏幕大小动态地修改html根节点字体大小，来进行适配。\n\n原理是通过媒体查询判断当前屏幕的大小，并修改html根节点字体大小。但是不同的机型需要手写不同的方案，我们在项目中会引入lib-flexible.js文件，和px-to-rem包，就能自动实现px转rem进行动态适配了。\n\n代码如下：\n\n@media (width:375px) { //iphone6、7、8\n        html {\n          font-size: 37.5px;\n        }\n      }\n\n\n1\n2\n3\n4\n5\n\n\nbody {\n    height: (100 / 37.5rem);\n}\n\n\n1\n2\n3\n\n\n使用媒体查询需要单独设置机型，太过麻烦，建议配合flexible.js（手机淘宝团队出品）使用\n\n配合flexible.js文件使用\n\n引入js文件即可\n\n<script src=\"./js/flexible.js\"><\/script>\n\n\n1\n\n\n\n# flex布局\n\n# 1.更换主轴方向\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n> flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n# 2.flex-wrap实现多行排列\n\n弹性盒子换行显示：flex-wrap: wrap;\n\n调整行对齐方式：align-content，取值与justify-content基本相同\n\n> .box{\n> flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-wrap可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n# 3. flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n> flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-grow是如果有剩余空间，是否扩大，1为扩大 flex-shrink是如果剩余空间不够，是否缩小，1为缩小 flex-basis为项目本身的大小，默认值是auto\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n# flex缩写的等值\n\n了解了三个属性各自的含义之后，可以看下三个属性对应的等值。\n\n语法              等值\nflex: initial   flex: 0 1 auto\nflex: 0         flex: 0 1 0%\nflex: none      flex: 0 0 auto\nflex: 1         flex: 1 1 0%\nflex: auto      flex: 1 1 auto\n\n你了解flex:1，flex:auto，flex:0，flex:none的区别吗？\n\n一文搞懂flex:0,1,auto,none\n\n\n# css3的新属性\n\n * transition 过渡 二帧\n\n * transform 放大缩小\n\n * animation keyframe 帧动画\n\n * flex布局\n\n * background-size cover,contain\n\n * box-shadow 盒子阴影\n\n * text-shadow 文字阴影\n\n * border-radius 圆角\n\n\n# 你对less,sass的理解，区别是什么\n\n * 这二个都是css预处理语言，(我以前项目中二个都在用，移动端用less，PC端后台管理项目用sass )\n\n * 共同点\n   \n   * 都有变量 嵌套语法 父选择器& 混入mixin\n\n * 区别\n   \n   * 变量：less是@符开头的,sass是以$开头的\n   * sass功能要更加强大一些，因为在sass中可以在里面写条件判断和循环的，这一点less是做不到的\n\n\n# 回流（重排）和重绘\n\n * 我先给您说一下浏览器渲染工作原理\n   \n   * 首先html会被解析成dom树，css会被解析成css规则树，然后这二个东西会合并出来一个render tree(渲染树)，浏览器就会根据渲染树来进行页面绘制\n\n * 回流:DOM元素创建、移除还有尺寸(px相关)发生变化的时候，就会导致DOM树重建，渲染树重建\n\n * 重绘：一般指的颜色相关的,color,background-color这些只会导致渲染树需要重建\n\n * 回流一定会重绘，但是重绘不一定会回流\n   \n   \n\n * 这块我建议为了引导面试官，可以稍微补充一句话：我们尽量要避免重绘和回流，因为这个会影响页面性能 这个时候面试官会问一个：如何去避免重绘和回流\n   \n   * 多个属性尽量使用简写，例如：boder可以代替boder-width、boder-color、boder-style\n   * DocumentFragment,先把所有的DOM元素添加到这个东西上，然后再一次性追加到DOM树上\n   * 避免设置多层内联样式，避免节点层级过多\n   * 不要一个一个去修改行内样式，而是创建一个类名，把要修改的东西全部写在这个类名里面，然后直接给元素加上这个类名，只会有一次回流和重绘\n   * 先把这个元素隐藏，然后把样式该加的全部加上，然后最后再显示，只会有一次回流和重绘\n   * 尽量多使用CSS3新特性，比如transform,可以让页面开启gpu加速，不会导致重绘和回流\n   * 将频繁重绘或回流的节点设置为图层，图层能够阻止该节点的渲染行为影响到别的节点（例：will-change\\video\\iframe等标签），浏览器会自动将该节点变为图层",normalizedContent:"# css\n\n\n# 移动端适配方案\n\n我们在项目中通常用到的方案有两种，分别是rem适配和vw适配。\n\n * rem适配方案实际上是通过媒体查询判断当前屏幕的大小动态的修改html根节点字体的大小。使用媒体查询需要单独设置机型，我们通常直接引入lib-flexible.js\n\n再使用：post-loader 加 postcss-pxtorem 对css文件进行转换\n\n * 使用插件 postcss-px-to-viewport 进行相关配置，就可以帮助我们将 px 自动转化为 vw\n   \n   ignoring 特性，对不需要转换的属性进行标注\n\n# 1、rem\n\nrem适配方案实际上是根据当前设备的屏幕大小动态地修改html根节点字体大小，来进行适配。\n\n原理是通过媒体查询判断当前屏幕的大小，并修改html根节点字体大小。但是不同的机型需要手写不同的方案，我们在项目中会引入lib-flexible.js文件，和px-to-rem包，就能自动实现px转rem进行动态适配了。\n\n代码如下：\n\n@media (width:375px) { //iphone6、7、8\n        html {\n          font-size: 37.5px;\n        }\n      }\n\n\n1\n2\n3\n4\n5\n\n\nbody {\n    height: (100 / 37.5rem);\n}\n\n\n1\n2\n3\n\n\n使用媒体查询需要单独设置机型，太过麻烦，建议配合flexible.js（手机淘宝团队出品）使用\n\n配合flexible.js文件使用\n\n引入js文件即可\n\n<script src=\"./js/flexible.js\"><\/script>\n\n\n1\n\n\n\n# flex布局\n\n# 1.更换主轴方向\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n> flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n# 2.flex-wrap实现多行排列\n\n弹性盒子换行显示：flex-wrap: wrap;\n\n调整行对齐方式：align-content，取值与justify-content基本相同\n\n> .box{\n> flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-wrap可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n# 3. flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n> flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\nflex-grow是如果有剩余空间，是否扩大，1为扩大 flex-shrink是如果剩余空间不够，是否缩小，1为缩小 flex-basis为项目本身的大小，默认值是auto\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n# flex缩写的等值\n\n了解了三个属性各自的含义之后，可以看下三个属性对应的等值。\n\n语法              等值\nflex: initial   flex: 0 1 auto\nflex: 0         flex: 0 1 0%\nflex: none      flex: 0 0 auto\nflex: 1         flex: 1 1 0%\nflex: auto      flex: 1 1 auto\n\n你了解flex:1，flex:auto，flex:0，flex:none的区别吗？\n\n一文搞懂flex:0,1,auto,none\n\n\n# css3的新属性\n\n * transition 过渡 二帧\n\n * transform 放大缩小\n\n * animation keyframe 帧动画\n\n * flex布局\n\n * background-size cover,contain\n\n * box-shadow 盒子阴影\n\n * text-shadow 文字阴影\n\n * border-radius 圆角\n\n\n# 你对less,sass的理解，区别是什么\n\n * 这二个都是css预处理语言，(我以前项目中二个都在用，移动端用less，pc端后台管理项目用sass )\n\n * 共同点\n   \n   * 都有变量 嵌套语法 父选择器& 混入mixin\n\n * 区别\n   \n   * 变量：less是@符开头的,sass是以$开头的\n   * sass功能要更加强大一些，因为在sass中可以在里面写条件判断和循环的，这一点less是做不到的\n\n\n# 回流（重排）和重绘\n\n * 我先给您说一下浏览器渲染工作原理\n   \n   * 首先html会被解析成dom树，css会被解析成css规则树，然后这二个东西会合并出来一个render tree(渲染树)，浏览器就会根据渲染树来进行页面绘制\n\n * 回流:dom元素创建、移除还有尺寸(px相关)发生变化的时候，就会导致dom树重建，渲染树重建\n\n * 重绘：一般指的颜色相关的,color,background-color这些只会导致渲染树需要重建\n\n * 回流一定会重绘，但是重绘不一定会回流\n   \n   \n\n * 这块我建议为了引导面试官，可以稍微补充一句话：我们尽量要避免重绘和回流，因为这个会影响页面性能 这个时候面试官会问一个：如何去避免重绘和回流\n   \n   * 多个属性尽量使用简写，例如：boder可以代替boder-width、boder-color、boder-style\n   * documentfragment,先把所有的dom元素添加到这个东西上，然后再一次性追加到dom树上\n   * 避免设置多层内联样式，避免节点层级过多\n   * 不要一个一个去修改行内样式，而是创建一个类名，把要修改的东西全部写在这个类名里面，然后直接给元素加上这个类名，只会有一次回流和重绘\n   * 先把这个元素隐藏，然后把样式该加的全部加上，然后最后再显示，只会有一次回流和重绘\n   * 尽量多使用css3新特性，比如transform,可以让页面开启gpu加速，不会导致重绘和回流\n   * 将频繁重绘或回流的节点设置为图层，图层能够阻止该节点的渲染行为影响到别的节点（例：will-change\\video\\iframe等标签），浏览器会自动将该节点变为图层",charsets:{cjk:!0},lastUpdated:"2025/02/11, 00:54:52",lastUpdatedTimestamp:1739206492e3},{title:"JS",frontmatter:{title:"JS",date:"2022-03-03T14:59:21.000Z",permalink:"/pages/e4dc2c/",categories:["更多","技术面"],tags:["Javascript","面试总结"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/01.JS.html",relativePath:"55.更多/05.技术面/01.JS.md",key:"v-5fb11738",path:"/pages/e4dc2c/",headers:[{level:2,title:"回调函数的概念",slug:"回调函数的概念",normalizedTitle:"回调函数的概念",charIndex:2},{level:2,title:"数组的常用方法有哪些?",slug:"数组的常用方法有哪些",normalizedTitle:"数组的常用方法有哪些?",charIndex:699},{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:1765},{level:2,title:"new关键字的执行过程",slug:"new关键字的执行过程",normalizedTitle:"new关键字的执行过程",charIndex:2311},{level:2,title:"ES6",slug:"es6",normalizedTitle:"es6",charIndex:1238},{level:3,title:"let const",slug:"let-const",normalizedTitle:"let const",charIndex:2571},{level:3,title:"Set&Map",slug:"set-map",normalizedTitle:"set&amp;map",charIndex:null},{level:3,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:2603},{level:3,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:2594},{level:3,title:"模块化",slug:"模块化",normalizedTitle:"模块化",charIndex:2613},{level:3,title:"箭头函数和普通函数的区别",slug:"箭头函数和普通函数的区别",normalizedTitle:"箭头函数和普通函数的区别",charIndex:3408},{level:3,title:"Class",slug:"class",normalizedTitle:"class",charIndex:3568},{level:3,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:2631},{level:2,title:"for in&for of",slug:"for-in-for-of",normalizedTitle:"for in&amp;for of",charIndex:null},{level:2,title:"深浅拷贝 递归",slug:"深浅拷贝-递归",normalizedTitle:"深浅拷贝 递归",charIndex:6284},{level:2,title:"闭包",slug:"闭包",normalizedTitle:"闭包",charIndex:7523},{level:2,title:"垃圾回收机制",slug:"垃圾回收机制",normalizedTitle:"垃圾回收机制",charIndex:7766},{level:2,title:"作用域链",slug:"作用域链",normalizedTitle:"作用域链",charIndex:9249},{level:2,title:"this指向",slug:"this指向",normalizedTitle:"this指向",charIndex:2378},{level:2,title:"事件委托&事件冒泡",slug:"事件委托-事件冒泡",normalizedTitle:"事件委托&amp;事件冒泡",charIndex:null},{level:2,title:"执行栈",slug:"执行栈",normalizedTitle:"执行栈",charIndex:9856},{level:2,title:"如何理解JS的异步",slug:"如何理解js的异步",normalizedTitle:"如何理解js的异步",charIndex:10084},{level:2,title:"事件循环",slug:"事件循环",normalizedTitle:"事件循环",charIndex:10466},{level:2,title:"宏任务&微任务",slug:"宏任务-微任务",normalizedTitle:"宏任务&amp;微任务",charIndex:null},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:2070},{level:2,title:"防抖节流",slug:"防抖节流",normalizedTitle:"防抖节流",charIndex:11858},{level:2,title:"前端如何捕获错误",slug:"前端如何捕获错误",normalizedTitle:"前端如何捕获错误",charIndex:13225},{level:2,title:"数组转树形结构",slug:"数组转树形结构",normalizedTitle:"数组转树形结构",charIndex:13439},{level:2,title:"树形扁平化转数组",slug:"树形扁平化转数组",normalizedTitle:"树形扁平化转数组",charIndex:14352},{level:2,title:"无感知登录",slug:"无感知登录",normalizedTitle:"无感知登录",charIndex:15053}],headersStr:"回调函数的概念 数组的常用方法有哪些? 原型链 new关键字的执行过程 ES6 let const Set&Map 模板字符串 解构赋值 模块化 箭头函数和普通函数的区别 Class Promise for in&for of 深浅拷贝 递归 闭包 垃圾回收机制 作用域链 this指向 事件委托&事件冒泡 执行栈 如何理解JS的异步 事件循环 宏任务&微任务 继承 防抖节流 前端如何捕获错误 数组转树形结构 树形扁平化转数组 无感知登录",content:"# 回调函数的概念\n\n> fs模块\n> \n> fs.writeFile('文件路径'，'编码格式'，function(err,dataStr){})\n> \n>  * fs.writeFile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。__dirname为当前目录可以用来拼接文件路径\n>  * 第二个参数是编码格式，一边采用utf-8 国际码\n>  * 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。dataStr为读取的文件内容。\n\nJavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。 它的英语名字 callback，直译过来就是\"重新调用\"。\n\n读取文件进行处理，是这样写的。\n\n fs.readFile('/etc/passwd', function (err, data) {\n   if (err) throw err;\n   console.log(data);\n });\n\n\n1\n2\n3\n4\n\n\n上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。\n\n一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。\n\n\n# 数组的常用方法有哪些?\n\n * join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符\n * push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)\n * pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）\n * shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined\n * unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）\n * slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变\n * splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）\n * fill()：使用特定值填充数组中的一个或多个元素(修改原数组)\n * filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组\n * concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替\n * indexOf()：返回当前值在数组中第一次出现位置的索引\n * lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。\n * every()：判断数组中每一项是否都符合条件\n * some()：判断数组中是否存在满足的项\n * includes()：判断一个数组是否包含指定的值\n * sort(orderfunction):按指定的参数对数组进行排序(修改原数组)\n * reverse()：将数组反序(修改原数组)\n * forEach()：循环遍历数组每一项（没有返回值）\n * map()：循环遍历数组的每一项（有返回值）\n * copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）\n * find(): 返回第一个匹配的值，并停止查找\n * findIndex(): 返回第一个匹配值的索引，并停止查找\n * toLocaleString()、toString():将数组转换为字符串\n * flat()、flatMap()：扁平化数组\n * entries() 、keys() 、values():遍历数组\n\n\n# 原型链\n\nJS的每个函数在创建的时候，都会生成一个属性prototype，这个属性指向一个对象，这个对象就是此函数的原型对象。该原型对象中有个属性为constructor，指向该函数。\n\n每个通过构造函数创建出来的实例对象，其本身有个属性__proto__，这个属性会指向该实例对象的构造函数的原型对象，这么说好像有点绕\n\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的__proto__隐式属性，找到它的构造函数的原型对象，如果还没有找到就会再在其构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n\n原型继承：\n\n原型继承: 把父级实例化对象给到子级的原型对象\n\n再把constructor重新指向自己的构造函数\n\n原型链： 每一个对象都有自己的原型, 而原型也是对象,也会有自己的原型，此次类推形成链式结构。称之为原型链。(原型链的终点是null)\n\n对象访问原型链规则： 就近原则\n\n对象先访问自己的，自己没有就找原型的，原型没有就找原型的原型，一直到原型链终点null.如果还找不到。 属性则获取undefined, 方法则会报错 xxx is not function\n\n\n# new关键字的执行过程\n\n * 将新对象的__proto__ 指向了构造函数的原型对象（prototype）\n\n * 将构造函数内部的this指向新对象\n\n * 执行构造函数给this(实例对象)添加属性或方法\n\n * 默认return this\n   \n   如果写了return 看数据类型\n   \n   数据类型是简单数据类型: return简单数据类型忽略，最终还是return this\n   \n   如果数据类型是复杂数据类型: 最终得到是该复杂数据类型，return this无效\n\n\n# ES6\n\n * let const\n\n * 箭头函数\n\n * 解构赋值\n\n * 模板字符串\n\n * 模块化\n\n * class\n\n * Promise\n\n * Set&Map\n\n\n# let const\n\n 1. var声明的变量作用域是函数级别的，而 let 和const 声明的变量作用域是块别的，块级别作用域可以是一个函数、一对花括号或一个模块。\n\n 2. 使用var声明的变量可以在声明之前访问，但是其值为undefined，而let 和const声明的变量在声明之前访问会抛出 ReferenceError。\n\n 3. var 声明的变量可以被重复声明，而let和const声明的变量不允许重复声明。\n\n 4. 使用let声明的变量可以被重新赋值，而使用const声明的变量是不可变的，即其值不能被重新赋值\n\n 5. const声明的变量必须在声明时初始化，不能在之后赋值。\n\n\n# Set&Map\n\n\n# 模板字符串\n\n\n# 解构赋值\n\n解构赋值允许从数组或对象中快速提取值并将其分配给多个变量，简化了数据交换和属性提取。\n\n// 数组解构\n     const [first, second, , fourth] = [1, 2, 3, 4];\n     console.log(first); // 1\n     console.log(fourth); // 4\n \n// 对象解构\n     const person = { name: \"Alice\", age: 30, city: \"Seattle\" };\n     const { name, age } = person;\n     console.log(name); // \"Alice\"\n     console.log(age); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模块化\n\n默认导出是在一个模块中只导出一个，变量或者函数，但是按需导出可以导出多个变量或者函数\n\n\n# 箭头函数和普通函数的区别\n\n 1. 箭头函数this指向上下文，普通函数this看调用方式\n\n 2. 剪头函数没有arguments对象，普通函数具备arguments对象\n\n 3. 箭头函数没有prototype, 普通函数具备prototype\n\n 4. 箭头函数不能用做构造函数，普通函数可以用做构造函数\n\n\n# Class\n\nES6 引入了基于原型的类（class）语法，提供了一种更接近传统面向对象语言的类定义方式，但本质上仍然是对原有构造函数和原型链机制的封装\n\nclass Person {\n       constructor(name, age) {\n         this.name = name;\n         this.age = age;\n       }\n \n       introduce() {\n         return `My name is ${this.name}, and I am ${this.age} years old.`;\n       }\n     }\n \n     const alice = new Person(\"Alice\", 30);\n     console.log(alice.introduce()); // My name is Alice, and I am 30 years old.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# Promise\n\n概念\n\npromise是一个对象/构造函数,es6新增的,更加灵活的处理异步,也可以解决回调地狱问题\n\npromise有三种状态:pending fullfield rejected状态不可逆 pending => (resolve)fullfield，pending =>(rejecte) rejected\n\n实例方法\n\n * then方法：接收promise处理后的结果，\n   \n   * 第一个回调接收成功的结果，第二个回调用于接收失败的结果\n   * then支持链式调用，在then中可以返回新的promise，并且调用resolve，会将成功的结果传递到下一个then中，所以借助then的链式解决了回调地狱的问题\n   * 具备穿透性：在then中通过返回的promise调用resolve传递数据，下一个then如果没有通过回调进行接收，则会继续向下传递\n   * then的返回值是promise，而且then的成功回调如果返回的不是promise，也会被then的promise的resolve进行处理\n   * 终止then的成功回调的链式：reject、throw Error Promise.reject\n\n * catch方法：专门处理失败的状态\n\n * finnaly方法：都会执行\n\n静态方法\n\n * all：同时处理多个异步，语法参数为数组，数组每一项是Promise实例，只有所有异步处理成功，才会进入then的成功回调，有一个失败，进入all的then的失败回调，结果是数组，值对应的就是参数数组的顺序\n\n * allsettled：语法基本和all一致，不管处理的异步中是否调用reject，最终都会进入allsettled的成功回调，在成功的回调中，数组每一项是对象，对象会有status，状态，成功或失败，还有value就是异步处理的结果\n\n * race：语法基本和all一致，可以获取到异步处理最快的那一个，在then中通过成功回调或失败回调获取结果\n\n * any：语法基本和all一致，可以获取到异步处理成功最快的那一个\n\nasync和await\n\npromise的终极解决方案是async await\n\nawait 用来修饰promise, 当然await也可以修饰非promise，如果修饰的不是promise则会将 await后面的内容包装为promise，await的返回值会一直是promise的resolve处理，await下面的代码相当于是promise的then成功回调的代码，所以await下面的代码属于异步微任务\n\nasync用来修饰await就近的函数，被async修饰的函数，该函数返回值为promise，内部如果return数据，则该数据被promise的resolve进行处理，所以需要通过函数的then的成功回调获取期结果\n\nasync和await实际是generator的语法糖\n\nGenerator\n\n概念: 也是es6的,可以将函数的控制权交出,也可以利用generator更方便的控制异步,实际async和await就是他的语法糖\n\n区分: 星号\n\n如何交出控制权: 通过yield进行控制权交出,通过next逐步调用\n\n如何处理异步: 可以通过yield配合promise达到类似async和await的效果,通过yiled返回promise,在promise中处理异步,等异步成功调用resolve,这样在外部可以通过next.value获取到promise,通过then等待成功后,执行下一次的next\n\n而且对应的自执行generator函数有co库,可以去自执行generator\n\n区别:\n\n\n\n\n# for in&for of\n\n 1. 遍历的对象不同： for...in循环用于遍历对象的可枚举属性。它会枚举对象及其原型链上的所有属性，包括继承的属性。它主要用于遍历对象属性。 for...of循环用于遍历可迭代对象中的值，例如数组、字符串、Map、Set等。它不适用于普通对象。\n\n 2. 迭代顺序不同： for...in循环的迭代顺序是不确定的，因为它是按照对象属性的添加顺序进行迭代的，但是对象的属性顺序是不确定的。它不能保证属性的顺序。 for...of循环的迭代顺序是由迭代器决定的，通常是按照元素在集合中出现的顺序进行迭代的。\n\n 3. 迭代的值不同： for...in循环迭代的是属性名，而不是属性值。因此，要访问属性值，需要使用对象的属性访问方法，例如obj[key]。 for...of循环迭代的是值。例如，对于数组，它迭代的是数组元素的值。\n\n 4. 可以使用的对象不同： for...in循环可以用于遍历普通对象的属性。但是它不能用于遍历数组等可迭代对象，因为它会遍历数组的所有属性，包括数组的原型属性。 for...of循环只能用于遍历可迭代对象，例如数组、字符串、Map、Set等。 综上所述，for...in循环用于遍历对象的属性，而for...of循环用于遍历可迭代对象的值。在使用时需要根据不同的情况选择合适的循环结构。\n\n中断for\n\n * continue：终止该次循环，进入下一次，使用所有循环结构\n\n * break：跳出循环，执行循环后的语句，如果多层循环，只会退出当前层循环\n\n * return：终止循环，结束当前方法\n\n\n# 深浅拷贝 递归\n\n在声明基本类型的变量时，变量的值会存储在栈内存当中，声明引用类型的变量时，会在堆内存中分配一个空间来存储引用类型的值。同时，在栈中也会保存一个引用地址指向这一块空间。声明一个变量B，并且B赋值为已存在的基本类型变量a，那么它赋值的是存储在栈中的真实的值，对于引用类型而言，声明一个变量O2，并给这个O2赋值为已存在的O1，那么他赋值的是栈中的引用地址，当改变O1O2任意一个时，真正改变的是堆内存中存储的值，那么当输出O1或者O2的时候，他们输出的结果都是会发生改变的\n\n浅拷贝是新对象的属性和源对象的属性会共用同一个内存空间，浅拷贝拷贝的是地址\n\n实现方法是Object.assgin()，它会将一个或多个源对象的可枚举属性复制到目标对象中，如果目标对象中已有相同的属性，则会覆盖原有的属性值\n\n另一个实现方式是数组的浅拷贝可以使用slice()方法、concat()方法或者...展开运算符实现\n\n深拷贝是新对象的属性和源对象的属性会不会共用同一个内存空间，需要在堆内存中开辟一块新的空间来存放这个属性的值\n\n深拷贝会递归拷贝对象的所有属性，包含子对象\n\n实现方法是JSON.parse(JSON.stringify()) ，用JSON格式实现深拷贝， 将需要拷贝的对象先转为字符串，再将字符串转为新的对象，这种方法可以一次性处理整个对象，缺点是只能处理JSON支持的数据类型，不能处理函数和正则表达式\n\n递归拷贝，遍历需要拷贝的对象，对每个属性判断是否是基本数据类型如果是就直接拷贝，否则就递归调用自身进行深度拷贝\n\n使用lodash库cloneDeep方法\n\n浅拷贝方式：\n\n拷贝对象-Object.assgin()或展开运算符...{obj},\n\n拷贝数组Array.prototype.concat()\n\n深拷贝方式：\n\n 1. 使用lodash库cloneDeep方法\n\n 2. 使用JSON.parse(JSON.stringify())\n    \n    缺点：\n    \n    1. 如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；\n    2. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；\n    3. 如果obj有函数、undefined，则序列化之后的结果会把函数、undefined丢失。\n    4. 如果obj里有NaN、 Infinity和-infinity，则序列化的结果会变成null\n    5. JSON.stringify()只能序列化对象的可枚举的自有属性,例如如果obj中的对象是有构造函数生成则使用JSON.parse(JSON.stringify(obj)深拷贝后,会丢弃对象的constructor;\n    6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；\n\n 3. 递归\n\n\n# 闭包\n\n函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包\n\n闭包的作用：\n\n实现模块化：通过闭包，可以封装变量和函数，避免污染全局命名空间，实现模块化开发。\n\n实现私有变量和私有方法：通过闭包，可以创建私有变量和私有方法，避免被外部访问。\n\n缓存变量：通过闭包，可以缓存变量，避免重复计算，提高性能\n\n闭包可能引起的问题？\n\n使函数内部变量存在于内存中，闭包多的时候，内存消耗大\n\n在IE浏览器中会导致内存泄露，手动将外部变量置为null\n\n> IE浏览器采用的是引用计数垃圾回收机制。在闭包中，由于内部函数引用了外部函数的变量，导致外部函数的作用域对象无法被销毁，引用计数无法降为0，从而导致内存泄露\n> \n> 在其他浏览器中，如Chrome、Firefox等，采用的是标记清除垃圾回收机制。闭包执行完之后，如果没有其他函数引用外部函数的变量，就会把这个变量标记为不可访问，从而被回收\n\n闭包的使用场景\n\n * setTimeout传参\n   \n   * 回调\n   * 函数防抖\n\n * 封装私有变量\n   \n   * 实现类和继承\n\n为什么要使用闭包？\n\n * 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。\n\n闭包怎么实现私有变量和私有方法\n\n闭包可以通过将变量和函数定义在外部函数内部，然后在内部函数中访问这些变量和函数，从而实现私有变量和私有方法。\n\n具体实现方法如下：\n\n 1. 将需要私有的变量和函数定义在外部函数内部。\n 2. 在外部函数内部定义一个内部函数，该内部函数可以访问外部函数内部的变量和函数。\n 3. 在内部函数中定义需要暴露给外部的函数，将其作为内部函数的返回值。\n 4. 外部函数返回内部函数，从而形成闭包，内部函数可以访问外部函数的变量和函数，但是外部函数无法访问内部函数的变量和函数，从而实现私有变量和私有方法。\n\n示例代码如下：\n\nfunction outer() {\n  var privateVar = 10; // 私有变量\n  function privateFunc() { // 私有方法\n    console.log('This is a private function');\n  }\n  return {\n    publicFunc: function() { // 公有方法\n      console.log('This is a public function');\n      privateFunc();\n      console.log('Private variable:', privateVar);\n    }\n  }\n}\n\nvar obj = outer();\nobj.publicFunc(); // 输出：This is a public function\n                  // This is a private function\n                  // Private variable: 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在上述示例中，私有变量和私有方法是通过在外部函数中定义变量和函数，然后在内部函数中访问这些变量和函数，从而实现的。公有方法是通过将需要暴露给外部的函数定义在返回对象中，从而实现的。\n\n\n# 垃圾回收机制\n\nJavaScript的垃圾回收机制是自动的，它通过监视对象的引用关系来确定哪些对象是活动的，哪些对象可以被回收。当一个对象不再被引用时，它就会被标记为垃圾，等待垃圾回收器将其回收。\n\nJavaScript垃圾回收器的实现通常使用两种算法：标记清除和引用计数。\n\n * 标记清除算法：垃圾回收器会先标记所有可以访问的对象，然后清除所有未被标记的对象。\n * 引用计数算法：垃圾回收器会记录每个对象被引用的次数，当引用次数变为0时，就会回收该对象。\n\n在实际应用中，大多数浏览器都采用标记清除算法来进行垃圾回收，因为引用计数算法容易出现循环引用的情况，导致一些对象无法被回收。\n\n\n# 作用域链\n\n内部函数访问变量，先在自身作用域找声明，如果没有，往外层找，直到找到全局，如果有，采取就近原则\n\n\n# this指向\n\n\n# 事件委托&事件冒泡\n\n事件冒泡（Event Bubbling）是指当一个元素上触发某个事件时，该事件会从该元素开始向上冒泡到祖先元素，直到到达文档根节点。在事件冒泡过程中，可以通过事件对象的target属性来获取当前触发事件的元素。\n\n事件冒泡机制的优点是可以在父元素上统一处理多个子元素的事件，从而减少代码量和提高性能。同时，也可以方便地通过事件委托来实现动态绑定和解绑事件处理程序的需求。但是，如果不加以控制，事件冒泡也可能会导致意外的事件触发和处理，从而影响应用程序的稳定性和可靠性。因此，在实际应用中需要谨慎使用事件冒泡和事件委托技术，合理控制事件的传播和处理。\n\n事件委托（Event Delegation）是一种常见的优化技巧，它利用了事件的冒泡机制来减少事件处理程序的数量。事件委托的核心思想是将事件处理程序绑定到父元素上，而不是绑定到每个子元素上。当子元素上触发事件时，事件会冒泡到父元素，由父元素上的事件处理程序来处理。\n\n例如，如果我们需要对一个列表中的每个项绑定点击事件，我们可以绑定一个事件处理程序到列表的父元素上，然后通过事件委托来处理每个子元素的点击事件。这样就可以避免在每个子元素上都绑定一个事件处理程序，从而提高性能和代码的可维护性。\n\n\n# 执行栈\n\n执行栈是JavaScript中的一种数据结构，用于存储代码执行的顺序。当JavaScript代码被执行时，它会被添加到执行栈中。代码按照先进先出的顺序执行，也就是说，最先添加到执行栈中的代码最先执行，最后添加的代码最后执行。\n\n当JavaScript执行一个函数时，它会将该函数添加到执行栈中，并在函数执行完毕后将其从执行栈中移除。如果函数内部调用了其他函数，那么这些函数也会被添加到执行栈中，直到所有的函数都执行完毕并从执行栈中移除。\n\n\n# 如何理解JS的异步\n\nJS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。\n\n而渲染主线程承担着诸多的工作，渲染页面、执行 JS都在其中运行。\n\n如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步的方式来避免。 具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。\n\n当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行（这里涉及到JS的事件轮询机制，可以展开讲）。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。\n\n\n# 事件循环\n\n事件循环是JavaScript中的一种机制，用于处理异步任务。当JavaScript执行一个异步任务时，它会将该任务添加到事件队列中，而不是执行栈中。当执行栈中的所有任务都执行完毕后，JavaScript会检查事件队列中是否有任务需要执行。如果有，JavaScript会将队列中的第一个任务添加到执行栈中，并执行该任务。\n\nJavaScript事件循环的过程是不断重复的，直到事件队列中没有任务为止。这意味着JavaScript可以同时处理多个异步任务，而不会阻塞其他任务的执行。\n\n\n# 宏任务&微任务\n\nECMscript里面是没有宏任务微任务概念的。先宏后微是因为整个的js代码，js变量的声明，js方法的实现，都属于宏任务的范畴当中，有先宏后微这个说法是因为到了事件循环的机制中的时候，会存在事件队列，存在一个调用的栈，还有一个出队列和入栈的过程，在这个过程里面他会把当前现有的宏任务都执行完，然后再执行对应的微任务。等把宏任务下面的所有的微任务都执行完之后，在执行下一个宏任务\n\nJS中的任务分为宏任务和微任务。\n\n宏任务是指由浏览器或者Node.js环境提供的任务，例如DOM事件、setTimeout、setInterval等等。宏任务的执行顺序由浏览器或者Node.js环境决定，每个宏任务执行完后，会清空微任务队列。\n\n微任务是指在当前宏任务执行完后立即执行的任务，例如Promise.then、MutationObserver等等。微任务的执行时机在宏任务执行完后，会在当前宏任务结束之前执行，也就是说在下一个宏任务之前。微任务执行完后，会清空微任务队列，如果在微任务执行期间产生了新的微任务，那么会在当前微任务队列执行完后继续执行新的微任务队列。\n\n总结一下，宏任务和微任务的执行顺序如下：\n\n 1. 执行当前宏任务\n 2. 执行当前宏任务产生的微任务\n 3. 执行新的宏任务\n 4. 重复执行2、3步骤，直到所有任务都执行完毕\n\n需要注意的是，由于微任务的执行时机在宏任务执行完后，所以在同一个宏任务中产生的微任务会在当前宏任务结束之前执行完毕，而不会产生新的宏任务。\n\n\n# 继承\n\n在 JavaScript 中，实现继承的方式有以下几种：\n\n 1. 原型链继承 原型链继承是通过将子类的原型指向父类的实例来实现继承。这种方式简单易懂，但是会存在引用类型共享和无法向父类传递参数等缺点。\n\n 2. 构造函数继承 构造函数继承是通过在子类的构造函数中通过call借调父类的构造函数来实现继承。这种方式可以避免引用类型共享的问题，但是无法继承父类的原型上的属性和方法。\n\n 3. 组合继承 组合继承是将原型链继承和构造函数继承组合使用，既能继承父类原型上的属性和方法，又能避免引用类型共享的问题，但是会存在重复调用父类构造函数的问题。\n\n 4. 原型式继承 原型式继承是通过复制一个对象来实现继承，这种方式可以实现类似于对象的克隆，但是会存在引用类型共享的问题。\n\n 5. 寄生式继承 寄生式继承是在原型式继承的基础上添加一些扩展方法来实现继承，但是同样会存在引用类型共享的问题。\n\n 6. 寄生组合式继承 寄生组合式继承是在组合继承的基础上进行优化，避免重复调用父类构造函数，可以实现继承父类原型上的属性和方法，并避免引用类型共享的问题。\n\n\n# 防抖节流\n\n * 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。\n\n结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！\n\n空讲无益，show you 场景：\n\n有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n  // 2、防抖功能函数，接受传参\n    function debounce(fn) {\n      // 4、创建一个标记用来存放定时器的返回值\n      let timeout = null;\n      return function() {\n        // 5、每次当用户点击/输入的时候，把前一个定时器清除\n        clearTimeout(timeout);\n        // 6、然后创建一个新的 setTimeout，\n        // 这样就能保证点击按钮后的 interval 间隔内\n        // 如果用户还点击了的话，就不会执行 fn 函数\n        timeout = setTimeout(() => {\n          fn.call(this, arguments);\n        }, 1000);\n      };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 节流：指定时间间隔内只会执行一次任务。\n\n那么，节流在工作中的应用？\n\n 1. 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。\n 2. 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。\n\n // 2、节流函数体\n    function throttle(fn) {\n      // 4、通过闭包保存一个标记\n      let canRun = true;\n      return function() {\n        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数\n        if(!canRun) {\n          return;\n        }\n        // 6、将 canRun 设置为 false，防止执行之前再被执行\n        canRun = false;\n        // 7、定时器\n        setTimeout( () => {\n          fn.call(this, arguments);\n          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true\n          canRun = true;\n        }, 1000);\n      };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nLodash 的 debounce 和 throttle 的实现\n\n\n# 前端如何捕获错误\n\n可以直接用try catch捕获正常代码中的一些错误。但是这只适用于那种同步代码，对于Promise这种类型来说，我们是没有办法try catch直接捕获的。我们对于Promise的异常可以直接在Promise的catch里面去捕获错误，另外，我们可以把Promise放到async和await的函数里面，把它变成类似于同步函数的一个形式，那我们就可以在里面直接使用try catch进行错误捕获。\n\n\n# 数组转树形结构\n\n方法一：递归函数\n\nfunction transArrToTree(list,pid) {\n  const arr = []\n  list.forEach(item => {\n    if(item.pid === pid) {\n      item.children = transArrToTree(list,item.id)\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n方法二：map映射\n\nexport function transListToTreeUseMap(list) {\n  const arr = []\n  const map = {}\n  list.forEach(item => {\n    item.children = []\n    map[item.id] = item\n  })\n  list.forEach(item => {\n    if (map[item.pid]) {\n      map[item.pid].children.push(item)\n    } else {\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 首先定义一个空数组 arr 和一个空对象 map。\n 2. 遍历传入的列表 list，为每个节点添加一个空的 children 数组，并将节点对象以 id 为键，以节点对象本身为值，存入 map 对象中。\n 3. 再次遍历传入的列表 list，对于每个节点，如果其父节点在 map 对象中存在，则将该节点添加到其父节点的 children 数组中；否则，将该节点添加到 arr 数组中。\n 4. 最后返回 arr 数组，即为转换后的树形结构数据。\n\n这段代码的主要思路是利用一个对象 map 来存储每个节点对象，以便在后续遍历中快速查找其父节点，并将其添加到父节点的 children 数组中。\n\n\n# 树形扁平化转数组\n\n递归函数\n\n这段代码实现了将一个嵌套的树形结构数据扁平化的功能。具体实现如下：\n\n 1. 定义一个空数组 arr。\n 2. 遍历传入的树形结构数据 data，对于每个节点，判断其是否有子节点，如果有，则递归调用 dataFattening 函数，将子节点扁平化后合并到 arr 数组中；否则，将该节点直接添加到 arr 数组中。\n 3. 最后返回 arr 数组，即为扁平化后的数据。\n\n这段代码的主要思路是利用递归函数将嵌套的树形结构数据转换成扁平化的数组。在递归过程中，对于每个节点，如果它有子节点，则递归调用函数处理子节点，并将子节点扁平化后的结果合并到当前节点的扁平化结果中。如果当前节点没有子节点，则直接将当前节点添加到扁平化结果中。\n\n需要注意的是，在这段代码中使用了可选链操作符 ?.，它用于判断一个对象是否有某个属性或方法，如果有则返回该属性或方法的值，否则返回 undefined。这样可以避免在访问不存在的属性或方法时出现报错，提高代码的健壮性。\n\nfunction dataFattening (data) {\n  const arr = []\n  this.data.forEach(item => {\n    if(item.children?.length) {\n      arr = [ ...arr, ...dataFattening(item.children) ]\n    }esle {\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 无感知登录\n\nb站小鹿仙",normalizedContent:"# 回调函数的概念\n\n> fs模块\n> \n> fs.writefile('文件路径'，'编码格式'，function(err,datastr){})\n> \n>  * fs.writefile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。__dirname为当前目录可以用来拼接文件路径\n>  * 第二个参数是编码格式，一边采用utf-8 国际码\n>  * 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。datastr为读取的文件内容。\n\njavascript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。 它的英语名字 callback，直译过来就是\"重新调用\"。\n\n读取文件进行处理，是这样写的。\n\n fs.readfile('/etc/passwd', function (err, data) {\n   if (err) throw err;\n   console.log(data);\n });\n\n\n1\n2\n3\n4\n\n\n上面代码中，readfile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。\n\n一个有趣的问题是，为什么 node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。\n\n\n# 数组的常用方法有哪些?\n\n * join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符\n * push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)\n * pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）\n * shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined\n * unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）\n * slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变\n * splice(start,deletecount,val1,val2,…):从start位置开始删除deletecount项，并从该位置起插入。（修改原数组）\n * fill()：使用特定值填充数组中的一个或多个元素(修改原数组)\n * filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组\n * concat()：可以将两个数组合并在一起，如果是使用es6语法也可以用扩展运算符…来代替\n * indexof()：返回当前值在数组中第一次出现位置的索引\n * lastindexof()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。\n * every()：判断数组中每一项是否都符合条件\n * some()：判断数组中是否存在满足的项\n * includes()：判断一个数组是否包含指定的值\n * sort(orderfunction):按指定的参数对数组进行排序(修改原数组)\n * reverse()：将数组反序(修改原数组)\n * foreach()：循环遍历数组每一项（没有返回值）\n * map()：循环遍历数组的每一项（有返回值）\n * copywithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）\n * find(): 返回第一个匹配的值，并停止查找\n * findindex(): 返回第一个匹配值的索引，并停止查找\n * tolocalestring()、tostring():将数组转换为字符串\n * flat()、flatmap()：扁平化数组\n * entries() 、keys() 、values():遍历数组\n\n\n# 原型链\n\njs的每个函数在创建的时候，都会生成一个属性prototype，这个属性指向一个对象，这个对象就是此函数的原型对象。该原型对象中有个属性为constructor，指向该函数。\n\n每个通过构造函数创建出来的实例对象，其本身有个属性__proto__，这个属性会指向该实例对象的构造函数的原型对象，这么说好像有点绕\n\n当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会通过它的__proto__隐式属性，找到它的构造函数的原型对象，如果还没有找到就会再在其构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。\n\n原型继承：\n\n原型继承: 把父级实例化对象给到子级的原型对象\n\n再把constructor重新指向自己的构造函数\n\n原型链： 每一个对象都有自己的原型, 而原型也是对象,也会有自己的原型，此次类推形成链式结构。称之为原型链。(原型链的终点是null)\n\n对象访问原型链规则： 就近原则\n\n对象先访问自己的，自己没有就找原型的，原型没有就找原型的原型，一直到原型链终点null.如果还找不到。 属性则获取undefined, 方法则会报错 xxx is not function\n\n\n# new关键字的执行过程\n\n * 将新对象的__proto__ 指向了构造函数的原型对象（prototype）\n\n * 将构造函数内部的this指向新对象\n\n * 执行构造函数给this(实例对象)添加属性或方法\n\n * 默认return this\n   \n   如果写了return 看数据类型\n   \n   数据类型是简单数据类型: return简单数据类型忽略，最终还是return this\n   \n   如果数据类型是复杂数据类型: 最终得到是该复杂数据类型，return this无效\n\n\n# es6\n\n * let const\n\n * 箭头函数\n\n * 解构赋值\n\n * 模板字符串\n\n * 模块化\n\n * class\n\n * promise\n\n * set&map\n\n\n# let const\n\n 1. var声明的变量作用域是函数级别的，而 let 和const 声明的变量作用域是块别的，块级别作用域可以是一个函数、一对花括号或一个模块。\n\n 2. 使用var声明的变量可以在声明之前访问，但是其值为undefined，而let 和const声明的变量在声明之前访问会抛出 referenceerror。\n\n 3. var 声明的变量可以被重复声明，而let和const声明的变量不允许重复声明。\n\n 4. 使用let声明的变量可以被重新赋值，而使用const声明的变量是不可变的，即其值不能被重新赋值\n\n 5. const声明的变量必须在声明时初始化，不能在之后赋值。\n\n\n# set&map\n\n\n# 模板字符串\n\n\n# 解构赋值\n\n解构赋值允许从数组或对象中快速提取值并将其分配给多个变量，简化了数据交换和属性提取。\n\n// 数组解构\n     const [first, second, , fourth] = [1, 2, 3, 4];\n     console.log(first); // 1\n     console.log(fourth); // 4\n \n// 对象解构\n     const person = { name: \"alice\", age: 30, city: \"seattle\" };\n     const { name, age } = person;\n     console.log(name); // \"alice\"\n     console.log(age); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模块化\n\n默认导出是在一个模块中只导出一个，变量或者函数，但是按需导出可以导出多个变量或者函数\n\n\n# 箭头函数和普通函数的区别\n\n 1. 箭头函数this指向上下文，普通函数this看调用方式\n\n 2. 剪头函数没有arguments对象，普通函数具备arguments对象\n\n 3. 箭头函数没有prototype, 普通函数具备prototype\n\n 4. 箭头函数不能用做构造函数，普通函数可以用做构造函数\n\n\n# class\n\nes6 引入了基于原型的类（class）语法，提供了一种更接近传统面向对象语言的类定义方式，但本质上仍然是对原有构造函数和原型链机制的封装\n\nclass person {\n       constructor(name, age) {\n         this.name = name;\n         this.age = age;\n       }\n \n       introduce() {\n         return `my name is ${this.name}, and i am ${this.age} years old.`;\n       }\n     }\n \n     const alice = new person(\"alice\", 30);\n     console.log(alice.introduce()); // my name is alice, and i am 30 years old.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# promise\n\n概念\n\npromise是一个对象/构造函数,es6新增的,更加灵活的处理异步,也可以解决回调地狱问题\n\npromise有三种状态:pending fullfield rejected状态不可逆 pending => (resolve)fullfield，pending =>(rejecte) rejected\n\n实例方法\n\n * then方法：接收promise处理后的结果，\n   \n   * 第一个回调接收成功的结果，第二个回调用于接收失败的结果\n   * then支持链式调用，在then中可以返回新的promise，并且调用resolve，会将成功的结果传递到下一个then中，所以借助then的链式解决了回调地狱的问题\n   * 具备穿透性：在then中通过返回的promise调用resolve传递数据，下一个then如果没有通过回调进行接收，则会继续向下传递\n   * then的返回值是promise，而且then的成功回调如果返回的不是promise，也会被then的promise的resolve进行处理\n   * 终止then的成功回调的链式：reject、throw error promise.reject\n\n * catch方法：专门处理失败的状态\n\n * finnaly方法：都会执行\n\n静态方法\n\n * all：同时处理多个异步，语法参数为数组，数组每一项是promise实例，只有所有异步处理成功，才会进入then的成功回调，有一个失败，进入all的then的失败回调，结果是数组，值对应的就是参数数组的顺序\n\n * allsettled：语法基本和all一致，不管处理的异步中是否调用reject，最终都会进入allsettled的成功回调，在成功的回调中，数组每一项是对象，对象会有status，状态，成功或失败，还有value就是异步处理的结果\n\n * race：语法基本和all一致，可以获取到异步处理最快的那一个，在then中通过成功回调或失败回调获取结果\n\n * any：语法基本和all一致，可以获取到异步处理成功最快的那一个\n\nasync和await\n\npromise的终极解决方案是async await\n\nawait 用来修饰promise, 当然await也可以修饰非promise，如果修饰的不是promise则会将 await后面的内容包装为promise，await的返回值会一直是promise的resolve处理，await下面的代码相当于是promise的then成功回调的代码，所以await下面的代码属于异步微任务\n\nasync用来修饰await就近的函数，被async修饰的函数，该函数返回值为promise，内部如果return数据，则该数据被promise的resolve进行处理，所以需要通过函数的then的成功回调获取期结果\n\nasync和await实际是generator的语法糖\n\ngenerator\n\n概念: 也是es6的,可以将函数的控制权交出,也可以利用generator更方便的控制异步,实际async和await就是他的语法糖\n\n区分: 星号\n\n如何交出控制权: 通过yield进行控制权交出,通过next逐步调用\n\n如何处理异步: 可以通过yield配合promise达到类似async和await的效果,通过yiled返回promise,在promise中处理异步,等异步成功调用resolve,这样在外部可以通过next.value获取到promise,通过then等待成功后,执行下一次的next\n\n而且对应的自执行generator函数有co库,可以去自执行generator\n\n区别:\n\n\n\n\n# for in&for of\n\n 1. 遍历的对象不同： for...in循环用于遍历对象的可枚举属性。它会枚举对象及其原型链上的所有属性，包括继承的属性。它主要用于遍历对象属性。 for...of循环用于遍历可迭代对象中的值，例如数组、字符串、map、set等。它不适用于普通对象。\n\n 2. 迭代顺序不同： for...in循环的迭代顺序是不确定的，因为它是按照对象属性的添加顺序进行迭代的，但是对象的属性顺序是不确定的。它不能保证属性的顺序。 for...of循环的迭代顺序是由迭代器决定的，通常是按照元素在集合中出现的顺序进行迭代的。\n\n 3. 迭代的值不同： for...in循环迭代的是属性名，而不是属性值。因此，要访问属性值，需要使用对象的属性访问方法，例如obj[key]。 for...of循环迭代的是值。例如，对于数组，它迭代的是数组元素的值。\n\n 4. 可以使用的对象不同： for...in循环可以用于遍历普通对象的属性。但是它不能用于遍历数组等可迭代对象，因为它会遍历数组的所有属性，包括数组的原型属性。 for...of循环只能用于遍历可迭代对象，例如数组、字符串、map、set等。 综上所述，for...in循环用于遍历对象的属性，而for...of循环用于遍历可迭代对象的值。在使用时需要根据不同的情况选择合适的循环结构。\n\n中断for\n\n * continue：终止该次循环，进入下一次，使用所有循环结构\n\n * break：跳出循环，执行循环后的语句，如果多层循环，只会退出当前层循环\n\n * return：终止循环，结束当前方法\n\n\n# 深浅拷贝 递归\n\n在声明基本类型的变量时，变量的值会存储在栈内存当中，声明引用类型的变量时，会在堆内存中分配一个空间来存储引用类型的值。同时，在栈中也会保存一个引用地址指向这一块空间。声明一个变量b，并且b赋值为已存在的基本类型变量a，那么它赋值的是存储在栈中的真实的值，对于引用类型而言，声明一个变量o2，并给这个o2赋值为已存在的o1，那么他赋值的是栈中的引用地址，当改变o1o2任意一个时，真正改变的是堆内存中存储的值，那么当输出o1或者o2的时候，他们输出的结果都是会发生改变的\n\n浅拷贝是新对象的属性和源对象的属性会共用同一个内存空间，浅拷贝拷贝的是地址\n\n实现方法是object.assgin()，它会将一个或多个源对象的可枚举属性复制到目标对象中，如果目标对象中已有相同的属性，则会覆盖原有的属性值\n\n另一个实现方式是数组的浅拷贝可以使用slice()方法、concat()方法或者...展开运算符实现\n\n深拷贝是新对象的属性和源对象的属性会不会共用同一个内存空间，需要在堆内存中开辟一块新的空间来存放这个属性的值\n\n深拷贝会递归拷贝对象的所有属性，包含子对象\n\n实现方法是json.parse(json.stringify()) ，用json格式实现深拷贝， 将需要拷贝的对象先转为字符串，再将字符串转为新的对象，这种方法可以一次性处理整个对象，缺点是只能处理json支持的数据类型，不能处理函数和正则表达式\n\n递归拷贝，遍历需要拷贝的对象，对每个属性判断是否是基本数据类型如果是就直接拷贝，否则就递归调用自身进行深度拷贝\n\n使用lodash库clonedeep方法\n\n浅拷贝方式：\n\n拷贝对象-object.assgin()或展开运算符...{obj},\n\n拷贝数组array.prototype.concat()\n\n深拷贝方式：\n\n 1. 使用lodash库clonedeep方法\n\n 2. 使用json.parse(json.stringify())\n    \n    缺点：\n    \n    1. 如果obj里面有时间对象，则json.stringify后再json.parse的结果，时间将只是字符串的形式。而不是时间对象；\n    2. 如果obj里有regexp、error对象，则序列化的结果将只得到空对象；\n    3. 如果obj有函数、undefined，则序列化之后的结果会把函数、undefined丢失。\n    4. 如果obj里有nan、 infinity和-infinity，则序列化的结果会变成null\n    5. json.stringify()只能序列化对象的可枚举的自有属性,例如如果obj中的对象是有构造函数生成则使用json.parse(json.stringify(obj)深拷贝后,会丢弃对象的constructor;\n    6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；\n\n 3. 递归\n\n\n# 闭包\n\n函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包\n\n闭包的作用：\n\n实现模块化：通过闭包，可以封装变量和函数，避免污染全局命名空间，实现模块化开发。\n\n实现私有变量和私有方法：通过闭包，可以创建私有变量和私有方法，避免被外部访问。\n\n缓存变量：通过闭包，可以缓存变量，避免重复计算，提高性能\n\n闭包可能引起的问题？\n\n使函数内部变量存在于内存中，闭包多的时候，内存消耗大\n\n在ie浏览器中会导致内存泄露，手动将外部变量置为null\n\n> ie浏览器采用的是引用计数垃圾回收机制。在闭包中，由于内部函数引用了外部函数的变量，导致外部函数的作用域对象无法被销毁，引用计数无法降为0，从而导致内存泄露\n> \n> 在其他浏览器中，如chrome、firefox等，采用的是标记清除垃圾回收机制。闭包执行完之后，如果没有其他函数引用外部函数的变量，就会把这个变量标记为不可访问，从而被回收\n\n闭包的使用场景\n\n * settimeout传参\n   \n   * 回调\n   * 函数防抖\n\n * 封装私有变量\n   \n   * 实现类和继承\n\n为什么要使用闭包？\n\n * 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。\n\n闭包怎么实现私有变量和私有方法\n\n闭包可以通过将变量和函数定义在外部函数内部，然后在内部函数中访问这些变量和函数，从而实现私有变量和私有方法。\n\n具体实现方法如下：\n\n 1. 将需要私有的变量和函数定义在外部函数内部。\n 2. 在外部函数内部定义一个内部函数，该内部函数可以访问外部函数内部的变量和函数。\n 3. 在内部函数中定义需要暴露给外部的函数，将其作为内部函数的返回值。\n 4. 外部函数返回内部函数，从而形成闭包，内部函数可以访问外部函数的变量和函数，但是外部函数无法访问内部函数的变量和函数，从而实现私有变量和私有方法。\n\n示例代码如下：\n\nfunction outer() {\n  var privatevar = 10; // 私有变量\n  function privatefunc() { // 私有方法\n    console.log('this is a private function');\n  }\n  return {\n    publicfunc: function() { // 公有方法\n      console.log('this is a public function');\n      privatefunc();\n      console.log('private variable:', privatevar);\n    }\n  }\n}\n\nvar obj = outer();\nobj.publicfunc(); // 输出：this is a public function\n                  // this is a private function\n                  // private variable: 10\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在上述示例中，私有变量和私有方法是通过在外部函数中定义变量和函数，然后在内部函数中访问这些变量和函数，从而实现的。公有方法是通过将需要暴露给外部的函数定义在返回对象中，从而实现的。\n\n\n# 垃圾回收机制\n\njavascript的垃圾回收机制是自动的，它通过监视对象的引用关系来确定哪些对象是活动的，哪些对象可以被回收。当一个对象不再被引用时，它就会被标记为垃圾，等待垃圾回收器将其回收。\n\njavascript垃圾回收器的实现通常使用两种算法：标记清除和引用计数。\n\n * 标记清除算法：垃圾回收器会先标记所有可以访问的对象，然后清除所有未被标记的对象。\n * 引用计数算法：垃圾回收器会记录每个对象被引用的次数，当引用次数变为0时，就会回收该对象。\n\n在实际应用中，大多数浏览器都采用标记清除算法来进行垃圾回收，因为引用计数算法容易出现循环引用的情况，导致一些对象无法被回收。\n\n\n# 作用域链\n\n内部函数访问变量，先在自身作用域找声明，如果没有，往外层找，直到找到全局，如果有，采取就近原则\n\n\n# this指向\n\n\n# 事件委托&事件冒泡\n\n事件冒泡（event bubbling）是指当一个元素上触发某个事件时，该事件会从该元素开始向上冒泡到祖先元素，直到到达文档根节点。在事件冒泡过程中，可以通过事件对象的target属性来获取当前触发事件的元素。\n\n事件冒泡机制的优点是可以在父元素上统一处理多个子元素的事件，从而减少代码量和提高性能。同时，也可以方便地通过事件委托来实现动态绑定和解绑事件处理程序的需求。但是，如果不加以控制，事件冒泡也可能会导致意外的事件触发和处理，从而影响应用程序的稳定性和可靠性。因此，在实际应用中需要谨慎使用事件冒泡和事件委托技术，合理控制事件的传播和处理。\n\n事件委托（event delegation）是一种常见的优化技巧，它利用了事件的冒泡机制来减少事件处理程序的数量。事件委托的核心思想是将事件处理程序绑定到父元素上，而不是绑定到每个子元素上。当子元素上触发事件时，事件会冒泡到父元素，由父元素上的事件处理程序来处理。\n\n例如，如果我们需要对一个列表中的每个项绑定点击事件，我们可以绑定一个事件处理程序到列表的父元素上，然后通过事件委托来处理每个子元素的点击事件。这样就可以避免在每个子元素上都绑定一个事件处理程序，从而提高性能和代码的可维护性。\n\n\n# 执行栈\n\n执行栈是javascript中的一种数据结构，用于存储代码执行的顺序。当javascript代码被执行时，它会被添加到执行栈中。代码按照先进先出的顺序执行，也就是说，最先添加到执行栈中的代码最先执行，最后添加的代码最后执行。\n\n当javascript执行一个函数时，它会将该函数添加到执行栈中，并在函数执行完毕后将其从执行栈中移除。如果函数内部调用了其他函数，那么这些函数也会被添加到执行栈中，直到所有的函数都执行完毕并从执行栈中移除。\n\n\n# 如何理解js的异步\n\njs是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。\n\n而渲染主线程承担着诸多的工作，渲染页面、执行 js都在其中运行。\n\n如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步的方式来避免。 具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。\n\n当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行（这里涉及到js的事件轮询机制，可以展开讲）。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。\n\n\n# 事件循环\n\n事件循环是javascript中的一种机制，用于处理异步任务。当javascript执行一个异步任务时，它会将该任务添加到事件队列中，而不是执行栈中。当执行栈中的所有任务都执行完毕后，javascript会检查事件队列中是否有任务需要执行。如果有，javascript会将队列中的第一个任务添加到执行栈中，并执行该任务。\n\njavascript事件循环的过程是不断重复的，直到事件队列中没有任务为止。这意味着javascript可以同时处理多个异步任务，而不会阻塞其他任务的执行。\n\n\n# 宏任务&微任务\n\necmscript里面是没有宏任务微任务概念的。先宏后微是因为整个的js代码，js变量的声明，js方法的实现，都属于宏任务的范畴当中，有先宏后微这个说法是因为到了事件循环的机制中的时候，会存在事件队列，存在一个调用的栈，还有一个出队列和入栈的过程，在这个过程里面他会把当前现有的宏任务都执行完，然后再执行对应的微任务。等把宏任务下面的所有的微任务都执行完之后，在执行下一个宏任务\n\njs中的任务分为宏任务和微任务。\n\n宏任务是指由浏览器或者node.js环境提供的任务，例如dom事件、settimeout、setinterval等等。宏任务的执行顺序由浏览器或者node.js环境决定，每个宏任务执行完后，会清空微任务队列。\n\n微任务是指在当前宏任务执行完后立即执行的任务，例如promise.then、mutationobserver等等。微任务的执行时机在宏任务执行完后，会在当前宏任务结束之前执行，也就是说在下一个宏任务之前。微任务执行完后，会清空微任务队列，如果在微任务执行期间产生了新的微任务，那么会在当前微任务队列执行完后继续执行新的微任务队列。\n\n总结一下，宏任务和微任务的执行顺序如下：\n\n 1. 执行当前宏任务\n 2. 执行当前宏任务产生的微任务\n 3. 执行新的宏任务\n 4. 重复执行2、3步骤，直到所有任务都执行完毕\n\n需要注意的是，由于微任务的执行时机在宏任务执行完后，所以在同一个宏任务中产生的微任务会在当前宏任务结束之前执行完毕，而不会产生新的宏任务。\n\n\n# 继承\n\n在 javascript 中，实现继承的方式有以下几种：\n\n 1. 原型链继承 原型链继承是通过将子类的原型指向父类的实例来实现继承。这种方式简单易懂，但是会存在引用类型共享和无法向父类传递参数等缺点。\n\n 2. 构造函数继承 构造函数继承是通过在子类的构造函数中通过call借调父类的构造函数来实现继承。这种方式可以避免引用类型共享的问题，但是无法继承父类的原型上的属性和方法。\n\n 3. 组合继承 组合继承是将原型链继承和构造函数继承组合使用，既能继承父类原型上的属性和方法，又能避免引用类型共享的问题，但是会存在重复调用父类构造函数的问题。\n\n 4. 原型式继承 原型式继承是通过复制一个对象来实现继承，这种方式可以实现类似于对象的克隆，但是会存在引用类型共享的问题。\n\n 5. 寄生式继承 寄生式继承是在原型式继承的基础上添加一些扩展方法来实现继承，但是同样会存在引用类型共享的问题。\n\n 6. 寄生组合式继承 寄生组合式继承是在组合继承的基础上进行优化，避免重复调用父类构造函数，可以实现继承父类原型上的属性和方法，并避免引用类型共享的问题。\n\n\n# 防抖节流\n\n * 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。\n\n结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！\n\n空讲无益，show you 场景：\n\n有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。\n\n  // 2、防抖功能函数，接受传参\n    function debounce(fn) {\n      // 4、创建一个标记用来存放定时器的返回值\n      let timeout = null;\n      return function() {\n        // 5、每次当用户点击/输入的时候，把前一个定时器清除\n        cleartimeout(timeout);\n        // 6、然后创建一个新的 settimeout，\n        // 这样就能保证点击按钮后的 interval 间隔内\n        // 如果用户还点击了的话，就不会执行 fn 函数\n        timeout = settimeout(() => {\n          fn.call(this, arguments);\n        }, 1000);\n      };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n * 节流：指定时间间隔内只会执行一次任务。\n\n那么，节流在工作中的应用？\n\n 1. 懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。\n 2. 用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。\n\n // 2、节流函数体\n    function throttle(fn) {\n      // 4、通过闭包保存一个标记\n      let canrun = true;\n      return function() {\n        // 5、在函数开头判断标志是否为 true，不为 true 则中断函数\n        if(!canrun) {\n          return;\n        }\n        // 6、将 canrun 设置为 false，防止执行之前再被执行\n        canrun = false;\n        // 7、定时器\n        settimeout( () => {\n          fn.call(this, arguments);\n          // 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true\n          canrun = true;\n        }, 1000);\n      };\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nlodash 的 debounce 和 throttle 的实现\n\n\n# 前端如何捕获错误\n\n可以直接用try catch捕获正常代码中的一些错误。但是这只适用于那种同步代码，对于promise这种类型来说，我们是没有办法try catch直接捕获的。我们对于promise的异常可以直接在promise的catch里面去捕获错误，另外，我们可以把promise放到async和await的函数里面，把它变成类似于同步函数的一个形式，那我们就可以在里面直接使用try catch进行错误捕获。\n\n\n# 数组转树形结构\n\n方法一：递归函数\n\nfunction transarrtotree(list,pid) {\n  const arr = []\n  list.foreach(item => {\n    if(item.pid === pid) {\n      item.children = transarrtotree(list,item.id)\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n方法二：map映射\n\nexport function translisttotreeusemap(list) {\n  const arr = []\n  const map = {}\n  list.foreach(item => {\n    item.children = []\n    map[item.id] = item\n  })\n  list.foreach(item => {\n    if (map[item.pid]) {\n      map[item.pid].children.push(item)\n    } else {\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n 1. 首先定义一个空数组 arr 和一个空对象 map。\n 2. 遍历传入的列表 list，为每个节点添加一个空的 children 数组，并将节点对象以 id 为键，以节点对象本身为值，存入 map 对象中。\n 3. 再次遍历传入的列表 list，对于每个节点，如果其父节点在 map 对象中存在，则将该节点添加到其父节点的 children 数组中；否则，将该节点添加到 arr 数组中。\n 4. 最后返回 arr 数组，即为转换后的树形结构数据。\n\n这段代码的主要思路是利用一个对象 map 来存储每个节点对象，以便在后续遍历中快速查找其父节点，并将其添加到父节点的 children 数组中。\n\n\n# 树形扁平化转数组\n\n递归函数\n\n这段代码实现了将一个嵌套的树形结构数据扁平化的功能。具体实现如下：\n\n 1. 定义一个空数组 arr。\n 2. 遍历传入的树形结构数据 data，对于每个节点，判断其是否有子节点，如果有，则递归调用 datafattening 函数，将子节点扁平化后合并到 arr 数组中；否则，将该节点直接添加到 arr 数组中。\n 3. 最后返回 arr 数组，即为扁平化后的数据。\n\n这段代码的主要思路是利用递归函数将嵌套的树形结构数据转换成扁平化的数组。在递归过程中，对于每个节点，如果它有子节点，则递归调用函数处理子节点，并将子节点扁平化后的结果合并到当前节点的扁平化结果中。如果当前节点没有子节点，则直接将当前节点添加到扁平化结果中。\n\n需要注意的是，在这段代码中使用了可选链操作符 ?.，它用于判断一个对象是否有某个属性或方法，如果有则返回该属性或方法的值，否则返回 undefined。这样可以避免在访问不存在的属性或方法时出现报错，提高代码的健壮性。\n\nfunction datafattening (data) {\n  const arr = []\n  this.data.foreach(item => {\n    if(item.children?.length) {\n      arr = [ ...arr, ...datafattening(item.children) ]\n    }esle {\n      arr.push(item)\n    }\n  })\n  return arr\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 无感知登录\n\nb站小鹿仙",charsets:{cjk:!0},lastUpdated:"2025/02/11, 03:59:16",lastUpdatedTimestamp:1739217556e3},{title:"Vue",frontmatter:{title:"Vue",date:"2022-03-16T08:37:51.000Z",permalink:"/more/interview-vue/",categories:["更多","技术面"],tags:["Vue","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/04.Vue.html",relativePath:"55.更多/05.技术面/04.Vue.md",key:"v-16dd473a",path:"/more/interview-vue/",headers:[{level:2,title:"Vue",slug:"vue",normalizedTitle:"vue",charIndex:2},{level:3,title:"vue优缺点",slug:"vue优缺点",normalizedTitle:"vue优缺点",charIndex:10},{level:3,title:"SPA的优缺点",slug:"spa的优缺点",normalizedTitle:"spa的优缺点",charIndex:203},{level:3,title:"双向数据绑定",slug:"双向数据绑定",normalizedTitle:"双向数据绑定",charIndex:51},{level:3,title:"v-if&v-for",slug:"v-if-v-for",normalizedTitle:"v-if&amp;v-for",charIndex:null},{level:3,title:"v-for时候key有什么作用",slug:"v-for时候key有什么作用",normalizedTitle:"v-for时候key有什么作用",charIndex:1721},{level:3,title:"data为什么是一个函数而不是对象",slug:"data为什么是一个函数而不是对象",normalizedTitle:"data为什么是一个函数而不是对象",charIndex:2187},{level:3,title:"Vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？",slug:"vue-data中某一个属性的值发生改变后-视图会立即同步执行重新渲染吗",normalizedTitle:"vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？",charIndex:2368},{level:3,title:"nextTick",slug:"nexttick",normalizedTitle:"nexttick",charIndex:2491},{level:3,title:"vuex和localstorage的区别",slug:"vuex和localstorage的区别",normalizedTitle:"vuex和localstorage的区别",charIndex:3967},{level:3,title:"单向数据流",slug:"单向数据流",normalizedTitle:"单向数据流",charIndex:4298},{level:3,title:"组件传值",slug:"组件传值",normalizedTitle:"组件传值",charIndex:4389},{level:3,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:6093},{level:3,title:"mixin",slug:"mixin",normalizedTitle:"mixin",charIndex:6932},{level:3,title:"路由模式",slug:"路由模式",normalizedTitle:"路由模式",charIndex:7195},{level:3,title:"Vue-router&location.href",slug:"vue-router-location-href",normalizedTitle:"vue-router&amp;location.href",charIndex:null},{level:3,title:"路由懒加载",slug:"路由懒加载",normalizedTitle:"路由懒加载",charIndex:7937},{level:3,title:"keep-alive",slug:"keep-alive",normalizedTitle:"keep-alive",charIndex:7947},{level:3,title:"虚拟dom是什么",slug:"虚拟dom是什么",normalizedTitle:"虚拟dom是什么",charIndex:8319},{level:3,title:"diff算法",slug:"diff算法",normalizedTitle:"diff算法",charIndex:8928},{level:3,title:"Vue的性能优化有哪些",slug:"vue的性能优化有哪些",normalizedTitle:"vue的性能优化有哪些",charIndex:10658},{level:2,title:"Web worker",slug:"web-worker",normalizedTitle:"web worker",charIndex:11186},{level:2,title:"跨页面通信",slug:"跨页面通信",normalizedTitle:"跨页面通信",charIndex:11452},{level:2,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:12267},{level:2,title:"路由导航守卫",slug:"路由导航守卫",normalizedTitle:"路由导航守卫",charIndex:13026},{level:2,title:"登录流程",slug:"登录流程",normalizedTitle:"登录流程",charIndex:13037},{level:2,title:"虚拟列表",slug:"虚拟列表",normalizedTitle:"虚拟列表",charIndex:13046},{level:2,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:10933},{level:2,title:"二次封装组件",slug:"二次封装组件",normalizedTitle:"二次封装组件",charIndex:13065},{level:2,title:"JSBridge",slug:"jsbridge",normalizedTitle:"jsbridge",charIndex:13076},{level:2,title:"项目发布上线真实流程到底是什么？",slug:"项目发布上线真实流程到底是什么",normalizedTitle:"项目发布上线真实流程到底是什么？",charIndex:13129},{level:2,title:"布局容器",slug:"布局容器",normalizedTitle:"布局容器",charIndex:13422}],headersStr:"Vue vue优缺点 SPA的优缺点 双向数据绑定 v-if&v-for v-for时候key有什么作用 data为什么是一个函数而不是对象 Vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？ nextTick vuex和localstorage的区别 单向数据流 组件传值 生命周期 mixin 路由模式 Vue-router&location.href 路由懒加载 keep-alive 虚拟dom是什么 diff算法 Vue的性能优化有哪些 Web worker 跨页面通信 文件上传 路由导航守卫 登录流程 虚拟列表 图片懒加载 二次封装组件 JSBridge 项目发布上线真实流程到底是什么？ 布局容器",content:"# Vue\n\n\n# vue优缺点\n\n优点：\n\n * 简单易用\n\n * 渐进式\n\n * 响应式\n\n * 双向数据绑定\n\n * 虚拟dom\n\n * 耦合低\n\n * 组件化开发\n\n * 结合vue-router实现spa\n\n缺点：\n\n * vue2: 逻辑分散\n\n * 无法兼容ie8一下,无法shim, 底层采用的Object.defineproperty,无法兼容ie8一下\n\n * seo很不友好\n\n\n# SPA的优缺点\n\n优点\n\n * 良好的交互体验\n\n * 单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过Ajax异步获取，没有页面之间的切换，就不会出现“白屏现象”，也不会出现假死并有“闪烁”现象，页面显示流畅\n\n * 良好的前后端工作分离模式\n\n * 后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端\n\n * 减轻服务器压力\n\n * 单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍\n\n缺点\n\n * 首屏加载慢\n   \n   解决方案：\n   \n   1. Vue-route懒加载\n      \n      Vue-router懒加载就是按需加载组件，只有当路由被访问时才会加载对应的组件，而不是在加载首页的时候就加载，项目越大，对首屏加载的速度提升得越明显\n   \n   2. 使用CDN加速\n      \n      在做项目时，我们会用到很多库，采用cdn加载可以加快加载速度。\n   \n   3. 异步加载组件\n   \n   4. 服务端渲染\n      \n      服务端渲染还能对seo优化起到作用，有利于搜素引華抓取更多有用的信息（如果页面纯前端渲染，搜素引挚抓取到的就只是空页面）\n\n * 不利于SEO\n   \n   seo 本质是一个服务器向另一个服务器发超请求，解析请求内容。但一般来说搜素引孳是不会去执行请求到的js的。也就是说，搜素引/挚的基础爬主的原理就是抓取url，然后获取htm/源代码并解析。如果—个单页应用，html在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，即搜索引孳请求到的html是模型页面而不是最终数据的渲染页面。这样就很不利于内容被搜索引孳搜索到\n   \n   解决方案：\n   \n   1. 服务端渲染\n      \n      服务器合成完整的 html 文件再输出到浏览器\n   \n   2. 页面预渲染\n   \n   3. 路由采用h5 history模式\n\n * 不适合开发大型项目\n   \n   大型项目中可能会涉及大量的DOM操作、复杂的动画效果，也就不适合使用Vue、react框架进行开发\n\n\n# 双向数据绑定\n\n * 双向数据绑定\n   \n   mvvm的设计模式的思想，数据发生变化，视图自动同步，视图发生变化，数据同步\n   \n   m：model数据\n   \n   v：view视图\n   \n   vm：实现view和视图的自动绑定\n   \n   在vue中v-model可以实现双向数据绑定\n   \n   在表单或组件均可使用v-model绑定数据，从而达到双向数据绑定的效果\n\n * v-model的表层原理 动态绑定value和注册input事件，所以v-model只是语法糖，视图发生变化同步数据很容易，因为页面有事件， 但是数据发生变化同步给视图实际vue采用的是数据响应式的原理\n\n * 数据响应式原理 简单：底层采用的是Object.defineProperty数据劫持+观察者模式，在数据劫持的get中进行依赖收集，在set中通过dep.notify进行依赖通知，依赖收集和依赖通知采用的是观察者模式 复杂：源码\n\n\n# v-if&v-for\n\n在Vue2中，v-if不能和v-for一起使用的原因是v-for的优先级比v-if高，每创建一个节点都会进行一次判断，造成性能浪费\n\n解决方案有两种，把v-if放在v-for的外层或者写一个计算属性，把数组过滤一遍再拿过来用v-for遍历\n\n\n# v-for时候key有什么作用\n\n * 简单通俗地讲，没有key时，状态默认绑定的是位置，有key时，状态根据key的属性值绑定到了响应的数组元素。\n * 在Vue中，key属性主要用于帮助Vue区分每个节点，以便在进行虚拟DOM更新时能够更高效地操作。具体来说，Vue会使用一个包含所有子节点的Map对象来记录每个节点的key值与对应的虚拟DOM节点，这样就可以在进行虚拟DOM更新时，通过key值快速定位到对应的虚拟DOM节点，从而进行相应的DOM操作。这个Map对象是Vue内部维护的，不需要手动创建或操作。\n * 首先，key是为了更高效的更新虚拟DOM。如果不加 key 的话，会循环遍历整个数组 (O(n))，加key就会去Map里匹配 (O(1))，肯定加 key 要快一点，性能更高\n * 其次，如果不加 key 那么在插入或删除的时候就会出现，原本不是同一个节点的元素被认为是相同节点，因此可能会有额外 DOM 操作\n * 推荐使用数组内的字段（保证唯一性）作为key的唯一标识，不建议直接使用index\n\n\n# data为什么是一个函数而不是对象\n\n> data是函数的目的：防止多个组件数据共享(污染)\n\n 1. 如果某个组件的data属性是一个对象，如果当前组件在很多地方都引入了，由于对象是引用数据类型，会造成组件间的数据污染\n 2. 如果data是一个函数，vue内部解析的时候，会执行当前函数，返回一个全新的对象 >> 防止组件之间的数据共享(数据污染)\n\n\n# Vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\n\n> 不会同步更新的\n\n流程\n\n当模板中使用到的某一个数据发生变化以后，会通知Dep通知watcher(get的时候收集的，模板编译的时候)更新，而是把当前的更新方法通过nextTick放到callbacks数组里面，nexttick执行是在微任务里面的，所以不是同步更新\n\n> 总结：\n> \n> 不会立即同步执行重新渲染。\n> \n> Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。\n> \n> Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n> \n> 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 tick 中，Vue 刷新队列并执行实际（已去重的）工作。\n\n\n# nextTick\n\n> 因为vue 采用的是异步更新策略，当监听到数据发生变化的时候不会立即去更新DOM，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更;这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作DOM的次数。\n> \n> nextTick 是接收一个回调函数作为参数，并将这个回调函数延迟到DOM更新循环结束之后执行。在修改数据之后呢，立即调用nextTick来获取更新后的DOM。nextTick主要采用了宏任务和微任务，根据执行环境，分别尝试采用Promise，MutationObserver，setImmediate，如果以上都不行，就会用setTimeout,定义了一个异步方案。多次的调用nextTick会将方法存入队列中，通过这个异步方法来清空当前队列\n\n如果想要【在修改数据后立刻得到更新后的DOM结构/在created钩子函数內获取dom】，可以使用Vue.nextTick()\n\n第一个参数为：回调函数（可以获取最近的DOM结构）\n\n第二个参数为：执行函数上下文\n\n// 修改数据\nvm.message = '修改后的值'\n// DOM 还没有更新\nconsole.log(vm.$el.textContent) // 原始的值\nVue.nextTick(function () {\n  // DOM 更新了\n  console.log(vm.$el.textContent) // 修改后的值\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n组件内使用 vm.$nextTick() 实例方法只需要通过this.$nextTick()，并且回调函数中的 this 将自动绑定到当前的 Vue 实例上\n\nthis.message = '修改后的值'\nconsole.log(this.$el.textContent) // => '原始的值'\nthis.$nextTick(function () {\n    console.log(this.$el.textContent) // => '修改后的值'\n})\n\n\n1\n2\n3\n4\n5\n\n\n$nextTick() 会返回一个 Promise 对象，可以是用async/await完成相同作用的事情\n\nthis.message = '修改后的值'\nconsole.log(this.$el.textContent) // => '原始的值'\nawait this.$nextTick()\nconsole.log(this.$el.textContent) // => '修改后的值'\n\n\n1\n2\n3\n4\n\n\nnextTick实现原理（面试官）\n\nnextTick实现原理（源码）\n\n降级方案解读\n\n\n# vuex和localstorage的区别\n\n使用场景不同： vuex通常用于管理共享状态，可以在不同组件中共享数据，可以方便的实现数据响应式更新，使应用的状态管理更加可维护和可控。localstorage则更适合简单的数据储存需求，如存储用户设置，用户登录状态等。\n\n数据存储方式不同： vuex的数据存储在内存中，localstorage的数据存储在浏览器的localstorage对象中，由于vuex是在内存中操作数据，所以性能比localstorage更好。\n\n数据安全性不同： vuex的数据在内存中，相对比较安全，但是只能在同一个域名下的不同组件之间共享数据。localstorage的数据存储在客户端浏览器中，如果不加密或者防护，会有风险。\n\n\n# 单向数据流\n\n数据只能由父组件流向子组件，如果想要修改父组件内部的数据，只能子组件通过自定义事件触发父组件修改数据的方法，由父组件去修改数据，不能再子组件直接修改父组件数据\n\n\n# 组件传值\n\n * 父传子: 自定义属性传递参数，子组件使用props接收数据\n\n * 子传父: 父组件提供自定义事件，子组件通过＄emit触发事件进行传值\n\n * 兄弟组件通信：数据提升\n\n * vuex【解决跨组件传值比较混乱的问题，把数据集中维护，所有组件可以直接和vuex进行通信】\n\n * ref 可以获取到组件的实例，调用实例提供的方法可以直接传参\n\n * v-model【数据的双向绑定】值是valve属性，提供一个input事件，子组件通过＄emit触发input可以修改值【只能添加一个】\n   \n   如何修改value属性或者input事件名：model：{ event：\"修改事件名\"，prop：\"属性名，子\n\n * .sync 提供一个具体的属性，提供一个update：属性名：，触发此方法可以修改这个数据【可以添加多个】\n\n * $children: 可以获取当前组件的所有子组件,并以数组的格式返回数据\n\n * $parent: 可以获取到当前组件的父组件, 返回当前组件的父组件\n\n * provide/inject: 跨组件传值provide,进行给后代组件提供值,inject在后代组件上进行注入值\n\n * $attrs: 【父组件传递给子组件的数据，如果子组件没有使用props接收，这个数据就会出现在当前组件实例的$attrs属性上】\n\n * eventbus: // 手写发布订阅模式\n   \n   事件总线传值\n   \n   class EventBus {\n     // 记录事件和回调\n     clientList = {\n       send: [() => {}, () => {}],\n     }\n     // 订阅事件,参数event事件名,callback 回调\n     $on = function (event, callback) {\n       // 将事件和函数记录\n       // 如果事件记录过,那就将回调push\n       if (this.clientList[event]) {\n         this.clientList[event].push(callback)\n       } else {\n         this.clientList[event] = [callback]\n       }\n     }\n   \n     $emit = function (event, val) {\n       if (!this.clientList[event]) {\n         throw new Error(event + ' is not a event')\n       }\n       this.clientList[event].forEach((cb) => {\n         cb(val)\n       })\n     }\n   }\n   \n   const eventBus = new EventBus()\n   \n   // 订阅事件\n   eventBus.$on('send', (val) => {\n     console.log('send订阅' + val)\n   })\n   eventBus.$on('send', (val) => {\n     console.log('send订阅' + val)\n   })\n   \n   eventBus.$emit('send', 1)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n\n# 生命周期\n\n组件\n\n本质:就是函数,会在特定的阶段自动调用,生命周期函数\n\n作用:可以让我们在某个阶段做一些事情\n\n4个阶段\n\n阶段1: 创建阶段\n\n * beforeCreate: 开始创建实例,此时实例的数据和方法还没有\n\n * created:\n   \n   * 作用:实例已经创建完成,数据和方法都已存在\n   * 应用场景: 发送请求获取数据, 页面进入的方法需要立即执行\n   * 扩展: 如果非要在created中操作dom也可以,利用$nextTick\n\n阶段2: 挂载阶段(dom)\n\n * beforeMount: 开始挂载dom,真正的dom元素还没有挂载完成, 操作dom不可以\n\n * mounted:\n   \n   * dom已经挂载完成,可以操作真实dom\n   * 应用场景: 页面已进入操作dom\n\n阶段3: 更新阶段\n\n * beforeUpdate: 数据变了,但是视图还没变\n\n * updated: 数据和视图都变了\n\n阶段4: 销毁阶段\n\n * beforeDestory: 即将销毁\n\n * destoryed: 组件销毁\n   \n   * 应用场景: 清除挂载在window相关的行为,例如定义器\\事件\n\n父子\n\n创建挂载阶段\n\n父beforeCreated > 父created > 父 beforeMounted > 子beforeCreate > 子created > 子beforeMount > 子>mounted > 父mounted\n\n更新阶段\n\n如果更新的数据不涉及到子组件,只会父组件更新 父beforeUpdate > 父updated\n\n如果更新的数据涉及到子组件, 父beforeUpdate > 子beforeUpdate > 子updated > 父updated\n\n销毁阶段\n\n父beforeDestory > 子beforeDestory > 子destoryed> 父destoryed\n\n\n# mixin\n\nmixins: 将组件中的逻辑功能进行复用,复用部分可以提取到一个js文件中,然后通过mixins这个选项将该文件中暴漏的对象进行混入即可 可以混入哪些: 正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中 优先级:\n\n * 生命周期,组件和混入的都会调用(混入的先调用\n * data/computed数据: 进行合并,冲突以组件为主,mixins被覆盖\n * methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对\n\n\n# 路由模式\n\nabstract支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。\n\n * 是否有# hash有 history: 没有\n * 是否经过服务器 hash: 不会 history: 会\n * 是否需要后端配合 hash: 不需要 history: 需要\n * 底层原理 hash: 跳转 window.location.href, 监听 onhashchange history: 跳转history API, history.pushState和history.repleaceState 监听 onpopState(前进/后退) 封装的方法: pushState(history.pushState/history.repleaceState)\n\n\n# Vue-router&location.href\n\nVue Router 使用 history 模式时，通过 html5里面的History API 来实现路由的跳转。当页面路由发生变化时，Vue Router 会对浏览器的 History API 进行操作，从而实现无刷新页面的路由跳转。 如果用了location.href页面会刷新 具体来说，Vue Router 会通过 pushState() 或 replaceState() 方法向浏览器的历史记录栈添加或替换一个新的状态，并根据这个新的状态来触发路由的变化。而在浏览器的前进或后退操作时，Vue Router 则会通过 popstate 事件来监听历史记录的变化，并从而进行相应的路由跳转。 如果使用了hash模式，监听路径的变化用的onhashChange事件。\n\n\n# 路由懒加载\n\n\n# keep-alive\n\nkeep-alive是缓存组件，能在组件切换过程中，将状态保存到内存中，防止DOM重复渲染。\n\n他有三个属性，include包含要缓存的组件，exclude是排除掉除他之外的组件，max是最多要缓存多少组件。而且也可以通过路由的meta属性设置keepAlive为true来实现。\n\n设置了 keep-alive 缓存的组件，会多出两个特别的生命周期钩子，activated是激活，访问时触发，deactivated是不激活，退出时触发\n\n缓存过多如何进行销毁 可以使用 include 和 exclude 属性来选择哪些组件应该缓存，或者手动在销毁组件时调用 $destroy() 方法来销毁组件实例，释放相关的内存。另外，你也可以通过设置 max 属性来限制缓存的最大数量，超出最大数量的组件实例会被销毁。\n\n\n# 虚拟dom是什么\n\nVue的就地复用策略：Vue会尽可能地（同层级），对比虚拟DOM，复用旧DOM的结构，进行差异化更新。\n\n虚拟DOM是一个JS对象，是用来描述真实DOM的。真实DOM节点上挂载了太多的属性和方法，对比时性能消耗太大，所以使用虚拟DOM，只保存一些基本的属性。\n\n虚拟DOM有什么作用\n\n 1. 提高页面性能：虚拟DOM通过比较新旧两个虚拟DOM树的差异，仅更新需要更新的部分，从而减少了页面的重绘和回流，提高了页面的渲染性能和用户体验\n\n 2. 简化开发：虚拟DOM的实现方式通常是通过javaScript库来实现的，例如React，Vue等。这些库会将虚拟DOM与组件系统相结合，提供了一种高效，灵活的开发方式，使开发者可以更加专注业务逻辑的实现\n\n 3. 跨平台支持：虚拟DOM可以在多种平台上运行，列入Web，ISO，Android等。这使得开发者可以使用相同的代码库来开发跨平台应用，提供了开发效率和可维护性\n\n 4. 更好的抽象：虚拟DOM可以看作真的DOM的抽象表示，他提供了一种更好的抽象方式来描述页面的结构和行为。这是的开发者可以更加轻松地管理和维护页面的代码。\n\n 5. 更好的测试：虚拟DOM是的页面的行为可以更加容易地被测试，开发者可以通过虚拟DOM的操作来测试页面的行为，从而提高了测试的效率和可靠性\n\n 6. 新旧的虚拟dom进行对比，可以更加高效，节省了性能。\n\n\n# diff算法\n\ndiff算法的策略：\n\n * 当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom上\n * 差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程\n * 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较\n * 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的\n * 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。\n * 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。\n * 这样一直递归的遍历下去，直到整棵树完成对比。\n\ndiff算法会先比较头部和尾部的节点，头头、尾尾、尾头、头尾，如果没有匹配上就再去依次比较中间的节点，还没有就创新新的dom节点。\n\n在新旧dom比较时，有startIndex和endIndex，匹配到的节点和，会改变index的值。\n\n没有指定唯一的key时：\n\n 1. 没有key\n    \n    此时新旧节点的key都为undefine，所以相同，如果这时tagName也相同就直接复用该节点，同时往下一层级进行比较。\n\n 2. key为index\n    \n    此时新插入的dom只要位置与原dom位置一致则index相同，即key相同，直接复用并往下层级进行比较。\n\n可以发现当没有key和key为index的时候，diff算法的计算次数是相同的，并没有节省性能。\n\n指定唯一的key时：\n\n找到key和tagName都相同的节点直接复用，不在往下进行比较。\n\n如果在数组中插入一个值，制定了key的就只更新插入的一个dom，未指定key就会更新插入位置开始到最后的dom。\n\n> 因为Vue是双向相应的框架，Data里面的数据只要变化了，它会对应去渲染页面中相关的dom元素，出于渲染效率的考虑，作者在实现的时候实际上把所有页面的dom元素都进行了虚拟化，就是虚拟dom。如果某个数据发生了变化，那么他会考虑性能问题，去比较新的和旧的两个虚拟dom，通过diff算法找到最小的更新路径来更新dom元素，因为JS的运行相比渲染dom的效率是高很多的。\n\n> diff算法他的前提一定是同层级和同类型的的节点,那核心一定是列表循环中的diff算法。说白了，加key之后元素怎么移动、删除和创建。\n> \n> Vue2.0叫做双端交叉指针，新老Vdom各有两个指针，分别头头、尾尾、尾头、头尾，他会对比4次，如果说4次寻找到元素的key相同，就会去进行复用移动元素的位置。如果说这四种情况都没有匹配，就再去依次比较中间的节点，看老的Vdom里面有没有对应的元素，进行相应的移动删除和创建。\n> \n> Vue3.0叫做双端快速diff，实际上他也有两个指针，新老Vdom各两个，只对比两种情况，队头和队头，队尾和队尾，如果能匹配上，和vue2.0是一样的。一旦没有匹配上，会触发对新的Vdom去进行最长递增子序列的计算。这套算法说白了是在新的Vdom里寻找依次递增的元素有哪些，找到之后，那这些元素的顺序就是固定的。去寻找不在这些列表里面的元素和老的Vdom进行对比，再进行移动删除和创建。\n> \n> 不过最长递增子序列这个算法实际上他的时间复杂度是O(n*log(n)),但是在Vue2.0里面他的他的时间复杂度是O(n)。3.0的核心是要减少dom移动，在浏览器中dom的移动它是非常昂贵的，但是JS损失一点也没有关系。所以总体来看损失了JS的性能，但是提升了浏览器dom的渲染效率，总体来讲是利大于弊的。\n\n\n# Vue的性能优化有哪些\n\n 1. 编码阶段\n    * 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\n    * v-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理\n    * SPA 页面采用keep-alive缓存组件\n    * 在更多的情况下，使用v-if替代v-show\n    * key保证唯一\n    * 使用路由懒加载、异步组件\n    * 防抖、节流\n    * 第三方模块按需导入\n    * 长列表滚动到可视区域动态加载\n    * 图片懒加载\n 2. SEO优化\n    * 预渲染\n 3. 服务端渲染SSR\n    * 打包优化\n    * 压缩代码\n    * Tree Shaking/Scope Hoisting\n    * 使用cdn加载第三方模块\n    * 多线程打包happypack\n    * splitChunks抽离公共文件\n    * sourceMap优化\n 4. 用户体验\n    * 骨架屏\n    * PWA\n    * 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\n\n\n# Web worker\n\n一文彻底学会使用web worker\n\n在js主线程之外开辟新的Worker线程，并将一段js脚本运行其中，它赋予了开发者利用js操作多线程的能力。 因为是独立的线程，Worker线程与js主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给Worker线程去处理，当Worker线程计算完成，再把结果返回给js主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。\n\n\n# 跨页面通信\n\n    const bd = new BroadcastChannel('myChannel');\n    var btn = document.querySelector('.btn');\n    // 发送参数\n    btn.onclick = function () {\n        console.log('发送消息')\n        bd.postMessage('hello world');\n    }\n    // 接收参数\n    bd.onmessage = function (e) {\n        console.log(e.data);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n项目内以退出登录为例\n\n在utils中新建一个postMessage.js 接受参数\n\nimport store from '@/store'\nimport router from '@/router'\n\nconst bd = new BroadcastChannel('myChannel')\n\nbd.onmessage = function(e) {\n  if (e.data === 'logout') {\n    console.log('退出登录')\n    // 触发退出登录的action\n    store.dispatch('user/logoutAction')\n    // 跳转登录界面\n    router.push('/login')\n  }\n}\nexport default bd\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n触发后发送参数\n\nbd.postMessage('logout')\n\n\n1\n\n\nMain.js中引入\n\nimport '@/utils/postMessage'\n\n\n1\n\n\n\n# 文件上传\n\n 1. 通过element-ui的el-upload进行文件上传\n\n 2. 选择文件后触发el-upload组件的change事件，然后通过参数file内部的raw获取到文件对象\n\n 3. 将文件对象进行切片\n    \n    ●固定数量\n    \n    ●固定大小\n    \n    比如通过固定大小,切割的文件大小,根据file的size和每块的大小得到切割截取的次数,循环截取逻辑都是通过slice进行文件切片,循环截取.slice方法不是数组的slice方法,文件对象原型上的slice方法,继承自 Blob的slice\n\n 4. 断点续传\n    \n    ●串行：点击暂停或者上传失败，return终止，这次请求完事后，下一次不在请求了\n    \n    ●并行：点击暂停或者上传失败，return终止，取消请求\n    \n    ●chunList保存需要传送给后端的chunk，每上传成功一个，将chunkList中对应的chunk删除，下次重新请求从chunkList从头开始上传\n\n 5. 全部上传后,发送和并请求,后端会进行合并\n\n 6. 文件重新上传考虑文件内容相同文件名不同,上传过的秒传 spark-MD5根据文件内容生成hash,文件名变化不影响,通过SparckMd5.ArrayBuffer得到一个实例,通过该实例append一个buffer数据流 通过js api FIleReader 解析文件对象,实例有一个readAsArrayBuffer读取文件对象的流数据,读取是异步的,所以项目利用promise进行封装成功后利用resolve传出 根据end获取到hash,切两片列表中除了有一个chunk切片数据,还有一个filename: 由hash加索引\n\n\n# 路由导航守卫\n\n\n# 登录流程\n\n\n# 虚拟列表\n\n\n# 图片懒加载\n\n\n# 二次封装组件\n\n\n# JSBridge\n\n前端H5与客户端Native交互原理 - JSBridge双向通信机制的实现\n\n\n# 项目发布上线真实流程到底是什么？\n\n 1. 一般情况下发布上线不会由普通开发者直接操作。\n 2. devlopment\n 3. Master\n    1. 只需要负责把代码提交到git远程仓库里面 【git push】\n    2. 代码push上去之后会自动的执行发布上线的流程\n    3. 代码push上去之后会自动的执行发布上线的流程\n    4. jekins配置的时候，写死一些脚本\n    5. jenkins的服务可以实现\n    6. 功能分支 /login\n    7. 检测特定分支的提交 【dev 二部署到开发环境】【master ＞ 部署到线上环境】\n\n\n# 布局容器\n\nLayout 布局\n\nContainer 布局容器",normalizedContent:"# vue\n\n\n# vue优缺点\n\n优点：\n\n * 简单易用\n\n * 渐进式\n\n * 响应式\n\n * 双向数据绑定\n\n * 虚拟dom\n\n * 耦合低\n\n * 组件化开发\n\n * 结合vue-router实现spa\n\n缺点：\n\n * vue2: 逻辑分散\n\n * 无法兼容ie8一下,无法shim, 底层采用的object.defineproperty,无法兼容ie8一下\n\n * seo很不友好\n\n\n# spa的优缺点\n\n优点\n\n * 良好的交互体验\n\n * 单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过ajax异步获取，没有页面之间的切换，就不会出现“白屏现象”，也不会出现假死并有“闪烁”现象，页面显示流畅\n\n * 良好的前后端工作分离模式\n\n * 后端不再负责模板渲染、输出页面工作，后端api通用化，即同一套后端程序代码，不用修改就可以用于web界面、手机、平板等多种客户端\n\n * 减轻服务器压力\n\n * 单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍\n\n缺点\n\n * 首屏加载慢\n   \n   解决方案：\n   \n   1. vue-route懒加载\n      \n      vue-router懒加载就是按需加载组件，只有当路由被访问时才会加载对应的组件，而不是在加载首页的时候就加载，项目越大，对首屏加载的速度提升得越明显\n   \n   2. 使用cdn加速\n      \n      在做项目时，我们会用到很多库，采用cdn加载可以加快加载速度。\n   \n   3. 异步加载组件\n   \n   4. 服务端渲染\n      \n      服务端渲染还能对seo优化起到作用，有利于搜素引華抓取更多有用的信息（如果页面纯前端渲染，搜素引挚抓取到的就只是空页面）\n\n * 不利于seo\n   \n   seo 本质是一个服务器向另一个服务器发超请求，解析请求内容。但一般来说搜素引孳是不会去执行请求到的js的。也就是说，搜素引/挚的基础爬主的原理就是抓取url，然后获取htm/源代码并解析。如果—个单页应用，html在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，即搜索引孳请求到的html是模型页面而不是最终数据的渲染页面。这样就很不利于内容被搜索引孳搜索到\n   \n   解决方案：\n   \n   1. 服务端渲染\n      \n      服务器合成完整的 html 文件再输出到浏览器\n   \n   2. 页面预渲染\n   \n   3. 路由采用h5 history模式\n\n * 不适合开发大型项目\n   \n   大型项目中可能会涉及大量的dom操作、复杂的动画效果，也就不适合使用vue、react框架进行开发\n\n\n# 双向数据绑定\n\n * 双向数据绑定\n   \n   mvvm的设计模式的思想，数据发生变化，视图自动同步，视图发生变化，数据同步\n   \n   m：model数据\n   \n   v：view视图\n   \n   vm：实现view和视图的自动绑定\n   \n   在vue中v-model可以实现双向数据绑定\n   \n   在表单或组件均可使用v-model绑定数据，从而达到双向数据绑定的效果\n\n * v-model的表层原理 动态绑定value和注册input事件，所以v-model只是语法糖，视图发生变化同步数据很容易，因为页面有事件， 但是数据发生变化同步给视图实际vue采用的是数据响应式的原理\n\n * 数据响应式原理 简单：底层采用的是object.defineproperty数据劫持+观察者模式，在数据劫持的get中进行依赖收集，在set中通过dep.notify进行依赖通知，依赖收集和依赖通知采用的是观察者模式 复杂：源码\n\n\n# v-if&v-for\n\n在vue2中，v-if不能和v-for一起使用的原因是v-for的优先级比v-if高，每创建一个节点都会进行一次判断，造成性能浪费\n\n解决方案有两种，把v-if放在v-for的外层或者写一个计算属性，把数组过滤一遍再拿过来用v-for遍历\n\n\n# v-for时候key有什么作用\n\n * 简单通俗地讲，没有key时，状态默认绑定的是位置，有key时，状态根据key的属性值绑定到了响应的数组元素。\n * 在vue中，key属性主要用于帮助vue区分每个节点，以便在进行虚拟dom更新时能够更高效地操作。具体来说，vue会使用一个包含所有子节点的map对象来记录每个节点的key值与对应的虚拟dom节点，这样就可以在进行虚拟dom更新时，通过key值快速定位到对应的虚拟dom节点，从而进行相应的dom操作。这个map对象是vue内部维护的，不需要手动创建或操作。\n * 首先，key是为了更高效的更新虚拟dom。如果不加 key 的话，会循环遍历整个数组 (o(n))，加key就会去map里匹配 (o(1))，肯定加 key 要快一点，性能更高\n * 其次，如果不加 key 那么在插入或删除的时候就会出现，原本不是同一个节点的元素被认为是相同节点，因此可能会有额外 dom 操作\n * 推荐使用数组内的字段（保证唯一性）作为key的唯一标识，不建议直接使用index\n\n\n# data为什么是一个函数而不是对象\n\n> data是函数的目的：防止多个组件数据共享(污染)\n\n 1. 如果某个组件的data属性是一个对象，如果当前组件在很多地方都引入了，由于对象是引用数据类型，会造成组件间的数据污染\n 2. 如果data是一个函数，vue内部解析的时候，会执行当前函数，返回一个全新的对象 >> 防止组件之间的数据共享(数据污染)\n\n\n# vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？\n\n> 不会同步更新的\n\n流程\n\n当模板中使用到的某一个数据发生变化以后，会通知dep通知watcher(get的时候收集的，模板编译的时候)更新，而是把当前的更新方法通过nexttick放到callbacks数组里面，nexttick执行是在微任务里面的，所以不是同步更新\n\n> 总结：\n> \n> 不会立即同步执行重新渲染。\n> \n> vue 实现响应式并不是数据发生变化之后 dom 立即变化，而是按一定的策略进行 dom 的更新。\n> \n> vue 在更新 dom 时是异步执行的。只要侦听到数据变化， vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n> \n> 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 dom 操作是非常重要的。然后，在下一个的事件循环 tick 中，vue 刷新队列并执行实际（已去重的）工作。\n\n\n# nexttick\n\n> 因为vue 采用的是异步更新策略，当监听到数据发生变化的时候不会立即去更新dom，而是开启一个任务队列，并缓存在同一事件循环中发生的所有数据变更;这种做法带来的好处就是可以将多次数据更新合并成一次，减少操作dom的次数。\n> \n> nexttick 是接收一个回调函数作为参数，并将这个回调函数延迟到dom更新循环结束之后执行。在修改数据之后呢，立即调用nexttick来获取更新后的dom。nexttick主要采用了宏任务和微任务，根据执行环境，分别尝试采用promise，mutationobserver，setimmediate，如果以上都不行，就会用settimeout,定义了一个异步方案。多次的调用nexttick会将方法存入队列中，通过这个异步方法来清空当前队列\n\n如果想要【在修改数据后立刻得到更新后的dom结构/在created钩子函数內获取dom】，可以使用vue.nexttick()\n\n第一个参数为：回调函数（可以获取最近的dom结构）\n\n第二个参数为：执行函数上下文\n\n// 修改数据\nvm.message = '修改后的值'\n// dom 还没有更新\nconsole.log(vm.$el.textcontent) // 原始的值\nvue.nexttick(function () {\n  // dom 更新了\n  console.log(vm.$el.textcontent) // 修改后的值\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n组件内使用 vm.$nexttick() 实例方法只需要通过this.$nexttick()，并且回调函数中的 this 将自动绑定到当前的 vue 实例上\n\nthis.message = '修改后的值'\nconsole.log(this.$el.textcontent) // => '原始的值'\nthis.$nexttick(function () {\n    console.log(this.$el.textcontent) // => '修改后的值'\n})\n\n\n1\n2\n3\n4\n5\n\n\n$nexttick() 会返回一个 promise 对象，可以是用async/await完成相同作用的事情\n\nthis.message = '修改后的值'\nconsole.log(this.$el.textcontent) // => '原始的值'\nawait this.$nexttick()\nconsole.log(this.$el.textcontent) // => '修改后的值'\n\n\n1\n2\n3\n4\n\n\nnexttick实现原理（面试官）\n\nnexttick实现原理（源码）\n\n降级方案解读\n\n\n# vuex和localstorage的区别\n\n使用场景不同： vuex通常用于管理共享状态，可以在不同组件中共享数据，可以方便的实现数据响应式更新，使应用的状态管理更加可维护和可控。localstorage则更适合简单的数据储存需求，如存储用户设置，用户登录状态等。\n\n数据存储方式不同： vuex的数据存储在内存中，localstorage的数据存储在浏览器的localstorage对象中，由于vuex是在内存中操作数据，所以性能比localstorage更好。\n\n数据安全性不同： vuex的数据在内存中，相对比较安全，但是只能在同一个域名下的不同组件之间共享数据。localstorage的数据存储在客户端浏览器中，如果不加密或者防护，会有风险。\n\n\n# 单向数据流\n\n数据只能由父组件流向子组件，如果想要修改父组件内部的数据，只能子组件通过自定义事件触发父组件修改数据的方法，由父组件去修改数据，不能再子组件直接修改父组件数据\n\n\n# 组件传值\n\n * 父传子: 自定义属性传递参数，子组件使用props接收数据\n\n * 子传父: 父组件提供自定义事件，子组件通过＄emit触发事件进行传值\n\n * 兄弟组件通信：数据提升\n\n * vuex【解决跨组件传值比较混乱的问题，把数据集中维护，所有组件可以直接和vuex进行通信】\n\n * ref 可以获取到组件的实例，调用实例提供的方法可以直接传参\n\n * v-model【数据的双向绑定】值是valve属性，提供一个input事件，子组件通过＄emit触发input可以修改值【只能添加一个】\n   \n   如何修改value属性或者input事件名：model：{ event：\"修改事件名\"，prop：\"属性名，子\n\n * .sync 提供一个具体的属性，提供一个update：属性名：，触发此方法可以修改这个数据【可以添加多个】\n\n * $children: 可以获取当前组件的所有子组件,并以数组的格式返回数据\n\n * $parent: 可以获取到当前组件的父组件, 返回当前组件的父组件\n\n * provide/inject: 跨组件传值provide,进行给后代组件提供值,inject在后代组件上进行注入值\n\n * $attrs: 【父组件传递给子组件的数据，如果子组件没有使用props接收，这个数据就会出现在当前组件实例的$attrs属性上】\n\n * eventbus: // 手写发布订阅模式\n   \n   事件总线传值\n   \n   class eventbus {\n     // 记录事件和回调\n     clientlist = {\n       send: [() => {}, () => {}],\n     }\n     // 订阅事件,参数event事件名,callback 回调\n     $on = function (event, callback) {\n       // 将事件和函数记录\n       // 如果事件记录过,那就将回调push\n       if (this.clientlist[event]) {\n         this.clientlist[event].push(callback)\n       } else {\n         this.clientlist[event] = [callback]\n       }\n     }\n   \n     $emit = function (event, val) {\n       if (!this.clientlist[event]) {\n         throw new error(event + ' is not a event')\n       }\n       this.clientlist[event].foreach((cb) => {\n         cb(val)\n       })\n     }\n   }\n   \n   const eventbus = new eventbus()\n   \n   // 订阅事件\n   eventbus.$on('send', (val) => {\n     console.log('send订阅' + val)\n   })\n   eventbus.$on('send', (val) => {\n     console.log('send订阅' + val)\n   })\n   \n   eventbus.$emit('send', 1)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n\n# 生命周期\n\n组件\n\n本质:就是函数,会在特定的阶段自动调用,生命周期函数\n\n作用:可以让我们在某个阶段做一些事情\n\n4个阶段\n\n阶段1: 创建阶段\n\n * beforecreate: 开始创建实例,此时实例的数据和方法还没有\n\n * created:\n   \n   * 作用:实例已经创建完成,数据和方法都已存在\n   * 应用场景: 发送请求获取数据, 页面进入的方法需要立即执行\n   * 扩展: 如果非要在created中操作dom也可以,利用$nexttick\n\n阶段2: 挂载阶段(dom)\n\n * beforemount: 开始挂载dom,真正的dom元素还没有挂载完成, 操作dom不可以\n\n * mounted:\n   \n   * dom已经挂载完成,可以操作真实dom\n   * 应用场景: 页面已进入操作dom\n\n阶段3: 更新阶段\n\n * beforeupdate: 数据变了,但是视图还没变\n\n * updated: 数据和视图都变了\n\n阶段4: 销毁阶段\n\n * beforedestory: 即将销毁\n\n * destoryed: 组件销毁\n   \n   * 应用场景: 清除挂载在window相关的行为,例如定义器\\事件\n\n父子\n\n创建挂载阶段\n\n父beforecreated > 父created > 父 beforemounted > 子beforecreate > 子created > 子beforemount > 子>mounted > 父mounted\n\n更新阶段\n\n如果更新的数据不涉及到子组件,只会父组件更新 父beforeupdate > 父updated\n\n如果更新的数据涉及到子组件, 父beforeupdate > 子beforeupdate > 子updated > 父updated\n\n销毁阶段\n\n父beforedestory > 子beforedestory > 子destoryed> 父destoryed\n\n\n# mixin\n\nmixins: 将组件中的逻辑功能进行复用,复用部分可以提取到一个js文件中,然后通过mixins这个选项将该文件中暴漏的对象进行混入即可 可以混入哪些: 正常的实例对象一样包含实例选项，这些选项将会被合并到最终的选项中 优先级:\n\n * 生命周期,组件和混入的都会调用(混入的先调用\n * data/computed数据: 进行合并,冲突以组件为主,mixins被覆盖\n * methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对\n\n\n# 路由模式\n\nabstract支持所有 javascript 运行环境，如 node.js 服务器端。如果发现没有浏览器的 api，路由会自动强制进入这个模式。\n\n * 是否有# hash有 history: 没有\n * 是否经过服务器 hash: 不会 history: 会\n * 是否需要后端配合 hash: 不需要 history: 需要\n * 底层原理 hash: 跳转 window.location.href, 监听 onhashchange history: 跳转history api, history.pushstate和history.repleacestate 监听 onpopstate(前进/后退) 封装的方法: pushstate(history.pushstate/history.repleacestate)\n\n\n# vue-router&location.href\n\nvue router 使用 history 模式时，通过 html5里面的history api 来实现路由的跳转。当页面路由发生变化时，vue router 会对浏览器的 history api 进行操作，从而实现无刷新页面的路由跳转。 如果用了location.href页面会刷新 具体来说，vue router 会通过 pushstate() 或 replacestate() 方法向浏览器的历史记录栈添加或替换一个新的状态，并根据这个新的状态来触发路由的变化。而在浏览器的前进或后退操作时，vue router 则会通过 popstate 事件来监听历史记录的变化，并从而进行相应的路由跳转。 如果使用了hash模式，监听路径的变化用的onhashchange事件。\n\n\n# 路由懒加载\n\n\n# keep-alive\n\nkeep-alive是缓存组件，能在组件切换过程中，将状态保存到内存中，防止dom重复渲染。\n\n他有三个属性，include包含要缓存的组件，exclude是排除掉除他之外的组件，max是最多要缓存多少组件。而且也可以通过路由的meta属性设置keepalive为true来实现。\n\n设置了 keep-alive 缓存的组件，会多出两个特别的生命周期钩子，activated是激活，访问时触发，deactivated是不激活，退出时触发\n\n缓存过多如何进行销毁 可以使用 include 和 exclude 属性来选择哪些组件应该缓存，或者手动在销毁组件时调用 $destroy() 方法来销毁组件实例，释放相关的内存。另外，你也可以通过设置 max 属性来限制缓存的最大数量，超出最大数量的组件实例会被销毁。\n\n\n# 虚拟dom是什么\n\nvue的就地复用策略：vue会尽可能地（同层级），对比虚拟dom，复用旧dom的结构，进行差异化更新。\n\n虚拟dom是一个js对象，是用来描述真实dom的。真实dom节点上挂载了太多的属性和方法，对比时性能消耗太大，所以使用虚拟dom，只保存一些基本的属性。\n\n虚拟dom有什么作用\n\n 1. 提高页面性能：虚拟dom通过比较新旧两个虚拟dom树的差异，仅更新需要更新的部分，从而减少了页面的重绘和回流，提高了页面的渲染性能和用户体验\n\n 2. 简化开发：虚拟dom的实现方式通常是通过javascript库来实现的，例如react，vue等。这些库会将虚拟dom与组件系统相结合，提供了一种高效，灵活的开发方式，使开发者可以更加专注业务逻辑的实现\n\n 3. 跨平台支持：虚拟dom可以在多种平台上运行，列入web，iso，android等。这使得开发者可以使用相同的代码库来开发跨平台应用，提供了开发效率和可维护性\n\n 4. 更好的抽象：虚拟dom可以看作真的dom的抽象表示，他提供了一种更好的抽象方式来描述页面的结构和行为。这是的开发者可以更加轻松地管理和维护页面的代码。\n\n 5. 更好的测试：虚拟dom是的页面的行为可以更加容易地被测试，开发者可以通过虚拟dom的操作来测试页面的行为，从而提高了测试的效率和可靠性\n\n 6. 新旧的虚拟dom进行对比，可以更加高效，节省了性能。\n\n\n# diff算法\n\ndiff算法的策略：\n\n * 当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom上\n * 差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程\n * 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较\n * 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的\n * 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。\n * 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。\n * 这样一直递归的遍历下去，直到整棵树完成对比。\n\ndiff算法会先比较头部和尾部的节点，头头、尾尾、尾头、头尾，如果没有匹配上就再去依次比较中间的节点，还没有就创新新的dom节点。\n\n在新旧dom比较时，有startindex和endindex，匹配到的节点和，会改变index的值。\n\n没有指定唯一的key时：\n\n 1. 没有key\n    \n    此时新旧节点的key都为undefine，所以相同，如果这时tagname也相同就直接复用该节点，同时往下一层级进行比较。\n\n 2. key为index\n    \n    此时新插入的dom只要位置与原dom位置一致则index相同，即key相同，直接复用并往下层级进行比较。\n\n可以发现当没有key和key为index的时候，diff算法的计算次数是相同的，并没有节省性能。\n\n指定唯一的key时：\n\n找到key和tagname都相同的节点直接复用，不在往下进行比较。\n\n如果在数组中插入一个值，制定了key的就只更新插入的一个dom，未指定key就会更新插入位置开始到最后的dom。\n\n> 因为vue是双向相应的框架，data里面的数据只要变化了，它会对应去渲染页面中相关的dom元素，出于渲染效率的考虑，作者在实现的时候实际上把所有页面的dom元素都进行了虚拟化，就是虚拟dom。如果某个数据发生了变化，那么他会考虑性能问题，去比较新的和旧的两个虚拟dom，通过diff算法找到最小的更新路径来更新dom元素，因为js的运行相比渲染dom的效率是高很多的。\n\n> diff算法他的前提一定是同层级和同类型的的节点,那核心一定是列表循环中的diff算法。说白了，加key之后元素怎么移动、删除和创建。\n> \n> vue2.0叫做双端交叉指针，新老vdom各有两个指针，分别头头、尾尾、尾头、头尾，他会对比4次，如果说4次寻找到元素的key相同，就会去进行复用移动元素的位置。如果说这四种情况都没有匹配，就再去依次比较中间的节点，看老的vdom里面有没有对应的元素，进行相应的移动删除和创建。\n> \n> vue3.0叫做双端快速diff，实际上他也有两个指针，新老vdom各两个，只对比两种情况，队头和队头，队尾和队尾，如果能匹配上，和vue2.0是一样的。一旦没有匹配上，会触发对新的vdom去进行最长递增子序列的计算。这套算法说白了是在新的vdom里寻找依次递增的元素有哪些，找到之后，那这些元素的顺序就是固定的。去寻找不在这些列表里面的元素和老的vdom进行对比，再进行移动删除和创建。\n> \n> 不过最长递增子序列这个算法实际上他的时间复杂度是o(n*log(n)),但是在vue2.0里面他的他的时间复杂度是o(n)。3.0的核心是要减少dom移动，在浏览器中dom的移动它是非常昂贵的，但是js损失一点也没有关系。所以总体来看损失了js的性能，但是提升了浏览器dom的渲染效率，总体来讲是利大于弊的。\n\n\n# vue的性能优化有哪些\n\n 1. 编码阶段\n    * 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher\n    * v-if和v-for不能连用如果需要使用v-for给每项元素绑定事件时使用事件代理\n    * spa 页面采用keep-alive缓存组件\n    * 在更多的情况下，使用v-if替代v-show\n    * key保证唯一\n    * 使用路由懒加载、异步组件\n    * 防抖、节流\n    * 第三方模块按需导入\n    * 长列表滚动到可视区域动态加载\n    * 图片懒加载\n 2. seo优化\n    * 预渲染\n 3. 服务端渲染ssr\n    * 打包优化\n    * 压缩代码\n    * tree shaking/scope hoisting\n    * 使用cdn加载第三方模块\n    * 多线程打包happypack\n    * splitchunks抽离公共文件\n    * sourcemap优化\n 4. 用户体验\n    * 骨架屏\n    * pwa\n    * 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。\n\n\n# web worker\n\n一文彻底学会使用web worker\n\n在js主线程之外开辟新的worker线程，并将一段js脚本运行其中，它赋予了开发者利用js操作多线程的能力。 因为是独立的线程，worker线程与js主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给worker线程去处理，当worker线程计算完成，再把结果返回给js主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。\n\n\n# 跨页面通信\n\n    const bd = new broadcastchannel('mychannel');\n    var btn = document.queryselector('.btn');\n    // 发送参数\n    btn.onclick = function () {\n        console.log('发送消息')\n        bd.postmessage('hello world');\n    }\n    // 接收参数\n    bd.onmessage = function (e) {\n        console.log(e.data);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n项目内以退出登录为例\n\n在utils中新建一个postmessage.js 接受参数\n\nimport store from '@/store'\nimport router from '@/router'\n\nconst bd = new broadcastchannel('mychannel')\n\nbd.onmessage = function(e) {\n  if (e.data === 'logout') {\n    console.log('退出登录')\n    // 触发退出登录的action\n    store.dispatch('user/logoutaction')\n    // 跳转登录界面\n    router.push('/login')\n  }\n}\nexport default bd\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n触发后发送参数\n\nbd.postmessage('logout')\n\n\n1\n\n\nmain.js中引入\n\nimport '@/utils/postmessage'\n\n\n1\n\n\n\n# 文件上传\n\n 1. 通过element-ui的el-upload进行文件上传\n\n 2. 选择文件后触发el-upload组件的change事件，然后通过参数file内部的raw获取到文件对象\n\n 3. 将文件对象进行切片\n    \n    ●固定数量\n    \n    ●固定大小\n    \n    比如通过固定大小,切割的文件大小,根据file的size和每块的大小得到切割截取的次数,循环截取逻辑都是通过slice进行文件切片,循环截取.slice方法不是数组的slice方法,文件对象原型上的slice方法,继承自 blob的slice\n\n 4. 断点续传\n    \n    ●串行：点击暂停或者上传失败，return终止，这次请求完事后，下一次不在请求了\n    \n    ●并行：点击暂停或者上传失败，return终止，取消请求\n    \n    ●chunlist保存需要传送给后端的chunk，每上传成功一个，将chunklist中对应的chunk删除，下次重新请求从chunklist从头开始上传\n\n 5. 全部上传后,发送和并请求,后端会进行合并\n\n 6. 文件重新上传考虑文件内容相同文件名不同,上传过的秒传 spark-md5根据文件内容生成hash,文件名变化不影响,通过sparckmd5.arraybuffer得到一个实例,通过该实例append一个buffer数据流 通过js api filereader 解析文件对象,实例有一个readasarraybuffer读取文件对象的流数据,读取是异步的,所以项目利用promise进行封装成功后利用resolve传出 根据end获取到hash,切两片列表中除了有一个chunk切片数据,还有一个filename: 由hash加索引\n\n\n# 路由导航守卫\n\n\n# 登录流程\n\n\n# 虚拟列表\n\n\n# 图片懒加载\n\n\n# 二次封装组件\n\n\n# jsbridge\n\n前端h5与客户端native交互原理 - jsbridge双向通信机制的实现\n\n\n# 项目发布上线真实流程到底是什么？\n\n 1. 一般情况下发布上线不会由普通开发者直接操作。\n 2. devlopment\n 3. master\n    1. 只需要负责把代码提交到git远程仓库里面 【git push】\n    2. 代码push上去之后会自动的执行发布上线的流程\n    3. 代码push上去之后会自动的执行发布上线的流程\n    4. jekins配置的时候，写死一些脚本\n    5. jenkins的服务可以实现\n    6. 功能分支 /login\n    7. 检测特定分支的提交 【dev 二部署到开发环境】【master ＞ 部署到线上环境】\n\n\n# 布局容器\n\nlayout 布局\n\ncontainer 布局容器",charsets:{cjk:!0},lastUpdated:"2025/03/04, 10:43:57",lastUpdatedTimestamp:1741056237e3},{title:"面试问题集锦",frontmatter:{title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/more/interview/",categories:["更多","面试"],tags:["面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/04.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html",relativePath:"55.更多/04.面试/01.面试问题集锦.md",key:"v-6a2bce46",path:"/more/interview/",headers:[{level:2,title:"请做一下自我介绍",slug:"请做一下自我介绍",normalizedTitle:"请做一下自我介绍",charIndex:13},{level:2,title:"你最大的优点是什么？",slug:"你最大的优点是什么",normalizedTitle:"你最大的优点是什么？",charIndex:166},{level:2,title:"说说你最大的缺点？",slug:"说说你最大的缺点",normalizedTitle:"说说你最大的缺点？",charIndex:252},{level:2,title:"说说你对加班的看法？",slug:"说说你对加班的看法",normalizedTitle:"说说你对加班的看法？",charIndex:378},{level:2,title:"说说你对薪资的要求？",slug:"说说你对薪资的要求",normalizedTitle:"说说你对薪资的要求？",charIndex:513},{level:2,title:"在五年内，你的职业规划？",slug:"在五年内-你的职业规划",normalizedTitle:"在五年内，你的职业规划？",charIndex:903},{level:2,title:"你朋友对你的评价?",slug:"你朋友对你的评价",normalizedTitle:"你朋友对你的评价?",charIndex:1081},{level:2,title:"你还有什么问题要问吗?",slug:"你还有什么问题要问吗",normalizedTitle:"你还有什么问题要问吗?",charIndex:1241},{level:2,title:"录用后发现不适合这个职位，怎么办?",slug:"录用后发现不适合这个职位-怎么办",normalizedTitle:"录用后发现不适合这个职位，怎么办?",charIndex:1424},{level:2,title:"工作时跟领导意见不同怎么办?",slug:"工作时跟领导意见不同怎么办",normalizedTitle:"工作时跟领导意见不同怎么办?",charIndex:1601},{level:2,title:"工作出现失误并造成损失，你会怎么做?",slug:"工作出现失误并造成损失-你会怎么做",normalizedTitle:"工作出现失误并造成损失，你会怎么做?",charIndex:1779},{level:2,title:"谈谈你对跳槽的看法?",slug:"谈谈你对跳槽的看法",normalizedTitle:"谈谈你对跳槽的看法?",charIndex:2028},{level:2,title:"和同事、上司难以相处，你怎么办?",slug:"和同事、上司难以相处-你怎么办",normalizedTitle:"和同事、上司难以相处，你怎么办?",charIndex:2098},{level:2,title:"上级领导抢了你的功劳怎么办?",slug:"上级领导抢了你的功劳怎么办",normalizedTitle:"上级领导抢了你的功劳怎么办?",charIndex:2311},{level:2,title:"同事孤立你，你怎么办?",slug:"同事孤立你-你怎么办",normalizedTitle:"同事孤立你，你怎么办?",charIndex:2485},{level:2,title:"你最近是否参加了培训课程?",slug:"你最近是否参加了培训课程",normalizedTitle:"你最近是否参加了培训课程?",charIndex:2582},{level:2,title:"你对于我们公司了解多少?",slug:"你对于我们公司了解多少",normalizedTitle:"你对于我们公司了解多少?",charIndex:2636},{level:2,title:"你最擅长的技术方向是什么?",slug:"你最擅长的技术方向是什么",normalizedTitle:"你最擅长的技术方向是什么?",charIndex:2727},{level:2,title:"请说出你选择这份工作的动机?",slug:"请说出你选择这份工作的动机",normalizedTitle:"请说出你选择这份工作的动机?",charIndex:2784},{level:2,title:"你能为我们公司带来什么呢?",slug:"你能为我们公司带来什么呢",normalizedTitle:"你能为我们公司带来什么呢?",charIndex:2912},{level:2,title:"最能概括你自己的三个词?",slug:"最能概括你自己的三个词",normalizedTitle:"最能概括你自己的三个词?",charIndex:3159},{level:2,title:"作为被面试者给我打一下分?",slug:"作为被面试者给我打一下分",normalizedTitle:"作为被面试者给我打一下分?",charIndex:3225},{level:2,title:"你怎么理解你应聘的职位?",slug:"你怎么理解你应聘的职位",normalizedTitle:"你怎么理解你应聘的职位?",charIndex:3302},{level:2,title:"喜欢这份工作的哪一点?",slug:"喜欢这份工作的哪一点",normalizedTitle:"喜欢这份工作的哪一点?",charIndex:3346},{level:2,title:"为什么要离职?",slug:"为什么要离职",normalizedTitle:"为什么要离职?",charIndex:3497},{level:2,title:"说说你对行业、技术发展趋势的看法?",slug:"说说你对行业、技术发展趋势的看法",normalizedTitle:"说说你对行业、技术发展趋势的看法?",charIndex:3739},{level:2,title:"对工作的期望与目标何在?",slug:"对工作的期望与目标何在",normalizedTitle:"对工作的期望与目标何在?",charIndex:3923},{level:2,title:"谈谈你的家庭?",slug:"谈谈你的家庭",normalizedTitle:"谈谈你的家庭?",charIndex:4183},{level:2,title:"你认为自己申请这个职位还欠缺什么?",slug:"你认为自己申请这个职位还欠缺什么",normalizedTitle:"你认为自己申请这个职位还欠缺什么?",charIndex:4413},{level:2,title:"你欣赏哪种性格的人?",slug:"你欣赏哪种性格的人",normalizedTitle:"你欣赏哪种性格的人?",charIndex:4580},{level:2,title:"你通常如何处理别人的批评?",slug:"你通常如何处理别人的批评",normalizedTitle:"你通常如何处理别人的批评?",charIndex:4633},{level:2,title:"怎样对待自己的失败?",slug:"怎样对待自己的失败",normalizedTitle:"怎样对待自己的失败?",charIndex:4705},{level:2,title:"什么会让你有成就感?",slug:"什么会让你有成就感",normalizedTitle:"什么会让你有成就感?",charIndex:4761},{level:2,title:"眼下你生活中最重要的是什么?",slug:"眼下你生活中最重要的是什么",normalizedTitle:"眼下你生活中最重要的是什么?",charIndex:4805},{level:2,title:"你为什么愿意到我们公司来工作?",slug:"你为什么愿意到我们公司来工作",normalizedTitle:"你为什么愿意到我们公司来工作?",charIndex:4867},{level:2,title:"你和别人发生过争执吗?",slug:"你和别人发生过争执吗",normalizedTitle:"你和别人发生过争执吗?",charIndex:5043},{level:2,title:"你做过的哪件事最令自己感到骄傲?",slug:"你做过的哪件事最令自己感到骄傲",normalizedTitle:"你做过的哪件事最令自己感到骄傲?",charIndex:5234},{level:2,title:"对这项工作，你有哪些可预见的困难?",slug:"对这项工作-你有哪些可预见的困难",normalizedTitle:"对这项工作，你有哪些可预见的困难?",charIndex:5366},{level:2,title:"录用后你将怎样开展工作?",slug:"录用后你将怎样开展工作",normalizedTitle:"录用后你将怎样开展工作?",charIndex:5512},{level:2,title:"你希望与什么样的上级共事?",slug:"你希望与什么样的上级共事",normalizedTitle:"你希望与什么样的上级共事?",charIndex:5657},{level:2,title:"你工作经验欠缺，如何能胜任这项工作?",slug:"你工作经验欠缺-如何能胜任这项工作",normalizedTitle:"你工作经验欠缺，如何能胜任这项工作?",charIndex:5813},{level:2,title:"你会怎样获得同事的帮助?",slug:"你会怎样获得同事的帮助",normalizedTitle:"你会怎样获得同事的帮助?",charIndex:6093},{level:2,title:"如果你没被录用，你怎么打算?",slug:"如果你没被录用-你怎么打算",normalizedTitle:"如果你没被录用，你怎么打算?",charIndex:6229},{level:2,title:"最令你沮丧的事情?",slug:"最令你沮丧的事情",normalizedTitle:"最令你沮丧的事情?",charIndex:6671},{level:2,title:"想过创业吗?",slug:"想过创业吗",normalizedTitle:"想过创业吗?",charIndex:6868},{level:2,title:"为什么我们要在众多的面试者中选择你?",slug:"为什么我们要在众多的面试者中选择你",normalizedTitle:"为什么我们要在众多的面试者中选择你?",charIndex:6941},{level:2,title:"除了本公司外，还应聘了哪些公司?",slug:"除了本公司外-还应聘了哪些公司",normalizedTitle:"除了本公司外，还应聘了哪些公司?",charIndex:7126},{level:2,title:"你并非毕业于名牌院校?",slug:"你并非毕业于名牌院校",normalizedTitle:"你并非毕业于名牌院校?",charIndex:7255},{level:2,title:"怎样看待学历和能力?",slug:"怎样看待学历和能力",normalizedTitle:"怎样看待学历和能力?",charIndex:7379},{level:2,title:"谈谈如何适应办公室工作的新环境?",slug:"谈谈如何适应办公室工作的新环境",normalizedTitle:"谈谈如何适应办公室工作的新环境?",charIndex:7605},{level:2,title:"谈谈对这个职务的期许?",slug:"谈谈对这个职务的期许",normalizedTitle:"谈谈对这个职务的期许?",charIndex:7742},{level:2,title:"何时可以到职?",slug:"何时可以到职",normalizedTitle:"何时可以到职?",charIndex:7882}],headersStr:"请做一下自我介绍 你最大的优点是什么？ 说说你最大的缺点？ 说说你对加班的看法？ 说说你对薪资的要求？ 在五年内，你的职业规划？ 你朋友对你的评价? 你还有什么问题要问吗? 录用后发现不适合这个职位，怎么办? 工作时跟领导意见不同怎么办? 工作出现失误并造成损失，你会怎么做? 谈谈你对跳槽的看法? 和同事、上司难以相处，你怎么办? 上级领导抢了你的功劳怎么办? 同事孤立你，你怎么办? 你最近是否参加了培训课程? 你对于我们公司了解多少? 你最擅长的技术方向是什么? 请说出你选择这份工作的动机? 你能为我们公司带来什么呢? 最能概括你自己的三个词? 作为被面试者给我打一下分? 你怎么理解你应聘的职位? 喜欢这份工作的哪一点? 为什么要离职? 说说你对行业、技术发展趋势的看法? 对工作的期望与目标何在? 谈谈你的家庭? 你认为自己申请这个职位还欠缺什么? 你欣赏哪种性格的人? 你通常如何处理别人的批评? 怎样对待自己的失败? 什么会让你有成就感? 眼下你生活中最重要的是什么? 你为什么愿意到我们公司来工作? 你和别人发生过争执吗? 你做过的哪件事最令自己感到骄傲? 对这项工作，你有哪些可预见的困难? 录用后你将怎样开展工作? 你希望与什么样的上级共事? 你工作经验欠缺，如何能胜任这项工作? 你会怎样获得同事的帮助? 如果你没被录用，你怎么打算? 最令你沮丧的事情? 想过创业吗? 为什么我们要在众多的面试者中选择你? 除了本公司外，还应聘了哪些公司? 你并非毕业于名牌院校? 怎样看待学历和能力? 谈谈如何适应办公室工作的新环境? 谈谈对这个职务的期许? 何时可以到职?",content:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",normalizedContent:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在xx经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是xx的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的oem合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过xx近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、eq上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了xx的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:33:08",lastUpdatedTimestamp:1682357588e3},{title:"浏览器&http",frontmatter:{title:"浏览器&http",date:"2022-03-03T15:02:16.000Z",permalink:"/pages/d178b0/",categories:["更多","技术面"],tags:["面试总结"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/03.%E6%B5%8F%E8%A7%88%E5%99%A8&http.html",relativePath:"55.更多/05.技术面/03.浏览器&http.md",key:"v-c17e9308",path:"/pages/d178b0/",headers:[{level:2,title:"强缓存&协商缓存",slug:"强缓存-协商缓存",normalizedTitle:"强缓存&amp;协商缓存",charIndex:null},{level:2,title:"cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:1725},{level:2,title:"TCP UDP",slug:"tcp-udp",normalizedTitle:"tcp udp",charIndex:1736},{level:2,title:"在浏览器里输入url会经历哪些流程？",slug:"在浏览器里输入url会经历哪些流程",normalizedTitle:"在浏览器里输入url会经历哪些流程？",charIndex:1748},{level:3,title:"问1： 为什么把CSS加载放在head里？",slug:"问1-为什么把css加载放在head里",normalizedTitle:"问1： 为什么把css加载放在head里？",charIndex:2358},{level:3,title:"问2：为什么要把js加载放着body最后？",slug:"问2-为什么要把js加载放着body最后",normalizedTitle:"问2：为什么要把js加载放着body最后？",charIndex:2453},{level:2,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:2540},{level:3,title:"1. 浏览器加载资源优化",slug:"_1-浏览器加载资源优化",normalizedTitle:"1. 浏览器加载资源优化",charIndex:2549},{level:3,title:"2. 浏览器渲染优化",slug:"_2-浏览器渲染优化",normalizedTitle:"2. 浏览器渲染优化",charIndex:2900},{level:3,title:"3. 打包层面",slug:"_3-打包层面",normalizedTitle:"3. 打包层面",charIndex:3504},{level:4,title:"服务端渲染ssr",slug:"服务端渲染ssr",normalizedTitle:"服务端渲染ssr",charIndex:4211},{level:2,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:2988},{level:2,title:"跨域",slug:"跨域",normalizedTitle:"跨域",charIndex:6354},{level:3,title:"开发环境下解决跨域问题",slug:"开发环境下解决跨域问题",normalizedTitle:"开发环境下解决跨域问题",charIndex:6810},{level:3,title:"生产环境下解决跨域问题",slug:"生产环境下解决跨域问题",normalizedTitle:"生产环境下解决跨域问题",charIndex:6961},{level:2,title:"http版本",slug:"http版本",normalizedTitle:"http版本",charIndex:7260},{level:2,title:"http&https",slug:"http-https",normalizedTitle:"http&amp;https",charIndex:null},{level:2,title:"状态码",slug:"状态码",normalizedTitle:"状态码",charIndex:1381},{level:2,title:"get和post请求的区别",slug:"get和post请求的区别",normalizedTitle:"get和post请求的区别",charIndex:10225}],headersStr:"强缓存&协商缓存 cookie TCP UDP 在浏览器里输入url会经历哪些流程？ 问1： 为什么把CSS加载放在head里？ 问2：为什么要把js加载放着body最后？ 性能优化 1. 浏览器加载资源优化 2. 浏览器渲染优化 3. 打包层面 服务端渲染ssr 图片懒加载 跨域 开发环境下解决跨域问题 生产环境下解决跨域问题 http版本 http&https 状态码 get和post请求的区别",content:'# 强缓存&协商缓存\n\n> 浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，需要缓存的话就将请求结果和缓存标识存入浏览器缓存中\n> \n> 缓存机制的基本原则是：\n> \n>  * 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n>  * 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n> \n> 强制缓存就是向浏览器缓存查找该请求结果，并根据这个结果的缓存规则来决定是否使用该缓存结果的过程。\n> \n> 当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是Expires和Cache-Control，其中Cache-Control优先级比Expires高。\n> \n> Expires 是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\n> \n> > Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1，那么在HTTP/1.1中网页缓存还是否由Expires控制？\n> \n> 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么Cache-Control又是如何控制的呢？\n> \n> # Cache-Control\n> \n> 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：\n> \n>  * public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n>  * private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n>  * no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n>  * no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n>  * max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n> \n> 由于Cache-Control的优先级比expires高，在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control相比于expires是更好的选择，所以同时存在时，只有Cache-Control生效。\n\n浏览器的缓存主要是为了提高访问效率，什么是强制缓存 呢？比如说我们访问一个网站，当我们第一次访问的时候，里面一些静态资源，比如说图片啊CSS，JS这些资源，甚至icon。这些实际上是从服务器上下载的。但是如果说我们刷新网页的话，那这个资源是没有必要在服务器上重新去请求的，因为他没有变动。那像这种资源的话，浏览器会默认是一些强制缓存。那么强制缓存，当你第二次访问的时候，他不会再去服务器上重新下载，同样他会给你返回一个200的状态码，但是这个资源呢，它会从浏览器的本地缓存里去取这种图片，像这种图片第二次去取的缓存的状态，就是一种强制缓存。\n\n协商缓存 ，就是我们和后台去协商这个资源，要不要对它去进行缓存。如果这个资源是需要协商缓存的，那第一次返回的结果里面的状态码是200，同时会携带一个是否更新Last Modified的一个状态，还会给他返回一个唯一标识etag，可以理解为是一个内容资源的hash。只要说这个资源在服务端没有变化，那么当下次访问的时候，后台会对比这个标签etag，或者说对比这个Last Modified的时间。如果这个资源没有变动，那么他会告诉你返回一个304的状态码，那当浏览器接收到这个304的状态之后，他会认为这个资源没有变化，我只需要从本地把这个缓存的资源拿出来就行了\n\n\n# cookie\n\n\n# TCP UDP\n\n\n# 在浏览器里输入url会经历哪些流程？\n\n输入url会发生什么事情？\n\n 1. 核心：引到自己擅长的领域\n\n 2. 域名 ==> 解析成IP【DNS服务器做的这个事情】\n\n 3. TCP的三次握手，四次挥手\n\n 4. 连接建立\n\n 5. 服务器端会根据当前这次请求的请求头里面的if-modifined-since，和服务器端的当前文件的上次修改时间进行对比，如果一致，本地缓存可用，服务器返回304的状态码，直接使用本地的缓存资源\n\n 6. 强缓存\n    \n    1. 第一次请求服务器端资源的时候，服务器不仅返回当前资源，同时会通过响应头里面cache-control:max-age=最大缓存时间\n    \n    2. 下次请求的时候，先判断缓存是否到期，如果没有到期，使用本地缓存资源，如果到期，请求服务器端\n\n 7. 如何合理的设置强缓存\n    \n    1. html不能加缓存\n    \n    2. js和css需要添加强缓存，但是每个文件需要一个唯一的hash值，如果没有hash值的话，强缓存会一直命中，导致的问题是：加入服务器端文件更新了，本地浏览器端获取不到最新的内容\n\n 8. 浏览器获取到html页面的时候，先解析一下html，预加载的文件，会提前加载，预解析完毕以后，开始绘制界面，构建HTML树，构建css树，合并成渲染树，调用显卡渲染到页面上。\n\n 9. js的异步加载\n\n\n# 问1： 为什么把CSS加载放在head里？\n\n如果我们把css加载放在最后，这时候页面已经渲染完成了，然后发现css改变了，还有重新一个个去查找渲染一遍，这样就拖慢了页面渲染的速度\n\n\n# 问2：为什么要把js加载放着body最后？\n\n因为遇到<script>会暂停渲染，如果把js加载放在前面，这时页面还没渲染完，暂停住了，就加长了整个页面渲染的时间。\n\n\n# 性能优化\n\n\n# 1. 浏览器加载资源优化\n\n * 减少资源体积：压缩代码\n\n * webpack打包会压缩代码\n\n * 减少访问次数：合并代码，ssr（服务端渲染），缓存\n\n * 合并代码\n\n//三次网络请求\n<script src="a. js"><\/script> \n<script src="b. is"><\/script> \n<script src="c. js"><\/script>\n\n//合并成一次网络请求,网络请求减少了 \n<script src="abc.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 缓存(强缓存&协商缓存)\n * SSR：服务端渲染\n * SSR(前后端不分离）：将网页和数据一起加载\n * 非SSR（前后端分离）：先加载网页，再加载数据，再渲染数据\n\n\n# 2. 浏览器渲染优化\n\n * CSS放着head，JS放在body最下面\n\n * 尽早开始执行JS，页面渲染完之后马上开始执行js，不要在图片资源加载完后才去执行JS\n\n * 图片懒加载\n   \n   用户看到第一屏的图片先加载，在屏幕之外的图片先加载一张本地预览图片，等用户滑动到的时候再加载，如果用户快速滑动，会先显示一张预览图片的占个位，等到网络请求完成了，预览图就变成了真正的网络请求下来的图片。\n\n * 对DOM查询操作进行缓存\n\n * 减少回流重绘\n   \n   * 多个属性尽量使用简写，例如：boder可以代替boder-width、boder-color、boder-style\n   * 避免频繁修改样式，可以使用CSS class来批量修改样式。\n   * 先把这个元素隐藏，然后把样式该加的全部加上，然后最后再显示，只会有一次回流和重绘\n   * 将多次修改DOM的操作合并为一次，减少重绘和回流的次数。\n\n * 节流throttle\n   \n   拖拽一个元素时，要随时拿到该元素的被拖拽的位置，直接使用原生事件会频繁触发，很容易造成卡顿。无论拖拽多快，我们可以每隔500ms触发一次\n\n * 防抖debounce\n   \n   例如，我们在输入框中快速的输入文字的时候，不能实时进行网络请求，可以每次输入后的500ms后进行一次网络请求，这样可以大大减少网络请求的次数。\n\n\n# 3. 打包层面\n\n 1. 移除console.log: 通过babel的插件进行移除(babel-plugin-transform-remove-console)\n\n 2. soucemap: 映射生产阶段的代码和开发阶段的代码的对应关系,在生产阶段报错,根据map的映射文件提示出开发阶段的代码哪里出错, 项目真正上线,关闭(线上出现bug)\n\n 3. 路由懒加载: 当路由匹配的时候才会加载响应资源\n\n 4. splitChunks: 提取公共资源, 某一个文件被多次引入, 进行公共提取\n\n 5. gzip压缩: compression-webpack-plugin, 需要后端开启支持\n\n 6. 图片压缩: image-webpack-loader 实现图片压缩\n\n 7. runtimeChunks: 开启运行时代码, 运行时代码发生变化不影响app主模块的hash变化(可以继续使用强缓存)\n\n 8. 使用更快的网络：CDN，配置config，\n    \n    之后通过 html-webpack-plugin注入到 index.html之中:\n    \n    config.plugin(\'html\').tap(args => {\n      args[0].cdn = cdn\n      return args\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    在index.html注入cdn配置\n\n 9. ssr: 服务端渲染 解决首屏加载速度慢的问题,首屏服务端直接返回,还可以解决seo,实现ssrvue结合nuxt\n\n# 服务端渲染ssr\n\n * 为什么? spa单页面应用的seo不友好,spa单页面,由js进行渲染页面,不同的路由规则渲染不同的组件,对应html就是一个空页面,百度爬虫在爬,什么都爬不到,导致seo不友好\n\n * ssr 服务端渲染: 先由服务端将页面解析好返回,返回之后,浏览器进行渲染,直接将页面的内容进行渲染,html不在是一个空页面,爬虫可以爬到\n\n * 配置 路由: 在pages下创建文件,自动生成路由\n   \n   ui组件库: 在nuxt.config.js中通过plugins节点指定配置文件的路径,在对应的路径文件中进行配置\n   \n   css全局样式: 可以在nuxt.config.js中的css节点中进行配置\n   \n   seo优化: nuxt.config.js中通过head进行title和meta的配置\n   \n   在pages中也可以通过head进行页面级别的配置\n\n * 获取数据\n   \n   生命周期分为\n   \n   服务端\n   \n   nuxtServerInit: 服务端初始化\n   \n   RouteMiddleware: 中间件\n   \n   validate: ok\n   \n   asyncData: 获取服务端数据\n   \n   asyncData中进行获取数据,该生命周期是在服务端执行的,所以不能使用this\n   \n   * 服务端异步获取数据asyncData可以分为首屏异步获取和切换组件获取\n     * 首屏异步获取数据，在服务端预渲染的时候就应该已经完成\n     * 切换组件通过mixin混入，在beforeMount钩子完成数据获取\n   \n   客户端 created => fetch(fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncData 方法类似，不同的是它不会设置组件的数据。) = mounted\n\n\n# 图片懒加载\n\nIntersectionObserver\n\n网页开发时，常常需要了解某个元素是否进入了"视口"（viewport），即用户能不能看到它。\n\n传统的实现方法是，监听到 scroll 事件后，调用目标元素的 getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。\n\n目前有一个新的 IntersectionObserver API，可以自动"观察"元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做"交叉观察器"。\n\nAPI IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。\n\nvar io = new IntersectionObserver(callback, option)\n\n// 开始观察\nio.observe(document.getElementById(\'example\'))\n\n// 停止观察\nio.unobserve(element)\n\n// 关闭观察器\nio.disconnect()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果要观察多个节点，就要多次调用这个方法。\n\nio.observe(elementA)\nio.observe(elementB)\n\n\n1\n2\n\n\n目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。\n\nvar io = new IntersectionObserver((entries) => {\n  console.log(entries)\n})\n\n\n1\n2\n3\n\n\ncallback 函数的参数（entries）是一个数组，每个成员都是一个 IntersectionObserverEntry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。\n\n * time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒\n * target：被观察的目标元素，是一个 DOM 节点对象\n * isIntersecting: 目标是否可见\n * rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null\n * boundingClientRect：目标元素的矩形区域的信息\n * intersectionRect：目标元素与视口（或根元素）的交叉区域的信息\n * intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1，完全不可见时小于等于 0\n\n\n# 跨域\n\n跨域是由于浏览器的同源策略，协议、域名、端口号其中任一不同即为跨域，但是服务器和服务器之间不存在跨域。\n\n历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：\n\n * JSONP\n * CORS\n * 服务器代理(webpack代理, Nginx反向代理)\n\nJSONP\n\n这是一种非常经典的跨域方案，它利用了<script> 标签不受同源策略的限制的特性，实现跨域效果。\n\n优点：\n\n * 实现简单\n * 兼容性好\n\n缺点：\n\n * 只支持 GET 请求 （因为 <script> 标签只能发送 GET 请求）\n * 存在被 XSS 攻击的可能，缺乏安全性保证\n * 需要服务端配合改造\n\nCORS\n\n跨域资源共享（CORS），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 HTTP 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。\n\n当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 HTTP 请求。\n\n\n# 开发环境下解决跨域问题\n\nwebpack反向代理\n\n开发环境下我们启动了本地的localhost服务器，使得浏览器和本地服务器是同源，不存在跨域。\n\n那么我们就让本地服务器转发请求给远程服务器，远程服务器返回数据给本地服务器，本地服务器再转返回给浏览器。\n\n这就是webpack反向代理。\n\n\n\n\n# 生产环境下解决跨域问题\n\nnginx反向代理\n\n反向代理的原理其实很简单：\n\n> Nginx 作为代理服务器，所有客户端的请求都必须先经过 Nginx 的处理，然后再将请求转发给其他后端程序（比如 Node.js 或Java 程序），这样就规避同源策略的影响\n\n    # 请求转发：\n    # 例如 http://localhost/api 的请求会被转发到 http://124.222.141.165:99   \n\t\tlocation /api {\n        proxy_pass http://124.222.141.165:99/;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# http版本\n\nHTTP1.0：\n\n浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接\n\n服务器完成请求处理后立即断开TCP连接。\n\n简单来讲，每次与服务器交互，都需要新开一个连接\n\nHTTP1.1：\n\n * 引入了持久连接，即TCP连接默认不关闭，在同一个TCP连接里面，客户端可以同时发送多个请求\n\n * 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n\n * 新增了一些请求方法，新增了一些请求头和响应头\n\nHTTP2.0：\n\n * 采用二进制格式而非文本格式\n\n * 多路复用，只需一个连接即可实现并行\n\n * 使用报头压缩，降低开销\n\n * 服务器推送\n\nHTTP3.0：\n\n * 是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。\n\n\n# http&https\n\n> 总结：\n> \n>  1. http明文传输\n> \n>  2. https加密传输\n> \n>  3. http默认的端口号80\n> \n>  4. https默认的端口号是443\n> \n>  5. 加密算法：对称加密，非对称加密，hash算法\n> \n>  6. https的传输过程使用对称加密，传输之前先用秘钥进行加密，加密传输，目标端使用相同的密钥解密。\n\n 1. HTTPS 是安全版的 HTTP。\n\n 2. HTTP 协议在传输数据时采用的是明文传输，因此，⼀些敏感信息的传输就变得很不安全。\n\n 3. 而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的\n\n 4. HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。\n\n 5. CA证书确保公钥的安全性，防止代理服务器伪造，或者网站不安全\n\n 6. 数字签名用于保证CA证书没有被篡改过，是源服务器签发的证书\n\n> ssl证书：SSL 证书就是遵守 SSL协议（它是在传输通信协议（TCP/IP）上实现的一种安全协议，采用公开密钥技术），由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能\n\n> http：基于7层协议中的应用层（提供应用程序间的交换和数据交换） https：基于7层协议中的传输层（传输层协议提供计算机之间的通信会话，并确保数据在计算机之间可靠地传输。） 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层\n\n对称加密\n\n发送方和接收方使用同一个密钥（一串字符串）进行加密和解密\n\n 1. 服务端使用密钥进行加密\n\n 2. 客户端使用密钥进行解密\n    \n    但是第一次要传输一次密钥，如果密钥被拦截，就被破解了\n    \n    性能好，速度快，缺点，密钥被拦截被破解\n\n非对称加密\n\n公钥加密，私钥解密\n\n 1. 服务端\n\n 2. 客户端\n\n 3. 客户端公钥加密传输（被拦截无法解密，需要用私钥）\n\n 4. 服务端通过私钥解密\n    \n    优点：安全\n    \n    缺点：性能差，耗时间\n\n> 使用非对称加密进行密钥传输，使用对称加密进行数据传输 如何保证首次传输的公钥是安全的，需要网站机构，进行网站和公钥的登记（CA机构，颁发证书，安全可靠）\n\n\n# 状态码\n\n1xx: 请求处理成功状态码\n\n代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\n\n> 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n> \n> 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx: 请求处理成功状态码\n\n代表请求已成功被服务器接收、理解、并接受\n\n> 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n> \n> 201（已创建）：请求成功并且服务器创建了新的资源\n> \n> 202（已创建）：服务器已经接收请求，但尚未处理\n> \n> 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n> \n> 204（无内容）：服务器成功处理请求，但没有返回任何内容\n> \n> 205（重置内容）：服务器成功处理请求，但没有返回任何内容\n> \n> 206（部分内容）：服务器成功处理了部分请求\n\n3xx：请求重定向\n\n表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向\n\n> 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n> \n> 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置\n> \n> 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n> \n> 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码\n> \n> 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n> \n> 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx: 请求失败\n\n代表了客户端看起来可能发生了错误，妨碍了服务器的处理\n\n> 400（错误请求）： 服务器不理解请求的语法\n> \n> 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n> \n> 403（禁止）： 服务器拒绝请求\n> \n> 404（未找到）： 服务器找不到请求的网页\n> \n> 405（方法禁用）： 禁用请求中指定的方法\n> \n> 406（不接受）： 无法使用请求的内容特性响应请求的网页\n> \n> 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n> \n> 408（请求超时）： 服务器等候请求时发生超时\n\n5xx：服务器问题\n\n表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生\n\n> 500（服务器内部错误）：服务器遇到错误，无法完成请求\n> \n> 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n> \n> 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n> \n> 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n> \n> 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n> \n> 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本\n\n\n# get和post请求的区别',normalizedContent:'# 强缓存&协商缓存\n\n> 浏览器发起http请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中http头的缓存标识，决定是否缓存结果，需要缓存的话就将请求结果和缓存标识存入浏览器缓存中\n> \n> 缓存机制的基本原则是：\n> \n>  * 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中\n>  * 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识\n> \n> 强制缓存就是向浏览器缓存查找该请求结果，并根据这个结果的缓存规则来决定是否使用该缓存结果的过程。\n> \n> 当浏览器向服务器发起请求时，服务器会将缓存规则放入http响应报文的http头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是expires和cache-control，其中cache-control优先级比expires高。\n> \n> expires 是http/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于expires的值时，直接使用缓存结果。\n> \n> > expires是http/1.0的字段，但是现在浏览器默认使用的是http/1.1，那么在http/1.1中网页缓存还是否由expires控制？\n> \n> 到了http/1.1，expire已经被cache-control替代，原因在于expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么cache-control又是如何控制的呢？\n> \n> # cache-control\n> \n> 在http/1.1中，cache-control是最重要的规则，主要用于控制网页缓存，主要取值为：\n> \n>  * public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n>  * private：所有内容只有客户端可以缓存，cache-control的默认取值\n>  * no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n>  * no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n>  * max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n> \n> 由于cache-control的优先级比expires高，在无法确定客户端的时间是否与服务端的时间同步的情况下，cache-control相比于expires是更好的选择，所以同时存在时，只有cache-control生效。\n\n浏览器的缓存主要是为了提高访问效率，什么是强制缓存 呢？比如说我们访问一个网站，当我们第一次访问的时候，里面一些静态资源，比如说图片啊css，js这些资源，甚至icon。这些实际上是从服务器上下载的。但是如果说我们刷新网页的话，那这个资源是没有必要在服务器上重新去请求的，因为他没有变动。那像这种资源的话，浏览器会默认是一些强制缓存。那么强制缓存，当你第二次访问的时候，他不会再去服务器上重新下载，同样他会给你返回一个200的状态码，但是这个资源呢，它会从浏览器的本地缓存里去取这种图片，像这种图片第二次去取的缓存的状态，就是一种强制缓存。\n\n协商缓存 ，就是我们和后台去协商这个资源，要不要对它去进行缓存。如果这个资源是需要协商缓存的，那第一次返回的结果里面的状态码是200，同时会携带一个是否更新last modified的一个状态，还会给他返回一个唯一标识etag，可以理解为是一个内容资源的hash。只要说这个资源在服务端没有变化，那么当下次访问的时候，后台会对比这个标签etag，或者说对比这个last modified的时间。如果这个资源没有变动，那么他会告诉你返回一个304的状态码，那当浏览器接收到这个304的状态之后，他会认为这个资源没有变化，我只需要从本地把这个缓存的资源拿出来就行了\n\n\n# cookie\n\n\n# tcp udp\n\n\n# 在浏览器里输入url会经历哪些流程？\n\n输入url会发生什么事情？\n\n 1. 核心：引到自己擅长的领域\n\n 2. 域名 ==> 解析成ip【dns服务器做的这个事情】\n\n 3. tcp的三次握手，四次挥手\n\n 4. 连接建立\n\n 5. 服务器端会根据当前这次请求的请求头里面的if-modifined-since，和服务器端的当前文件的上次修改时间进行对比，如果一致，本地缓存可用，服务器返回304的状态码，直接使用本地的缓存资源\n\n 6. 强缓存\n    \n    1. 第一次请求服务器端资源的时候，服务器不仅返回当前资源，同时会通过响应头里面cache-control:max-age=最大缓存时间\n    \n    2. 下次请求的时候，先判断缓存是否到期，如果没有到期，使用本地缓存资源，如果到期，请求服务器端\n\n 7. 如何合理的设置强缓存\n    \n    1. html不能加缓存\n    \n    2. js和css需要添加强缓存，但是每个文件需要一个唯一的hash值，如果没有hash值的话，强缓存会一直命中，导致的问题是：加入服务器端文件更新了，本地浏览器端获取不到最新的内容\n\n 8. 浏览器获取到html页面的时候，先解析一下html，预加载的文件，会提前加载，预解析完毕以后，开始绘制界面，构建html树，构建css树，合并成渲染树，调用显卡渲染到页面上。\n\n 9. js的异步加载\n\n\n# 问1： 为什么把css加载放在head里？\n\n如果我们把css加载放在最后，这时候页面已经渲染完成了，然后发现css改变了，还有重新一个个去查找渲染一遍，这样就拖慢了页面渲染的速度\n\n\n# 问2：为什么要把js加载放着body最后？\n\n因为遇到<script>会暂停渲染，如果把js加载放在前面，这时页面还没渲染完，暂停住了，就加长了整个页面渲染的时间。\n\n\n# 性能优化\n\n\n# 1. 浏览器加载资源优化\n\n * 减少资源体积：压缩代码\n\n * webpack打包会压缩代码\n\n * 减少访问次数：合并代码，ssr（服务端渲染），缓存\n\n * 合并代码\n\n//三次网络请求\n<script src="a. js"><\/script> \n<script src="b. is"><\/script> \n<script src="c. js"><\/script>\n\n//合并成一次网络请求,网络请求减少了 \n<script src="abc.js"><\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * 缓存(强缓存&协商缓存)\n * ssr：服务端渲染\n * ssr(前后端不分离）：将网页和数据一起加载\n * 非ssr（前后端分离）：先加载网页，再加载数据，再渲染数据\n\n\n# 2. 浏览器渲染优化\n\n * css放着head，js放在body最下面\n\n * 尽早开始执行js，页面渲染完之后马上开始执行js，不要在图片资源加载完后才去执行js\n\n * 图片懒加载\n   \n   用户看到第一屏的图片先加载，在屏幕之外的图片先加载一张本地预览图片，等用户滑动到的时候再加载，如果用户快速滑动，会先显示一张预览图片的占个位，等到网络请求完成了，预览图就变成了真正的网络请求下来的图片。\n\n * 对dom查询操作进行缓存\n\n * 减少回流重绘\n   \n   * 多个属性尽量使用简写，例如：boder可以代替boder-width、boder-color、boder-style\n   * 避免频繁修改样式，可以使用css class来批量修改样式。\n   * 先把这个元素隐藏，然后把样式该加的全部加上，然后最后再显示，只会有一次回流和重绘\n   * 将多次修改dom的操作合并为一次，减少重绘和回流的次数。\n\n * 节流throttle\n   \n   拖拽一个元素时，要随时拿到该元素的被拖拽的位置，直接使用原生事件会频繁触发，很容易造成卡顿。无论拖拽多快，我们可以每隔500ms触发一次\n\n * 防抖debounce\n   \n   例如，我们在输入框中快速的输入文字的时候，不能实时进行网络请求，可以每次输入后的500ms后进行一次网络请求，这样可以大大减少网络请求的次数。\n\n\n# 3. 打包层面\n\n 1. 移除console.log: 通过babel的插件进行移除(babel-plugin-transform-remove-console)\n\n 2. soucemap: 映射生产阶段的代码和开发阶段的代码的对应关系,在生产阶段报错,根据map的映射文件提示出开发阶段的代码哪里出错, 项目真正上线,关闭(线上出现bug)\n\n 3. 路由懒加载: 当路由匹配的时候才会加载响应资源\n\n 4. splitchunks: 提取公共资源, 某一个文件被多次引入, 进行公共提取\n\n 5. gzip压缩: compression-webpack-plugin, 需要后端开启支持\n\n 6. 图片压缩: image-webpack-loader 实现图片压缩\n\n 7. runtimechunks: 开启运行时代码, 运行时代码发生变化不影响app主模块的hash变化(可以继续使用强缓存)\n\n 8. 使用更快的网络：cdn，配置config，\n    \n    之后通过 html-webpack-plugin注入到 index.html之中:\n    \n    config.plugin(\'html\').tap(args => {\n      args[0].cdn = cdn\n      return args\n    })\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    在index.html注入cdn配置\n\n 9. ssr: 服务端渲染 解决首屏加载速度慢的问题,首屏服务端直接返回,还可以解决seo,实现ssrvue结合nuxt\n\n# 服务端渲染ssr\n\n * 为什么? spa单页面应用的seo不友好,spa单页面,由js进行渲染页面,不同的路由规则渲染不同的组件,对应html就是一个空页面,百度爬虫在爬,什么都爬不到,导致seo不友好\n\n * ssr 服务端渲染: 先由服务端将页面解析好返回,返回之后,浏览器进行渲染,直接将页面的内容进行渲染,html不在是一个空页面,爬虫可以爬到\n\n * 配置 路由: 在pages下创建文件,自动生成路由\n   \n   ui组件库: 在nuxt.config.js中通过plugins节点指定配置文件的路径,在对应的路径文件中进行配置\n   \n   css全局样式: 可以在nuxt.config.js中的css节点中进行配置\n   \n   seo优化: nuxt.config.js中通过head进行title和meta的配置\n   \n   在pages中也可以通过head进行页面级别的配置\n\n * 获取数据\n   \n   生命周期分为\n   \n   服务端\n   \n   nuxtserverinit: 服务端初始化\n   \n   routemiddleware: 中间件\n   \n   validate: ok\n   \n   asyncdata: 获取服务端数据\n   \n   asyncdata中进行获取数据,该生命周期是在服务端执行的,所以不能使用this\n   \n   * 服务端异步获取数据asyncdata可以分为首屏异步获取和切换组件获取\n     * 首屏异步获取数据，在服务端预渲染的时候就应该已经完成\n     * 切换组件通过mixin混入，在beforemount钩子完成数据获取\n   \n   客户端 created => fetch(fetch 方法用于在渲染页面前填充应用的状态树（store）数据， 与 asyncdata 方法类似，不同的是它不会设置组件的数据。) = mounted\n\n\n# 图片懒加载\n\nintersectionobserver\n\n网页开发时，常常需要了解某个元素是否进入了"视口"（viewport），即用户能不能看到它。\n\n传统的实现方法是，监听到 scroll 事件后，调用目标元素的 getboundingclientrect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。\n\n目前有一个新的 intersectionobserver api，可以自动"观察"元素是否可见，chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 api 叫做"交叉观察器"。\n\napi intersectionobserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）。\n\nvar io = new intersectionobserver(callback, option)\n\n// 开始观察\nio.observe(document.getelementbyid(\'example\'))\n\n// 停止观察\nio.unobserve(element)\n\n// 关闭观察器\nio.disconnect()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果要观察多个节点，就要多次调用这个方法。\n\nio.observe(elementa)\nio.observe(elementb)\n\n\n1\n2\n\n\n目标元素的可见性变化时，就会调用观察器的回调函数 callback。callback 一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。\n\nvar io = new intersectionobserver((entries) => {\n  console.log(entries)\n})\n\n\n1\n2\n3\n\n\ncallback 函数的参数（entries）是一个数组，每个成员都是一个 intersectionobserverentry 对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries 数组就会有两个成员。\n\n * time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒\n * target：被观察的目标元素，是一个 dom 节点对象\n * isintersecting: 目标是否可见\n * rootbounds：根元素的矩形区域的信息，getboundingclientrect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 null\n * boundingclientrect：目标元素的矩形区域的信息\n * intersectionrect：目标元素与视口（或根元素）的交叉区域的信息\n * intersectionratio：目标元素的可见比例，即 intersectionrect 占 boundingclientrect 的比例，完全可见时为 1，完全不可见时小于等于 0\n\n\n# 跨域\n\n跨域是由于浏览器的同源策略，协议、域名、端口号其中任一不同即为跨域，但是服务器和服务器之间不存在跨域。\n\n历史上出现过的跨域⼿段有很多，本章主要介绍目前主流的3种跨域⽅案：\n\n * jsonp\n * cors\n * 服务器代理(webpack代理, nginx反向代理)\n\njsonp\n\n这是一种非常经典的跨域方案，它利用了<script> 标签不受同源策略的限制的特性，实现跨域效果。\n\n优点：\n\n * 实现简单\n * 兼容性好\n\n缺点：\n\n * 只支持 get 请求 （因为 <script> 标签只能发送 get 请求）\n * 存在被 xss 攻击的可能，缺乏安全性保证\n * 需要服务端配合改造\n\ncors\n\n跨域资源共享（cors），这是⽬前比较主流的跨域解决⽅案，它利用一些额外的 http 响应头来通知浏览器允许访问来自指定 origin 的非同源服务器上的资源。\n\n当在⼀个资源中去请求与本资源所在的服务器有不同协议、域、或端⼝的另一个资源时，就会发起⼀个跨域 http 请求。\n\n\n# 开发环境下解决跨域问题\n\nwebpack反向代理\n\n开发环境下我们启动了本地的localhost服务器，使得浏览器和本地服务器是同源，不存在跨域。\n\n那么我们就让本地服务器转发请求给远程服务器，远程服务器返回数据给本地服务器，本地服务器再转返回给浏览器。\n\n这就是webpack反向代理。\n\n\n\n\n# 生产环境下解决跨域问题\n\nnginx反向代理\n\n反向代理的原理其实很简单：\n\n> nginx 作为代理服务器，所有客户端的请求都必须先经过 nginx 的处理，然后再将请求转发给其他后端程序（比如 node.js 或java 程序），这样就规避同源策略的影响\n\n    # 请求转发：\n    # 例如 http://localhost/api 的请求会被转发到 http://124.222.141.165:99   \n\t\tlocation /api {\n        proxy_pass http://124.222.141.165:99/;\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# http版本\n\nhttp1.0：\n\n浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个tcp连接\n\n服务器完成请求处理后立即断开tcp连接。\n\n简单来讲，每次与服务器交互，都需要新开一个连接\n\nhttp1.1：\n\n * 引入了持久连接，即tcp连接默认不关闭，在同一个tcp连接里面，客户端可以同时发送多个请求\n\n * 虽然允许复用tcp连接，但是同一个tcp连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着\n\n * 新增了一些请求方法，新增了一些请求头和响应头\n\nhttp2.0：\n\n * 采用二进制格式而非文本格式\n\n * 多路复用，只需一个连接即可实现并行\n\n * 使用报头压缩，降低开销\n\n * 服务器推送\n\nhttp3.0：\n\n * 是 http/3 中的底层支撑协议，该协议基于 udp，又取了 tcp 中的精华，实现了即快又可靠的协议。\n\n\n# http&https\n\n> 总结：\n> \n>  1. http明文传输\n> \n>  2. https加密传输\n> \n>  3. http默认的端口号80\n> \n>  4. https默认的端口号是443\n> \n>  5. 加密算法：对称加密，非对称加密，hash算法\n> \n>  6. https的传输过程使用对称加密，传输之前先用秘钥进行加密，加密传输，目标端使用相同的密钥解密。\n\n 1. https 是安全版的 http。\n\n 2. http 协议在传输数据时采用的是明文传输，因此，⼀些敏感信息的传输就变得很不安全。\n\n 3. 而 https 就是为了解决 http 的不安全⽽产⽣的\n\n 4. https 在传输数据的过程中会对数据进行加密处理，保证安全性。\n\n 5. ca证书确保公钥的安全性，防止代理服务器伪造，或者网站不安全\n\n 6. 数字签名用于保证ca证书没有被篡改过，是源服务器签发的证书\n\n> ssl证书：ssl 证书就是遵守 ssl协议（它是在传输通信协议（tcp/ip）上实现的一种安全协议，采用公开密钥技术），由受信任的数字证书颁发机构ca，在验证服务器身份后颁发，具有服务器身份验证和数据传输加密功能\n\n> http：基于7层协议中的应用层（提供应用程序间的交换和数据交换） https：基于7层协议中的传输层（传输层协议提供计算机之间的通信会话，并确保数据在计算机之间可靠地传输。） 物理层、数据链路层、网络层、传输层、会话层、表示层、应用层\n\n对称加密\n\n发送方和接收方使用同一个密钥（一串字符串）进行加密和解密\n\n 1. 服务端使用密钥进行加密\n\n 2. 客户端使用密钥进行解密\n    \n    但是第一次要传输一次密钥，如果密钥被拦截，就被破解了\n    \n    性能好，速度快，缺点，密钥被拦截被破解\n\n非对称加密\n\n公钥加密，私钥解密\n\n 1. 服务端\n\n 2. 客户端\n\n 3. 客户端公钥加密传输（被拦截无法解密，需要用私钥）\n\n 4. 服务端通过私钥解密\n    \n    优点：安全\n    \n    缺点：性能差，耗时间\n\n> 使用非对称加密进行密钥传输，使用对称加密进行数据传输 如何保证首次传输的公钥是安全的，需要网站机构，进行网站和公钥的登记（ca机构，颁发证书，安全可靠）\n\n\n# 状态码\n\n1xx: 请求处理成功状态码\n\n代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束\n\n> 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应\n> \n> 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级\n\n2xx: 请求处理成功状态码\n\n代表请求已成功被服务器接收、理解、并接受\n\n> 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回\n> \n> 201（已创建）：请求成功并且服务器创建了新的资源\n> \n> 202（已创建）：服务器已经接收请求，但尚未处理\n> \n> 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源\n> \n> 204（无内容）：服务器成功处理请求，但没有返回任何内容\n> \n> 205（重置内容）：服务器成功处理请求，但没有返回任何内容\n> \n> 206（部分内容）：服务器成功处理了部分请求\n\n3xx：请求重定向\n\n表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向\n\n> 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择\n> \n> 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 get 或 head 请求的响应）时，会自动将请求者转到新位置\n> \n> 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n> \n> 303（查看其他位置）：请求者应当对不同的位置使用单独的 get 请求来检索响应时，服务器返回此代码\n> \n> 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理\n> \n> 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求\n\n4xx: 请求失败\n\n代表了客户端看起来可能发生了错误，妨碍了服务器的处理\n\n> 400（错误请求）： 服务器不理解请求的语法\n> \n> 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。\n> \n> 403（禁止）： 服务器拒绝请求\n> \n> 404（未找到）： 服务器找不到请求的网页\n> \n> 405（方法禁用）： 禁用请求中指定的方法\n> \n> 406（不接受）： 无法使用请求的内容特性响应请求的网页\n> \n> 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理\n> \n> 408（请求超时）： 服务器等候请求时发生超时\n\n5xx：服务器问题\n\n表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生\n\n> 500（服务器内部错误）：服务器遇到错误，无法完成请求\n> \n> 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码\n> \n> 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应\n> \n> 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）\n> \n> 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求\n> \n> 505（http 版本不受支持）： 服务器不支持请求中所用的 http 协议版本\n\n\n# get和post请求的区别',charsets:{cjk:!0},lastUpdated:"2023/05/10, 02:29:24",lastUpdatedTimestamp:1683656964e3},{title:"new Vue的流程",frontmatter:{title:"new Vue的流程",date:"2022-03-20T17:54:52.000Z",permalink:"/pages/3d4029/",titleTag:"原创",sticky:2,categories:["更多","技术面"],tags:["Vue","面试总结"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/07.new%20vue%E4%B8%BB%E4%BD%93%E6%B5%81%E7%A8%8B.html",relativePath:"55.更多/05.技术面/07.new vue主体流程.md",key:"v-4df113c3",path:"/pages/3d4029/",headersStr:null,content:"github地址\n\nnew Vue({\n  // el: '#app',\n  data() {\n    return {\n      name: 'Ming'\n    }\n  }\n}).$mout('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n 1. 传入一个配置项options\n\n 2. 调用this._init(options)\n\n 3. 调用beforecreate生命周期钩子函数\n\n 4. 通过initState(vm)初始化数据 data/methods/props/computed/watcher/provide/inject\n    \n    1. 如果vm上面有data属性 >> 调用initData(data)数据\n    2. 判断当前data是否是函数 >> 如果是函数，执行函数获取数据，如果不是，直接拿data即可\n    3. 调用proxy代理 >> data里面的数据挂载到vm实例上\n    4. observe(data)劫持数据\n       1. 如果data不是对象/数组 或者是null >> 直接return掉\n       2. 判断__ob__属性 >> 判断当前数据是否被观测过，如果观测过，return\n       3. new Observer(data)\n          1. 添加__ob__的标识\n          2. 判断是否data是否是数组\n             1. 是数组 >> 1、劫持数组原型方法 2、遍历数组，调用observe(数组成员)\n             2. 是对象 >> 1、调用walk(data)方法 2、遍历对象，调用defineReactive进行object.defineProperty劫持\n          3. defineReactive方法内部\n             1. 当前对象的值继续调用observe处理\n             2. 声明const dep =new Dep()\n             3. get劫持\n                1. 收集依赖(使用到当前数据的组件的更新watcher)\n                2. 收集到的依赖，添加到dep里面的subs数组里面\n             4. set劫持\n                1. 判断新旧的值是否一致，如果一致，直接return\n                2. Observe(newvalue)新的值进行响应式处理\n                3. 赋值操作\n                4. Dep.notify() 通知dep里面的subs的watcher执行\n\n 5. 调用created生命周期钩子函数\n\n 6. 编译模板\n    \n    1. 判断options是否传入el\n       1. 如果有el，vue内部会自动调用$mount方法\n       2. 如果没有el，需要new Vue的时候手动调用$mount\n\n 7. $mount方法\n    \n    1. 判断用户是否传入render函数，如果render函数，什么事情都没有做\n    \n    2. 如果没有render函数，vue会把template编译成render函数,render函数的返回值就是当前组件的虚拟dom\n       \n       \n\n 8. 调用mountComponet 进行组件挂载\n    \n    1. 调用beforeMount表示开始挂载组件\n    2. 声明一个updateComponent方法 >> 调用组件更新的方法(render函数)，进行patch，新旧虚拟dom的对比，进行界面的更新\n    3. new Watcher(vm, updateComponent)\n       1. 把当前组件的更新watcher添加到Dep.target身上（获取数据的时候能够收集到dep里面的subs里面）\n       2. 调用getter方法 >> (updateComponet组件的更新方法)\n       3. 编译模板 >> 获取数据 >> 触发当前数据get方法 >> 会把当前组件的更新watcher(Dep.target)添加到dep里面的subs里面\n       4. 已经添加完毕之后，就可以Dep.target = null（删掉watcher）\n       5. 调用mounted钩子\n    \n    > 调用声明周期钩子的时候，都是使用的callHook函数\n\n 9. 调用更新watcher的时候，并不是同步调用\n    \n    1. 把当前的更新watcher通过nextTick放到异步队列里面进行异步的调用。\n    2. 相同的wathcer同一批更新只会添加一次，所以vue中同一个方法内部进行多次的数据修改，页面只会更新一次。",normalizedContent:"github地址\n\nnew vue({\n  // el: '#app',\n  data() {\n    return {\n      name: 'ming'\n    }\n  }\n}).$mout('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n 1. 传入一个配置项options\n\n 2. 调用this._init(options)\n\n 3. 调用beforecreate生命周期钩子函数\n\n 4. 通过initstate(vm)初始化数据 data/methods/props/computed/watcher/provide/inject\n    \n    1. 如果vm上面有data属性 >> 调用initdata(data)数据\n    2. 判断当前data是否是函数 >> 如果是函数，执行函数获取数据，如果不是，直接拿data即可\n    3. 调用proxy代理 >> data里面的数据挂载到vm实例上\n    4. observe(data)劫持数据\n       1. 如果data不是对象/数组 或者是null >> 直接return掉\n       2. 判断__ob__属性 >> 判断当前数据是否被观测过，如果观测过，return\n       3. new observer(data)\n          1. 添加__ob__的标识\n          2. 判断是否data是否是数组\n             1. 是数组 >> 1、劫持数组原型方法 2、遍历数组，调用observe(数组成员)\n             2. 是对象 >> 1、调用walk(data)方法 2、遍历对象，调用definereactive进行object.defineproperty劫持\n          3. definereactive方法内部\n             1. 当前对象的值继续调用observe处理\n             2. 声明const dep =new dep()\n             3. get劫持\n                1. 收集依赖(使用到当前数据的组件的更新watcher)\n                2. 收集到的依赖，添加到dep里面的subs数组里面\n             4. set劫持\n                1. 判断新旧的值是否一致，如果一致，直接return\n                2. observe(newvalue)新的值进行响应式处理\n                3. 赋值操作\n                4. dep.notify() 通知dep里面的subs的watcher执行\n\n 5. 调用created生命周期钩子函数\n\n 6. 编译模板\n    \n    1. 判断options是否传入el\n       1. 如果有el，vue内部会自动调用$mount方法\n       2. 如果没有el，需要new vue的时候手动调用$mount\n\n 7. $mount方法\n    \n    1. 判断用户是否传入render函数，如果render函数，什么事情都没有做\n    \n    2. 如果没有render函数，vue会把template编译成render函数,render函数的返回值就是当前组件的虚拟dom\n       \n       \n\n 8. 调用mountcomponet 进行组件挂载\n    \n    1. 调用beforemount表示开始挂载组件\n    2. 声明一个updatecomponent方法 >> 调用组件更新的方法(render函数)，进行patch，新旧虚拟dom的对比，进行界面的更新\n    3. new watcher(vm, updatecomponent)\n       1. 把当前组件的更新watcher添加到dep.target身上（获取数据的时候能够收集到dep里面的subs里面）\n       2. 调用getter方法 >> (updatecomponet组件的更新方法)\n       3. 编译模板 >> 获取数据 >> 触发当前数据get方法 >> 会把当前组件的更新watcher(dep.target)添加到dep里面的subs里面\n       4. 已经添加完毕之后，就可以dep.target = null（删掉watcher）\n       5. 调用mounted钩子\n    \n    > 调用声明周期钩子的时候，都是使用的callhook函数\n\n 9. 调用更新watcher的时候，并不是同步调用\n    \n    1. 把当前的更新watcher通过nexttick放到异步队列里面进行异步的调用。\n    2. 相同的wathcer同一批更新只会添加一次，所以vue中同一个方法内部进行多次的数据修改，页面只会更新一次。",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:33:08",lastUpdatedTimestamp:1682357588e3},{title:"导航站",frontmatter:{title:"导航站",date:"2022-01-04T20:02:46.000Z",permalink:"/navigation/",titleTag:"优质",article:!1,categories:[null],tags:[null],readingShow:"top"},regularPath:"/01.%E5%AF%BC%E8%88%AA%E7%AB%99.html",relativePath:"01.导航站.md",key:"v-751178aa",path:"/navigation/",headers:[{level:2,title:"友情链接",slug:"友情链接",normalizedTitle:"友情链接",charIndex:65},{level:2,title:"搜索引擎",slug:"搜索引擎",normalizedTitle:"搜索引擎",charIndex:1942},{level:2,title:"代码托管",slug:"代码托管",normalizedTitle:"代码托管",charIndex:1951},{level:2,title:"前端开发",slug:"前端开发",normalizedTitle:"前端开发",charIndex:1960},{level:2,title:"后端开发",slug:"后端开发",normalizedTitle:"后端开发",charIndex:1969},{level:2,title:"文档工具",slug:"文档工具",normalizedTitle:"文档工具",charIndex:1978},{level:2,title:"热门社区",slug:"热门社区",normalizedTitle:"热门社区",charIndex:1987},{level:2,title:"工具合集",slug:"工具合集",normalizedTitle:"工具合集",charIndex:1996},{level:2,title:"文档教程",slug:"文档教程",normalizedTitle:"文档教程",charIndex:2005},{level:2,title:"动态图表",slug:"动态图表",normalizedTitle:"动态图表",charIndex:2014},{level:2,title:"图片图标",slug:"图片图标",normalizedTitle:"图片图标",charIndex:2023},{level:2,title:"CSS样式",slug:"css样式",normalizedTitle:"css样式",charIndex:2032},{level:2,title:"网站分析",slug:"网站分析",normalizedTitle:"网站分析",charIndex:2042},{level:2,title:"其它资源",slug:"其它资源",normalizedTitle:"其它资源",charIndex:2051},{level:2,title:"参考来源",slug:"参考来源",normalizedTitle:"参考来源",charIndex:2060}],headersStr:"友情链接 搜索引擎 代码托管 前端开发 后端开发 文档工具 热门社区 工具合集 文档教程 动态图表 图片图标 CSS样式 网站分析 其它资源 参考来源",content:"笔记\n\n1本内容因为制作卡片效果，导致空间大小有限，如果想访问更多内容，点击前往。\n\n2021-01-11 @Da Wu\n\n\n# 友情链接\n\nGeorge Chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nEvan's blog\n\n前端的小学生\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nWeibw\n\n一个没有梦想的咸鱼\n\nJava 全栈知识体系\n\nJava 全栈知识体系\n\n风祈的时光录\n\n主要是Java技术栈的博客，比较偏原理，源码类型的博主\n\nxustudyxu\n\n一起学习编程!\n\n- name: George Chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4oKMVI.jpg\n  link: https://cyc0819.top/\n  bgColor: '#FFB6C1'\n  textColor: '#621529'  \n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgColor: '#CBEAFA'\n  textColor: '#6854A1'\n  \n- name: Evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n\n- name: 二丫讲梵\n  desc: 💻学习📝记录🔗分享\n  avatar: https://wiki.eryajf.net/img/logo.png\n  link: https://wiki.eryajf.net/\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n\n- name: Weibw\n  link: http://weibw162.com/\n  avatar: https://cdn.staticaly.com/gh/Weibw162/image-hosting@dev/杂录/image.735febsv1zo0.webp\n  desc: 一个没有梦想的咸鱼\n  bgColor: '#FFCEDE'\n  textColor: '#621529'\n  \n- name: Java 全栈知识体系\n  desc: Java 全栈知识体系\n  avatar: https://www.pdai.tech/_images/index-read.gif\n  link: https://www.pdai.tech/\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n  \n- name: 风祈的时光录\n  link: https://imlql.cn/\n  avatar: https://npm.elemecdn.com/lql_static@latest/avatar/1.jpg\n  desc: 主要是Java技术栈的博客，比较偏原理，源码类型的博主\n  bgColor: '#FFEFE2'\n  textColor: '#A05F2C'\n \n- name: xustudyxu\n  desc: 一起学习编程!\n  avatar: https://cdn.staticaly.com/gh/xustudyxu/image-hosting@master/20220423/01.3d9wrma6qlq0.webp\n  link: https://frxcat.fun/\n  bgColor: '#CBEAFA'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n如果您想互留友链，点击前往\n\n\n# 搜索引擎\n\n\n# 代码托管\n\n\n# 前端开发\n\n\n# 后端开发\n\n\n# 文档工具\n\n\n# 热门社区\n\n\n# 工具合集\n\n\n# 文档教程\n\n\n# 动态图表\n\n\n# 图片图标\n\n\n# CSS样式\n\n\n# 网站分析\n\n\n# 其它资源\n\n\n# 参考来源\n\nhttps://www.pdai.tech/md/resource/tools.html",normalizedContent:"笔记\n\n1本内容因为制作卡片效果，导致空间大小有限，如果想访问更多内容，点击前往。\n\n2021-01-11 @da wu\n\n\n# 友情链接\n\ngeorge chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nevan's blog\n\n前端的小学生\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nweibw\n\n一个没有梦想的咸鱼\n\njava 全栈知识体系\n\njava 全栈知识体系\n\n风祈的时光录\n\n主要是java技术栈的博客，比较偏原理，源码类型的博主\n\nxustudyxu\n\n一起学习编程!\n\n- name: george chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4okmvi.jpg\n  link: https://cyc0819.top/\n  bgcolor: '#ffb6c1'\n  textcolor: '#621529'  \n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgcolor: '#cbeafa'\n  textcolor: '#6854a1'\n  \n- name: evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n\n- name: 二丫讲梵\n  desc: 💻学习📝记录🔗分享\n  avatar: https://wiki.eryajf.net/img/logo.png\n  link: https://wiki.eryajf.net/\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n\n- name: weibw\n  link: http://weibw162.com/\n  avatar: https://cdn.staticaly.com/gh/weibw162/image-hosting@dev/杂录/image.735febsv1zo0.webp\n  desc: 一个没有梦想的咸鱼\n  bgcolor: '#ffcede'\n  textcolor: '#621529'\n  \n- name: java 全栈知识体系\n  desc: java 全栈知识体系\n  avatar: https://www.pdai.tech/_images/index-read.gif\n  link: https://www.pdai.tech/\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n  \n- name: 风祈的时光录\n  link: https://imlql.cn/\n  avatar: https://npm.elemecdn.com/lql_static@latest/avatar/1.jpg\n  desc: 主要是java技术栈的博客，比较偏原理，源码类型的博主\n  bgcolor: '#ffefe2'\n  textcolor: '#a05f2c'\n \n- name: xustudyxu\n  desc: 一起学习编程!\n  avatar: https://cdn.staticaly.com/gh/xustudyxu/image-hosting@master/20220423/01.3d9wrma6qlq0.webp\n  link: https://frxcat.fun/\n  bgcolor: '#cbeafa'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n如果您想互留友链，点击前往\n\n\n# 搜索引擎\n\n\n# 代码托管\n\n\n# 前端开发\n\n\n# 后端开发\n\n\n# 文档工具\n\n\n# 热门社区\n\n\n# 工具合集\n\n\n# 文档教程\n\n\n# 动态图表\n\n\n# 图片图标\n\n\n# css样式\n\n\n# 网站分析\n\n\n# 其它资源\n\n\n# 参考来源\n\nhttps://www.pdai.tech/md/resource/tools.html",charsets:{cjk:!0},lastUpdated:"2023/03/30, 21:12:32",lastUpdatedTimestamp:1680181952e3},{title:"友情连接",frontmatter:{title:"友情连接",date:"2021-10-28T12:52:20.000Z",permalink:"/friends",article:!1,sidebar:!1,comment:!0,readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/99.%E5%8F%8B%E6%83%85%E8%BF%9E%E6%8E%A5.html",relativePath:"55.更多/99.友情连接.md",key:"v-14bf4ff7",path:"/friends/",headersStr:null,content:"George Chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nEvan's blog\n\n前端的小学生\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nWeibw\n\n一个没有梦想的咸鱼\n\nJava 全栈知识体系\n\nJava 全栈知识体系\n\n风祈的时光录\n\n主要是Java技术栈的博客，比较偏原理，源码类型的博主\n\nxustudyxu\n\n一起学习编程!\n\n从01开始\n\n那就从零开始\n\nJohnsonXin\n\n风和日暖令人愿意永远活下去\n\n- name: George Chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4oKMVI.jpg\n  link: https://cyc0819.top/\n  bgColor: '#FFB6C1'\n  textColor: '#621529'  \n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgColor: '#CBEAFA'\n  textColor: '#6854A1'\n  \n- name: Evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n\n- name: 二丫讲梵\n  desc: 💻学习📝记录🔗分享\n  avatar: https://wiki.eryajf.net/img/logo.png\n  link: https://wiki.eryajf.net/\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n\n- name: Weibw\n  link: http://weibw162.com/\n  avatar: https://cdn.staticaly.com/gh/Weibw162/image-hosting@dev/杂录/image.735febsv1zo0.webp\n  desc: 一个没有梦想的咸鱼\n  bgColor: '#FFCEDE'\n  textColor: '#621529'\n  \n- name: Java 全栈知识体系\n  desc: Java 全栈知识体系\n  avatar: https://www.pdai.tech/_images/index-read.gif\n  link: https://www.pdai.tech/\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n  \n- name: 风祈的时光录\n  link: https://imlql.cn/\n  avatar: https://npm.elemecdn.com/lql_static@latest/avatar/1.jpg\n  desc: 主要是Java技术栈的博客，比较偏原理，源码类型的博主\n  bgColor: '#FFEFE2'\n  textColor: '#A05F2C'\n \n- name: xustudyxu\n  desc: 一起学习编程!\n  avatar: https://cdn.staticaly.com/gh/xustudyxu/image-hosting@master/20220423/01.3d9wrma6qlq0.webp\n  link: https://frxcat.fun/\n  bgColor: '#CBEAFA'\n\n- name: 从01开始\n  desc: 那就从零开始\n  avatar: https://image.peterjxl.com/blog/re0.jpg\n  link: https://www.peterjxl.com\n  bgColor: blue\n\n- name: JohnsonXin\n  desc: 风和日暖令人愿意永远活下去\n  avatar: https://p3-passport.byteimg.com/img/user-avatar/6133eb6b49b7709241a07379f7f509c0~180x180.awebp\n  link: https://reday.asia\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: Young Kbt Blog\t# 昵称\n  desc: 故事由我书写，旅程由你见证，传奇由她聆听\t# 介绍\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png\t# 头像\n  link: https://notes.youngkbt.cn/\t# 链接\n  bgColor: '#FFB6C1'\t# 可选\n  textColor: '#621529'\t# 可选\n\n\n1\n2\n3\n4\n5\n6\n\n\n申请前记得先添加本站哦~",normalizedContent:"george chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nevan's blog\n\n前端的小学生\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nweibw\n\n一个没有梦想的咸鱼\n\njava 全栈知识体系\n\njava 全栈知识体系\n\n风祈的时光录\n\n主要是java技术栈的博客，比较偏原理，源码类型的博主\n\nxustudyxu\n\n一起学习编程!\n\n从01开始\n\n那就从零开始\n\njohnsonxin\n\n风和日暖令人愿意永远活下去\n\n- name: george chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4okmvi.jpg\n  link: https://cyc0819.top/\n  bgcolor: '#ffb6c1'\n  textcolor: '#621529'  \n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgcolor: '#cbeafa'\n  textcolor: '#6854a1'\n  \n- name: evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n\n- name: 二丫讲梵\n  desc: 💻学习📝记录🔗分享\n  avatar: https://wiki.eryajf.net/img/logo.png\n  link: https://wiki.eryajf.net/\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n\n- name: weibw\n  link: http://weibw162.com/\n  avatar: https://cdn.staticaly.com/gh/weibw162/image-hosting@dev/杂录/image.735febsv1zo0.webp\n  desc: 一个没有梦想的咸鱼\n  bgcolor: '#ffcede'\n  textcolor: '#621529'\n  \n- name: java 全栈知识体系\n  desc: java 全栈知识体系\n  avatar: https://www.pdai.tech/_images/index-read.gif\n  link: https://www.pdai.tech/\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n  \n- name: 风祈的时光录\n  link: https://imlql.cn/\n  avatar: https://npm.elemecdn.com/lql_static@latest/avatar/1.jpg\n  desc: 主要是java技术栈的博客，比较偏原理，源码类型的博主\n  bgcolor: '#ffefe2'\n  textcolor: '#a05f2c'\n \n- name: xustudyxu\n  desc: 一起学习编程!\n  avatar: https://cdn.staticaly.com/gh/xustudyxu/image-hosting@master/20220423/01.3d9wrma6qlq0.webp\n  link: https://frxcat.fun/\n  bgcolor: '#cbeafa'\n\n- name: 从01开始\n  desc: 那就从零开始\n  avatar: https://image.peterjxl.com/blog/re0.jpg\n  link: https://www.peterjxl.com\n  bgcolor: blue\n\n- name: johnsonxin\n  desc: 风和日暖令人愿意永远活下去\n  avatar: https://p3-passport.byteimg.com/img/user-avatar/6133eb6b49b7709241a07379f7f509c0~180x180.awebp\n  link: https://reday.asia\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: young kbt blog\t# 昵称\n  desc: 故事由我书写，旅程由你见证，传奇由她聆听\t# 介绍\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png\t# 头像\n  link: https://notes.youngkbt.cn/\t# 链接\n  bgcolor: '#ffb6c1'\t# 可选\n  textcolor: '#621529'\t# 可选\n\n\n1\n2\n3\n4\n5\n6\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"Vue2响应式源码",frontmatter:{title:"Vue2响应式源码",date:"2022-03-15T21:54:22.000Z",permalink:"/pages/053424/",titleTag:"原创",sticky:1,categories:["更多","技术面"],tags:["Vue","面试总结"],readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/08.Vue2%E5%93%8D%E5%BA%94%E5%BC%8F%E6%BA%90%E7%A0%81.html",relativePath:"55.更多/05.技术面/08.Vue2响应式源码.md",key:"v-8efda230",path:"/pages/053424/",headers:[{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:198},{level:2,title:"编译模板的步骤 AST",slug:"编译模板的步骤-ast",normalizedTitle:"编译模板的步骤 ast",charIndex:9504},{level:2,title:"虚拟dom进行对比",slug:"虚拟dom进行对比",normalizedTitle:"虚拟dom进行对比",charIndex:16083},{level:2,title:"观察者模式",slug:"观察者模式",normalizedTitle:"观察者模式",charIndex:16265},{level:2,title:"观察者模式进行数据更新",slug:"观察者模式进行数据更新",normalizedTitle:"观察者模式进行数据更新",charIndex:17039},{level:2,title:"nextTick页面的异步的更新",slug:"nexttick页面的异步的更新",normalizedTitle:"nexttick页面的异步的更新",charIndex:17543},{level:2,title:"步骤详解",slug:"步骤详解",normalizedTitle:"步骤详解",charIndex:18397}],excerpt:'<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>在vue2中，数据响应式更新主要是通过watcher，dep，observe三个核心来实现的，其中watcher是用来观察表达式的变化，发生变化的时候来更新视图，dep是用来收集和管理vue实例中所有的watcher，同时也用来通知已经收集到的watcher来进行更新，最后还有observe用来遍历所有对象，给他们添加get和set方法。</p>\n<div class="custom-block right">\n<p>2022-07-15 @Du Wu</p>\n</div>\n</div>\n',headersStr:"总结 编译模板的步骤 AST 虚拟dom进行对比 观察者模式 观察者模式进行数据更新 nextTick页面的异步的更新 步骤详解",content:"序言\n\n在vue2中，数据响应式更新主要是通过watcher，dep，observe三个核心来实现的，其中watcher是用来观察表达式的变化，发生变化的时候来更新视图，dep是用来收集和管理vue实例中所有的watcher，同时也用来通知已经收集到的watcher来进行更新，最后还有observe用来遍历所有对象，给他们添加get和set方法。\n\n2022-07-15 @Du Wu\n\n\n# 总结\n\n> 在vue2中，数据响应式更新主要是通过watcher，dep，observe三个核心来实现的，其中watcher是用来观察表达式的变化，发生变化的时候来更新视图，dep是用来收集和管理vue实例中所有的watcher，同时也用来通知已经收集到的watcher来进行更新，最后还有observe用来遍历所有对象，给他们添加get和set方法。 具体是当一个vue实例被创建的时候，vue用observe会先遍历对象的所有属性，并通过Object.defineProperty将其添加getter和setter属性，这件事情是发生在beforCreated之后，Created之前。 但是这里有两个问题，当对象里套对象之类的比较深的时候，普通遍历是遍历不到那么深的，所以它会进行递归遍历，这样就可以完成深度的属性转换。 第二个问题是，当对象的属性一开始没有后面才有，这样一开始的时候这个数据没有被劫持到，这个数据就不是响应式的了，所以需要我们手动劫持使用$set或者$delete来添加数据或者删除数据。\n> \n> 然后，当数据是数组的话，vue会更改它的原型指向，让它指向vue自己重新更改的七个改变数组方法，但是为了让数组依然保持数组的特性，vue又把自己的隐式原型再指向数组的方法。 这里也会有一个问题，数组是监测不到里面的属性的，当你想单独使用数组里面的某一个数据的时候，比如赋值，是没办法做到响应式更新的，所以这个时候我们还是可以使用$set手动修改。\n> \n> 所以简单来说，observe就做了一件事，它把一个普通的对象，让他的所有属性尽量的变成一个响应式，可以读取属性，改变属性，可以收到通知\n> \n> 那么dep是用来干嘛的呢？dep是在observe把数据变成响应式的时候，为对象中的每一个属性，数组创建一个dep实例，每个dep实例用来记录依赖（谁在用我），派发更新（我更新了，要通知用到我的人）。\n> \n> 那dep是怎么知道谁在用到它的呢，这里vue就用到了一个巧妙的方法watcher，vue中每个组件渲染过程中都会对应一个watcher实例，当一个组件使用到数据的时候，就会触发数据的get方法，就会将当前组件的更新watcher添加到数据的dep数组内，当数据发生变化的时候，vue会调用dep.notify方法去调用dep数组里的更新watcher里的updata方法进行页面更新。\n> \n> 总结简单来说dep管理依赖项和通知更新，然后watcher观察对象的变化，接收dep的通知重新收集依赖并执行回调函数。\n\nobserve(data); // 观测这个数据\n\n\n1\n\n\n当我们new Vue之后，做了什么事情？\n\n 1. 当我们new Vue之后，调用了Vue构造函数，传入配置项\n\n 2. Vue构造函数传入的配置项，调用this._init(options)方法\n\n// Object.defineProperty() vue2版本的数据劫持\n// 构造函数或者类\nfunction Vue(options) {\n  // console.log(options)\n  // 内部要进行初始化的操作\n  this._init(options); // 初始化操作\n}\n\n// 原型模式\ninitMixin(Vue); // 添加原型的方法\nrenderMixin(Vue);\nlifeCycleMixin(Vue);\n\n\n// initGlobalApi 给构造函数来扩展全局的方法\ninitGlobalAPI(Vue);\nVue.prototype.$nextTick = nextTick\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n 3. _init方法时通过原型模式进行注入的\n\n 4. 提供一个_initMixin方法，传入Vue构造函数\n\nexport function initMixin(Vue) {\n  // 传入的构造函数的原型上添加方法\n  Vue.prototype._init = function (options) {\n    // Vue的内部 $options 就是用户传递的所有参数\n    const vm = this; // this指向initMixin的实例\n    // 这个options 就包含了用户创建实例时传入的所有属性 Vue.options\n    vm.$options = mergeOptions(vm.constructor.options, options); // 用户传入的参数\n    callHook(vm, 'beforeCreate') // 调用生命周期函数\n    // vm._data = vm.$options.data; // 获取用户传入的data\n    initState(vm); // 初始化状态 data/methods/props/computed/watcher/provide/inject\n\n    callHook(vm, 'created') // 执行了created函数\n    // 需要通过模板进行渲染\n    if (vm.$options.el) { // 用户传入了el属性\n      vm.$mount(vm.$options.el)\n    }\n  }\n  Vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.querySelector(el); // 获取el属性\n\n    // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    const opts = vm.$options; // 获取用户传入的所有参数\n\n    if (!opts.render) { // 没有render方法\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerHTML; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compileToFunctions(template); // div v-if v-show {{  }}\n      // compileToFunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n    // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n    mountComponent(vm, el); // 组件的挂载流程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n5，initMixin方法内部会把_init挂载到Vue原型上\n\n6，_init方法内部在执行数据挂载之前，先通过callHook函数调用beforeCreate函数\n\n    initState(vm); // 初始化状态 data/methods/props/computed/watcher/provide/inject\n\n\n1\n\n\n7，内部会判断是否有data选项，如果有，通过initData执行数据的响应式处理initData（vm）\n\n8，处理data数据：判断data是不是一个函数，如果是函数通过call方法，this执行vm之后再带哦用【使用的时候data函数内部的this指向的是vue实例】，如果不是一个函数，直接赋值\n\nfunction initData(vm) {\n  // 数据响应式原理 data中的数据需要做一个数据劫持，当我改变数据时，应该更新视图\n  let data = vm.$options.data; // 用户传入的数据挂载到了vm.$options上\n  // this.data = vm.$options.data\n  // vm._data 就是检测后的数据了\n  // vm._data是做什么的？ 为了方便后续的操作，将用户传入的data数据，放到vm._data上\n  // 为data做一个代理，方便用户直接通过vm.key 获取到data里面的属性，用this.key也可以获取到data里面的属性\n  // 为什么可以使用this进行访问到？ 因为在initState中，已经将data代理到了vm实例上了\n  // 修改this指向，指向vm实例\n  data = vm._data = typeof data === 'function' ? data.call(vm) : data;\n  // 观测数据\n  // 将数据全部代理到vm的实例上\n\n  // this.msg\n  // this.data.msg\n  for (let key in data) { // 将data上的所有属性都代理到vm上\n    proxy(vm, '_data', key);\n  }\n  // 效果：已经可以使用this.key 获取到data里面的属性了，也可以设置属性了，经过了数据的代理\n  observe(data); // 观测这个数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n9，【数据的代理】遍历data数据：initDdata中的observe（data）观测这个数据\n\nexport function observe(data) {\n  // 对象就是使用defineProperty 来实现响应式原理\n  // 如果这个数据不是对象 或者是null 那就不用监控了\n  if (!isObject(data)) {\n    return\n  }\n  // 对象或者数组\n  // 当前数据是否已经被响应式劫持过\n  if (data.__ob__) {\n    return\n  }\n  // if (data.__ob__ instanceof Observer) { // 防止对象被重复观测\n  //   return;\n  // }\n\n  // 对数据进行defineProperty\n  return new Observer(data); // 可以看到当前数据是否被观测过\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用Object.defineProperty进行数据劫持\n\n【获取属性】组件内部通过this.【data里面的键】获取值的时候，会返回vm上的_data里面的数据\n\n【设置属性】通过this.【data里面的键】设置键的时候，属性设置给数据，而不是直接添加到vm实例上\n\n10，【数据劫持】调用observe（data），开始执行真正的响应式操作\n\n11，第一步：coustructor会先给当前的数据打一个标记，__ob__添加了这个属性就不需要二次处理，添加一个，不可枚举，不可以遍历。添加了一个，不可删除，不能修改，不可以重新定义，不可配置。\n\n12，先判断是不是一个数组，因为数组和对象的处理方法不一样，如果是一个数组的话：\n\n// 先判断是不是一个数组，因为数组的索引是可以被改变的，所以需要对数组的索引进行拦截\n    // 为什么这里的data会有数组类型？ 因为vue是可以监控数组的变化的,所以这里的data可能是数组\n    if (Array.isArray(data)) { // 如果是数组的话，就要重写数组的方法\n      // vue如何对数组进行处理呢？ 数组用的是重写数组的方法  函数劫持\n      // 改变数组本身的方法我就可以监控到了\n      data.__proto__ = arrayMethods; // 重写当前数组的原型方法\n      // 每一级的数组和对象都要进行劫持,如果是数组的话，就要重写数组的方法，如果是对象的话，就要重写对象的方法\n      // 劫持之后，做成响应式数据\n      this.observeArray(data);\n      //   1、重写数组的原型方法(push,....7个)\n      //   2、遍历数组，判断每一项是不是对象或者数组，如果是继续处理，上一个数组的内部\n    } else {\n      // data是一个对象\n      this.walk(data); // 可以对数据一步一步的处理\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这里数组的响应式和对象的响应式是不一样的，但是我们先判断是不是一个数组，再判断是不是一个对象。因为：数组也是一个对象，如果先判断对象，没有办法分辨出是一个数组还是一个对象了。\n\n13，数组劫持了数组的七个方法，vue重写可以改变数组的七种方法；如果是对象的话：劫持Object.defineProperty；\n\n处理数组的方法，进行递归遍历，一直遍历到普通数据类型\n\n创建一个新的原型对象，传入了原生数组的原型对象，作为空对象的原型对象，这样就可以找到数组原型上的方法，而且修改对象的时候，不会影响到原数组的原型方法\n\n把数组的原型指向这个新的对象，当调用数组的方法的时候，先从这个新对象上去找，如果找不到的话，去数组的原型上找\n\n重新编写数组使用了AOP的切片编程\n\nlet oldArrayMethods = Array.prototype; // 获取数组原型上的方法\n\n// 创建一个全新的对象，传入了原生数组的原型对象，作为空对象的原型对象，可以找到数组原型上的方法，而且修改对象时不会影响原数组的原型方法\n// 把数组的原型指向这个新的对象，当调用数组的方法时，先从这个新的对象上找，如果找不到再去数组原型上找\nexport let arrayMethods = Object.create(oldArrayMethods); // {}.__proto__\n\nlet methods = [ // 这七个方法都可以改变原数组\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\n\n// arr.filter()\n\n// arrayMethods = {\n//   push () {},\n//   pop() {},\n//   // ...\n// }\n\n// vue劫持数组方法的目的是什么？\n// object.defineProerty\nmethods.forEach(method => {\n  arrayMethods[method] = function (...args) { // 函数劫持 AOP\n    // 当用户调用数组方法时 会先执行我自己改造的逻辑 在执行数组默认的逻辑\n    const ob = this.__ob__;\n    // oldArrayMethods原生数组的方法\n    // this指向数组，args是用户传递的参数，apply可以改变this指向，让this指向数组\n    // 为什么要用apply？因为apply可以传递多个参数\n    // AOP 面向切片编程,在不改变原有逻辑的基础上,对原有逻辑进行扩展,比如在原有逻辑之前或之后执行一些逻辑,这就是AOP\n    let result = oldArrayMethods[method].apply(this, args); // 调用数组原生的方法,指向数组\n    // this.arr.push('23')\n    let inserted;\n    // push unshift splice 都可以新增属性  （新增的属性可能是一个对象类型）\n    // 内部还对数组中引用类型也做了一次劫持  [].push({name:'hm'})\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break;\n      case 'splice': // 也是新增属性  可以修改 可以删除  [].splice(arr,1,'div')\n        inserted = args.slice(2);\n        break;\n      default:\n        break;\n    }\n    inserted && ob.observeArray(inserted);\n    // render() // 重新渲染界面\n    return result;\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n如果是对象的话，进行递归，判断里面的每一项，直至递归到都是普通数据类型，给每一项添加一个get和set方法，进行数据的渲染和数据的更新，添加一个dep进行watcher的收集\n\n// vue2响应式有什么缺点\n// 1，如果数据层次过多，递归会很消耗性能【如果是一次性使用的数据，使用Object.freeze进行冻结】\n// 2，初次渲染的时候，性能不好，因为需要递归的去遍历对象，把属性都进行defineProperty\n// 3，无法检测到对象属性的新增和删除，因为vue2是在初始化的时候，对属性进行defineProperty，所以无法检测到对象属性的新增和删除，需要使用$set方法进行变化，或者使用数组的索引进行变化\n// 4，数组的变化无法检测到，因为数组的变化方法没有被重写，所以无法检测到数组的变化，需要使用$set方法进行变化，或者使用数组的索引进行变化\n// 5，如果数据对象中嵌套了太多层次的对象，那么递归的去遍历对象，会造成性能的浪费\n// 数据劫持的是数组的方法\n// 为什么数组不适用Object.defineProperty\n// 初始化的时候只劫持data已经存在的属性\n// 检测不到数据key的删除\nfunction defineReactive(data, key, value) { // data对象  key msg  value 23·\n    // 如果值是一个对象的话，就继续递归循环检测,如果是基本类型的话，就不用递归了\n    // 如果传入的值还是一个对象的话 就做递归循环检测\n    // 数据对象，每个人都会获取到一个dep，相当于收集依赖的容器\n  observe(value);\n    // 给数据的每一个属性都增加一个get和set方法\n  let dep = new Dep(); // msg.dep =[watcher]  age.dep = [watcher]  // 渲染watcher中.deps [msg.dep,age.dep]\n  // 观察者，get收集依赖，set触发依赖。收集watcher，触发watcher\n  Object.defineProperty(data, key, {\n    get() {\n      // 获取数据的时候会触发，初始化数据的时候，不会触发get\n      // 编译模板的时候会获取数据，获取数据会触发当前数据的get方法\n      // get触发的时候，会把当前的组件更新方法，添加到dep中\n      // vue的更新操作是组件级别的\n      // 这里会有取值的操作，给这个属性增加一个dep，这个dep 要和刚才我放到全局变量的上的watcher 做一个对应关系\n      // 添加观察者\n      // 当前数据被哪个组件使用到了，当前组件的更新方法添加到观察者\n      if (Dep.target) {\n        dep.depend(); // 让这个dep 去收集watcher\n      }\n      return value\n    },\n    set(newValue) {\n      // 修改数据的时候会触发，初始化数据的时候，不会触发set\n      if (newValue == value) return; // 如果新值和老值一样，就不用更新了\n      observe(newValue); // 监控当前设置的值，有可能用户给了一个新值，用户设置的最新的值\n      value = newValue;\n      // 当我们更新数据后 要把当前自己对应的watcher 去重新执行以下.\n      // 手机进去的依赖进行更新\n      dep.notify(); // 更新数据的时候，把get方法中收集的watcher全部执行一遍\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 编译模板的步骤 AST\n\ninitMixin给给构造函数的原型上添加方法，添加_init和this指向initMixin赋值给vm\n\nvm获取用户传入的参数\n\n使用Vue.prototypr.$mount函数，获取到vm的实例化对象，然后获取到el的属性\n\n  Vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.querySelector(el); // 获取el属性\n// 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\nconst opts = vm.$options; // 获取用户传入的所有参数\n\n\n1\n2\n3\n4\n5\n\n\n获取到用户传入的参数，进行判断有没有render方法\n\n    if (!opts.render) { // 没有render函数\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerHTML; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compileToFunctions(template); // div v-if v-show {{  }}\n      // compileToFunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果调用的时候没有render函数，就会去获取模板，首先获取外部模板，编译程div的格式，这个时候的div格式是字符串类型\n\n      const render = compileToFunctions(template); // div v-if v-show {{  }}\n\n\n1\n\n\n如果调用的时候有render函数，直接走编译\n\n  Vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.querySelector(el); // 获取el属性\n\n    // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    const opts = vm.$options; // 获取用户传入的所有参数\n\n    if (!opts.render) { // 没有render方法\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerHTML; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compileToFunctions(template); // div v-if v-show {{  }}\n      // compileToFunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n    // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n    mountComponent(vm, el); // 组件的挂载流程\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n1，parseHTML编译出来ast语法树（静态节点编译优化）【进行正则匹配】\n\n  let ast = parseHTML(template); // '<div></div>'进行页面编译，把字符串编译成ast语法树\n\n\n1\n\n\n创建AST树，进行正则的匹配\n\n//              字母a-zA-Z_ - . 数组小写字母 大写字母\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\n// ?:匹配不捕获   <aaa:aaa>\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n// startTagOpen 可以匹配到开始标签 正则捕获到的内容是 (标签名)\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\n// 闭合标签 </xxxxxxx>\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\n// <div aa   =   \"123\"  bb=123  cc='123'\n// 捕获到的是 属性名 和 属性值 arguments[1] || arguments[2] || arguments[2]\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// <div >   <br/>\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n// 匹配动态变量的  +? 尽可能少匹配\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\nexport function parseHTML(html) {\n  // ast 树 表示html的语法\n  let root; // 树根\n  let currentParent; // 标识当前父亲是谁\n  let stack = []; // 用来判断标签是否正常闭合  [div]  解析器可以借助栈型结构\n  // <div id=\"app\" style=\"color:red\"><span>    helloworld {{msg}}   </span></div>\n\n  // vue2.0 只能有一个根节点 必须是html 元素\n\n  // 常见数据结构 栈 队列 数组 链表 集合 hash表 树\n  function createASTElement(tagName, attrs) { // 产生ast元素的\n    return { // ast语法树 用对象来描述原生语法\n      tag: tagName, // 标签名\n      attrs,  // 属性\n      children: [], // 子元素\n      parent: null, // 父亲是谁\n      type: 1 // 1 普通元素  3 文本\n    }\n  }\n\n  // console.log(html)\n  function start(tagName, attrs) { // 开始标签 每次解析开始标签 都会执行此方法\n    let element = createASTElement(tagName, attrs);\n    if (!root) {\n      root = element; // 只有第一次是根\n    }\n    currentParent = element; // 标识当前父亲是谁\n    stack.push(element); // 将开始标签存放到栈中\n  }\n\n  // <div> <span></span> hello world</div>   [div,span]\n  function end(tagName) { // 结束标签  确立父子关系\n    let element = stack.pop(); // 取出栈中的最后一个\n    currentParent = stack[stack.length - 1]; // 取出当前的父亲是谁\n    if (currentParent) { // 在闭合时可以知道这个标签的父亲是谁\n      element.parent = currentParent; // 在闭合时可以知道这个标签的父亲是谁\n      currentParent.children.push(element); // 实现了一个树的父子关系\n    }\n  }\n\n  function chars(text) { // 文本\n    text = text.replace(/\\s/g, ''); // 去掉空格\n    if (text) { // 如果是空字符串 不处理\n      currentParent.children.push({ // 将文本放到当前父亲的children中\n        type: 3, // 文本类型\n        text // 文本内容\n      })\n    }\n  }\n\n  // 根据 html 解析成树结构  </span></div>\n  while (html) { // 只要html不为空字符串 就一直解析\n    let textEnd = html.indexOf('<'); // 查找<的位置\n    if (textEnd == 0) { // 如果当前索引为0 说明是一个标签 开始标签或者结束标签\n      const startTageMatch = parseStartTag(); // 通过这个方法获取到匹配的结果 tagName,attrs\n\n      if (startTageMatch) {\n        // 开始标签\n        start(startTageMatch.tagName, startTageMatch.attrs) // 开始标签的处理\n      }\n      const endTagMatch = html.match(endTag); // 匹配结束标签\n\n      if (endTagMatch) {\n        advance(endTagMatch[0].length); // 删除结束标签\n        end(endTagMatch[1]) // 将结束标签传入\n      }\n      // 结束标签\n    }\n\n    // 如果不是0 说明是文本\n    let text; // 文本\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd); // 是文本就把文本内容进行截取\n      chars(text); // 将文本进行处理\n    }\n    if (text) {\n      advance(text.length); // 删除文本内容\n    }\n  }\n\n  function advance(n) {\n    html = html.substring(n); // 删除指定的内容\n  }\n\n  function parseStartTag() {\n    const start = html.match(startTagOpen); // 匹配开始标签\n    if (start) {\n      const match = {\n        tagName: start[1], // 匹配到的标签名\n        attrs: [] // 匹配到的属性\n      }\n      advance(start[0].length);\n      let end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) { // 只要不是结尾标签 并且能匹配到属性 就一直解析\n        advance(attr[0].length); // 删除属性\n        match.attrs.push({name: attr[1], value: attr[3] || attr[4] || attr[5]}) // 将属性放到match的attrs中\n      }\n\n      if (end) {\n        advance(end[0].length); // 删除开始标签结束的 >\n        return match; // 返回匹配的结果\n      }\n    }\n  }\n\n  return root;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n\n\n将AST进行优化\n\n优化的目标：生成模板AST，检测不需要进行DOM改变的静态子树，一定那检测到这些静态树，我们就能做以下这些事情\n\n（1）把他们变成常熟，这样我们就再也不需要每次重新渲染时创建新的节点了\n\n（2）在patch的过程中直接进行跳过\n\n2，generate编译出可执行的函数字符串【遍历语法树，进行字符串的拼接】\n\n3，使用with包裹【拼接字符串】，拼接字符串的时候会为变量添加this指向，这样模板使用data中的数据的时候，就不用写this了\n\n4，new Function把字符串变成可执行函数\n\n如果走到最后，说不需要进行编译了，用户传入的就是一个render函数，直接给函数vm实例和el进行挂载\n\n使用mountComponent，进行callHook函数调用\n\n调用mountComponent函数进行新旧dom的对比，使用Watcher进行页面的更新\n\n\n# 虚拟dom进行对比\n\ncallHook挂载前获取vm实例和beforeMount钩子，然后开始编译\n\n在updataComponent函数中进行新旧dom的对比，调用render方法后返回的时虚拟dom\n\n每次数据发生变化，旧执行update方法 new Watcher进行页面的更新\n\n创建Watcher的实例化对象，所以Watcher时更新数据的方法\n\n\n# 观察者模式\n\n使用Object.defineProperty对对象数据进行拦截，判断是否有__ob__的属性，如果没有__ob__的情况下，会添加一个__ob__，然后添加不可枚举和不可修改的属性。\n\n进行判断data是不是数组类型，如果是数组类型的情况下，vue进行函数劫持，然后重写数组的原型方法，如果说劫持的是数组就改变数组的七种方法，如果说劫持的是对象就改变对象的方法。\n\n如果值是一个对象的话defineReactive，就继续递归循环检测，如果说是基本类型的话，就不用进行递归。传入对象就进行递归的循环检测，给每一个数据添加一个dep，收集依赖的容器，用来收集watcher。声明一个new Dep，进行赋值。【开启观察者模式】get进行依赖的watcher的收集，set触发依赖，触发watcher中的run方法以及进行数据的更新。\n\nget获取数据的时候会触发，初始化数据的时候，不会触发get。编译模板的时候会获取数据，获取数据会触发当前的数据的get方法，get触发的时候会把当前组件进行更新，添加到dep中，vue的更新操作是组件级别的，这个会有一个取值的操作，给这个属性添加一个dep要和全局变量的watcher做出一个对应关系。\n\n下一步，把watcher储存到deo中\n\ndep和watcher是典型的观察者模式，dep是目标（有一个subs），watcher是观察者，把watcehr储存到sunes里面，对数据进行观测，当目标数据方法变化的时候，通知所有的观察者，观察者执行对应的方法，更新视图。更新视图的方法是调用notify，进行修改，触发set方法。\n\n为什么让watcher储存到dep中？因为watcher是组件级别的，dep是全局唯一的，所以让watcher进行dep储存，储存之后进行模板编译\n\n\n# 观察者模式进行数据更新\n\n触发set方法，然后触发dep.notify()方法，notify中有一个subs数组，存的是需要更新的watcher，然后watcher中调用updata函数触发然后queueWatcher函数，将watcher进行修改，进行页面视图的更新处理\n\n首先要知道一个概念，Vue是组件化更新页面的，Vue一个组件中有多个属性，会产生多个watcher，但是这些watcher的id是相同的。【Vue中不同的组件的watcher id是不相同的，但是同一个组件的watcher id是相同的】\n\n数据更新步骤\n\n第一步：首先给watcher储存到一个队列当中【等待多个组件一起储存，一起更新】\n\n第二步：页面同步更新的时候，当前watcher.id已经存在了，不需要再次进行储存，这样，页面的同步更新和异步更新都会进行更新操作\n\n第二部：等待更新，清空队列，一直执行watcher的set方法，set方法会触发dep.notify（），dep.notify（）会触发watcher的updata方法\n\n第四步：执行watcher的run方法，调用get方法，重新进行页面的渲染\n\n\n# nextTick页面的异步的更新\n\nnextTick，想要获取最新的页面dom结构的时候需要使用到nextTick\n\n当修改完数据以后，会触发当前数据的set方法，通知当前数据在get阶段收集到的所有依赖【watcher】进行更新，更新不是同步更新的，而是通过nextTick注册异步任务进行更新，所以修改完数据以后想要立即获取最新的页面结构是获取不到的。\n\n这个时候我们可以使用nextTick继续注册一个异步任务\n\n同步代码走完，开始清空异步任务\n\nnextTick的异步任务类型是根据宿主环境进行判断promise,mutationObserver,setImmediate,setTimeout。\n\n场景：行内编辑的时候，自动获取焦点\n\n修改完数据之后，会触发set方法，通知set阶段收集watcher触发updata方法，将watcher储存到更新队列中，使用nextTick中的定时器进行异步更新，进行队列的清空，一次执行watcher的run方法，调用get方法，重新进行渲染。也就是当数据进行修改的时候，为什么需要nextTick进行异步操作才能拿到数据？当data中的数据初始化的时候，劫持这个数据，使用get和set方法，触发数据的get方法，页面进行渲染，数据初始化完成之后，编译模板，将模板中的数据和页面进行绑定。get只要触发了，当前组件更新watcher就会被收集到Dep里面【观察者模式】\n\n如果我们修改了data里面的数据，会触发set方法，set方法触发dep.notify()，depnotify()会触发watcher的updata方法。就把收集到所有的依赖【更新watcher】，通过nextTick进行异步更新，清空队列，一次执行watcher的run方法，调用get方法，重新进行页面的渲染。\n\nnextTick的异步根据宿主环境进行何种异步的更新判断。promise，mutationObserver,setImmediate,setTimeout.\n\n\n# 步骤详解\n\nnew vue之后传入一个_init方法，使用initMixin（vue），把_init方法挂载到vue的原型上\n\ninitMixin(Vue); // 添加原型的方法\n\n\n1\n",normalizedContent:"序言\n\n在vue2中，数据响应式更新主要是通过watcher，dep，observe三个核心来实现的，其中watcher是用来观察表达式的变化，发生变化的时候来更新视图，dep是用来收集和管理vue实例中所有的watcher，同时也用来通知已经收集到的watcher来进行更新，最后还有observe用来遍历所有对象，给他们添加get和set方法。\n\n2022-07-15 @du wu\n\n\n# 总结\n\n> 在vue2中，数据响应式更新主要是通过watcher，dep，observe三个核心来实现的，其中watcher是用来观察表达式的变化，发生变化的时候来更新视图，dep是用来收集和管理vue实例中所有的watcher，同时也用来通知已经收集到的watcher来进行更新，最后还有observe用来遍历所有对象，给他们添加get和set方法。 具体是当一个vue实例被创建的时候，vue用observe会先遍历对象的所有属性，并通过object.defineproperty将其添加getter和setter属性，这件事情是发生在beforcreated之后，created之前。 但是这里有两个问题，当对象里套对象之类的比较深的时候，普通遍历是遍历不到那么深的，所以它会进行递归遍历，这样就可以完成深度的属性转换。 第二个问题是，当对象的属性一开始没有后面才有，这样一开始的时候这个数据没有被劫持到，这个数据就不是响应式的了，所以需要我们手动劫持使用$set或者$delete来添加数据或者删除数据。\n> \n> 然后，当数据是数组的话，vue会更改它的原型指向，让它指向vue自己重新更改的七个改变数组方法，但是为了让数组依然保持数组的特性，vue又把自己的隐式原型再指向数组的方法。 这里也会有一个问题，数组是监测不到里面的属性的，当你想单独使用数组里面的某一个数据的时候，比如赋值，是没办法做到响应式更新的，所以这个时候我们还是可以使用$set手动修改。\n> \n> 所以简单来说，observe就做了一件事，它把一个普通的对象，让他的所有属性尽量的变成一个响应式，可以读取属性，改变属性，可以收到通知\n> \n> 那么dep是用来干嘛的呢？dep是在observe把数据变成响应式的时候，为对象中的每一个属性，数组创建一个dep实例，每个dep实例用来记录依赖（谁在用我），派发更新（我更新了，要通知用到我的人）。\n> \n> 那dep是怎么知道谁在用到它的呢，这里vue就用到了一个巧妙的方法watcher，vue中每个组件渲染过程中都会对应一个watcher实例，当一个组件使用到数据的时候，就会触发数据的get方法，就会将当前组件的更新watcher添加到数据的dep数组内，当数据发生变化的时候，vue会调用dep.notify方法去调用dep数组里的更新watcher里的updata方法进行页面更新。\n> \n> 总结简单来说dep管理依赖项和通知更新，然后watcher观察对象的变化，接收dep的通知重新收集依赖并执行回调函数。\n\nobserve(data); // 观测这个数据\n\n\n1\n\n\n当我们new vue之后，做了什么事情？\n\n 1. 当我们new vue之后，调用了vue构造函数，传入配置项\n\n 2. vue构造函数传入的配置项，调用this._init(options)方法\n\n// object.defineproperty() vue2版本的数据劫持\n// 构造函数或者类\nfunction vue(options) {\n  // console.log(options)\n  // 内部要进行初始化的操作\n  this._init(options); // 初始化操作\n}\n\n// 原型模式\ninitmixin(vue); // 添加原型的方法\nrendermixin(vue);\nlifecyclemixin(vue);\n\n\n// initglobalapi 给构造函数来扩展全局的方法\ninitglobalapi(vue);\nvue.prototype.$nexttick = nexttick\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n 3. _init方法时通过原型模式进行注入的\n\n 4. 提供一个_initmixin方法，传入vue构造函数\n\nexport function initmixin(vue) {\n  // 传入的构造函数的原型上添加方法\n  vue.prototype._init = function (options) {\n    // vue的内部 $options 就是用户传递的所有参数\n    const vm = this; // this指向initmixin的实例\n    // 这个options 就包含了用户创建实例时传入的所有属性 vue.options\n    vm.$options = mergeoptions(vm.constructor.options, options); // 用户传入的参数\n    callhook(vm, 'beforecreate') // 调用生命周期函数\n    // vm._data = vm.$options.data; // 获取用户传入的data\n    initstate(vm); // 初始化状态 data/methods/props/computed/watcher/provide/inject\n\n    callhook(vm, 'created') // 执行了created函数\n    // 需要通过模板进行渲染\n    if (vm.$options.el) { // 用户传入了el属性\n      vm.$mount(vm.$options.el)\n    }\n  }\n  vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.queryselector(el); // 获取el属性\n\n    // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    const opts = vm.$options; // 获取用户传入的所有参数\n\n    if (!opts.render) { // 没有render方法\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerhtml; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compiletofunctions(template); // div v-if v-show {{  }}\n      // compiletofunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n    // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n    mountcomponent(vm, el); // 组件的挂载流程\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n5，initmixin方法内部会把_init挂载到vue原型上\n\n6，_init方法内部在执行数据挂载之前，先通过callhook函数调用beforecreate函数\n\n    initstate(vm); // 初始化状态 data/methods/props/computed/watcher/provide/inject\n\n\n1\n\n\n7，内部会判断是否有data选项，如果有，通过initdata执行数据的响应式处理initdata（vm）\n\n8，处理data数据：判断data是不是一个函数，如果是函数通过call方法，this执行vm之后再带哦用【使用的时候data函数内部的this指向的是vue实例】，如果不是一个函数，直接赋值\n\nfunction initdata(vm) {\n  // 数据响应式原理 data中的数据需要做一个数据劫持，当我改变数据时，应该更新视图\n  let data = vm.$options.data; // 用户传入的数据挂载到了vm.$options上\n  // this.data = vm.$options.data\n  // vm._data 就是检测后的数据了\n  // vm._data是做什么的？ 为了方便后续的操作，将用户传入的data数据，放到vm._data上\n  // 为data做一个代理，方便用户直接通过vm.key 获取到data里面的属性，用this.key也可以获取到data里面的属性\n  // 为什么可以使用this进行访问到？ 因为在initstate中，已经将data代理到了vm实例上了\n  // 修改this指向，指向vm实例\n  data = vm._data = typeof data === 'function' ? data.call(vm) : data;\n  // 观测数据\n  // 将数据全部代理到vm的实例上\n\n  // this.msg\n  // this.data.msg\n  for (let key in data) { // 将data上的所有属性都代理到vm上\n    proxy(vm, '_data', key);\n  }\n  // 效果：已经可以使用this.key 获取到data里面的属性了，也可以设置属性了，经过了数据的代理\n  observe(data); // 观测这个数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n9，【数据的代理】遍历data数据：initddata中的observe（data）观测这个数据\n\nexport function observe(data) {\n  // 对象就是使用defineproperty 来实现响应式原理\n  // 如果这个数据不是对象 或者是null 那就不用监控了\n  if (!isobject(data)) {\n    return\n  }\n  // 对象或者数组\n  // 当前数据是否已经被响应式劫持过\n  if (data.__ob__) {\n    return\n  }\n  // if (data.__ob__ instanceof observer) { // 防止对象被重复观测\n  //   return;\n  // }\n\n  // 对数据进行defineproperty\n  return new observer(data); // 可以看到当前数据是否被观测过\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n使用object.defineproperty进行数据劫持\n\n【获取属性】组件内部通过this.【data里面的键】获取值的时候，会返回vm上的_data里面的数据\n\n【设置属性】通过this.【data里面的键】设置键的时候，属性设置给数据，而不是直接添加到vm实例上\n\n10，【数据劫持】调用observe（data），开始执行真正的响应式操作\n\n11，第一步：coustructor会先给当前的数据打一个标记，__ob__添加了这个属性就不需要二次处理，添加一个，不可枚举，不可以遍历。添加了一个，不可删除，不能修改，不可以重新定义，不可配置。\n\n12，先判断是不是一个数组，因为数组和对象的处理方法不一样，如果是一个数组的话：\n\n// 先判断是不是一个数组，因为数组的索引是可以被改变的，所以需要对数组的索引进行拦截\n    // 为什么这里的data会有数组类型？ 因为vue是可以监控数组的变化的,所以这里的data可能是数组\n    if (array.isarray(data)) { // 如果是数组的话，就要重写数组的方法\n      // vue如何对数组进行处理呢？ 数组用的是重写数组的方法  函数劫持\n      // 改变数组本身的方法我就可以监控到了\n      data.__proto__ = arraymethods; // 重写当前数组的原型方法\n      // 每一级的数组和对象都要进行劫持,如果是数组的话，就要重写数组的方法，如果是对象的话，就要重写对象的方法\n      // 劫持之后，做成响应式数据\n      this.observearray(data);\n      //   1、重写数组的原型方法(push,....7个)\n      //   2、遍历数组，判断每一项是不是对象或者数组，如果是继续处理，上一个数组的内部\n    } else {\n      // data是一个对象\n      this.walk(data); // 可以对数据一步一步的处理\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这里数组的响应式和对象的响应式是不一样的，但是我们先判断是不是一个数组，再判断是不是一个对象。因为：数组也是一个对象，如果先判断对象，没有办法分辨出是一个数组还是一个对象了。\n\n13，数组劫持了数组的七个方法，vue重写可以改变数组的七种方法；如果是对象的话：劫持object.defineproperty；\n\n处理数组的方法，进行递归遍历，一直遍历到普通数据类型\n\n创建一个新的原型对象，传入了原生数组的原型对象，作为空对象的原型对象，这样就可以找到数组原型上的方法，而且修改对象的时候，不会影响到原数组的原型方法\n\n把数组的原型指向这个新的对象，当调用数组的方法的时候，先从这个新对象上去找，如果找不到的话，去数组的原型上找\n\n重新编写数组使用了aop的切片编程\n\nlet oldarraymethods = array.prototype; // 获取数组原型上的方法\n\n// 创建一个全新的对象，传入了原生数组的原型对象，作为空对象的原型对象，可以找到数组原型上的方法，而且修改对象时不会影响原数组的原型方法\n// 把数组的原型指向这个新的对象，当调用数组的方法时，先从这个新的对象上找，如果找不到再去数组原型上找\nexport let arraymethods = object.create(oldarraymethods); // {}.__proto__\n\nlet methods = [ // 这七个方法都可以改变原数组\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'sort',\n  'reverse',\n  'splice'\n]\n\n// arr.filter()\n\n// arraymethods = {\n//   push () {},\n//   pop() {},\n//   // ...\n// }\n\n// vue劫持数组方法的目的是什么？\n// object.defineproerty\nmethods.foreach(method => {\n  arraymethods[method] = function (...args) { // 函数劫持 aop\n    // 当用户调用数组方法时 会先执行我自己改造的逻辑 在执行数组默认的逻辑\n    const ob = this.__ob__;\n    // oldarraymethods原生数组的方法\n    // this指向数组，args是用户传递的参数，apply可以改变this指向，让this指向数组\n    // 为什么要用apply？因为apply可以传递多个参数\n    // aop 面向切片编程,在不改变原有逻辑的基础上,对原有逻辑进行扩展,比如在原有逻辑之前或之后执行一些逻辑,这就是aop\n    let result = oldarraymethods[method].apply(this, args); // 调用数组原生的方法,指向数组\n    // this.arr.push('23')\n    let inserted;\n    // push unshift splice 都可以新增属性  （新增的属性可能是一个对象类型）\n    // 内部还对数组中引用类型也做了一次劫持  [].push({name:'hm'})\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args\n        break;\n      case 'splice': // 也是新增属性  可以修改 可以删除  [].splice(arr,1,'div')\n        inserted = args.slice(2);\n        break;\n      default:\n        break;\n    }\n    inserted && ob.observearray(inserted);\n    // render() // 重新渲染界面\n    return result;\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n如果是对象的话，进行递归，判断里面的每一项，直至递归到都是普通数据类型，给每一项添加一个get和set方法，进行数据的渲染和数据的更新，添加一个dep进行watcher的收集\n\n// vue2响应式有什么缺点\n// 1，如果数据层次过多，递归会很消耗性能【如果是一次性使用的数据，使用object.freeze进行冻结】\n// 2，初次渲染的时候，性能不好，因为需要递归的去遍历对象，把属性都进行defineproperty\n// 3，无法检测到对象属性的新增和删除，因为vue2是在初始化的时候，对属性进行defineproperty，所以无法检测到对象属性的新增和删除，需要使用$set方法进行变化，或者使用数组的索引进行变化\n// 4，数组的变化无法检测到，因为数组的变化方法没有被重写，所以无法检测到数组的变化，需要使用$set方法进行变化，或者使用数组的索引进行变化\n// 5，如果数据对象中嵌套了太多层次的对象，那么递归的去遍历对象，会造成性能的浪费\n// 数据劫持的是数组的方法\n// 为什么数组不适用object.defineproperty\n// 初始化的时候只劫持data已经存在的属性\n// 检测不到数据key的删除\nfunction definereactive(data, key, value) { // data对象  key msg  value 23·\n    // 如果值是一个对象的话，就继续递归循环检测,如果是基本类型的话，就不用递归了\n    // 如果传入的值还是一个对象的话 就做递归循环检测\n    // 数据对象，每个人都会获取到一个dep，相当于收集依赖的容器\n  observe(value);\n    // 给数据的每一个属性都增加一个get和set方法\n  let dep = new dep(); // msg.dep =[watcher]  age.dep = [watcher]  // 渲染watcher中.deps [msg.dep,age.dep]\n  // 观察者，get收集依赖，set触发依赖。收集watcher，触发watcher\n  object.defineproperty(data, key, {\n    get() {\n      // 获取数据的时候会触发，初始化数据的时候，不会触发get\n      // 编译模板的时候会获取数据，获取数据会触发当前数据的get方法\n      // get触发的时候，会把当前的组件更新方法，添加到dep中\n      // vue的更新操作是组件级别的\n      // 这里会有取值的操作，给这个属性增加一个dep，这个dep 要和刚才我放到全局变量的上的watcher 做一个对应关系\n      // 添加观察者\n      // 当前数据被哪个组件使用到了，当前组件的更新方法添加到观察者\n      if (dep.target) {\n        dep.depend(); // 让这个dep 去收集watcher\n      }\n      return value\n    },\n    set(newvalue) {\n      // 修改数据的时候会触发，初始化数据的时候，不会触发set\n      if (newvalue == value) return; // 如果新值和老值一样，就不用更新了\n      observe(newvalue); // 监控当前设置的值，有可能用户给了一个新值，用户设置的最新的值\n      value = newvalue;\n      // 当我们更新数据后 要把当前自己对应的watcher 去重新执行以下.\n      // 手机进去的依赖进行更新\n      dep.notify(); // 更新数据的时候，把get方法中收集的watcher全部执行一遍\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 编译模板的步骤 ast\n\ninitmixin给给构造函数的原型上添加方法，添加_init和this指向initmixin赋值给vm\n\nvm获取用户传入的参数\n\n使用vue.prototypr.$mount函数，获取到vm的实例化对象，然后获取到el的属性\n\n  vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.queryselector(el); // 获取el属性\n// 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\nconst opts = vm.$options; // 获取用户传入的所有参数\n\n\n1\n2\n3\n4\n5\n\n\n获取到用户传入的参数，进行判断有没有render方法\n\n    if (!opts.render) { // 没有render函数\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerhtml; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compiletofunctions(template); // div v-if v-show {{  }}\n      // compiletofunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果调用的时候没有render函数，就会去获取模板，首先获取外部模板，编译程div的格式，这个时候的div格式是字符串类型\n\n      const render = compiletofunctions(template); // div v-if v-show {{  }}\n\n\n1\n\n\n如果调用的时候有render函数，直接走编译\n\n  vue.prototype.$mount = function (el) { // 可能是字符串 也可以传入一个dom对象 #app\n    const vm = this;\n    el = vm.$el = document.queryselector(el); // 获取el属性\n\n    // 如果同时传入 template 和render  默认会采用render 抛弃template，如果都没传就使用id=\"app\"中的模板\n    const opts = vm.$options; // 获取用户传入的所有参数\n\n    if (!opts.render) { // 没有render方法\n      let template = opts.template; // 获取模板\n      if (!template && el) { // 应该使用外部的模板\n        template = el.outerhtml; // 获取外部模板\n        console.log(template) // <div id=\"app\"><p>hello</p></div>\n      }\n\n      const render = compiletofunctions(template); // div v-if v-show {{  }}\n      // compiletofunctions => render函数  相当于把template模板编译成了render函数，这个函数一致性就会返回当前组件的虚拟dom\n      opts.render = render; // render函数执行返回一个当前组件的虚拟dom结构\n    }\n    // 走到这里说明不需要编译了 ，因为用户传入的就是 一个render函数\n    mountcomponent(vm, el); // 组件的挂载流程\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n1，parsehtml编译出来ast语法树（静态节点编译优化）【进行正则匹配】\n\n  let ast = parsehtml(template); // '<div></div>'进行页面编译，把字符串编译成ast语法树\n\n\n1\n\n\n创建ast树，进行正则的匹配\n\n//              字母a-za-z_ - . 数组小写字母 大写字母\nconst ncname = `[a-za-z_][\\\\-\\\\.0-9_a-za-z]*`; // 标签名\n// ?:匹配不捕获   <aaa:aaa>\nconst qnamecapture = `((?:${ncname}\\\\:)?${ncname})`;\n// starttagopen 可以匹配到开始标签 正则捕获到的内容是 (标签名)\nconst starttagopen = new regexp(`^<${qnamecapture}`); // 标签开头的正则 捕获的内容是标签名\n// 闭合标签 </xxxxxxx>\nconst endtag = new regexp(`^<\\\\/${qnamecapture}[^>]*>`); // 匹配标签结尾的 </div>\n// <div aa   =   \"123\"  bb=123  cc='123'\n// 捕获到的是 属性名 和 属性值 arguments[1] || arguments[2] || arguments[2]\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// <div >   <br/>\nconst starttagclose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n// 匹配动态变量的  +? 尽可能少匹配\nconst defaulttagre = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\n\nexport function parsehtml(html) {\n  // ast 树 表示html的语法\n  let root; // 树根\n  let currentparent; // 标识当前父亲是谁\n  let stack = []; // 用来判断标签是否正常闭合  [div]  解析器可以借助栈型结构\n  // <div id=\"app\" style=\"color:red\"><span>    helloworld {{msg}}   </span></div>\n\n  // vue2.0 只能有一个根节点 必须是html 元素\n\n  // 常见数据结构 栈 队列 数组 链表 集合 hash表 树\n  function createastelement(tagname, attrs) { // 产生ast元素的\n    return { // ast语法树 用对象来描述原生语法\n      tag: tagname, // 标签名\n      attrs,  // 属性\n      children: [], // 子元素\n      parent: null, // 父亲是谁\n      type: 1 // 1 普通元素  3 文本\n    }\n  }\n\n  // console.log(html)\n  function start(tagname, attrs) { // 开始标签 每次解析开始标签 都会执行此方法\n    let element = createastelement(tagname, attrs);\n    if (!root) {\n      root = element; // 只有第一次是根\n    }\n    currentparent = element; // 标识当前父亲是谁\n    stack.push(element); // 将开始标签存放到栈中\n  }\n\n  // <div> <span></span> hello world</div>   [div,span]\n  function end(tagname) { // 结束标签  确立父子关系\n    let element = stack.pop(); // 取出栈中的最后一个\n    currentparent = stack[stack.length - 1]; // 取出当前的父亲是谁\n    if (currentparent) { // 在闭合时可以知道这个标签的父亲是谁\n      element.parent = currentparent; // 在闭合时可以知道这个标签的父亲是谁\n      currentparent.children.push(element); // 实现了一个树的父子关系\n    }\n  }\n\n  function chars(text) { // 文本\n    text = text.replace(/\\s/g, ''); // 去掉空格\n    if (text) { // 如果是空字符串 不处理\n      currentparent.children.push({ // 将文本放到当前父亲的children中\n        type: 3, // 文本类型\n        text // 文本内容\n      })\n    }\n  }\n\n  // 根据 html 解析成树结构  </span></div>\n  while (html) { // 只要html不为空字符串 就一直解析\n    let textend = html.indexof('<'); // 查找<的位置\n    if (textend == 0) { // 如果当前索引为0 说明是一个标签 开始标签或者结束标签\n      const starttagematch = parsestarttag(); // 通过这个方法获取到匹配的结果 tagname,attrs\n\n      if (starttagematch) {\n        // 开始标签\n        start(starttagematch.tagname, starttagematch.attrs) // 开始标签的处理\n      }\n      const endtagmatch = html.match(endtag); // 匹配结束标签\n\n      if (endtagmatch) {\n        advance(endtagmatch[0].length); // 删除结束标签\n        end(endtagmatch[1]) // 将结束标签传入\n      }\n      // 结束标签\n    }\n\n    // 如果不是0 说明是文本\n    let text; // 文本\n    if (textend > 0) {\n      text = html.substring(0, textend); // 是文本就把文本内容进行截取\n      chars(text); // 将文本进行处理\n    }\n    if (text) {\n      advance(text.length); // 删除文本内容\n    }\n  }\n\n  function advance(n) {\n    html = html.substring(n); // 删除指定的内容\n  }\n\n  function parsestarttag() {\n    const start = html.match(starttagopen); // 匹配开始标签\n    if (start) {\n      const match = {\n        tagname: start[1], // 匹配到的标签名\n        attrs: [] // 匹配到的属性\n      }\n      advance(start[0].length);\n      let end, attr;\n      while (!(end = html.match(starttagclose)) && (attr = html.match(attribute))) { // 只要不是结尾标签 并且能匹配到属性 就一直解析\n        advance(attr[0].length); // 删除属性\n        match.attrs.push({name: attr[1], value: attr[3] || attr[4] || attr[5]}) // 将属性放到match的attrs中\n      }\n\n      if (end) {\n        advance(end[0].length); // 删除开始标签结束的 >\n        return match; // 返回匹配的结果\n      }\n    }\n  }\n\n  return root;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n\n\n将ast进行优化\n\n优化的目标：生成模板ast，检测不需要进行dom改变的静态子树，一定那检测到这些静态树，我们就能做以下这些事情\n\n（1）把他们变成常熟，这样我们就再也不需要每次重新渲染时创建新的节点了\n\n（2）在patch的过程中直接进行跳过\n\n2，generate编译出可执行的函数字符串【遍历语法树，进行字符串的拼接】\n\n3，使用with包裹【拼接字符串】，拼接字符串的时候会为变量添加this指向，这样模板使用data中的数据的时候，就不用写this了\n\n4，new function把字符串变成可执行函数\n\n如果走到最后，说不需要进行编译了，用户传入的就是一个render函数，直接给函数vm实例和el进行挂载\n\n使用mountcomponent，进行callhook函数调用\n\n调用mountcomponent函数进行新旧dom的对比，使用watcher进行页面的更新\n\n\n# 虚拟dom进行对比\n\ncallhook挂载前获取vm实例和beforemount钩子，然后开始编译\n\n在updatacomponent函数中进行新旧dom的对比，调用render方法后返回的时虚拟dom\n\n每次数据发生变化，旧执行update方法 new watcher进行页面的更新\n\n创建watcher的实例化对象，所以watcher时更新数据的方法\n\n\n# 观察者模式\n\n使用object.defineproperty对对象数据进行拦截，判断是否有__ob__的属性，如果没有__ob__的情况下，会添加一个__ob__，然后添加不可枚举和不可修改的属性。\n\n进行判断data是不是数组类型，如果是数组类型的情况下，vue进行函数劫持，然后重写数组的原型方法，如果说劫持的是数组就改变数组的七种方法，如果说劫持的是对象就改变对象的方法。\n\n如果值是一个对象的话definereactive，就继续递归循环检测，如果说是基本类型的话，就不用进行递归。传入对象就进行递归的循环检测，给每一个数据添加一个dep，收集依赖的容器，用来收集watcher。声明一个new dep，进行赋值。【开启观察者模式】get进行依赖的watcher的收集，set触发依赖，触发watcher中的run方法以及进行数据的更新。\n\nget获取数据的时候会触发，初始化数据的时候，不会触发get。编译模板的时候会获取数据，获取数据会触发当前的数据的get方法，get触发的时候会把当前组件进行更新，添加到dep中，vue的更新操作是组件级别的，这个会有一个取值的操作，给这个属性添加一个dep要和全局变量的watcher做出一个对应关系。\n\n下一步，把watcher储存到deo中\n\ndep和watcher是典型的观察者模式，dep是目标（有一个subs），watcher是观察者，把watcehr储存到sunes里面，对数据进行观测，当目标数据方法变化的时候，通知所有的观察者，观察者执行对应的方法，更新视图。更新视图的方法是调用notify，进行修改，触发set方法。\n\n为什么让watcher储存到dep中？因为watcher是组件级别的，dep是全局唯一的，所以让watcher进行dep储存，储存之后进行模板编译\n\n\n# 观察者模式进行数据更新\n\n触发set方法，然后触发dep.notify()方法，notify中有一个subs数组，存的是需要更新的watcher，然后watcher中调用updata函数触发然后queuewatcher函数，将watcher进行修改，进行页面视图的更新处理\n\n首先要知道一个概念，vue是组件化更新页面的，vue一个组件中有多个属性，会产生多个watcher，但是这些watcher的id是相同的。【vue中不同的组件的watcher id是不相同的，但是同一个组件的watcher id是相同的】\n\n数据更新步骤\n\n第一步：首先给watcher储存到一个队列当中【等待多个组件一起储存，一起更新】\n\n第二步：页面同步更新的时候，当前watcher.id已经存在了，不需要再次进行储存，这样，页面的同步更新和异步更新都会进行更新操作\n\n第二部：等待更新，清空队列，一直执行watcher的set方法，set方法会触发dep.notify（），dep.notify（）会触发watcher的updata方法\n\n第四步：执行watcher的run方法，调用get方法，重新进行页面的渲染\n\n\n# nexttick页面的异步的更新\n\nnexttick，想要获取最新的页面dom结构的时候需要使用到nexttick\n\n当修改完数据以后，会触发当前数据的set方法，通知当前数据在get阶段收集到的所有依赖【watcher】进行更新，更新不是同步更新的，而是通过nexttick注册异步任务进行更新，所以修改完数据以后想要立即获取最新的页面结构是获取不到的。\n\n这个时候我们可以使用nexttick继续注册一个异步任务\n\n同步代码走完，开始清空异步任务\n\nnexttick的异步任务类型是根据宿主环境进行判断promise,mutationobserver,setimmediate,settimeout。\n\n场景：行内编辑的时候，自动获取焦点\n\n修改完数据之后，会触发set方法，通知set阶段收集watcher触发updata方法，将watcher储存到更新队列中，使用nexttick中的定时器进行异步更新，进行队列的清空，一次执行watcher的run方法，调用get方法，重新进行渲染。也就是当数据进行修改的时候，为什么需要nexttick进行异步操作才能拿到数据？当data中的数据初始化的时候，劫持这个数据，使用get和set方法，触发数据的get方法，页面进行渲染，数据初始化完成之后，编译模板，将模板中的数据和页面进行绑定。get只要触发了，当前组件更新watcher就会被收集到dep里面【观察者模式】\n\n如果我们修改了data里面的数据，会触发set方法，set方法触发dep.notify()，depnotify()会触发watcher的updata方法。就把收集到所有的依赖【更新watcher】，通过nexttick进行异步更新，清空队列，一次执行watcher的run方法，调用get方法，重新进行页面的渲染。\n\nnexttick的异步根据宿主环境进行何种异步的更新判断。promise，mutationobserver,setimmediate,settimeout.\n\n\n# 步骤详解\n\nnew vue之后传入一个_init方法，使用initmixin（vue），把_init方法挂载到vue的原型上\n\ninitmixin(vue); // 添加原型的方法\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:33:08",lastUpdatedTimestamp:1682357588e3},{title:"Vue2 Diff 算法",frontmatter:{title:"Vue2 Diff 算法",date:"2022-01-23T14:48:41.000Z",permalink:"/pages/e1d719/",categories:["更多","技术面"],tags:["Vue","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"},readingShow:"top"},regularPath:"/55.%E6%9B%B4%E5%A4%9A/05.%E6%8A%80%E6%9C%AF%E9%9D%A2/09.Vue2%20Diff%20%E7%AE%97%E6%B3%95.html",relativePath:"55.更多/05.技术面/09.Vue2 Diff 算法.md",key:"v-82f6dcc4",path:"/pages/e1d719/",headers:[{level:2,title:"写在前面",slug:"写在前面",normalizedTitle:"写在前面",charIndex:14},{level:2,title:"为什么要用 Diff 算法",slug:"为什么要用-diff-算法",normalizedTitle:"为什么要用 diff 算法",charIndex:460},{level:3,title:"虚拟 DOM",slug:"虚拟-dom",normalizedTitle:"虚拟 dom",charIndex:478},{level:3,title:"最小量更新",slug:"最小量更新",normalizedTitle:"最小量更新",charIndex:644},{level:2,title:"页面更新流程",slug:"页面更新流程",normalizedTitle:"页面更新流程",charIndex:957},{level:2,title:"Diff 算法简单介绍",slug:"diff-算法简单介绍",normalizedTitle:"diff 算法简单介绍",charIndex:1462},{level:3,title:"Diff 算法的前提",slug:"diff-算法的前提",normalizedTitle:"diff 算法的前提",charIndex:1654},{level:2,title:"patchVnode 函数",slug:"patchvnode-函数",normalizedTitle:"patchvnode 函数",charIndex:2799},{level:2,title:"updateChildren 函数",slug:"updatechildren-函数",normalizedTitle:"updatechildren 函数",charIndex:5445},{level:2,title:"v-for 中为什么要加 key",slug:"v-for-中为什么要加-key",normalizedTitle:"v-for 中为什么要加 key",charIndex:9549},{level:2,title:"证明 key 的性能",slug:"证明-key-的性能",normalizedTitle:"证明 key 的性能",charIndex:9842},{level:2,title:"实验代码",slug:"实验代码",normalizedTitle:"实验代码",charIndex:9916},{level:3,title:"增加实验",slug:"增加实验",normalizedTitle:"增加实验",charIndex:11915},{level:4,title:"在队尾增加",slug:"在队尾增加",normalizedTitle:"在队尾增加",charIndex:11966},{level:4,title:"在队内增加",slug:"在队内增加",normalizedTitle:"在队内增加",charIndex:11977},{level:4,title:"在队首增加",slug:"在队首增加",normalizedTitle:"在队首增加",charIndex:11988},{level:3,title:"删除实验",slug:"删除实验",normalizedTitle:"删除实验",charIndex:12e3},{level:4,title:"在队尾删除",slug:"在队尾删除",normalizedTitle:"在队尾删除",charIndex:12008},{level:4,title:"在队内删除",slug:"在队内删除",normalizedTitle:"在队内删除",charIndex:12019},{level:4,title:"在队首删除",slug:"在队首删除",normalizedTitle:"在队首删除",charIndex:12030},{level:3,title:"实验结论",slug:"实验结论",normalizedTitle:"实验结论",charIndex:12042},{level:4,title:"增加实验",slug:"增加实验-2",normalizedTitle:"增加实验",charIndex:11915},{level:4,title:"删除实验",slug:"删除实验-2",normalizedTitle:"删除实验",charIndex:12e3},{level:2,title:"写在最后",slug:"写在最后",normalizedTitle:"写在最后",charIndex:12573},{level:2,title:"源码函数附录",slug:"源码函数附录",normalizedTitle:"源码函数附录",charIndex:12667}],headersStr:"写在前面 为什么要用 Diff 算法 虚拟 DOM 最小量更新 页面更新流程 Diff 算法简单介绍 Diff 算法的前提 patchVnode 函数 updateChildren 函数 v-for 中为什么要加 key 证明 key 的性能 实验代码 增加实验 在队尾增加 在队内增加 在队首增加 删除实验 在队尾删除 在队内删除 在队首删除 实验结论 增加实验 删除实验 写在最后 源码函数附录",content:'# Diff 算法\n\n\n# 写在前面\n\n因为之前看面试直播也经常问到 Diff 算法，然后作者本人用 Vue2 比较多，所以打算研究一下 Vue2 的 Diff 算法，其实很早就想学的，但是可能因为感觉 Diff 算法比较深奥，就一直拖着没学，但是最近在准备面试，就想着迟早都要学的，趁这个机会把 Diff 算法搞懂吧 🧐，作者就花了一天的时间研究了一下，可能没有完全理解 Diff 算法的精髓，请各位见谅。\n\n> 💡 这个其实算作者的学习笔记，而且作者水平有限，改文章仅代表作者个人观点，如果有错误可以评论区指出来，会不断完善；同时本文很长，所以请读者们有耐心的看完，看完后作者相信你们会对 Diff 算法有更深的了解。本人觉得本文比目前网上讲解 Diff 算法的大部分文章要更好，因为本文从问题出发，教会大家如何思考，而不是直接从答案出发，就像读答案一样，这样感觉没什么意思，本文一步一步的引导大家去感受 Diff 算法的精妙，同时最后也做了一下小实验，让大家对 Diff 算法有更加直观的感受 🎉。\n\n\n# 为什么要用 Diff 算法\n\n\n# 虚拟 DOM\n\n因为 Vue2 底层是用虚拟 DOM 来表示页面结构的，虚拟 DOM其实就是一个对象，如果想知道怎么生成的，其实大概流程就是：\n\n * 首先解析模板字符串，也就是 .vue 文件\n * 然后转换成 AST 语法树\n * 接着生成 render 函数\n * 最后调用 render 函数，就能生成虚拟 DOM\n\n\n# 最小量更新\n\n其实框架为了性能才使用的虚拟 DOM，因为 js 生成 DOM 然后展示页面是很消耗性能的，如果每一次的更新都把整个页面重新生成一遍那体验肯定不好，所以需要找到两个页面中变化的地方，然后只要把变化的地方用 js 更新 (可能是增加、删除或者更新) 一下就行了，也就是最小量更新。 那么怎么实现最小量更新呢？那么就要用 Diff 算法了，那么 Diff 算法对比的到底是什么呢？可能这是刚学 Diff 算法比较容易误解的地方，其实比对的是新旧虚拟 DOM，所以 Diff 算法就是找不同，找到两次虚拟 DOM 的不同之处，然后将不同反应到页面上，这就实现了最小量更新，如果只更新变化的地方那性能肯定更好。\n\n\n# 页面更新流程\n\n其实这个比较难解释，作者也就大致说一下，学了 Vue 的都知道这个框架的特点之一就有数据响应式，什么是响应式，也就是数据更新页面也更新，那么页面是怎么知道自己要更新了呢？其实这就是这个框架比较高明的地方了，大致流程如下：\n\n * 之前也说了会运行 render 函数，那么运行 render 函数的时候会被数据劫持，也就是进入 Object.defineProperty 的 get，那么在这里收集依赖，那么是谁收集依赖呢？是每个组件，每个组件就是一个 Watcher，会记录这个组件内的所有变量 (也就是依赖)，当然每个依赖 (Dep) 也会收集自己所在组件的 Watcher；\n * 然后当页面中的数据发生变化，那么就会出发 Object.defineProperty 的 set，在这个函数里面数据就会通知每个 Watcher 更新页面，然后每个页面就会调用更新方法，这个方法就是 patch；\n * 接着，就要找到两个页面之间的变化量，那么就要用到 Diff 算法了\n * 最后找到变化量后就可以进行更新页面了\n\n> 其实是边找边更新的，为了让大家理解容易就将这两个部分分开了\n\n\n# Diff 算法简单介绍\n\n面试问到 Diff 算法是什么，大家肯定会说两句，比如 头头、尾尾、尾头、头尾、深度优先遍历(dfs)、同层比较 类似这些话语，虽然能说一两句其实也是浅尝辄止。 其实作者看了 CSDN 上发的关于 Diff 算法的文章，就是阅读量很高的文章，作者觉得他也没讲明白，可能他自己没明白，或者自己明白了但是没讲清楚，那么作者会用自己的感悟和大家分享一下。\n\n\n# Diff 算法的前提\n\n为了让大家能够了解清楚，这里先说明一下函数调用流程：\n\n * patch\n * patchVnode\n * updateChildren\n\nDiff 算法的 前提 这个是很重要的，可能大家会问什么是前提？不就是之前说的那些比较嘛？说的没错但也不对，因为 Diff 算法到达之前说的 头头、尾尾、尾头、头尾 这一步的前提就是两次对比的节点是 相同的，这里的相同不是大家想的完全相同，只是符合某些条件就是相同了，为了简化说明，文章就只考虑一个标签只包含 key 和 标签名(tag)，那么之前说的相同就是 key 相同以及 tag 相同，为了证明作者的说法是有点正确的，那么这里也贴上源码：\n\n// https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts\n// 36行\nfunction sameVnode(a, b) {\n  return (\n    a.key === b.key &&\n    a.asyncFactory === b.asyncFactory &&\n    ((a.tag === b.tag &&\n      a.isComment === b.isComment &&\n      isDef(a.data) === isDef(b.data) &&\n      sameInputType(a, b)) ||\n      (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error)))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果怕乱了，下面的可以省略不看也没事不影响整体了解，下面只是为了考虑所有情况才加的一个判断： 那么如果两个虚拟 DOM 不相同其实就不用继续比较了，而且如果相同也不用比较了，这里的相同是真的完全相同，也就是两个虚拟 DOM 的地址是一样的，那么也贴上源码：\n\nfunction patchVnode(......) {\n  if (oldVnode === vnode) {\n    return\n  }\n  ......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n到目前为止大家可能会比较乱，现在总结一下：\n\n * 在 patch 函数里比较的是新老虚拟 DOM 是否是 key 相同以及 tag 相同，如果不相同那么就直接替换，如果相同用 patchVnode\n\n说了这么多，其实作者也就想表达一个观点，就是只有当两次比较的虚拟 DOM 是 相同的 才会考虑 Diff 算法，如果不符合那直接把原来的删除，替换新的 DOM 就行了。\n\n\n# patchVnode 函数\n\n这个函数里的才是真正意义上的 Diff 算法，那么接下来会结合源码向大家介绍一下。\n\n> 源码中核心代码在 patch.ts 的 638 行至 655 行。\n\n其实，目前介绍 patchVnode 的都是直接对着源码来介绍的，但是大家可能不清楚为啥要这么分类，那么作者在这里就让大家明白为什么这么分类，首先在这里说一个结论：\n\n * 就是 text 属性和 children 属性不可能同时存在，这个需要大家看模板解析源码部分\n\n那么在对比新旧节点的情况下，主要比较的就是是否存在 text 和 children 的情况，那么会有如下九种情况\n\n情况   老节点 TEXT   老节点 CHILDREN   新节点 TEXT   新节点 CHILDREN\n1    ❎          ❎              ❎          ❎\n2    ❎          ✅              ❎          ❎\n3    ✅          ❎              ❎          ❎\n4    ❎          ❎              ❎          ✅\n5    ❎          ✅              ❎          ✅\n6    ✅          ❎              ❎          ✅\n7    ❎          ❎              ✅          ❎\n8    ❎          ✅              ✅          ❎\n9    ✅          ❎              ✅          ❎\n\n按照上面的表格，因为如果新节点有文本节点，其实老节点不管是什么都会被替换掉，那么就可以按照 新节点 text 是否存在来分类，其实 Vue 源码也是这么来分类的：\n\nif (isUndef(vnode.text)) {\n  // 新虚拟 DOM 有子节点\n} else if (oldVnode.text !== vnode.text) {\n  // 如果新虚拟 DOM 是文本节点，直接用 textContent 替换掉\n  nodeOps.setTextContent(elm, vnode.text)\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么如果有子节点的话，那应该怎么分类呢？我们可以按照每种情况需要做什么来进行分类，比如说：\n\n * 第一种情况，我们啥都不用做，因此也可以不用考虑\n * 第二种情况，我们应该把原来 DOM 的 textContent 设置为 \'\'\n * 第三种情况，我们也应该把原来 DOM 的 textContent 设置为 \'\'\n * 第四种情况，我们应该加入新的子节点\n * 第五种情况，这个情况比较复杂，需要对比新老子节点的不同\n * 第六种情况，我们应该把原来的 textContent 设置为 \'\' 后再加入新的子节点\n\n那么通过以上六种情况 (新虚拟 DOM 不含有 text，也就是不是文本节点的情况)，我们可以很容易地进行归类：\n\n * 分类 1️⃣： 第二种情况 和 第三种情况。进行的是操作是：把原来 DOM 的 textContent 设置为 \'\'\n * 分类 2️⃣： 第四种情况 和 第六种情况。进行的是操作是：如果老虚拟 DOM 有 text，就置空，然后加入新的子节点\n * 分类 3️⃣：第五种情况。进行的是操作是：需要进行精细比较，即对比新老子节点的不同\n\n其实源码也是这么来进行分类的，而且之前说的 同层比较 也就得出来了，因为每次比较都是比较的同一个父节点每一个子元素 (这里的子元素包括文本节点和子节点) 是否相同，而 深度优先遍历(dfs) 是因为每次比较中，如果该节点有子节点 (这里的子节点指的是有 children 属性，而不包括文本节点) 的话需要进行递归遍历，知道最后到文本节点结束。\n\n> ⭕️ 这里需要搞清楚子节点和子元素的区别和联系\n\n然后我们来看看源码是怎么写吧，只看新虚拟 DOM 不含有 text，也就是不是文本节点的情况：\n\nif (isUndef(vnode.text)) {\n  if (isDef(oldCh) && isDef(ch)) {\n    if (oldCh !== ch)\n      // 递归处理，精细比较\n      // 对应分类 3️⃣\n      updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n  } else if (isDef(ch)) {\n    if (__DEV__) {\n      checkDuplicateKeys(ch) // 可以忽略不看\n    }\n    // 对应分类 2️⃣\n    if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \'\')\n    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n  } else if (isDef(oldCh)) {\n  \t// 对应分类 1️⃣\n    removeVnodes(oldCh, 0, oldCh.length - 1)\n  } else if (isDef(oldVnode.text)) {\n  \t// 对应分类 1️⃣\n    nodeOps.setTextContent(elm, \'\')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n❓我们可以看到源码把分类 1️⃣ 拆开来了，这是因为如果老虚拟 DOM 有子节，那么可能绑定了一些函数，需要进行解绑等一系列操作，作者也没自信看，大致瞄了一眼，但是如果我们要求不高，如果只是想自己手动实现 Diff 算法，那么没有拆开的必要。\n\n作者觉得这么讲可能比网上其他介绍 Diff 算法的要好，其他的可能直接给你说源码是怎么写的，可能没有说明白为啥这么写，但是通过之前这么分析讲解后可能你对为什么这么写会有更深的理解和帮助吧。\n\n\n# updateChildren 函数\n\n> 同层比较\n\n因为当都含有子节点，即都包含 children 属性后，需要精细比较不同，不能像之前那些情况一样进行简单处理就可以了 那么这个函数中就会介绍大家经常说的 头头、尾尾、尾头、头尾 比较了，其实这不是 Vue 提出来的，是很早就提出来的算法，就一直沿用至今，大家可以参考【snabbdom 库】\n\n🌟 在这之前我们要定义四个指针 newStartIdx、newEndIdx、oldStartIdx 和 oldEndIdx，分别指向 新头节点、新尾节点、旧头节点 与 旧尾节点\n\n循环条件如下：\n\nwhile(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n  ......\n}\n\n\n1\n2\n3\n\n\n其实这个比较也就是按人类的习惯来进行比较的，比较顺序如下 ：\n\n * 1️⃣ 新头节点与旧头节点：++newStartIdx 和 ++oldStartIdx\n\n * 2️⃣ 新尾节点与旧尾节点：--newEndIdx 和 --oldEndIdx\n\n * 3️⃣ 新尾节点与旧头节点：需要将 旧头节点 移动到 旧尾节点之前，为什么要这么做，讲起来比较复杂，记住就好，然后 --newEndIdx 和 ++oldStartIdx\n\n * 4️⃣ 新头节点与旧尾节点：需要将 旧尾节点 移动到 旧头节点之前，为什么要这么做，讲起来比较复杂，记住就好，然后 ++newStartIdx 和 --oldEndIdx\n\n * 5️⃣ 如果都没有匹配的话，就把新头节点在旧节点列表(也就是 children 属性的值) 中进行查找，查找方式按照如下：\n   \n   * 如果有 key 就把 key 在 oldKeyToIdx 进行匹配，oldKeyToIdx 根据旧节点列表中元素的 key 生成对应的下标\n   * 如果没有，就按顺序遍历旧节点列表找到该节点所在的下标\n   * 如果在旧节点列表是否找到也分为两种情况：\n     * 找到了，那么只要将 新头节点 添加到 旧头节点 之前即可\n     * 没找到，那么需要创建新的元素然后添加到 旧头节点 之前\n     * 然后把这个节点设置为 undefined\n\n根据循环条件我们可以得到两种剩余情况，如下：\n\n * 6️⃣ 如果 oldStartIdx > oldEndIdx 说明老节点先遍历完成，那么新节点比老节点多，就要把 newStartIdx 与 newEndIdx 之间的元素添加\n * 7️⃣ 如果 newStartIdx > newEndIdx 说明新节点先遍历完成，那么老节点比新节点多，就要把 oldStartIdx 与 oldEndIdx 之间的元素删除\n\n其实我们上面还没有考虑如果节点为 undefined 的情况，因为在上面也提到过，如果四种都不匹配后会将该节点置为 undefined，也只有旧节点列表中才有，因此要在开头考虑这两种情况：\n\n * 8️⃣ 当 oldStartVnode 为 undefined：++oldStartIdx\n * 9️⃣ 当 oldEndVnode 为 undefined：--oldEndIdx\n\n那么我们来看源码怎么写的吧，其中用到的函数可以查看源码附录：\n\n// https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts\n// 439 行至 556 行\nwhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n  if (isUndef(oldStartVnode)) {\n  \t// 情况 8️⃣\n    oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left\n  } else if (isUndef(oldEndVnode)) {\n  \t// 情况 9️⃣\n    oldEndVnode = oldCh[--oldEndIdx]\n  } else if (sameVnode(oldStartVnode, newStartVnode)) {\n  \t// 情况 1️⃣\n    patchVnode(...)\n    oldStartVnode = oldCh[++oldStartIdx]\n    newStartVnode = newCh[++newStartIdx]\n  } else if (sameVnode(oldEndVnode, newEndVnode)) {\n  \t// 情况 2️⃣\n    patchVnode(...)\n    oldEndVnode = oldCh[--oldEndIdx]\n    newEndVnode = newCh[--newEndIdx]\n  } else if (sameVnode(oldStartVnode, newEndVnode)) {\n    // Vnode moved right\n    // 情况 3️⃣\n    patchVnode(...)\n    canMove &&\n      nodeOps.insertBefore(\n        parentElm,\n        oldStartVnode.elm,\n        nodeOps.nextSibling(oldEndVnode.elm)\n      )\n    oldStartVnode = oldCh[++oldStartIdx]\n    newEndVnode = newCh[--newEndIdx]\n  } else if (sameVnode(oldEndVnode, newStartVnode)) {\n    // Vnode moved left\n    // 情况 4️⃣\n    patchVnode(...)\n    canMove &&\n      nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n    oldEndVnode = oldCh[--oldEndIdx]\n    newStartVnode = newCh[++newStartIdx]\n  } else {\n  \t// 情况 5️⃣\n    if (isUndef(oldKeyToIdx)) // 创建 key -> index 的 Map\n      oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) \n    // 找到 新头节点 的下标\n    idxInOld = isDef(newStartVnode.key)\n      ? oldKeyToIdx[newStartVnode.key]\n      : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)\n    if (isUndef(idxInOld)) {\n      // New element\n      // 如果没找到\n      createElm(...)\n    } else {\n      // 如果找到了\n      vnodeToMove = oldCh[idxInOld]\n      if (sameVnode(vnodeToMove, newStartVnode)) {\n        patchVnode(...)\n        oldCh[idxInOld] = undefined\n        canMove &&\n          nodeOps.insertBefore(\n            parentElm,\n            vnodeToMove.elm,\n            oldStartVnode.elm\n          )\n      } else {\n        // same key but different element. treat as new element\n        createElm(...)\n      }\n    }\n    newStartVnode = newCh[++newStartIdx]\n  }\n}\nif (oldStartIdx > oldEndIdx) {\n  // 情况 6️⃣\n  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm\n  addVnodes(...)\n} else if (newStartIdx > newEndIdx) {\n  // 情况 7️⃣\n  removeVnodes(...)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n> 如果问为什么这么比较，回答就是经过很多人很多年的讨论得出的，其实只要记住过程就行了，如果想要更深了解 Diff 算法，可以去 B 站看【尚硅谷】Vue源码解析之虚拟DOM和diff算法\n\n\n# v-for 中为什么要加 key\n\n这个问题面试很常见，但是可能大部分人也就只会背八股，没有完全理解，那么经过以上的介绍，我们可以得到自己的理解：\n\n * 首先，如果不加 key 的话，那么就不会去 Map 里匹配 (O(1))，而是循环遍历整个列表 (O(n))，肯定加 key 要快一点，性能更高\n * 其次，如果不加 key 那么在插入或删除的时候就会出现，原本不是同一个节点的元素被认为是相同节点，上面也有说过是 sameVnode 函数判断的，因此可能会有额外 DOM 操作\n\n> 为什么说可能有额外 DOM 操作呢？这个和插入的地方有关，之后会讨论，同理删除也一样\n\n\n# 证明 key 的性能\n\n我们分为三个实验：没有 key、key 为 index、key 唯一，仅证明加了 key 可以进行最小化更新操作。\n\n\n# 实验代码\n\n有小伙伴评论说可以把代码贴上这样更好，那么作者就把代码附上 🥳：\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"><\/script>\n  <style>\n    .box {\n      display: flex;\n      flex-direction: row;\n    }\n    .item {\n      flex: 1;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app">\n    <div class="box">\n      <div class="item">\n        <h3>没有 key</h3>\n        <p v-for="(item, index) in list">{{ item }}</p>\n      </div>\n      <div class="item">\n        <h3>key 为 index</h3>\n        <p v-for="(item, index) in list" :key="index">{{ item }}</p>\n      </div>\n      <div class="item">\n        <h3>key 唯一</h3>\n        <p v-for="(item, index) in list" :key="item">{{ item }}</p>\n      </div>\n    </div>\n    <button @click="click1">push(4)</button>\n    <button @click="click2">splice(1, 0, 666)</button>\n    <button @click="click3">unshift(999)</button>\n    <br /><br />\n    <button @click="click4">pop()</button>\n    <button @click="click5">splice(1, 1)</button>\n    <button @click="click6">shift()</button>\n  </div>\n  <script>\n    var app = new Vue({\n      el: \'#app\',\n      data: {\n        show: false,\n        list: [1, 2, 3],\n      },\n      methods: {\n        click1() {\n          this.list.push(4);\n        },\n        click2() {\n          this.list.splice(1, 0, 666);\n        },\n        click3() {\n          this.list.unshift(999);\n        },\n        click4() {\n          this.list.pop();\n        },\n        click5() {\n          this.list.splice(1, 1);\n        },\n        click6() {\n          this.list.shift();\n        }\n      },\n    })\n  <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 增加实验\n\n实验如下所示，我们首先更改原文字，然后点击按钮**「观察节点发生变化的个数」**：\n\n# 在队尾增加\n\n\n\n# 在队内增加\n\n\n\n# 在队首增加\n\n\n\n\n# 删除实验\n\n# 在队尾删除\n\n\n\n# 在队内删除\n\n\n\n# 在队首删除\n\n\n\n\n# 实验结论\n\n# 增加实验\n\n表格为每次实验中，每种情况的最小更新量，假设列表原来的长度为 n\n\n实验      没有 KEY      KEY 为 INDEX   KEY 唯一\n在队尾增加   1           1             1\n在队中增加   n - i + 1   n - i + 1     1\n在队首增加   n + 1       n + 1         1\n\n# 删除实验\n\n表格为每次实验中，每种情况的最小更新量，假设列表原来的长度为 n\n\n实验      没有 KEY   KEY 为 INDEX   KEY 唯一\n在队尾删除   1        1             1\n在队中删除   n - i    n - i         1\n在队首删除   n        n             1\n\n通过以上实验和表格可以得到加上 key 的性能和最小量更新的个数是最小的，虽然在 在队尾增加 和 在队尾删除 的最小更新量相同，但是之前也说了，如果没有 key 是要循环整个列表查找的，时间复杂度是 O(n)，而加了 key 的查找时间复杂度为 O(1)，因此总体来说加了 key 的性能要更好。\n\n\n# 写在最后\n\n本文从源码和实验的角度介绍了 Diff 算法，相信大家对 Diff 算法有了更深的了解了，如果有问题可私信交流或者评论区交流，如果大家喜欢的话可以点赞 ➕ 收藏 🌟\n\n\n# 源码函数附录\n\n> 列举一些源码中出现的简单函数\n\nsetTextContent\n\nfunction setTextContent(node: Node, text: string) {\n  node.textContent = text\n}\n\n\n1\n2\n3\n\n\nisUndef\n\nfunction isUndef(v: any): v is undefined | null {\n  return v === undefined || v === null\n}\n\n\n1\n2\n3\n\n\nisDef\n\nfunction isDef<T>(v: T): v is NonNullable<T> {\n  return v !== undefined && v !== null\n}\n\n\n1\n2\n3\n\n\ninsertBefore\n\nfunction insertBefore(\n  parentNode: Node,\n  newNode: Node,\n  referenceNode: Node\n) {\n  parentNode.insertBefore(newNode, referenceNode)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnextSibling\n\nfunction nextSibling(node: Node) {\n  return node.nextSibling\n}\n\n\n1\n2\n3\n\n\ncreateKeyToOldIdx\n\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  let i, key\n  const map = {}\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key\n    if (isDef(key)) map[key] = i\n  }\n  return map\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# diff 算法\n\n\n# 写在前面\n\n因为之前看面试直播也经常问到 diff 算法，然后作者本人用 vue2 比较多，所以打算研究一下 vue2 的 diff 算法，其实很早就想学的，但是可能因为感觉 diff 算法比较深奥，就一直拖着没学，但是最近在准备面试，就想着迟早都要学的，趁这个机会把 diff 算法搞懂吧 🧐，作者就花了一天的时间研究了一下，可能没有完全理解 diff 算法的精髓，请各位见谅。\n\n> 💡 这个其实算作者的学习笔记，而且作者水平有限，改文章仅代表作者个人观点，如果有错误可以评论区指出来，会不断完善；同时本文很长，所以请读者们有耐心的看完，看完后作者相信你们会对 diff 算法有更深的了解。本人觉得本文比目前网上讲解 diff 算法的大部分文章要更好，因为本文从问题出发，教会大家如何思考，而不是直接从答案出发，就像读答案一样，这样感觉没什么意思，本文一步一步的引导大家去感受 diff 算法的精妙，同时最后也做了一下小实验，让大家对 diff 算法有更加直观的感受 🎉。\n\n\n# 为什么要用 diff 算法\n\n\n# 虚拟 dom\n\n因为 vue2 底层是用虚拟 dom 来表示页面结构的，虚拟 dom其实就是一个对象，如果想知道怎么生成的，其实大概流程就是：\n\n * 首先解析模板字符串，也就是 .vue 文件\n * 然后转换成 ast 语法树\n * 接着生成 render 函数\n * 最后调用 render 函数，就能生成虚拟 dom\n\n\n# 最小量更新\n\n其实框架为了性能才使用的虚拟 dom，因为 js 生成 dom 然后展示页面是很消耗性能的，如果每一次的更新都把整个页面重新生成一遍那体验肯定不好，所以需要找到两个页面中变化的地方，然后只要把变化的地方用 js 更新 (可能是增加、删除或者更新) 一下就行了，也就是最小量更新。 那么怎么实现最小量更新呢？那么就要用 diff 算法了，那么 diff 算法对比的到底是什么呢？可能这是刚学 diff 算法比较容易误解的地方，其实比对的是新旧虚拟 dom，所以 diff 算法就是找不同，找到两次虚拟 dom 的不同之处，然后将不同反应到页面上，这就实现了最小量更新，如果只更新变化的地方那性能肯定更好。\n\n\n# 页面更新流程\n\n其实这个比较难解释，作者也就大致说一下，学了 vue 的都知道这个框架的特点之一就有数据响应式，什么是响应式，也就是数据更新页面也更新，那么页面是怎么知道自己要更新了呢？其实这就是这个框架比较高明的地方了，大致流程如下：\n\n * 之前也说了会运行 render 函数，那么运行 render 函数的时候会被数据劫持，也就是进入 object.defineproperty 的 get，那么在这里收集依赖，那么是谁收集依赖呢？是每个组件，每个组件就是一个 watcher，会记录这个组件内的所有变量 (也就是依赖)，当然每个依赖 (dep) 也会收集自己所在组件的 watcher；\n * 然后当页面中的数据发生变化，那么就会出发 object.defineproperty 的 set，在这个函数里面数据就会通知每个 watcher 更新页面，然后每个页面就会调用更新方法，这个方法就是 patch；\n * 接着，就要找到两个页面之间的变化量，那么就要用到 diff 算法了\n * 最后找到变化量后就可以进行更新页面了\n\n> 其实是边找边更新的，为了让大家理解容易就将这两个部分分开了\n\n\n# diff 算法简单介绍\n\n面试问到 diff 算法是什么，大家肯定会说两句，比如 头头、尾尾、尾头、头尾、深度优先遍历(dfs)、同层比较 类似这些话语，虽然能说一两句其实也是浅尝辄止。 其实作者看了 csdn 上发的关于 diff 算法的文章，就是阅读量很高的文章，作者觉得他也没讲明白，可能他自己没明白，或者自己明白了但是没讲清楚，那么作者会用自己的感悟和大家分享一下。\n\n\n# diff 算法的前提\n\n为了让大家能够了解清楚，这里先说明一下函数调用流程：\n\n * patch\n * patchvnode\n * updatechildren\n\ndiff 算法的 前提 这个是很重要的，可能大家会问什么是前提？不就是之前说的那些比较嘛？说的没错但也不对，因为 diff 算法到达之前说的 头头、尾尾、尾头、头尾 这一步的前提就是两次对比的节点是 相同的，这里的相同不是大家想的完全相同，只是符合某些条件就是相同了，为了简化说明，文章就只考虑一个标签只包含 key 和 标签名(tag)，那么之前说的相同就是 key 相同以及 tag 相同，为了证明作者的说法是有点正确的，那么这里也贴上源码：\n\n// https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts\n// 36行\nfunction samevnode(a, b) {\n  return (\n    a.key === b.key &&\n    a.asyncfactory === b.asyncfactory &&\n    ((a.tag === b.tag &&\n      a.iscomment === b.iscomment &&\n      isdef(a.data) === isdef(b.data) &&\n      sameinputtype(a, b)) ||\n      (istrue(a.isasyncplaceholder) && isundef(b.asyncfactory.error)))\n  )\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果怕乱了，下面的可以省略不看也没事不影响整体了解，下面只是为了考虑所有情况才加的一个判断： 那么如果两个虚拟 dom 不相同其实就不用继续比较了，而且如果相同也不用比较了，这里的相同是真的完全相同，也就是两个虚拟 dom 的地址是一样的，那么也贴上源码：\n\nfunction patchvnode(......) {\n  if (oldvnode === vnode) {\n    return\n  }\n  ......\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n到目前为止大家可能会比较乱，现在总结一下：\n\n * 在 patch 函数里比较的是新老虚拟 dom 是否是 key 相同以及 tag 相同，如果不相同那么就直接替换，如果相同用 patchvnode\n\n说了这么多，其实作者也就想表达一个观点，就是只有当两次比较的虚拟 dom 是 相同的 才会考虑 diff 算法，如果不符合那直接把原来的删除，替换新的 dom 就行了。\n\n\n# patchvnode 函数\n\n这个函数里的才是真正意义上的 diff 算法，那么接下来会结合源码向大家介绍一下。\n\n> 源码中核心代码在 patch.ts 的 638 行至 655 行。\n\n其实，目前介绍 patchvnode 的都是直接对着源码来介绍的，但是大家可能不清楚为啥要这么分类，那么作者在这里就让大家明白为什么这么分类，首先在这里说一个结论：\n\n * 就是 text 属性和 children 属性不可能同时存在，这个需要大家看模板解析源码部分\n\n那么在对比新旧节点的情况下，主要比较的就是是否存在 text 和 children 的情况，那么会有如下九种情况\n\n情况   老节点 text   老节点 children   新节点 text   新节点 children\n1    ❎          ❎              ❎          ❎\n2    ❎          ✅              ❎          ❎\n3    ✅          ❎              ❎          ❎\n4    ❎          ❎              ❎          ✅\n5    ❎          ✅              ❎          ✅\n6    ✅          ❎              ❎          ✅\n7    ❎          ❎              ✅          ❎\n8    ❎          ✅              ✅          ❎\n9    ✅          ❎              ✅          ❎\n\n按照上面的表格，因为如果新节点有文本节点，其实老节点不管是什么都会被替换掉，那么就可以按照 新节点 text 是否存在来分类，其实 vue 源码也是这么来分类的：\n\nif (isundef(vnode.text)) {\n  // 新虚拟 dom 有子节点\n} else if (oldvnode.text !== vnode.text) {\n  // 如果新虚拟 dom 是文本节点，直接用 textcontent 替换掉\n  nodeops.settextcontent(elm, vnode.text)\n}\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n那么如果有子节点的话，那应该怎么分类呢？我们可以按照每种情况需要做什么来进行分类，比如说：\n\n * 第一种情况，我们啥都不用做，因此也可以不用考虑\n * 第二种情况，我们应该把原来 dom 的 textcontent 设置为 \'\'\n * 第三种情况，我们也应该把原来 dom 的 textcontent 设置为 \'\'\n * 第四种情况，我们应该加入新的子节点\n * 第五种情况，这个情况比较复杂，需要对比新老子节点的不同\n * 第六种情况，我们应该把原来的 textcontent 设置为 \'\' 后再加入新的子节点\n\n那么通过以上六种情况 (新虚拟 dom 不含有 text，也就是不是文本节点的情况)，我们可以很容易地进行归类：\n\n * 分类 1️⃣： 第二种情况 和 第三种情况。进行的是操作是：把原来 dom 的 textcontent 设置为 \'\'\n * 分类 2️⃣： 第四种情况 和 第六种情况。进行的是操作是：如果老虚拟 dom 有 text，就置空，然后加入新的子节点\n * 分类 3️⃣：第五种情况。进行的是操作是：需要进行精细比较，即对比新老子节点的不同\n\n其实源码也是这么来进行分类的，而且之前说的 同层比较 也就得出来了，因为每次比较都是比较的同一个父节点每一个子元素 (这里的子元素包括文本节点和子节点) 是否相同，而 深度优先遍历(dfs) 是因为每次比较中，如果该节点有子节点 (这里的子节点指的是有 children 属性，而不包括文本节点) 的话需要进行递归遍历，知道最后到文本节点结束。\n\n> ⭕️ 这里需要搞清楚子节点和子元素的区别和联系\n\n然后我们来看看源码是怎么写吧，只看新虚拟 dom 不含有 text，也就是不是文本节点的情况：\n\nif (isundef(vnode.text)) {\n  if (isdef(oldch) && isdef(ch)) {\n    if (oldch !== ch)\n      // 递归处理，精细比较\n      // 对应分类 3️⃣\n      updatechildren(elm, oldch, ch, insertedvnodequeue, removeonly)\n  } else if (isdef(ch)) {\n    if (__dev__) {\n      checkduplicatekeys(ch) // 可以忽略不看\n    }\n    // 对应分类 2️⃣\n    if (isdef(oldvnode.text)) nodeops.settextcontent(elm, \'\')\n    addvnodes(elm, null, ch, 0, ch.length - 1, insertedvnodequeue)\n  } else if (isdef(oldch)) {\n  \t// 对应分类 1️⃣\n    removevnodes(oldch, 0, oldch.length - 1)\n  } else if (isdef(oldvnode.text)) {\n  \t// 对应分类 1️⃣\n    nodeops.settextcontent(elm, \'\')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n❓我们可以看到源码把分类 1️⃣ 拆开来了，这是因为如果老虚拟 dom 有子节，那么可能绑定了一些函数，需要进行解绑等一系列操作，作者也没自信看，大致瞄了一眼，但是如果我们要求不高，如果只是想自己手动实现 diff 算法，那么没有拆开的必要。\n\n作者觉得这么讲可能比网上其他介绍 diff 算法的要好，其他的可能直接给你说源码是怎么写的，可能没有说明白为啥这么写，但是通过之前这么分析讲解后可能你对为什么这么写会有更深的理解和帮助吧。\n\n\n# updatechildren 函数\n\n> 同层比较\n\n因为当都含有子节点，即都包含 children 属性后，需要精细比较不同，不能像之前那些情况一样进行简单处理就可以了 那么这个函数中就会介绍大家经常说的 头头、尾尾、尾头、头尾 比较了，其实这不是 vue 提出来的，是很早就提出来的算法，就一直沿用至今，大家可以参考【snabbdom 库】\n\n🌟 在这之前我们要定义四个指针 newstartidx、newendidx、oldstartidx 和 oldendidx，分别指向 新头节点、新尾节点、旧头节点 与 旧尾节点\n\n循环条件如下：\n\nwhile(oldstartidx <= oldendidx && newstartidx <= newendidx) {\n  ......\n}\n\n\n1\n2\n3\n\n\n其实这个比较也就是按人类的习惯来进行比较的，比较顺序如下 ：\n\n * 1️⃣ 新头节点与旧头节点：++newstartidx 和 ++oldstartidx\n\n * 2️⃣ 新尾节点与旧尾节点：--newendidx 和 --oldendidx\n\n * 3️⃣ 新尾节点与旧头节点：需要将 旧头节点 移动到 旧尾节点之前，为什么要这么做，讲起来比较复杂，记住就好，然后 --newendidx 和 ++oldstartidx\n\n * 4️⃣ 新头节点与旧尾节点：需要将 旧尾节点 移动到 旧头节点之前，为什么要这么做，讲起来比较复杂，记住就好，然后 ++newstartidx 和 --oldendidx\n\n * 5️⃣ 如果都没有匹配的话，就把新头节点在旧节点列表(也就是 children 属性的值) 中进行查找，查找方式按照如下：\n   \n   * 如果有 key 就把 key 在 oldkeytoidx 进行匹配，oldkeytoidx 根据旧节点列表中元素的 key 生成对应的下标\n   * 如果没有，就按顺序遍历旧节点列表找到该节点所在的下标\n   * 如果在旧节点列表是否找到也分为两种情况：\n     * 找到了，那么只要将 新头节点 添加到 旧头节点 之前即可\n     * 没找到，那么需要创建新的元素然后添加到 旧头节点 之前\n     * 然后把这个节点设置为 undefined\n\n根据循环条件我们可以得到两种剩余情况，如下：\n\n * 6️⃣ 如果 oldstartidx > oldendidx 说明老节点先遍历完成，那么新节点比老节点多，就要把 newstartidx 与 newendidx 之间的元素添加\n * 7️⃣ 如果 newstartidx > newendidx 说明新节点先遍历完成，那么老节点比新节点多，就要把 oldstartidx 与 oldendidx 之间的元素删除\n\n其实我们上面还没有考虑如果节点为 undefined 的情况，因为在上面也提到过，如果四种都不匹配后会将该节点置为 undefined，也只有旧节点列表中才有，因此要在开头考虑这两种情况：\n\n * 8️⃣ 当 oldstartvnode 为 undefined：++oldstartidx\n * 9️⃣ 当 oldendvnode 为 undefined：--oldendidx\n\n那么我们来看源码怎么写的吧，其中用到的函数可以查看源码附录：\n\n// https://github.com/vuejs/vue/blob/main/src/core/vdom/patch.ts\n// 439 行至 556 行\nwhile (oldstartidx <= oldendidx && newstartidx <= newendidx) {\n  if (isundef(oldstartvnode)) {\n  \t// 情况 8️⃣\n    oldstartvnode = oldch[++oldstartidx] // vnode has been moved left\n  } else if (isundef(oldendvnode)) {\n  \t// 情况 9️⃣\n    oldendvnode = oldch[--oldendidx]\n  } else if (samevnode(oldstartvnode, newstartvnode)) {\n  \t// 情况 1️⃣\n    patchvnode(...)\n    oldstartvnode = oldch[++oldstartidx]\n    newstartvnode = newch[++newstartidx]\n  } else if (samevnode(oldendvnode, newendvnode)) {\n  \t// 情况 2️⃣\n    patchvnode(...)\n    oldendvnode = oldch[--oldendidx]\n    newendvnode = newch[--newendidx]\n  } else if (samevnode(oldstartvnode, newendvnode)) {\n    // vnode moved right\n    // 情况 3️⃣\n    patchvnode(...)\n    canmove &&\n      nodeops.insertbefore(\n        parentelm,\n        oldstartvnode.elm,\n        nodeops.nextsibling(oldendvnode.elm)\n      )\n    oldstartvnode = oldch[++oldstartidx]\n    newendvnode = newch[--newendidx]\n  } else if (samevnode(oldendvnode, newstartvnode)) {\n    // vnode moved left\n    // 情况 4️⃣\n    patchvnode(...)\n    canmove &&\n      nodeops.insertbefore(parentelm, oldendvnode.elm, oldstartvnode.elm)\n    oldendvnode = oldch[--oldendidx]\n    newstartvnode = newch[++newstartidx]\n  } else {\n  \t// 情况 5️⃣\n    if (isundef(oldkeytoidx)) // 创建 key -> index 的 map\n      oldkeytoidx = createkeytooldidx(oldch, oldstartidx, oldendidx) \n    // 找到 新头节点 的下标\n    idxinold = isdef(newstartvnode.key)\n      ? oldkeytoidx[newstartvnode.key]\n      : findidxinold(newstartvnode, oldch, oldstartidx, oldendidx)\n    if (isundef(idxinold)) {\n      // new element\n      // 如果没找到\n      createelm(...)\n    } else {\n      // 如果找到了\n      vnodetomove = oldch[idxinold]\n      if (samevnode(vnodetomove, newstartvnode)) {\n        patchvnode(...)\n        oldch[idxinold] = undefined\n        canmove &&\n          nodeops.insertbefore(\n            parentelm,\n            vnodetomove.elm,\n            oldstartvnode.elm\n          )\n      } else {\n        // same key but different element. treat as new element\n        createelm(...)\n      }\n    }\n    newstartvnode = newch[++newstartidx]\n  }\n}\nif (oldstartidx > oldendidx) {\n  // 情况 6️⃣\n  refelm = isundef(newch[newendidx + 1]) ? null : newch[newendidx + 1].elm\n  addvnodes(...)\n} else if (newstartidx > newendidx) {\n  // 情况 7️⃣\n  removevnodes(...)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n> 如果问为什么这么比较，回答就是经过很多人很多年的讨论得出的，其实只要记住过程就行了，如果想要更深了解 diff 算法，可以去 b 站看【尚硅谷】vue源码解析之虚拟dom和diff算法\n\n\n# v-for 中为什么要加 key\n\n这个问题面试很常见，但是可能大部分人也就只会背八股，没有完全理解，那么经过以上的介绍，我们可以得到自己的理解：\n\n * 首先，如果不加 key 的话，那么就不会去 map 里匹配 (o(1))，而是循环遍历整个列表 (o(n))，肯定加 key 要快一点，性能更高\n * 其次，如果不加 key 那么在插入或删除的时候就会出现，原本不是同一个节点的元素被认为是相同节点，上面也有说过是 samevnode 函数判断的，因此可能会有额外 dom 操作\n\n> 为什么说可能有额外 dom 操作呢？这个和插入的地方有关，之后会讨论，同理删除也一样\n\n\n# 证明 key 的性能\n\n我们分为三个实验：没有 key、key 为 index、key 唯一，仅证明加了 key 可以进行最小化更新操作。\n\n\n# 实验代码\n\n有小伙伴评论说可以把代码贴上这样更好，那么作者就把代码附上 🥳：\n\n<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"><\/script>\n  <style>\n    .box {\n      display: flex;\n      flex-direction: row;\n    }\n    .item {\n      flex: 1;\n    }\n  </style>\n</head>\n\n<body>\n  <div id="app">\n    <div class="box">\n      <div class="item">\n        <h3>没有 key</h3>\n        <p v-for="(item, index) in list">{{ item }}</p>\n      </div>\n      <div class="item">\n        <h3>key 为 index</h3>\n        <p v-for="(item, index) in list" :key="index">{{ item }}</p>\n      </div>\n      <div class="item">\n        <h3>key 唯一</h3>\n        <p v-for="(item, index) in list" :key="item">{{ item }}</p>\n      </div>\n    </div>\n    <button @click="click1">push(4)</button>\n    <button @click="click2">splice(1, 0, 666)</button>\n    <button @click="click3">unshift(999)</button>\n    <br /><br />\n    <button @click="click4">pop()</button>\n    <button @click="click5">splice(1, 1)</button>\n    <button @click="click6">shift()</button>\n  </div>\n  <script>\n    var app = new vue({\n      el: \'#app\',\n      data: {\n        show: false,\n        list: [1, 2, 3],\n      },\n      methods: {\n        click1() {\n          this.list.push(4);\n        },\n        click2() {\n          this.list.splice(1, 0, 666);\n        },\n        click3() {\n          this.list.unshift(999);\n        },\n        click4() {\n          this.list.pop();\n        },\n        click5() {\n          this.list.splice(1, 1);\n        },\n        click6() {\n          this.list.shift();\n        }\n      },\n    })\n  <\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 增加实验\n\n实验如下所示，我们首先更改原文字，然后点击按钮**「观察节点发生变化的个数」**：\n\n# 在队尾增加\n\n\n\n# 在队内增加\n\n\n\n# 在队首增加\n\n\n\n\n# 删除实验\n\n# 在队尾删除\n\n\n\n# 在队内删除\n\n\n\n# 在队首删除\n\n\n\n\n# 实验结论\n\n# 增加实验\n\n表格为每次实验中，每种情况的最小更新量，假设列表原来的长度为 n\n\n实验      没有 key      key 为 index   key 唯一\n在队尾增加   1           1             1\n在队中增加   n - i + 1   n - i + 1     1\n在队首增加   n + 1       n + 1         1\n\n# 删除实验\n\n表格为每次实验中，每种情况的最小更新量，假设列表原来的长度为 n\n\n实验      没有 key   key 为 index   key 唯一\n在队尾删除   1        1             1\n在队中删除   n - i    n - i         1\n在队首删除   n        n             1\n\n通过以上实验和表格可以得到加上 key 的性能和最小量更新的个数是最小的，虽然在 在队尾增加 和 在队尾删除 的最小更新量相同，但是之前也说了，如果没有 key 是要循环整个列表查找的，时间复杂度是 o(n)，而加了 key 的查找时间复杂度为 o(1)，因此总体来说加了 key 的性能要更好。\n\n\n# 写在最后\n\n本文从源码和实验的角度介绍了 diff 算法，相信大家对 diff 算法有了更深的了解了，如果有问题可私信交流或者评论区交流，如果大家喜欢的话可以点赞 ➕ 收藏 🌟\n\n\n# 源码函数附录\n\n> 列举一些源码中出现的简单函数\n\nsettextcontent\n\nfunction settextcontent(node: node, text: string) {\n  node.textcontent = text\n}\n\n\n1\n2\n3\n\n\nisundef\n\nfunction isundef(v: any): v is undefined | null {\n  return v === undefined || v === null\n}\n\n\n1\n2\n3\n\n\nisdef\n\nfunction isdef<t>(v: t): v is nonnullable<t> {\n  return v !== undefined && v !== null\n}\n\n\n1\n2\n3\n\n\ninsertbefore\n\nfunction insertbefore(\n  parentnode: node,\n  newnode: node,\n  referencenode: node\n) {\n  parentnode.insertbefore(newnode, referencenode)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnextsibling\n\nfunction nextsibling(node: node) {\n  return node.nextsibling\n}\n\n\n1\n2\n3\n\n\ncreatekeytooldidx\n\nfunction createkeytooldidx(children, beginidx, endidx) {\n  let i, key\n  const map = {}\n  for (i = beginidx; i <= endidx; ++i) {\n    key = children[i].key\n    if (isdef(key)) map[key] = i\n  }\n  return map\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2023/04/25, 01:33:08",lastUpdatedTimestamp:1682357588e3},{title:"网站轮子",frontmatter:{title:"网站轮子",permalink:"/whell/web/",date:"2020-04-19T11:33:04.000Z",article:!1,readingShow:"top"},regularPath:"/75.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99%E8%BD%AE%E5%AD%90.html",relativePath:"75.收藏夹/01.网站轮子.md",key:"v-14211e26",path:"/whell/web/",headers:[{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:12},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:220},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:411},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:475},{level:2,title:"文章",slug:"文章",normalizedTitle:"文章",charIndex:363},{level:2,title:"科学上网",slug:"科学上网",normalizedTitle:"科学上网",charIndex:567},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:627},{level:3,title:"电视直播",slug:"电视直播",normalizedTitle:"电视直播",charIndex:760},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:227},{level:2,title:"在线工具",slug:"在线工具",normalizedTitle:"在线工具",charIndex:881},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:63},{level:3,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:959},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1020},{level:3,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1120},{level:3,title:"作图",slug:"作图",normalizedTitle:"作图",charIndex:1354},{level:3,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:555},{level:3,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:1650},{level:3,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:1710},{level:3,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:1740},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:1801},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:389},{level:3,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:2902},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:3063},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:1980},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:96},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:2889},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:3870},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:4243},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:1890},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:4323}],headersStr:"文档 社区 博客 电子书 文章 科学上网 视频 电视直播 Github 在线工具 开发 代码编辑 Emoji表情 图片工具 作图 CSS CDN加速 网站托管 正则 其他 设计 图库 有趣 交互 教程 产品 实用 Talk 算法 生活",content:"# 个人收藏夹\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ\n * V2EX\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * 前端电子书收集\n * SoBooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用CSS开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(GCP)一键搭建 V2Ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * bilibili B站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * CCTV、卫视高清直播\n\n\n# Github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按Win+.快速打开表情选择框\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# CSS\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 Ps 学习教程\n * beTheme\n * UI 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * Little Big Details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq\n * v2ex\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * 前端电子书收集\n * sobooks 免费的电子书资源网站\n\n\n# 文章\n\n * 灵活运用css开发技巧\n\n\n# 科学上网\n\n * 谷歌chrome商店访问助手\n\n * 谷歌云(gcp)一键搭建 v2ray 让你畅快科学上网\n\n\n# 视频\n\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * bilibili b站，上面也有一些可供学习的免费视频\n * egghead 质量还不错的短视频教程，外网\n\n\n# 电视直播\n\n * cctv、卫视高清直播\n\n\n# github\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 在线工具\n\n\n# 开发\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows系统下按win+.快速打开表情选择框\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 作图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n\n\n# css\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n\n\n# 有趣\n\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * wallhaven 壁纸网站-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 诺基亚短信图片生成器\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n * little big details 同上，一个国外微交互汇集网站\n * cruip 登录页的各种页面设计，可以免费下载模板\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"前端轮子",frontmatter:{title:"前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/whell/front",article:!1,readingShow:"top"},regularPath:"/75.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"75.收藏夹/02.前端轮子.md",key:"v-354f58fa",path:"/whell/front/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"插件轮子",frontmatter:{title:"插件轮子",date:"2021-10-28T16:27:50.000Z",permalink:"/plugins",article:!1,readingShow:"top"},regularPath:"/75.%E6%94%B6%E8%97%8F%E5%A4%B9/03.%E6%8F%92%E4%BB%B6%E9%80%89%E6%8B%A9.html",relativePath:"75.收藏夹/03.插件选择.md",key:"v-09f97d06",path:"/plugins/",headers:[{level:2,title:"vuepress插件",slug:"vuepress插件",normalizedTitle:"vuepress插件",charIndex:2},{level:3,title:"vuepress-plugin-tabs",slug:"vuepress-plugin-tabs",normalizedTitle:"vuepress-plugin-tabs",charIndex:80},{level:3,title:"vuepress-plugin-demo-block",slug:"vuepress-plugin-demo-block",normalizedTitle:"vuepress-plugin-demo-block",charIndex:314},{level:3,title:"vuepress-plugin-reading-progress",slug:"vuepress-plugin-reading-progress",normalizedTitle:"vuepress-plugin-reading-progress",charIndex:483},{level:3,title:"vuepress-plugin-meting",slug:"vuepress-plugin-meting",normalizedTitle:"vuepress-plugin-meting",charIndex:596},{level:3,title:"vuepress-plugin-cursor-effects",slug:"vuepress-plugin-cursor-effects",normalizedTitle:"vuepress-plugin-cursor-effects",charIndex:703},{level:3,title:"vuepress-plugin-dynamic-title",slug:"vuepress-plugin-dynamic-title",normalizedTitle:"vuepress-plugin-dynamic-title",charIndex:826},{level:3,title:"vuepress-plugin-fulltext-search",slug:"vuepress-plugin-fulltext-search",normalizedTitle:"vuepress-plugin-fulltext-search",charIndex:956}],headersStr:"vuepress插件 vuepress-plugin-tabs vuepress-plugin-demo-block vuepress-plugin-reading-progress vuepress-plugin-meting vuepress-plugin-cursor-effects vuepress-plugin-dynamic-title vuepress-plugin-fulltext-search",content:"# vuepress插件\n\nVuepress 的社区所有插件：https://github.com/vuepress/awesome-vuepress\n\n\n# vuepress-plugin-tabs\n\n实现切换 tab。\n\n官网：https://github.com/pskordilakis/vuepress-plugin-tabs\n\n安装：https://notes.youngkbt.cn/about/mdskill/#tabs插件\n\n效果：\n\nmarkdown content\n\n() => {\n\n console.log('Javascript code example')\n\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# vuepress-plugin-demo-block\n\n官网：https://github.com/xiguaxigua/vuepress-plugin-demo-block/\n\n功能：既能看代码，也能看代码运行的效果。\n\nDemo：https://notes.youngkbt.cn/about/mdskill/#demo插件\n\n\n# vuepress-plugin-reading-progress\n\n顶部的阅读进度插件。\n\n官网：https://github.com/tolking/vuepress-plugin-reading-progress\n\n\n# vuepress-plugin-meting\n\n左小角的音乐播放器插件。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/meting.html\n\n\n# vuepress-plugin-cursor-effects\n\n鼠标点击页面的爆炸效果。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/cursor-effects.html\n\n\n# vuepress-plugin-dynamic-title\n\n动态标题，离开和回来网页后的标题发生变化。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/dynamic-title.html\n\n\n# vuepress-plugin-fulltext-search\n\n网站搜索插件，能搜索到文章的具体内容。\n\n官网：https://github.com/leo-buneev/vuepress-plugin-fulltext-search",normalizedContent:"# vuepress插件\n\nvuepress 的社区所有插件：https://github.com/vuepress/awesome-vuepress\n\n\n# vuepress-plugin-tabs\n\n实现切换 tab。\n\n官网：https://github.com/pskordilakis/vuepress-plugin-tabs\n\n安装：https://notes.youngkbt.cn/about/mdskill/#tabs插件\n\n效果：\n\nmarkdown content\n\n() => {\n\n console.log('javascript code example')\n\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# vuepress-plugin-demo-block\n\n官网：https://github.com/xiguaxigua/vuepress-plugin-demo-block/\n\n功能：既能看代码，也能看代码运行的效果。\n\ndemo：https://notes.youngkbt.cn/about/mdskill/#demo插件\n\n\n# vuepress-plugin-reading-progress\n\n顶部的阅读进度插件。\n\n官网：https://github.com/tolking/vuepress-plugin-reading-progress\n\n\n# vuepress-plugin-meting\n\n左小角的音乐播放器插件。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/meting.html\n\n\n# vuepress-plugin-cursor-effects\n\n鼠标点击页面的爆炸效果。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/cursor-effects.html\n\n\n# vuepress-plugin-dynamic-title\n\n动态标题，离开和回来网页后的标题发生变化。\n\n官网：https://moefyit.github.io/moefy-vuepress/packages/dynamic-title.html\n\n\n# vuepress-plugin-fulltext-search\n\n网站搜索插件，能搜索到文章的具体内容。\n\n官网：https://github.com/leo-buneev/vuepress-plugin-fulltext-search",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"自我 - 介绍",frontmatter:{title:"自我 - 介绍",date:"2021-07-30T22:29:33.000Z",permalink:"/about/me/introduce/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/02.%E8%87%AA%E6%88%91%20-%20%E4%BB%8B%E7%BB%8D.html",relativePath:"80.关于/03.关于 - 自我/02.自我 - 介绍.md",key:"v-5d5b1b5c",path:"/about/me/introduce/",headers:[{level:2,title:"Hello (\\/ω＼) 👋",slug:"hello-ω-👋",normalizedTitle:"hello (/ω＼) 👋",charIndex:null},{level:2,title:"技术栈 Tech Stacks 🐾",slug:"技术栈-tech-stacks-🐾",normalizedTitle:"技术栈 tech stacks 🐾",charIndex:22},{level:2,title:"开发环境 Development Environment 🍻",slug:"开发环境-development-environment-🍻",normalizedTitle:"开发环境 development environment 🍻",charIndex:44},{level:2,title:"网站初衷 🎨",slug:"网站初衷-🎨",normalizedTitle:"网站初衷 🎨",charIndex:79},{level:2,title:"联系我 💬",slug:"联系我-💬",normalizedTitle:"联系我 💬",charIndex:90}],headersStr:"Hello (\\/ω＼) 👋 技术栈 Tech Stacks 🐾 开发环境 Development Environment 🍻 网站初衷 🎨 联系我 💬",content:" * Hello (\\/ω＼) 👋\n * 技术栈 Tech Stacks 🐾\n * 开发环境 Development Environment 🍻\n * 网站初衷 🎨\n * 联系我 💬\n\n\n\n序言\n\n生活的过程，需要记录！\n\n2022-7-30 @Du Wu\n\n\n# Hello (*/ω＼*) 👋\n\n\n\n\n\n * 🌐 中文\n * 🏢 深圳 Shenzhen\n * 💼 刚毕业 Just graduated\n * ⏰ 7:00 - 24:00 UTC+8\n * ❤️ 🏀 🏃‍ 💻\n * 🔗 youngkbt.cn\n\n\n# 技术栈 Tech Stacks 🐾\n\n\n\n\n\n\n\n\n\n# 开发环境 Development Environment 🍻\n\n\n\n\n\n# 网站初衷 🎨\n\n技术如繁星之多，迭代如春笋涌出。而人的脑海无法储存这些大量的知识。所以需要一个平台来整理学习到的知识体系或者记录生活的琐事。\n\n我的曾经：\n\n * 忙于学习，忘记思考，会忽略很多知识，待到复习时，不知道从何开启\n * 有很多 idea 一闪而过，却无法记住，乃至后面回忆内容，已是模糊\n * 对知识焦虑，多次遇到同一个问题，苦恼没有记住，查阅时却找不到解决方案\n * 没有系统的梳理自己的知识体系，知识杂糅在脑中\n\n......\n\n搭建这个网站，不仅为了将学到的东西都记录下来 📌，也是为了督促自己学习 ✊，当然，希望分享自己的知识，来帮助更多的人 🦾。\n\n我只是个初学者，本站关于知识体系的文章基本是在书籍或者视频学习的过程中，总结或参考作者写好的讲义文章而来，对于这些文章，我会在文章页进行说明来源。\n\n加油，写出更多 💯 的文章 📄。\n\n\n# 联系我 💬\n\n📫：2456019588@qq.com\n\n🐧🐧：2456019588\n\nWeChat：Kele_Bingtang",normalizedContent:" * hello (\\/ω＼) 👋\n * 技术栈 tech stacks 🐾\n * 开发环境 development environment 🍻\n * 网站初衷 🎨\n * 联系我 💬\n\n\n\n序言\n\n生活的过程，需要记录！\n\n2022-7-30 @du wu\n\n\n# hello (*/ω＼*) 👋\n\n\n\n\n\n * 🌐 中文\n * 🏢 深圳 shenzhen\n * 💼 刚毕业 just graduated\n * ⏰ 7:00 - 24:00 utc+8\n * ❤️ 🏀 🏃‍ 💻\n * 🔗 youngkbt.cn\n\n\n# 技术栈 tech stacks 🐾\n\n\n\n\n\n\n\n\n\n# 开发环境 development environment 🍻\n\n\n\n\n\n# 网站初衷 🎨\n\n技术如繁星之多，迭代如春笋涌出。而人的脑海无法储存这些大量的知识。所以需要一个平台来整理学习到的知识体系或者记录生活的琐事。\n\n我的曾经：\n\n * 忙于学习，忘记思考，会忽略很多知识，待到复习时，不知道从何开启\n * 有很多 idea 一闪而过，却无法记住，乃至后面回忆内容，已是模糊\n * 对知识焦虑，多次遇到同一个问题，苦恼没有记住，查阅时却找不到解决方案\n * 没有系统的梳理自己的知识体系，知识杂糅在脑中\n\n......\n\n搭建这个网站，不仅为了将学到的东西都记录下来 📌，也是为了督促自己学习 ✊，当然，希望分享自己的知识，来帮助更多的人 🦾。\n\n我只是个初学者，本站关于知识体系的文章基本是在书籍或者视频学习的过程中，总结或参考作者写好的讲义文章而来，对于这些文章，我会在文章页进行说明来源。\n\n加油，写出更多 💯 的文章 📄。\n\n\n# 联系我 💬\n\n📫：2456019588@qq.com\n\n🐧🐧：2456019588\n\nwechat：kele_bingtang",charsets:{cjk:!0},lastUpdated:"2023/04/20, 18:38:01",lastUpdatedTimestamp:1681987081e3},{title:"自我 - 学习线",frontmatter:{title:"自我 - 学习线",date:"2021-11-13T15:09:47.000Z",permalink:"/about/learn-line/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/07.%E8%87%AA%E6%88%91%20-%20%E5%AD%A6%E4%B9%A0%E7%BA%BF.html",relativePath:"80.关于/03.关于 - 自我/07.自我 - 学习线.md",key:"v-7f849213",path:"/about/learn-line/",headers:[{level:2,title:"为什么做学习路线",slug:"为什么做学习路线",normalizedTitle:"为什么做学习路线",charIndex:54},{level:2,title:"编程路线",slug:"编程路线",normalizedTitle:"编程路线",charIndex:174},{level:2,title:"后续路线",slug:"后续路线",normalizedTitle:"后续路线",charIndex:4724},{level:2,title:"其他路线",slug:"其他路线",normalizedTitle:"其他路线",charIndex:5165},{level:2,title:"图片路线",slug:"图片路线",normalizedTitle:"图片路线",charIndex:5679}],excerpt:'<div class="custom-block note"><p class="custom-block-title">笔记</p>\n<p>很久之前，我决定踏上的这条路，映照了我与未来的因果。</p>\n<div class="custom-block right">\n<p>2021-11-13 @Du Wu</p>\n</div>\n</div>\n',headersStr:"为什么做学习路线 编程路线 后续路线 其他路线 图片路线",content:"笔记\n\n很久之前，我决定踏上的这条路，映照了我与未来的因果。\n\n2021-11-13 @Du Wu\n\n\n# 为什么做学习路线\n\n * 回忆自己的学习历程，养成好习惯\n\n * 记录路线，以后重塑时可以参考\n\n * 对自己走过的路程有个清晰的梳理，不会担心遗忘\n\n * 后面走的路有个规划，不会迷茫\n\n * 性格原因，喜欢记录\n\n......\n\n\n# 编程路线\n\n学习 Java 的路线非常之多，网上提供的路线有很多，并且内容大抵相同。\n\n这里记录我学习一年多到现在的路线，包括之后的路线规划。\n\n时间线排序规则：升序\n\n路线                         屋子                                  时间                        类型\nJava SE 基础（了解）             《Java 基础入门到精通》                      2019-12                   书籍\nJava SE 基础（深入）             Java300集 - 高琪视频                     2020-02                   视频\n学生信息管理系统                   无地址，控制台数字技术                         2020-06                   项目\nJava FX 桌面开发（GUI）          JavaFX桌面开发(GUI)_52集视频教程             2020-07                   视频\nJava Swing 桌面开发（GUI）       Java Swing入门课程_图形界面GUI编程_100集视频教程   2020-08                   视频\nJava SE 基础（重塑）             培训                                  2020-10 ~ 2021-04         培训/书籍\n仿 QQ 聊天系统（GUI）             自己写，GitHub 地址                       2021-04-31 ~ 2021-05-10   项目\nWeb 前端基础（Html、Css、Js、JQ）   WEB前端零基础入门                          2021-05-24 ~ 2021-06-10   视频\nWeb 后端基础（Servlet、Jsp）      java web零基础入门完整版                    2021-06-10 ~ 2021-06-20   视频\nWeb 前端进阶（PHP、Webpack）      视频已下架                               2021-06-21 ~ 2021-07-12   视频\nDbdToBean（v1.0 ~ v1.1）     自己手写逆向工程                            2021-06-28 ~ 2021-07-05   jar 包\n医院药品管理系统                   让我们从零打造一个基于Springboot2的《医院药品管理系统》   2021-07-16 ~ 2021-07-20   项目/视频\n网上购物商城                     团队写，GitHub 地址                       2021-07-21 ~ 2021-08-03   项目\nJava 框架 SSM                最全SSM框架教程                           2021-07-13 ~ 2021-07-20   视频\nJava 框架 Spring Boot        SpringBoot教程，6小时快速入门                2021-08-01 ~ 2021-08-03   视频\n微信小程序（React + Taro）和后台     团队写，小程序 Github 地址                   2021-08-04 ~ 2021-08-17   项目\nDbdToBean（v1.2）            升级自己写的 jar 包                        2021-08-09                jar 包\nJava 框架 Spring Security    细说SpringSecurity安全框架                2021-08-10 ~ 2021-08-17   视频\n                           spring security源码剖析从入门到精通\nReact                      React技术全家桶                          2021-08-10 ~ 2021-08-26   视频\nVue2 ~ Vue3 基础             Vue2.0+Vue3.0全套教程                   2021-08-19 ~ 2021-08-22   视频\n中医药门户系统                    无地址                                 2021-08-24 ~ 2021-09-01   项目\nJava 面试复习                  Java集合                              2021-09-01 ~ 2021-09-15   视频/文章/书籍\n                           基础、异常、IO流、TCP、servlet、框架均是文章和书籍复习\nJava MySQL 数据库             MySQL高级教程（一）                        2021-09-04 ~ 2021-09-07   视频\n                           MySQL高级教程（二）\nDbdToBean（v1.3）            支持 Spring Boot starter              2021-09-19 ~ 2021-09-24   jar 包\nJava 微服务 Dubbo             Dubbo快速入门                           2021-09-25 ~ 2021-09-27   视频\n                           Dubbo源码分析\n                           彻底精通Dubbo源码\nJava 微服务 Zookeeper         Zookeeper 3.5.7版本教程                 2021-09-28 ~ 2021-09-30   视频\nJava 微服务 全家桶               SpringCloud框架开发                     2021-09-30 ~ 2021-10-06   视频\nLinux                      一周学会Linux                           2021-10-07 ~ 2021-10-12   视频\nJava 数据库 Redis 6           Redis 6 入门到精通                       2021-10-13 ~ 2021-10-16   视频\nJava 中间件 ActiveMQ          ActiveMQ教程                          2021-10-17 ~ 2021-10-20   视频\nT-Beam-REP 后台管理系统          隐私，无地址                              2021-10-20 ~ 2021-11-07   项目\nJava 中间件 RabbitMQ          新版RabbitMQ教程                        2021-11-08 ~ 2021-11-12   视频\nElasticSearch              ElasticSearch教程入门到精通                2021-11-14 ~ 2021-11-18   视频\nDocker                     2021年最新Docker容器技术                   2021-11-19 ~ 2021-11-24   视频\nNginx                      从0到1学会Nginx分布式框架                    2021-11-25 ~ 2021-11-30   视频\nJVM                        尚硅谷宋红康JVM全套教程（详解java虚拟机）            2022-01-15 ~ 2021-02-01   视频\nMaven（重塑）                  maven项目管理从基础到高级                     2022-02-04 ~ 2021-02-05   视频/文章\nGit（重塑）                    Git入门到精通全套教程                        2022-02-06                视频\nJava 8 - 15 新特性            Java 8、9、11 新特性                     2022-02-09 ~ 2022-02-13   视频\n                           Java 10 新特性\n                           Java 12、13 新特性\n                           Java 14 新特性\n                           Java 15 新特性\n设计模式                       Java设计模式                            2022-02-24 ~ 2022-03-26   视频\nJUC                        JUC并发编程全套教程                         2022-05-04 ~ 2022-05-21   视频\nJenkins                    Jenkins教程（从配置到实战）                   2022-08-21 ~ 2022-08-24   视频\nTypeScript                 TypeScript入门视频教程                    2022-08-31 ~ 2022-09-17   视频\n\n\n# 后续路线\n\n路线                  完成度\nElasticsearch       done\nDocker              done\nNginx               done\nJVM                 done\nJUC                 done\nMaven（重塑）           done\nGit（重塑）             done\nJava 8 - 15 新特性     done\n设计模式                done\n算法                  doing\nSpring 生态源码         none\nElasticsearch（重塑）   none\nwebpack & node      none\n\nElasticsearch（重塑）是我在学完 Elasticsearch 后，依然觉得需要研究的内容还有很多，而规划的。\n\n提供重塑地址：\n\n地址1\n\n地址2\n\n\n# 其他路线\n\n路线               屋子                     时间                  类型\nExcel            Excel零基础入门起步           2018-11             视频\nPhotoshop        敬伟PS教程全集               2018-11 ~ 2019-02   视频\nAdobe Premiere   Pr教程全57集               2019-05             视频\nAfter Effect     AE软件课程入门首选             2019-06             视频\nAdobe Audition   AU全套教程                 2019-07             视频\nAxure            Axure RP7 .0高级全套视频教程   2020-11             视频\nVuePress         搭建vuepress高大上个人博客      2021-10-18          视频\n\n\n# 图片路线\n\n这里提供一些学习时收集并且按照路线学习过的图片\n\n某培训机构前端学习课程：\n\n\n\n某培训结构后端学习课程：\n\n\n\n某培训机构后端学习路线：\n\n",normalizedContent:"笔记\n\n很久之前，我决定踏上的这条路，映照了我与未来的因果。\n\n2021-11-13 @du wu\n\n\n# 为什么做学习路线\n\n * 回忆自己的学习历程，养成好习惯\n\n * 记录路线，以后重塑时可以参考\n\n * 对自己走过的路程有个清晰的梳理，不会担心遗忘\n\n * 后面走的路有个规划，不会迷茫\n\n * 性格原因，喜欢记录\n\n......\n\n\n# 编程路线\n\n学习 java 的路线非常之多，网上提供的路线有很多，并且内容大抵相同。\n\n这里记录我学习一年多到现在的路线，包括之后的路线规划。\n\n时间线排序规则：升序\n\n路线                         屋子                                  时间                        类型\njava se 基础（了解）             《java 基础入门到精通》                      2019-12                   书籍\njava se 基础（深入）             java300集 - 高琪视频                     2020-02                   视频\n学生信息管理系统                   无地址，控制台数字技术                         2020-06                   项目\njava fx 桌面开发（gui）          javafx桌面开发(gui)_52集视频教程             2020-07                   视频\njava swing 桌面开发（gui）       java swing入门课程_图形界面gui编程_100集视频教程   2020-08                   视频\njava se 基础（重塑）             培训                                  2020-10 ~ 2021-04         培训/书籍\n仿 qq 聊天系统（gui）             自己写，github 地址                       2021-04-31 ~ 2021-05-10   项目\nweb 前端基础（html、css、js、jq）   web前端零基础入门                          2021-05-24 ~ 2021-06-10   视频\nweb 后端基础（servlet、jsp）      java web零基础入门完整版                    2021-06-10 ~ 2021-06-20   视频\nweb 前端进阶（php、webpack）      视频已下架                               2021-06-21 ~ 2021-07-12   视频\ndbdtobean（v1.0 ~ v1.1）     自己手写逆向工程                            2021-06-28 ~ 2021-07-05   jar 包\n医院药品管理系统                   让我们从零打造一个基于springboot2的《医院药品管理系统》   2021-07-16 ~ 2021-07-20   项目/视频\n网上购物商城                     团队写，github 地址                       2021-07-21 ~ 2021-08-03   项目\njava 框架 ssm                最全ssm框架教程                           2021-07-13 ~ 2021-07-20   视频\njava 框架 spring boot        springboot教程，6小时快速入门                2021-08-01 ~ 2021-08-03   视频\n微信小程序（react + taro）和后台     团队写，小程序 github 地址                   2021-08-04 ~ 2021-08-17   项目\ndbdtobean（v1.2）            升级自己写的 jar 包                        2021-08-09                jar 包\njava 框架 spring security    细说springsecurity安全框架                2021-08-10 ~ 2021-08-17   视频\n                           spring security源码剖析从入门到精通\nreact                      react技术全家桶                          2021-08-10 ~ 2021-08-26   视频\nvue2 ~ vue3 基础             vue2.0+vue3.0全套教程                   2021-08-19 ~ 2021-08-22   视频\n中医药门户系统                    无地址                                 2021-08-24 ~ 2021-09-01   项目\njava 面试复习                  java集合                              2021-09-01 ~ 2021-09-15   视频/文章/书籍\n                           基础、异常、io流、tcp、servlet、框架均是文章和书籍复习\njava mysql 数据库             mysql高级教程（一）                        2021-09-04 ~ 2021-09-07   视频\n                           mysql高级教程（二）\ndbdtobean（v1.3）            支持 spring boot starter              2021-09-19 ~ 2021-09-24   jar 包\njava 微服务 dubbo             dubbo快速入门                           2021-09-25 ~ 2021-09-27   视频\n                           dubbo源码分析\n                           彻底精通dubbo源码\njava 微服务 zookeeper         zookeeper 3.5.7版本教程                 2021-09-28 ~ 2021-09-30   视频\njava 微服务 全家桶               springcloud框架开发                     2021-09-30 ~ 2021-10-06   视频\nlinux                      一周学会linux                           2021-10-07 ~ 2021-10-12   视频\njava 数据库 redis 6           redis 6 入门到精通                       2021-10-13 ~ 2021-10-16   视频\njava 中间件 activemq          activemq教程                          2021-10-17 ~ 2021-10-20   视频\nt-beam-rep 后台管理系统          隐私，无地址                              2021-10-20 ~ 2021-11-07   项目\njava 中间件 rabbitmq          新版rabbitmq教程                        2021-11-08 ~ 2021-11-12   视频\nelasticsearch              elasticsearch教程入门到精通                2021-11-14 ~ 2021-11-18   视频\ndocker                     2021年最新docker容器技术                   2021-11-19 ~ 2021-11-24   视频\nnginx                      从0到1学会nginx分布式框架                    2021-11-25 ~ 2021-11-30   视频\njvm                        尚硅谷宋红康jvm全套教程（详解java虚拟机）            2022-01-15 ~ 2021-02-01   视频\nmaven（重塑）                  maven项目管理从基础到高级                     2022-02-04 ~ 2021-02-05   视频/文章\ngit（重塑）                    git入门到精通全套教程                        2022-02-06                视频\njava 8 - 15 新特性            java 8、9、11 新特性                     2022-02-09 ~ 2022-02-13   视频\n                           java 10 新特性\n                           java 12、13 新特性\n                           java 14 新特性\n                           java 15 新特性\n设计模式                       java设计模式                            2022-02-24 ~ 2022-03-26   视频\njuc                        juc并发编程全套教程                         2022-05-04 ~ 2022-05-21   视频\njenkins                    jenkins教程（从配置到实战）                   2022-08-21 ~ 2022-08-24   视频\ntypescript                 typescript入门视频教程                    2022-08-31 ~ 2022-09-17   视频\n\n\n# 后续路线\n\n路线                  完成度\nelasticsearch       done\ndocker              done\nnginx               done\njvm                 done\njuc                 done\nmaven（重塑）           done\ngit（重塑）             done\njava 8 - 15 新特性     done\n设计模式                done\n算法                  doing\nspring 生态源码         none\nelasticsearch（重塑）   none\nwebpack & node      none\n\nelasticsearch（重塑）是我在学完 elasticsearch 后，依然觉得需要研究的内容还有很多，而规划的。\n\n提供重塑地址：\n\n地址1\n\n地址2\n\n\n# 其他路线\n\n路线               屋子                     时间                  类型\nexcel            excel零基础入门起步           2018-11             视频\nphotoshop        敬伟ps教程全集               2018-11 ~ 2019-02   视频\nadobe premiere   pr教程全57集               2019-05             视频\nafter effect     ae软件课程入门首选             2019-06             视频\nadobe audition   au全套教程                 2019-07             视频\naxure            axure rp7 .0高级全套视频教程   2020-11             视频\nvuepress         搭建vuepress高大上个人博客      2021-10-18          视频\n\n\n# 图片路线\n\n这里提供一些学习时收集并且按照路线学习过的图片\n\n某培训机构前端学习课程：\n\n\n\n某培训结构后端学习课程：\n\n\n\n某培训机构后端学习路线：\n\n",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"自我 - 尊贵公子",frontmatter:{title:"自我 - 尊贵公子",date:"2022-02-19T19:01:31.000Z",permalink:"/about/qin-yu/",private:!0,titleTag:"原创",categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/09.%E8%87%AA%E6%88%91%20-%20%E5%B0%8A%E8%B4%B5%E5%85%AC%E5%AD%90.html",relativePath:"80.关于/03.关于 - 自我/09.自我 - 尊贵公子.md",key:"v-7c7210d4",path:"/about/qin-yu/",headersStr:null,content:"笔记\n\n记录大学的一位朋友。\n\n2022-02-19 @Du Wu\n\n他带着一副金珠渡边的金黄色框眼镜，一圈圈复杂的纹路刻在上面，仿佛上世纪盛行的被无数绅士追捧的饰品，优雅又高贵。他时不时哼上几句流行的歌曲，伴随着微风吹走微热躁动的空气，引起头顶电风扇的共鸣。他双眼微眯，手随着歌曲不自觉的轻敲着桌子，某种旋律浅浅地向天空盘旋，像是沉迷在自己的世界里，开着许多人渴望却止步的演唱会，享受着台下的尖叫声和五颜六色的拥有魔力的聚光灯。风骤然剧烈，吹过他骄傲的经过高级理发师精心修理的时尚的头发，发泽乌黑，略带桀骜的纹边，就像少年嘴角的笑，随风摇荡，肆意张扬。\n\n哼完几句歌，于是他趴在放满书的岁月雕刻的桌子上，双手微掩着脸，兴许是累了，趴了一会，他粗重的呼吸缓缓变轻，像是暴风雨过后的水面，归于平静。\n\n我看着他的侧脸愣了愣神，岁月似乎从未在他的略瘦的英俊的脸留下痕迹，反而衬托得愈发灿烂，如同太阳下的少年手上的钻石，散发着昏眩的金光。他的脸上的线条菱角分明，像是上帝亲手刻的一幅画，掉落人间。我想，他一定与众不凡。\n\n我拿起空白的笔记本的一页，轻轻的写下：遇见了一个与众不凡的人，也许在未来或者不久之后会遇见并且相识，我相信，我会被他的一切折服。记 —— 2018.9.23\n\n寥寥几十个字仿佛深深刻印在了笔记本里，我正要起身离开，余光正好见他缩回了倚靠着脸的左手，我随意一瞥，看到写在他书本上的两个字，大气磅礴。\n\n秦宇!\n\n我轻轻笑了笑，收拾手中的和桌子的书，离开了这间教室。越走越远，我看向远方，有人在那里等着我。",normalizedContent:"笔记\n\n记录大学的一位朋友。\n\n2022-02-19 @du wu\n\n他带着一副金珠渡边的金黄色框眼镜，一圈圈复杂的纹路刻在上面，仿佛上世纪盛行的被无数绅士追捧的饰品，优雅又高贵。他时不时哼上几句流行的歌曲，伴随着微风吹走微热躁动的空气，引起头顶电风扇的共鸣。他双眼微眯，手随着歌曲不自觉的轻敲着桌子，某种旋律浅浅地向天空盘旋，像是沉迷在自己的世界里，开着许多人渴望却止步的演唱会，享受着台下的尖叫声和五颜六色的拥有魔力的聚光灯。风骤然剧烈，吹过他骄傲的经过高级理发师精心修理的时尚的头发，发泽乌黑，略带桀骜的纹边，就像少年嘴角的笑，随风摇荡，肆意张扬。\n\n哼完几句歌，于是他趴在放满书的岁月雕刻的桌子上，双手微掩着脸，兴许是累了，趴了一会，他粗重的呼吸缓缓变轻，像是暴风雨过后的水面，归于平静。\n\n我看着他的侧脸愣了愣神，岁月似乎从未在他的略瘦的英俊的脸留下痕迹，反而衬托得愈发灿烂，如同太阳下的少年手上的钻石，散发着昏眩的金光。他的脸上的线条菱角分明，像是上帝亲手刻的一幅画，掉落人间。我想，他一定与众不凡。\n\n我拿起空白的笔记本的一页，轻轻的写下：遇见了一个与众不凡的人，也许在未来或者不久之后会遇见并且相识，我相信，我会被他的一切折服。记 —— 2018.9.23\n\n寥寥几十个字仿佛深深刻印在了笔记本里，我正要起身离开，余光正好见他缩回了倚靠着脸的左手，我随意一瞥，看到写在他书本上的两个字，大气磅礴。\n\n秦宇!\n\n我轻轻笑了笑，收拾手中的和桌子的书，离开了这间教室。越走越远，我看向远方，有人在那里等着我。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"自我 - 温润少年",frontmatter:{title:"自我 - 温润少年",date:"2022-02-19T19:05:15.000Z",permalink:"/about/liang-shi-bo/",private:!0,titleTag:"原创",categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/11.%E8%87%AA%E6%88%91%20-%20%E6%B8%A9%E6%B6%A6%E5%B0%91%E5%B9%B4.html",relativePath:"80.关于/03.关于 - 自我/11.自我 - 温润少年.md",key:"v-66b3d6ef",path:"/about/liang-shi-bo/",headersStr:null,content:"笔记\n\n记录大学的一位朋友。\n\n2022-02-19 @Du Wu\n\n他穿着件黄色的短袖，以及灰白色的黑条纹刻边的长裤，遮住了瘦弱的令无数女生嫉妒羡慕的身躯。他戴着普通平凡的没有更换过的蓝色口罩，微露的脸颊两侧有了些许岁月的刻痕。教室的电风扇彼此呼应，共鸣而出的风声又被其旋转绞灭，而卷起的风，轻轻地划过他的头发，色泽发黑，精短清爽，他仿佛遥远的大山的放牧的少年，坐着草地上，轻轻吹着笛声，悠远深情。\n\n此时的他微低着头，眼睛前的概率笔记时不时被他纤细的手往前翻开，笔记的内容仿佛汪洋大海，又仿佛一曲音符，被他缓慢的吸收吐纳。他习惯性的抖着腿，淡蓝色花纹圈住的黑色的镜框点缀了他干净的双眼，也藏不住他对知识的渴望和生命的认知。他恬静优雅，周围的声音似乎无法进入他的世界，扰乱接受知识的心神。徒然间，他皱了皱眉，双腿抖动的频率愈发加快，嘴里喃喃自语，似是遇到了阻碍，微眯着的双眼一点点亮光出现，慢慢照亮前方的那堵墙，分析它的结构，一一分解，逐个击破。\n\n我看了看他的侧脸，有些愣神，他学习的认真似乎让我回到了那个青葱的无比怀念的年代，那时候的我也是如此，揣怀着梦想，在灿烂的阳光下肆意迸发，在油绿的草地里畅意飞奔，在狭隘的空间中无限延伸。看着他，我希望他能一直保持这份在晦暗交错的大时代下的少年精神。\n\n我拿起空白的练习册的一页，轻轻的写下：遇见了一个与众不凡的人，也许在未来或者不久之后会遇见并且相识，我相信，我会被他的一切折服。记 —— 2020.5.18\n\n寥寥几个字深深刻在了练习册里，此时早晨的阳光照进了教室，风扇割裂着它，却让狂暴的风逐渐柔和，暖进每个人的肌肤。我正要起身离开，余光正好见他轻轻地翻到了第一页，我随意一瞥，看到写在他笔记本上的三个字，温润如玉。\n\n梁师博!\n\n我轻轻笑了笑，收拾手中的和桌子的书，离开了这间教室。越走越远，我看向远方，有人在那里等着我。",normalizedContent:"笔记\n\n记录大学的一位朋友。\n\n2022-02-19 @du wu\n\n他穿着件黄色的短袖，以及灰白色的黑条纹刻边的长裤，遮住了瘦弱的令无数女生嫉妒羡慕的身躯。他戴着普通平凡的没有更换过的蓝色口罩，微露的脸颊两侧有了些许岁月的刻痕。教室的电风扇彼此呼应，共鸣而出的风声又被其旋转绞灭，而卷起的风，轻轻地划过他的头发，色泽发黑，精短清爽，他仿佛遥远的大山的放牧的少年，坐着草地上，轻轻吹着笛声，悠远深情。\n\n此时的他微低着头，眼睛前的概率笔记时不时被他纤细的手往前翻开，笔记的内容仿佛汪洋大海，又仿佛一曲音符，被他缓慢的吸收吐纳。他习惯性的抖着腿，淡蓝色花纹圈住的黑色的镜框点缀了他干净的双眼，也藏不住他对知识的渴望和生命的认知。他恬静优雅，周围的声音似乎无法进入他的世界，扰乱接受知识的心神。徒然间，他皱了皱眉，双腿抖动的频率愈发加快，嘴里喃喃自语，似是遇到了阻碍，微眯着的双眼一点点亮光出现，慢慢照亮前方的那堵墙，分析它的结构，一一分解，逐个击破。\n\n我看了看他的侧脸，有些愣神，他学习的认真似乎让我回到了那个青葱的无比怀念的年代，那时候的我也是如此，揣怀着梦想，在灿烂的阳光下肆意迸发，在油绿的草地里畅意飞奔，在狭隘的空间中无限延伸。看着他，我希望他能一直保持这份在晦暗交错的大时代下的少年精神。\n\n我拿起空白的练习册的一页，轻轻的写下：遇见了一个与众不凡的人，也许在未来或者不久之后会遇见并且相识，我相信，我会被他的一切折服。记 —— 2020.5.18\n\n寥寥几个字深深刻在了练习册里，此时早晨的阳光照进了教室，风扇割裂着它，却让狂暴的风逐渐柔和，暖进每个人的肌肤。我正要起身离开，余光正好见他轻轻地翻到了第一页，我随意一瞥，看到写在他笔记本上的三个字，温润如玉。\n\n梁师博!\n\n我轻轻笑了笑，收拾手中的和桌子的书，离开了这间教室。越走越远，我看向远方，有人在那里等着我。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"自我 - 清单",frontmatter:{title:"自我 - 清单",date:"2021-11-13T12:31:23.000Z",permalink:"/about/list/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/05.%E8%87%AA%E6%88%91%20-%20%E6%B8%85%E5%8D%95.html",relativePath:"80.关于/03.关于 - 自我/05.自我 - 清单.md",key:"v-5df3ba47",path:"/about/list/",headers:[{level:2,title:"Spring Boot 清单",slug:"spring-boot-清单",normalizedTitle:"spring boot 清单",charIndex:126},{level:2,title:"TypeScript 清单",slug:"typescript-清单",normalizedTitle:"typescript 清单",charIndex:491},{level:2,title:"Jenkins 清单",slug:"jenkins-清单",normalizedTitle:"jenkins 清单",charIndex:2931},{level:2,title:"ActiveMQ 清单",slug:"activemq-清单",normalizedTitle:"activemq 清单",charIndex:3165},{level:2,title:"Vue 清单",slug:"vue-清单",normalizedTitle:"vue 清单",charIndex:3897},{level:2,title:"JUC 清单",slug:"juc-清单",normalizedTitle:"juc 清单",charIndex:4187},{level:2,title:"Java 清单",slug:"java-清单",normalizedTitle:"java 清单",charIndex:4789},{level:2,title:"算法清单",slug:"算法清单",normalizedTitle:"算法清单",charIndex:4895},{level:2,title:"设计模式清单",slug:"设计模式清单",normalizedTitle:"设计模式清单",charIndex:5328},{level:2,title:"React 清单",slug:"react-清单",normalizedTitle:"react 清单",charIndex:6742},{level:2,title:"Java 版本新特性清单",slug:"java-版本新特性清单",normalizedTitle:"java 版本新特性清单",charIndex:7152},{level:2,title:"Git 清单",slug:"git-清单",normalizedTitle:"git 清单",charIndex:7646},{level:2,title:"Maven 清单",slug:"maven-清单",normalizedTitle:"maven 清单",charIndex:8060},{level:2,title:"JVM 清单",slug:"jvm-清单",normalizedTitle:"jvm 清单",charIndex:8213},{level:2,title:"Redis 清单",slug:"redis-清单",normalizedTitle:"redis 清单",charIndex:9766},{level:2,title:"Spring Security 清单",slug:"spring-security-清单",normalizedTitle:"spring security 清单",charIndex:10684},{level:2,title:"Nginx 清单",slug:"nginx-清单",normalizedTitle:"nginx 清单",charIndex:11163},{level:2,title:"Docker 清单",slug:"docker-清单",normalizedTitle:"docker 清单",charIndex:12048},{level:2,title:"ElasticSearch 清单",slug:"elasticsearch-清单",normalizedTitle:"elasticsearch 清单",charIndex:12673},{level:2,title:"RabbitMQ 清单",slug:"rabbitmq-清单",normalizedTitle:"rabbitmq 清单",charIndex:13811},{level:2,title:"轮子使用清单",slug:"轮子使用清单",normalizedTitle:"轮子使用清单",charIndex:14495},{level:2,title:"随笔清单",slug:"随笔清单",normalizedTitle:"随笔清单",charIndex:14709},{level:2,title:"关于清单",slug:"关于清单",normalizedTitle:"关于清单",charIndex:15197},{level:2,title:"项目工程清单",slug:"项目工程清单",normalizedTitle:"项目工程清单",charIndex:16522},{level:2,title:"MySQL 清单",slug:"mysql-清单",normalizedTitle:"mysql 清单",charIndex:17197}],excerpt:'<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>记录习惯，生活更加可见性有序。</p>\n<div class="custom-block right">\n<p>2021-11-13 @Du Wu</p>\n</div>\n</div>\n',headersStr:"Spring Boot 清单 TypeScript 清单 Jenkins 清单 ActiveMQ 清单 Vue 清单 JUC 清单 Java 清单 算法清单 设计模式清单 React 清单 Java 版本新特性清单 Git 清单 Maven 清单 JVM 清单 Redis 清单 Spring Security 清单 Nginx 清单 Docker 清单 ElasticSearch 清单 RabbitMQ 清单 轮子使用清单 随笔清单 关于清单 项目工程清单 MySQL 清单",content:"序言\n\n记录习惯，生活更加可见性有序。\n\n2021-11-13 @Du Wu\n\n记录一些知识体系的创建和更新清单，养成一种好习惯。\n\n更新时间要么是发布的时间，要么是发布后最后一次更新的时间。\n\n按照最新体系的第一个知识内容创建时间进行升序。\n\n\n# Spring Boot 清单\n\nSpring Boot 目录\n\n知识体系          知识内容                         创建时间         更新时间\nSpring Boot   Spring Boot - 映射请求           2022-12-22   2022-12-22\nSpring Boot   Spring Boot - 请求参数接收         2022-12-12   2022-12-12\nSpring Boot   Spring Boot - RestTemplate   2022-12-12   2022-12-12\nSpring Boot   Spring Boot - 参数校验           2022-12-11   2022-12-11\n\n\n# TypeScript 清单\n\nTypeScript 目录\n\n知识体系         知识内容                          创建时间         更新时间\nTypeScript   TypeScript Office - 三斜线指令     2022-09-17   2022-09-17\nTypeScript   TypeScript Office - 声明合并      2022-09-17   2022-09-17\nTypeScript   TypeScript Office - 命名空间与模块   2022-09-16   2022-09-17\nTypeScript   TypeScript Office - 命名空间      2022-09-16   2022-09-17\nTypeScript   TypeScript Office - 模块解析      2022-09-16   2022-09-17\nTypeScript   TypeScript Office - 模块进阶      2022-09-16   2022-09-17\nTypeScript   TypeScript Office - 混入        2022-09-16   2022-09-17\nTypeScript   TypeScript Office - JSX       2022-09-15   2022-09-17\nTypeScript   TypeScript Office - 装饰器       2022-09-15   2022-09-17\nTypeScript   TypeScript Office - 迭代器和生成器   2022-09-15   2022-09-17\nTypeScript   TypeScript Office - 类型兼容性     2022-09-14   2022-09-17\nTypeScript   TypeScript Office - Symbols   2022-09-14   2022-09-17\nTypeScript   TypeScript Office - 公共类型      2022-09-14   2022-09-17\nTypeScript   TypeScript Office - 枚举        2022-09-14   2022-09-17\nTypeScript   TypeScript Office - 类型推断      2022-09-13   2022-09-17\nTypeScript   TypeScript Office - 变量声明      2022-09-13   2022-09-17\nTypeScript   TypeScript Office - 模块        2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 类         2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 类型操纵      2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 对象类型      2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 更多函数      2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 类型缩小      2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 常用类型      2022-09-12   2022-09-17\nTypeScript   TypeScript Office - 入门        2022-09-11   2022-09-17\nTypeScript   TypeScript - 高级类型             2022-09-08   2022-09-12\nTypeScript   TypeScript - 类型推断             2022-09-08   2022-09-12\nTypeScript   TypeScript - 泛型               2022-09-08   2022-09-12\nTypeScript   TypeScript - 类                2022-09-08   2022-09-12\nTypeScript   TypeScript - 函数               2022-09-08   2022-09-12\nTypeScript   TypeScript - 接口               2022-09-08   2022-09-12\nTypeScript   TypeScript - 文件打包             2022-09-08   2022-09-12\nTypeScript   TypeScript - 编译和配置            2022-09-08   2022-09-12\nTypeScript   TypeScript - 基本类型             2022-09-07   2022-09-12\nTypeScript   TypeScript - 安装和使用            2022-09-08   2022-09-12\nTypeScript   TypeScript - 介绍               2022-08-31   2022-09-12\n\n\n# Jenkins 清单\n\nJenkins 目录\n\n知识体系      知识内容               创建时间         更新时间\nJenkins   Jenkins - 多个项目搭建   2022-08-24   2022-08-24\nJenkins   Jenkins - 安装和配置    2022-08-22   2022-08-24\nJenkins   Jenkins - 介绍       2022-08-21   2022-08-24\n\n\n# ActiveMQ 清单\n\nActiveMQ 目录\n\n知识体系       知识内容                    创建时间         更新时间\nActiveMQ   ActiveMQ - 高级特性         2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 外部持久化        2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 传输协议         2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - Spring框架集成   2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 事务性          2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 自带持久化        2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - JMS规范        2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 主题           2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 队列           2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 安装           2022-07-30   2022-07-30\nActiveMQ   ActiveMQ - 概述           2022-07-30   2022-07-30\n\n\n# Vue 清单\n\nVue 目录\n\n知识体系   知识内容           创建时间         更新时间\nVue    Vue2 - Vue路由   2022-07-21   2022-07-27\nVue    Vue2 - Vuex    2022-07-21   2022-07-27\nVue    Vue2 - 组件      2022-07-22   2022-07-27\nVue    Vue2 - 生命周期    2022-07-27   2022-07-28\nVue    Vue2 - 基础      2022-07-28   2022-07-28\n\n\n# JUC 清单\n\nJUC 目录\n\n知识体系   知识内容              创建时间         更新时间\nJUC    JUC - 共享模式之并发类    2022-05-21   2022-05-24\nJUC    JUC - 共享模型之读写锁    2022-05-18   2022-05-24\nJUC    JUC - 共享模型之线程池    2022-05-15   2022-05-24\nJUC    JUC - 共享模型之不可变    2022-05-15   2022-05-15\nJUC    JUC - 共享模型之无锁     2022-05-13   2022-05-15\nJUC    JUC - 共享模式之内存     2022-05-12   2022-05-15\nJUC    JUC - 共享模式之锁进阶    2022-05-12   2022-05-15\nJUC    JUC - 共享模式之锁基础    2022-05-12   2022-05-15\nJUC    JUC - 共享模型之管程安全   2022-05-08   2022-05-08\nJUC    JUC - Java线程      2022-05-04   2022-05-08\nJUC    JUC - 概念          2022-05-04   2022-05-06\n\n\n# Java 清单\n\nJava 目录\n\n知识体系   知识内容          创建时间         更新时间\nJava   JavaSE - 反射   2022-06-20   2022-06-21\n\n\n# 算法清单\n\n算法目录\n\n知识体系   知识内容            创建时间         更新时间\n算法     算法思想 - 回溯算法     2022-06-18   2022-06-21\n算法     算法思想 - 贪心算法     2022-06-01   2022-06-07\n算法     算法思想 - 优先遍历算法   2022-04-30   2022-05-01\n算法     算法思想 - 二分查找算法   2022-04-30   2022-05-01\n算法     算法模板 - 单调栈      2022-04-29   2022-05-01\n算法     算法模板 - 二叉树遍历    2022-04-27   2022-05-01\n算法     算法思想 - 动态规划算法   2022-04-20   2022-04-21\n算法     算法模板 - 滑动窗口模板   2022-04-19   2022-04-21\n\n\n# 设计模式清单\n\n设计模式目录\n\n知识体系   知识内容               创建时间         更新时间\n设计模式   设计模式 - 设计模式总结      2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型职责链模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型策略模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型状态模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型解释器模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型备忘录模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型中介模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型观察者模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型迭代器模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型访问者模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型命令模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型模板方法模式   2022-03-26   2022-03-27\n设计模式   设计模式 - 结构型代理模式     2022-03-16   2022-03-16\n设计模式   设计模式 - 结构型享元模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型外观模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型组合模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型装饰者模式    2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型桥接模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型适配器模式    2022-03-07   2022-03-08\n设计模式   设计模式 - 创建型建造者模式    2022-03-01   2022-03-01\n设计模式   设计模式 - 创建型原型模式     2022-03-01   2022-03-01\n设计模式   设计模式 - 创建型工厂模式     2022-02-27   2022-02-27\n设计模式   设计模式 - 创建型单例模式     2022-02-26   2022-02-26\n设计模式   设计模式 - 设计模式概述      2022-02-26   2022-02-26\n设计模式   设计模式 - UML类图       2022-02-26   2022-02-26\n设计模式   设计模式 - 设计思想        2022-02-24   2022-02-26\n设计模式   设计模式 - 七大原则认识      2022-02-24   2022-02-24\n\n\n# React 清单\n\nReact 目录\n\n知识体系    知识内容             创建时间         更新时间\nReact   父子传值与循环key       2022-02-26   2022-02-26\nReact   React - 进阶知识     2022-02-21   2022-02-21\nReact   React - 函数类型     2022-02-21   2022-02-21\nReact   React - Redux    2022-02-21   2022-02-21\nReact   React - 路由       2022-02-21   2022-02-21\nReact   React - 脚手架及使用   2022-02-21   2022-02-21\nReact   React - 基础与核心    2022-02-21   2022-02-21\n\n\n# Java 版本新特性清单\n\nJava 版本新特性目录\n\n知识体系         知识内容           创建时间         更新时间\nJava 版本新特性   Java15 - 新特性   2022-02-13   2022-02-13\nJava 版本新特性   Java14 - 新特性   2022-02-12   2022-02-12\nJava 版本新特性   Java13 - 新特性   2022-02-12   2022-02-12\nJava 版本新特性   Java12 - 新特性   2022-02-11   2022-02-12\nJava 版本新特性   Java11 - 新特性   2022-02-10   2022-02-11\nJava 版本新特性   Java10 - 新特性   2022-02-10   2022-02-10\nJava 版本新特性   Java9 - 新特性    2022-02-10   2022-02-10\nJava 版本新特性   Java8 - 新特性    2022-02-09   2022-02-10\n\n\n# Git 清单\n\nGit 目录\n\n知识体系   知识内容               创建时间         更新时间\nGit    Git - Commit常用表情   2022-02-08   2022-02-08\nGit    Git - 自建代码托管平台     2022-02-08   2022-02-08\nGit    Git - IDEA集成       2022-02-08   2022-02-08\nGit    Git - SSH免密登录      2022-02-08   2022-02-08\nGit    Git - 基本原理         2022-02-08   2022-02-08\nGit    Git - 常用命令         2022-02-08   2022-02-08\nGit    Git - 介绍与安装        2022-02-08   2022-02-08\n\n\n# Maven 清单\n\nMaven 目录\n\n知识体系    知识内容         创建时间         更新时间\nMaven   Maven - 进阶   2022-02-05   2022-02-06\nMaven   Maven - 基础   2022-02-04   2022-02-06\n\n\n# JVM 清单\n\nJVM 目录\n\n知识体系   知识内容                      创建时间         更新时间\nJVM    JVM - 分析GC日志              2022-02-01   2022-02-01\nJVM    JVM - 运行时参数               2022-02-01   2022-02-01\nJVM    JVM - 监控及诊断工具GUI          2022-01-31   2022-02-01\nJVM    JVM - 监控及诊断工具命令行          2022-01-31   2022-02-01\nJVM    JVM - 调优概述                2022-01-30   2022-02-01\nJVM    JVM - 再谈类的加载器             2022-01-30   2022-01-30\nJVM    JVM - 类的加载过程详解            2022-01-29   2022-01-30\nJVM    JVM - 字节码指令集与解析举例         2022-01-28   2022-01-29\nJVM    JVM - Class文件结构           2022-01-26   2022-01-27\nJVM    JVM - 垃圾回收器               2022-01-24   2022-01-25\nJVM    JVM - 垃圾回收相关概念            2022-01-24   2022-01-24\nJVM    JVM - 垃圾回收相关算法            2022-01-24   2022-01-24\nJVM    JVM - 垃圾回收概述              2022-01-24   2022-01-24\nJVM    JVM - StringTable字符串常量池   2022-01-23   2022-01-24\nJVM    JVM - 执行引擎                2022-01-23   2022-01-24\nJVM    JVM - 直接内存                2022-01-22   2022-01-23\nJVM    JVM - 对象实例化内存布局与访问定位      2022-01-22   2022-01-23\nJVM    JVM - 方法区                 2022-01-20   2022-01-22\nJVM    JVM - 堆                   2022-01-19   2022-01-20\nJVM    JVM - 本地方法栈               2022-01-18   2022-01-18\nJVM    JVM - 本地方法接口              2022-01-18   2022-01-18\nJVM    JVM - 虚拟机栈                2022-01-17   2022-01-18\nJVM    JVM - 程序计数器               2022-01-17   2022-01-18\nJVM    JVM - 运行时数据区概述及线程         2022-01-17   2022-01-18\nJVM    JVM - 类加载子系统              2022-01-17   2022-01-18\nJVM    JVM - Java体系结构            2022-01-15   2022-01-18\n\n\n# Redis 清单\n\nRedis 目录\n\n知识体系    知识内容                        创建时间         更新时间\nReids   Redis - Spring Data Redis   2022-12-11   2022-12-11\nRedis   Redis - 分布式锁                2021-12-26   2021-12-27\nRedis   Redis - 应用问题                2021-12-26   2021-12-27\nRedis   Redis - 集群搭建                2021-12-26   2021-12-27\nRedis   Redis - 主从复制                2021-12-26   2021-12-27\nRedis   Redis - 两种持久化               2021-12-26   2021-12-27\nRedis   Redis - 事务与锁                2021-12-26   2021-12-27\nRedis   Redis - Java整合              2021-12-26   2021-12-27\nRedis   Redis - 发布和订阅               2021-12-26   2021-12-27\nRedis   Redis - 配置文件                2021-12-26   2021-12-27\nRedis   Redis - 新增三大数据类型            2021-12-26   2021-12-27\nRedis   Redis - 五大数据类型及API          2021-12-25   2021-12-27\nRedis   Redis - 安装                  2021-12-25   2021-12-27\nRedis   Redis - 介绍                  2021-12-25   2021-12-27\n\n\n# Spring Security 清单\n\nSpring Security 目录\n\n知识体系              知识内容                 创建时间         更新时间\nSpring Security   Security - 源码与流程     2021-12-25   2021-12-27\nSpring Security   Security - JWT介绍     2021-12-25   2021-12-27\nSpring Security   Security - 信息验证      2021-12-25   2021-12-27\nSpring Security   Security - 概念与权限     2021-12-25   2021-12-27\nSpring Security   Security - 介绍        2021-12-25   2021-12-27\nSpring Security   Security - JWT登录实战   2021-12-24   2021-12-27\n\n\n# Nginx 清单\n\nNginx 目录\n\n知识体系    知识内容               创建时间         更新时间\nNginx   Nginx - 自定义镜像      2021-12-14   2021-12-15\nNginx   Nginx - Lua模块文档表   2021-11-30   2021-11-30\nNginx   Nginx - Lua扩展模块    2021-11-29   2021-11-30\nNginx   Nginx - Lau学习      2021-11-29   2021-11-30\nNginx   Nginx - 站点与认证      2021-11-29   2021-11-30\nNginx   Nginx - 部署与集群      2021-11-29   2021-11-30\nNginx   Nginx - 缓存集成       2021-11-28   2021-11-29\nNginx   Nginx - 负载均衡       2021-11-28   2021-11-29\nNginx   Nginx - 反向代理       2021-11-27   2021-11-29\nNginx   Nginx - 静态资源访问     2021-11-27   2021-11-29\nNginx   Nginx - 静态资源部署     2021-11-27   2021-11-29\nNginx   Nginx - 配置巩固实例     2021-11-26   2021-11-29\nNginx   Nginx - 核心配置文件     2021-11-26   2021-11-29\nNginx   Nginx - 基础指令       2021-11-26   2021-11-29\nNginx   Nginx - 环境准备       2021-11-25   2021-11-26\nNginx   Nginx - 介绍         2021-11-25   2021-11-26\n\n\n# Docker 清单\n\nDocker 目录\n\n知识体系     知识内容                  创建时间         更新时间\nDocker   Docker - Maven插件      2021-12-10   2021-12-11\nDocker   Docker - 软件安装         2021-11-24   2021-11-24\nDocker   Docker - Compose      2021-11-22   2021-11-24\nDocker   Docker - Dockerfile   2021-11-21   2021-11-24\nDocker   Docker - 数据卷          2021-11-20   2021-11-24\nDocker   Docker - 网络网桥         2021-11-20   2021-11-24\nDocker   Docker - 镜像原理         2021-11-20   2021-11-24\nDocker   Docker - 常用命令         2021-11-19   2021-11-24\nDocker   Docker - 安装           2021-11-19   2021-11-24\nDocker   Docker - 介绍           2021-11-19   2021-11-24\n\n\n# ElasticSearch 清单\n\nElasticSearch 目录\n\n知识体系            知识内容                         创建时间         更新时间\nElasticSearch   ElasticSearch - 面试题          2021-11-18   2021-11-18\nElasticSearch   ElasticSearch - 进阶优化         2021-11-18   2021-11-18\nElasticSearch   ElasticSearch - 多框架集成        2021-11-17   2021-11-18\nElasticSearch   ElasticSearch - 冲突问题处理       2021-11-17   2021-11-18\nElasticSearch   ElasticSearch - 多种分析器        2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - 分片操作原理       2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - 分片控制流程       2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - 分布式集群和路由计算   2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - 进阶概念         2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - 搭建集群         2021-11-16   2021-11-18\nElasticSearch   ElasticSearch - Java操作       2021-11-15   2021-11-18\nElasticSearch   ElasticSearch - 高级操作         2021-11-14   2021-11-18\nElasticSearch   ElasticSearch - 基本操作         2021-11-14   2021-11-18\nElasticSearch   ElasticSearch - 安装           2021-11-14   2021-11-18\nElasticSearch   ElasticSearch - 基础概念         2021-11-14   2021-11-18\n\n\n# RabbitMQ 清单\n\nRabbitMQ 目录\n\n知识体系       知识内容                创建时间         更新时间\nRabbitMQ   RabbitMQ - 优先级      2021-11-12   2021-11-12\nRabbitMQ   RabbitMQ - 高级发布确认   2021-11-11   2021-11-12\nRabbitMQ   RabbitMQ - 延迟队列     2021-11-10   2021-11-12\nRabbitMQ   RabbitMQ - 死信队列     2021-11-10   2021-11-12\nRabbitMQ   RabbitMQ - 交换机      2021-11-10   2021-11-12\nRabbitMQ   RabbitMQ - 应答与发布    2021-11-09   2021-11-12\nRabbitMQ   RabbitMQ - 基础案例     2021-11-09   2021-11-12\nRabbitMQ   RabbitMQ - 安装       2021-11-08   2021-11-12\nRabbitMQ   RabbitMQ - 介绍       2021-11-08   2021-11-12\nRabbitMQ   消息队列 - 介绍           2021-11-08   2021-11-12\nRabbitMQ   中间件 - 介绍            2021-11-08   2021-11-12\n\n\n# 轮子使用清单\n\n轮子介绍目录\n\n知识体系   知识内容               创建时间         更新时间\n轮子使用   DBeaver - SQL连接器   2021-12-12   2021-12-15\n轮子使用   Shields 徽章         2021-10-29   2021-10-29\n轮子使用   轮子介绍               2021-10-29   2021-10-29\n\n\n# 随笔清单\n\n技术随笔目录\n\n生活随笔目录\n\n知识体系   知识内容                 创建时间         更新时间\n生活随笔   生活随笔 - 习惯            2022-02-19   2022-02-19\n生活随笔   生活随笔 - 美词            2022-02-19   2022-02-19\n技术随笔   右键打开 IDEA 和 VSCode   2022-07-28   2022-07-28\n技术随笔   技术随笔 - Java启动的-D参数   2022-03-02   2022-03-02\n技术随笔   技术随笔 - 360天擎关闭       2022-02-22   2022-02-22\n技术随笔   Maven - 上传中央仓库       2022-02-07   2022-02-07\n技术随笔   Github - 好看的主页       2022-01-09   2022-01-09\n技术随笔   技术随笔 - 域名解析          2021-12-01   2021-12-17\n\n\n# 关于清单\n\n关于自我目录\n\n关于本站目录\n\n关于技巧目录\n\n知识体系      知识内容              创建时间         更新时间\n关于 - 自我   自我 - 温润少年         2022-02-19   2022-02-19\n关于 - 自我   自我 - 尊贵公子         2022-02-19   2022-02-19\n关于 - 自我   自我 - 学习线          2021-11-13   2021-11-13\n关于 - 自我   自我 - 清单           2021-11-13   一直在更新清单\n关于 - 自我   自我 - 介绍           2021-11-03   2021-11-03\n关于 - 本站   本站 - 全局时间消息提示模块   2022-02-13   2022-02-13\n关于 - 本站   本站 - 代码块隐藏模块      2022-02-13   2022-02-13\n关于 - 本站   本站 - 首页大图模块       2022-01-12   2022-01-13\n关于 - 本站   本站 - 导航站模块        2022-01-11   2022-01-11\n关于 - 本站   本站 - 私密文章模块       2022-01-07   2022-01-08\n关于 - 本站   本站 - 记录曾阅读位置插件    2022-01-04   2022-01-04\n关于 - 本站   本站 - 自定义样式模块      2021-01-01   2021-01-02\n关于 - 本站   本站 - 站点信息         2021-12-30   2021-01-02\n关于 - 本站   本站 - 服务器部署        2021-12-03   2021-12-09\n关于 - 本站   本站 - 主题           2021-11-07   2021-11-07\n关于 - 本站   本站 - 网站部署         2021-11-01   2021-11-01\n关于 - 本站   本站 - 规划           2021-11-01   2021-11-01\n关于 - 本站   本站 - 介绍           2021-11-01   2021-11-01\n关于 - 本站   本站 - 搭建           2021-10-31   2021-10-31\n关于 - 本站   本站 - 评论           2021-10-29   2021-10-29\n关于 - 首页   首页 - 下载站点         2021-12-14   2021-12-15\n关于 - 首页   首页 - 部署           2021-12-09   2021-12-10\n关于 - 技巧   排版 - 技巧           2021-11-13   2021-11-13\n关于 - 技巧   笔记 - 技巧           2021-10-28   2021-10-28\n\n\n# 项目工程清单\n\n项目过程目录页\n\ntbeam 项目目录\n\n报修系统目录\n\nYonYou 工程目录\n\n知识体系   知识内容                      发布时间         更新时间\n项目工程   YonYou - Client端开发        2022-03-03   2022-03-03\n项目工程   YonYou - 开发流程             2022-03-02   2022-03-02\n项目工程   YonYou - NCC节点开发          2022-02-23   2022-02-23\n项目工程   YonYou - 节点配置             2022-02-22   2022-02-22\n项目工程   报修系统 - 部署                 2021-11-30   2021-11-30\n项目工程   报修系统 - 详解                 2021-10-30   2021-11-02\n项目工程   tbeam - 技巧                2021-11-07   2021-11-07\n项目工程   Ant Design Vue 3.x - 新增   2021-10-28   2021-11-07\n项目工程   Ant Design Vue 3.x - 表格   2021-10-26   2021-10-26\n项目工程   tbeam 项目介绍                2021-10-28   2021-10-28\n\n\n# MySQL 清单\n\nMySQL 目录\n\n知识体系       知识内容              发布时间         更新时间\nMySQL 高级   MySQL - 主从复制      2021-10-24   2021-10-24\nMySQL 高级   MySQL - 日志        2021-10-24   2021-10-24\nMySQL 高级   MySQL - 常用工具      2021-10-24   2021-10-24\nMySQL 高级   MySQL - 常用sql     2021-10-24   2021-10-24\nMySQL 高级   MySQL - 锁问题       2021-10-24   2021-10-24\nMySQL 高级   MySQL - 并发参数优化    2021-10-24   2021-10-24\nMySQL 高级   MySQL - 内存管理优化    2021-10-24   2021-10-24\nMySQL 高级   MySQL - 缓存查询优化    2021-10-24   2021-10-24\nMySQL 高级   MySQL - SQL语句优化   2021-10-24   2021-10-24\nMySQL 高级   MySQL - 索引的使用     2021-10-24   2021-10-24\nMySQL 高级   MySQL - 检测优化SQL   2021-10-24   2021-10-24\nMySQL 高级   MySQL - 逻辑架构简介    2021-10-24   2021-10-24\nMySQL 高级   MySQL - 索引介绍      2021-10-24   2021-10-24\nMySQL 高级   初识MySQL           2021-10-24   2021-10-24",normalizedContent:"序言\n\n记录习惯，生活更加可见性有序。\n\n2021-11-13 @du wu\n\n记录一些知识体系的创建和更新清单，养成一种好习惯。\n\n更新时间要么是发布的时间，要么是发布后最后一次更新的时间。\n\n按照最新体系的第一个知识内容创建时间进行升序。\n\n\n# spring boot 清单\n\nspring boot 目录\n\n知识体系          知识内容                         创建时间         更新时间\nspring boot   spring boot - 映射请求           2022-12-22   2022-12-22\nspring boot   spring boot - 请求参数接收         2022-12-12   2022-12-12\nspring boot   spring boot - resttemplate   2022-12-12   2022-12-12\nspring boot   spring boot - 参数校验           2022-12-11   2022-12-11\n\n\n# typescript 清单\n\ntypescript 目录\n\n知识体系         知识内容                          创建时间         更新时间\ntypescript   typescript office - 三斜线指令     2022-09-17   2022-09-17\ntypescript   typescript office - 声明合并      2022-09-17   2022-09-17\ntypescript   typescript office - 命名空间与模块   2022-09-16   2022-09-17\ntypescript   typescript office - 命名空间      2022-09-16   2022-09-17\ntypescript   typescript office - 模块解析      2022-09-16   2022-09-17\ntypescript   typescript office - 模块进阶      2022-09-16   2022-09-17\ntypescript   typescript office - 混入        2022-09-16   2022-09-17\ntypescript   typescript office - jsx       2022-09-15   2022-09-17\ntypescript   typescript office - 装饰器       2022-09-15   2022-09-17\ntypescript   typescript office - 迭代器和生成器   2022-09-15   2022-09-17\ntypescript   typescript office - 类型兼容性     2022-09-14   2022-09-17\ntypescript   typescript office - symbols   2022-09-14   2022-09-17\ntypescript   typescript office - 公共类型      2022-09-14   2022-09-17\ntypescript   typescript office - 枚举        2022-09-14   2022-09-17\ntypescript   typescript office - 类型推断      2022-09-13   2022-09-17\ntypescript   typescript office - 变量声明      2022-09-13   2022-09-17\ntypescript   typescript office - 模块        2022-09-12   2022-09-17\ntypescript   typescript office - 类         2022-09-12   2022-09-17\ntypescript   typescript office - 类型操纵      2022-09-12   2022-09-17\ntypescript   typescript office - 对象类型      2022-09-12   2022-09-17\ntypescript   typescript office - 更多函数      2022-09-12   2022-09-17\ntypescript   typescript office - 类型缩小      2022-09-12   2022-09-17\ntypescript   typescript office - 常用类型      2022-09-12   2022-09-17\ntypescript   typescript office - 入门        2022-09-11   2022-09-17\ntypescript   typescript - 高级类型             2022-09-08   2022-09-12\ntypescript   typescript - 类型推断             2022-09-08   2022-09-12\ntypescript   typescript - 泛型               2022-09-08   2022-09-12\ntypescript   typescript - 类                2022-09-08   2022-09-12\ntypescript   typescript - 函数               2022-09-08   2022-09-12\ntypescript   typescript - 接口               2022-09-08   2022-09-12\ntypescript   typescript - 文件打包             2022-09-08   2022-09-12\ntypescript   typescript - 编译和配置            2022-09-08   2022-09-12\ntypescript   typescript - 基本类型             2022-09-07   2022-09-12\ntypescript   typescript - 安装和使用            2022-09-08   2022-09-12\ntypescript   typescript - 介绍               2022-08-31   2022-09-12\n\n\n# jenkins 清单\n\njenkins 目录\n\n知识体系      知识内容               创建时间         更新时间\njenkins   jenkins - 多个项目搭建   2022-08-24   2022-08-24\njenkins   jenkins - 安装和配置    2022-08-22   2022-08-24\njenkins   jenkins - 介绍       2022-08-21   2022-08-24\n\n\n# activemq 清单\n\nactivemq 目录\n\n知识体系       知识内容                    创建时间         更新时间\nactivemq   activemq - 高级特性         2022-07-30   2022-07-30\nactivemq   activemq - 外部持久化        2022-07-30   2022-07-30\nactivemq   activemq - 传输协议         2022-07-30   2022-07-30\nactivemq   activemq - spring框架集成   2022-07-30   2022-07-30\nactivemq   activemq - 事务性          2022-07-30   2022-07-30\nactivemq   activemq - 自带持久化        2022-07-30   2022-07-30\nactivemq   activemq - jms规范        2022-07-30   2022-07-30\nactivemq   activemq - 主题           2022-07-30   2022-07-30\nactivemq   activemq - 队列           2022-07-30   2022-07-30\nactivemq   activemq - 安装           2022-07-30   2022-07-30\nactivemq   activemq - 概述           2022-07-30   2022-07-30\n\n\n# vue 清单\n\nvue 目录\n\n知识体系   知识内容           创建时间         更新时间\nvue    vue2 - vue路由   2022-07-21   2022-07-27\nvue    vue2 - vuex    2022-07-21   2022-07-27\nvue    vue2 - 组件      2022-07-22   2022-07-27\nvue    vue2 - 生命周期    2022-07-27   2022-07-28\nvue    vue2 - 基础      2022-07-28   2022-07-28\n\n\n# juc 清单\n\njuc 目录\n\n知识体系   知识内容              创建时间         更新时间\njuc    juc - 共享模式之并发类    2022-05-21   2022-05-24\njuc    juc - 共享模型之读写锁    2022-05-18   2022-05-24\njuc    juc - 共享模型之线程池    2022-05-15   2022-05-24\njuc    juc - 共享模型之不可变    2022-05-15   2022-05-15\njuc    juc - 共享模型之无锁     2022-05-13   2022-05-15\njuc    juc - 共享模式之内存     2022-05-12   2022-05-15\njuc    juc - 共享模式之锁进阶    2022-05-12   2022-05-15\njuc    juc - 共享模式之锁基础    2022-05-12   2022-05-15\njuc    juc - 共享模型之管程安全   2022-05-08   2022-05-08\njuc    juc - java线程      2022-05-04   2022-05-08\njuc    juc - 概念          2022-05-04   2022-05-06\n\n\n# java 清单\n\njava 目录\n\n知识体系   知识内容          创建时间         更新时间\njava   javase - 反射   2022-06-20   2022-06-21\n\n\n# 算法清单\n\n算法目录\n\n知识体系   知识内容            创建时间         更新时间\n算法     算法思想 - 回溯算法     2022-06-18   2022-06-21\n算法     算法思想 - 贪心算法     2022-06-01   2022-06-07\n算法     算法思想 - 优先遍历算法   2022-04-30   2022-05-01\n算法     算法思想 - 二分查找算法   2022-04-30   2022-05-01\n算法     算法模板 - 单调栈      2022-04-29   2022-05-01\n算法     算法模板 - 二叉树遍历    2022-04-27   2022-05-01\n算法     算法思想 - 动态规划算法   2022-04-20   2022-04-21\n算法     算法模板 - 滑动窗口模板   2022-04-19   2022-04-21\n\n\n# 设计模式清单\n\n设计模式目录\n\n知识体系   知识内容               创建时间         更新时间\n设计模式   设计模式 - 设计模式总结      2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型职责链模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型策略模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型状态模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型解释器模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型备忘录模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型中介模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型观察者模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型迭代器模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型访问者模式    2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型命令模式     2022-03-26   2022-03-27\n设计模式   设计模式 - 行为型模板方法模式   2022-03-26   2022-03-27\n设计模式   设计模式 - 结构型代理模式     2022-03-16   2022-03-16\n设计模式   设计模式 - 结构型享元模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型外观模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型组合模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型装饰者模式    2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型桥接模式     2022-03-14   2022-03-16\n设计模式   设计模式 - 结构型适配器模式    2022-03-07   2022-03-08\n设计模式   设计模式 - 创建型建造者模式    2022-03-01   2022-03-01\n设计模式   设计模式 - 创建型原型模式     2022-03-01   2022-03-01\n设计模式   设计模式 - 创建型工厂模式     2022-02-27   2022-02-27\n设计模式   设计模式 - 创建型单例模式     2022-02-26   2022-02-26\n设计模式   设计模式 - 设计模式概述      2022-02-26   2022-02-26\n设计模式   设计模式 - uml类图       2022-02-26   2022-02-26\n设计模式   设计模式 - 设计思想        2022-02-24   2022-02-26\n设计模式   设计模式 - 七大原则认识      2022-02-24   2022-02-24\n\n\n# react 清单\n\nreact 目录\n\n知识体系    知识内容             创建时间         更新时间\nreact   父子传值与循环key       2022-02-26   2022-02-26\nreact   react - 进阶知识     2022-02-21   2022-02-21\nreact   react - 函数类型     2022-02-21   2022-02-21\nreact   react - redux    2022-02-21   2022-02-21\nreact   react - 路由       2022-02-21   2022-02-21\nreact   react - 脚手架及使用   2022-02-21   2022-02-21\nreact   react - 基础与核心    2022-02-21   2022-02-21\n\n\n# java 版本新特性清单\n\njava 版本新特性目录\n\n知识体系         知识内容           创建时间         更新时间\njava 版本新特性   java15 - 新特性   2022-02-13   2022-02-13\njava 版本新特性   java14 - 新特性   2022-02-12   2022-02-12\njava 版本新特性   java13 - 新特性   2022-02-12   2022-02-12\njava 版本新特性   java12 - 新特性   2022-02-11   2022-02-12\njava 版本新特性   java11 - 新特性   2022-02-10   2022-02-11\njava 版本新特性   java10 - 新特性   2022-02-10   2022-02-10\njava 版本新特性   java9 - 新特性    2022-02-10   2022-02-10\njava 版本新特性   java8 - 新特性    2022-02-09   2022-02-10\n\n\n# git 清单\n\ngit 目录\n\n知识体系   知识内容               创建时间         更新时间\ngit    git - commit常用表情   2022-02-08   2022-02-08\ngit    git - 自建代码托管平台     2022-02-08   2022-02-08\ngit    git - idea集成       2022-02-08   2022-02-08\ngit    git - ssh免密登录      2022-02-08   2022-02-08\ngit    git - 基本原理         2022-02-08   2022-02-08\ngit    git - 常用命令         2022-02-08   2022-02-08\ngit    git - 介绍与安装        2022-02-08   2022-02-08\n\n\n# maven 清单\n\nmaven 目录\n\n知识体系    知识内容         创建时间         更新时间\nmaven   maven - 进阶   2022-02-05   2022-02-06\nmaven   maven - 基础   2022-02-04   2022-02-06\n\n\n# jvm 清单\n\njvm 目录\n\n知识体系   知识内容                      创建时间         更新时间\njvm    jvm - 分析gc日志              2022-02-01   2022-02-01\njvm    jvm - 运行时参数               2022-02-01   2022-02-01\njvm    jvm - 监控及诊断工具gui          2022-01-31   2022-02-01\njvm    jvm - 监控及诊断工具命令行          2022-01-31   2022-02-01\njvm    jvm - 调优概述                2022-01-30   2022-02-01\njvm    jvm - 再谈类的加载器             2022-01-30   2022-01-30\njvm    jvm - 类的加载过程详解            2022-01-29   2022-01-30\njvm    jvm - 字节码指令集与解析举例         2022-01-28   2022-01-29\njvm    jvm - class文件结构           2022-01-26   2022-01-27\njvm    jvm - 垃圾回收器               2022-01-24   2022-01-25\njvm    jvm - 垃圾回收相关概念            2022-01-24   2022-01-24\njvm    jvm - 垃圾回收相关算法            2022-01-24   2022-01-24\njvm    jvm - 垃圾回收概述              2022-01-24   2022-01-24\njvm    jvm - stringtable字符串常量池   2022-01-23   2022-01-24\njvm    jvm - 执行引擎                2022-01-23   2022-01-24\njvm    jvm - 直接内存                2022-01-22   2022-01-23\njvm    jvm - 对象实例化内存布局与访问定位      2022-01-22   2022-01-23\njvm    jvm - 方法区                 2022-01-20   2022-01-22\njvm    jvm - 堆                   2022-01-19   2022-01-20\njvm    jvm - 本地方法栈               2022-01-18   2022-01-18\njvm    jvm - 本地方法接口              2022-01-18   2022-01-18\njvm    jvm - 虚拟机栈                2022-01-17   2022-01-18\njvm    jvm - 程序计数器               2022-01-17   2022-01-18\njvm    jvm - 运行时数据区概述及线程         2022-01-17   2022-01-18\njvm    jvm - 类加载子系统              2022-01-17   2022-01-18\njvm    jvm - java体系结构            2022-01-15   2022-01-18\n\n\n# redis 清单\n\nredis 目录\n\n知识体系    知识内容                        创建时间         更新时间\nreids   redis - spring data redis   2022-12-11   2022-12-11\nredis   redis - 分布式锁                2021-12-26   2021-12-27\nredis   redis - 应用问题                2021-12-26   2021-12-27\nredis   redis - 集群搭建                2021-12-26   2021-12-27\nredis   redis - 主从复制                2021-12-26   2021-12-27\nredis   redis - 两种持久化               2021-12-26   2021-12-27\nredis   redis - 事务与锁                2021-12-26   2021-12-27\nredis   redis - java整合              2021-12-26   2021-12-27\nredis   redis - 发布和订阅               2021-12-26   2021-12-27\nredis   redis - 配置文件                2021-12-26   2021-12-27\nredis   redis - 新增三大数据类型            2021-12-26   2021-12-27\nredis   redis - 五大数据类型及api          2021-12-25   2021-12-27\nredis   redis - 安装                  2021-12-25   2021-12-27\nredis   redis - 介绍                  2021-12-25   2021-12-27\n\n\n# spring security 清单\n\nspring security 目录\n\n知识体系              知识内容                 创建时间         更新时间\nspring security   security - 源码与流程     2021-12-25   2021-12-27\nspring security   security - jwt介绍     2021-12-25   2021-12-27\nspring security   security - 信息验证      2021-12-25   2021-12-27\nspring security   security - 概念与权限     2021-12-25   2021-12-27\nspring security   security - 介绍        2021-12-25   2021-12-27\nspring security   security - jwt登录实战   2021-12-24   2021-12-27\n\n\n# nginx 清单\n\nnginx 目录\n\n知识体系    知识内容               创建时间         更新时间\nnginx   nginx - 自定义镜像      2021-12-14   2021-12-15\nnginx   nginx - lua模块文档表   2021-11-30   2021-11-30\nnginx   nginx - lua扩展模块    2021-11-29   2021-11-30\nnginx   nginx - lau学习      2021-11-29   2021-11-30\nnginx   nginx - 站点与认证      2021-11-29   2021-11-30\nnginx   nginx - 部署与集群      2021-11-29   2021-11-30\nnginx   nginx - 缓存集成       2021-11-28   2021-11-29\nnginx   nginx - 负载均衡       2021-11-28   2021-11-29\nnginx   nginx - 反向代理       2021-11-27   2021-11-29\nnginx   nginx - 静态资源访问     2021-11-27   2021-11-29\nnginx   nginx - 静态资源部署     2021-11-27   2021-11-29\nnginx   nginx - 配置巩固实例     2021-11-26   2021-11-29\nnginx   nginx - 核心配置文件     2021-11-26   2021-11-29\nnginx   nginx - 基础指令       2021-11-26   2021-11-29\nnginx   nginx - 环境准备       2021-11-25   2021-11-26\nnginx   nginx - 介绍         2021-11-25   2021-11-26\n\n\n# docker 清单\n\ndocker 目录\n\n知识体系     知识内容                  创建时间         更新时间\ndocker   docker - maven插件      2021-12-10   2021-12-11\ndocker   docker - 软件安装         2021-11-24   2021-11-24\ndocker   docker - compose      2021-11-22   2021-11-24\ndocker   docker - dockerfile   2021-11-21   2021-11-24\ndocker   docker - 数据卷          2021-11-20   2021-11-24\ndocker   docker - 网络网桥         2021-11-20   2021-11-24\ndocker   docker - 镜像原理         2021-11-20   2021-11-24\ndocker   docker - 常用命令         2021-11-19   2021-11-24\ndocker   docker - 安装           2021-11-19   2021-11-24\ndocker   docker - 介绍           2021-11-19   2021-11-24\n\n\n# elasticsearch 清单\n\nelasticsearch 目录\n\n知识体系            知识内容                         创建时间         更新时间\nelasticsearch   elasticsearch - 面试题          2021-11-18   2021-11-18\nelasticsearch   elasticsearch - 进阶优化         2021-11-18   2021-11-18\nelasticsearch   elasticsearch - 多框架集成        2021-11-17   2021-11-18\nelasticsearch   elasticsearch - 冲突问题处理       2021-11-17   2021-11-18\nelasticsearch   elasticsearch - 多种分析器        2021-11-16   2021-11-18\nelasticsearch   elasticsearch - 分片操作原理       2021-11-16   2021-11-18\nelasticsearch   elasticsearch - 分片控制流程       2021-11-16   2021-11-18\nelasticsearch   elasticsearch - 分布式集群和路由计算   2021-11-16   2021-11-18\nelasticsearch   elasticsearch - 进阶概念         2021-11-16   2021-11-18\nelasticsearch   elasticsearch - 搭建集群         2021-11-16   2021-11-18\nelasticsearch   elasticsearch - java操作       2021-11-15   2021-11-18\nelasticsearch   elasticsearch - 高级操作         2021-11-14   2021-11-18\nelasticsearch   elasticsearch - 基本操作         2021-11-14   2021-11-18\nelasticsearch   elasticsearch - 安装           2021-11-14   2021-11-18\nelasticsearch   elasticsearch - 基础概念         2021-11-14   2021-11-18\n\n\n# rabbitmq 清单\n\nrabbitmq 目录\n\n知识体系       知识内容                创建时间         更新时间\nrabbitmq   rabbitmq - 优先级      2021-11-12   2021-11-12\nrabbitmq   rabbitmq - 高级发布确认   2021-11-11   2021-11-12\nrabbitmq   rabbitmq - 延迟队列     2021-11-10   2021-11-12\nrabbitmq   rabbitmq - 死信队列     2021-11-10   2021-11-12\nrabbitmq   rabbitmq - 交换机      2021-11-10   2021-11-12\nrabbitmq   rabbitmq - 应答与发布    2021-11-09   2021-11-12\nrabbitmq   rabbitmq - 基础案例     2021-11-09   2021-11-12\nrabbitmq   rabbitmq - 安装       2021-11-08   2021-11-12\nrabbitmq   rabbitmq - 介绍       2021-11-08   2021-11-12\nrabbitmq   消息队列 - 介绍           2021-11-08   2021-11-12\nrabbitmq   中间件 - 介绍            2021-11-08   2021-11-12\n\n\n# 轮子使用清单\n\n轮子介绍目录\n\n知识体系   知识内容               创建时间         更新时间\n轮子使用   dbeaver - sql连接器   2021-12-12   2021-12-15\n轮子使用   shields 徽章         2021-10-29   2021-10-29\n轮子使用   轮子介绍               2021-10-29   2021-10-29\n\n\n# 随笔清单\n\n技术随笔目录\n\n生活随笔目录\n\n知识体系   知识内容                 创建时间         更新时间\n生活随笔   生活随笔 - 习惯            2022-02-19   2022-02-19\n生活随笔   生活随笔 - 美词            2022-02-19   2022-02-19\n技术随笔   右键打开 idea 和 vscode   2022-07-28   2022-07-28\n技术随笔   技术随笔 - java启动的-d参数   2022-03-02   2022-03-02\n技术随笔   技术随笔 - 360天擎关闭       2022-02-22   2022-02-22\n技术随笔   maven - 上传中央仓库       2022-02-07   2022-02-07\n技术随笔   github - 好看的主页       2022-01-09   2022-01-09\n技术随笔   技术随笔 - 域名解析          2021-12-01   2021-12-17\n\n\n# 关于清单\n\n关于自我目录\n\n关于本站目录\n\n关于技巧目录\n\n知识体系      知识内容              创建时间         更新时间\n关于 - 自我   自我 - 温润少年         2022-02-19   2022-02-19\n关于 - 自我   自我 - 尊贵公子         2022-02-19   2022-02-19\n关于 - 自我   自我 - 学习线          2021-11-13   2021-11-13\n关于 - 自我   自我 - 清单           2021-11-13   一直在更新清单\n关于 - 自我   自我 - 介绍           2021-11-03   2021-11-03\n关于 - 本站   本站 - 全局时间消息提示模块   2022-02-13   2022-02-13\n关于 - 本站   本站 - 代码块隐藏模块      2022-02-13   2022-02-13\n关于 - 本站   本站 - 首页大图模块       2022-01-12   2022-01-13\n关于 - 本站   本站 - 导航站模块        2022-01-11   2022-01-11\n关于 - 本站   本站 - 私密文章模块       2022-01-07   2022-01-08\n关于 - 本站   本站 - 记录曾阅读位置插件    2022-01-04   2022-01-04\n关于 - 本站   本站 - 自定义样式模块      2021-01-01   2021-01-02\n关于 - 本站   本站 - 站点信息         2021-12-30   2021-01-02\n关于 - 本站   本站 - 服务器部署        2021-12-03   2021-12-09\n关于 - 本站   本站 - 主题           2021-11-07   2021-11-07\n关于 - 本站   本站 - 网站部署         2021-11-01   2021-11-01\n关于 - 本站   本站 - 规划           2021-11-01   2021-11-01\n关于 - 本站   本站 - 介绍           2021-11-01   2021-11-01\n关于 - 本站   本站 - 搭建           2021-10-31   2021-10-31\n关于 - 本站   本站 - 评论           2021-10-29   2021-10-29\n关于 - 首页   首页 - 下载站点         2021-12-14   2021-12-15\n关于 - 首页   首页 - 部署           2021-12-09   2021-12-10\n关于 - 技巧   排版 - 技巧           2021-11-13   2021-11-13\n关于 - 技巧   笔记 - 技巧           2021-10-28   2021-10-28\n\n\n# 项目工程清单\n\n项目过程目录页\n\ntbeam 项目目录\n\n报修系统目录\n\nyonyou 工程目录\n\n知识体系   知识内容                      发布时间         更新时间\n项目工程   yonyou - client端开发        2022-03-03   2022-03-03\n项目工程   yonyou - 开发流程             2022-03-02   2022-03-02\n项目工程   yonyou - ncc节点开发          2022-02-23   2022-02-23\n项目工程   yonyou - 节点配置             2022-02-22   2022-02-22\n项目工程   报修系统 - 部署                 2021-11-30   2021-11-30\n项目工程   报修系统 - 详解                 2021-10-30   2021-11-02\n项目工程   tbeam - 技巧                2021-11-07   2021-11-07\n项目工程   ant design vue 3.x - 新增   2021-10-28   2021-11-07\n项目工程   ant design vue 3.x - 表格   2021-10-26   2021-10-26\n项目工程   tbeam 项目介绍                2021-10-28   2021-10-28\n\n\n# mysql 清单\n\nmysql 目录\n\n知识体系       知识内容              发布时间         更新时间\nmysql 高级   mysql - 主从复制      2021-10-24   2021-10-24\nmysql 高级   mysql - 日志        2021-10-24   2021-10-24\nmysql 高级   mysql - 常用工具      2021-10-24   2021-10-24\nmysql 高级   mysql - 常用sql     2021-10-24   2021-10-24\nmysql 高级   mysql - 锁问题       2021-10-24   2021-10-24\nmysql 高级   mysql - 并发参数优化    2021-10-24   2021-10-24\nmysql 高级   mysql - 内存管理优化    2021-10-24   2021-10-24\nmysql 高级   mysql - 缓存查询优化    2021-10-24   2021-10-24\nmysql 高级   mysql - sql语句优化   2021-10-24   2021-10-24\nmysql 高级   mysql - 索引的使用     2021-10-24   2021-10-24\nmysql 高级   mysql - 检测优化sql   2021-10-24   2021-10-24\nmysql 高级   mysql - 逻辑架构简介    2021-10-24   2021-10-24\nmysql 高级   mysql - 索引介绍      2021-10-24   2021-10-24\nmysql 高级   初识mysql           2021-10-24   2021-10-24",charsets:{cjk:!0},lastUpdated:"2023/04/18, 11:24:12",lastUpdatedTimestamp:1681788252e3},{title:"本站 - 介绍",frontmatter:{title:"本站 - 介绍",date:"2021-11-01T11:03:34.000Z",permalink:"/about/website/introduce",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/01.%E6%9C%AC%E7%AB%99%20-%20%E4%BB%8B%E7%BB%8D.html",relativePath:"80.关于/06.关于 - 本站/01.本站 - 介绍.md",key:"v-5fd17c76",path:"/about/website/introduce/",headers:[{level:2,title:"由来",slug:"由来",normalizedTitle:"由来",charIndex:3},{level:2,title:"时间线",slug:"时间线",normalizedTitle:"时间线",charIndex:9},{level:2,title:"VuePress介绍",slug:"vuepress介绍",normalizedTitle:"vuepress介绍",charIndex:16},{level:3,title:"它是如何工作的？",slug:"它是如何工作的",normalizedTitle:"它是如何工作的？",charIndex:32},{level:3,title:"为什么不是...?",slug:"为什么不是",normalizedTitle:"为什么不是...?",charIndex:46},{level:3,title:"Nuxt",slug:"nuxt",normalizedTitle:"nuxt",charIndex:61},{level:3,title:"Docsify / Docute",slug:"docsify-docute",normalizedTitle:"docsify / docute",charIndex:71},{level:3,title:"Hexo",slug:"hexo",normalizedTitle:"hexo",charIndex:93},{level:3,title:"GitBook",slug:"gitbook",normalizedTitle:"gitbook",charIndex:103},{level:2,title:"Vdoing介绍",slug:"vdoing介绍",normalizedTitle:"vdoing介绍",charIndex:114},{level:3,title:"主题初衷与诞生",slug:"主题初衷与诞生",normalizedTitle:"主题初衷与诞生",charIndex:128},{level:3,title:"Markdown",slug:"markdown",normalizedTitle:"markdown",charIndex:141},{level:3,title:"知识管理",slug:"知识管理",normalizedTitle:"知识管理",charIndex:155},{level:3,title:"VuePress",slug:"vuepress",normalizedTitle:"vuepress",charIndex:16},{level:3,title:"知识管理&博客主题-Vdoing的诞生",slug:"知识管理-博客主题-vdoing的诞生",normalizedTitle:"知识管理&amp;博客主题-vdoing的诞生",charIndex:null},{level:3,title:"主题名称",slug:"主题名称",normalizedTitle:"主题名称",charIndex:204}],headersStr:"由来 时间线 VuePress介绍 它是如何工作的？ 为什么不是...? Nuxt Docsify / Docute Hexo GitBook Vdoing介绍 主题初衷与诞生 Markdown 知识管理 VuePress 知识管理&博客主题-Vdoing的诞生 主题名称",content:" * 由来\n * 时间线\n * VuePress介绍\n   * 它是如何工作的？\n   * 为什么不是...?\n   * Nuxt\n   * Docsify / Docute\n   * Hexo\n   * GitBook\n * Vdoing介绍\n   * 主题初衷与诞生\n   * Markdown\n   * 知识管理\n   * VuePress\n   * 知识管理&博客主题-Vdoing的诞生\n   * 主题名称\n\n\n\n\n# 由来\n\n我曾经在 B 站学习 Rabbit 消息中间件时，偶然翻了评论区，看到一位 up 的个人博客推荐。心脏骤然跳动间，进去浏览了一番，发现这个博客的 UI 似曾相识。是我喜欢的风格。经过一番寻找，发现了这是由 VuePress 搭建的。于是我有了搭建个人博客的冲动。也慢慢和本站有了缘分😄；\n\n本站使用了 VuePress 进行搭建，属于 Vue 全家桶的一员，它的诞生初衷是为了支持 Vue 及其子项目的文档需求；\n\n快速上手后，我使用了 Vdoing 主题。基于 VuePress 进行了一些功能添加和主题设计，🚀一款简洁高效的VuePress 知识管理&博客 主题。\n\n\n# 时间线\n\n事件          事件\n本站搭建        2021-10-19 下午\nVdoing 主题   2021-10-20 15:04:53\n\n\n# VuePress介绍\n\n前言\n\n以下内容均来自 VuePress 官网\n\n2021-11-01 @Du Wu\n\nVuePress 由两部分组成：第一部分是一个极简静态网站生成器 (opens new window)，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。\n\n每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。同时，一旦页面被加载，Vue 将接管这些静态内容，并将其转换成一个完整的单页应用（SPA），其他的页面则会只在用户浏览到的时候才按需加载。\n\n\n# 它是如何工作的？\n\n事实上，一个 VuePress 网站是一个由 Vue (opens new window)、Vue Router (opens new window)和 webpack (opens new window)驱动的单页应用。如果你以前使用过 Vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 Vue DevTools 去调试你的自定义主题。\n\n在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的HTML。这种做法的灵感来源于 Nuxt (opens new window)的 nuxt generate 命令，以及其他的一些项目，比如 Gatsby (opens new window)。\n\n\n# 为什么不是...?\n\n\n# Nuxt\n\nVuePress 能做的事情，Nuxt 理论上确实能够胜任，但 Nuxt 是为构建应用程序而生的，而 VuePress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。\n\n\n# Docsify / Docute\n\n这两个项目同样都是基于 Vue，然而它们都是完全的运行时驱动，因此对 SEO 不够友好。如果你并不关注 SEO，同时也不想安装大量依赖，它们仍然是非常好的选择！\n\n\n# Hexo\n\nHexo 一直驱动着 Vue 的文档 —— 事实上，在把我们的主站从 Hexo 迁移到 VuePress 之前，我们可能还有很长的路要走。Hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 Vue 来处理我们的布局和交互，同时，Hexo 的 Markdown 渲染的配置也不是最灵活的。\n\n\n# GitBook\n\n我们的子项目文档一直都在使用 GitBook。GitBook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 Vue 驱动的。GitBook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。\n\n\n# Vdoing介绍\n\nVdoing 全名为 vuepress-theme-vdoing，是一款基于 VuePress 打造的主题\n\n前言\n\n以下内容均来自 Vdoing 官网\n\n2021-11-01 @Du Wu\n\n\n# 主题初衷与诞生\n\n这个主题的初衷是打造一个好用的、面向程序员的知识管理工具。\n\n对于程序员来说，繁杂的知识体系难免会有遗忘的地方。如果有一个方便好用的知识管理工具，可以帮助我们很好的管理知识，并能够快速地把遗忘的知识点找回来。\n\n\n# Markdown\n\n最初接触 Markdown (opens new window) 的时候，我就被它简洁的语法干净的文本结构吸引住，它的代码块和兼容html标签的能力更是让我爱上它，很高兴找到了一个高效记录学习笔记的工具。\n\n\n# 知识管理\n\n在一段学习的日子里，我尝试过用 txt 记录笔记、云笔记、Markdown笔记，并把 Markdown 文件上传到 github 进行管理，但总感觉还是不够方便...直到我发现了 VuePress，它似乎可以管理我的学习笔记，并且把站点部署到 GiHub Pages 不就是一个在线的云笔记网站了吗\n\n\n# VuePress\n\nVuePress (opens new window) 是一个 Vue 驱动的静态网站生成器，正是以 Markdown 为中心的项目结构，它简洁至上的理念正合我心。对于我这个对Vue还算有一些了解的前端，迫不及待的想去使用它来搭建一个我的云笔记网站。\n\n\n# 知识管理&博客主题-Vdoing的诞生\n\n我以前的一个领导和我们说过一个好的知识管理可以帮助我们提高开发质量和开发效率，下面这张图就是他想传达的，我表示赞同：\n\n什么是一个好用的知识管理工具呢？其实我也在不断的寻找和思考中。不过我觉得它至少要结构清晰、管理方便，在查找知识点的过程中可以快速的找到，正像上图所说的要在15秒内找到一个知识点，在添加内容的时候可以很方便的添加，并且保证结构清晰。\n\nVuePress 的官方默认主题是专门为写文档而生的，和我心目中的知识库有一些差距，比如在满足结构清晰这点上，每添加一个内容就得手动的添加侧边栏数据，还有在满足 15 秒内找到一个知识点上还是不够好，因此我觉得需要做一些改造。\n\n在知识管理方面，有三种典型的知识形态：\n\n>  * 结构化：看重知识的条理性和实用性，有一定专业背景才能看懂\n>  * 碎片化：描述具体的知识点，通俗易懂\n>  * 体系化：对某一领域的完整解读，通常是某类知识的专业之作\n\n从这三种知识形态出发，我给主题添加了自动生成结构化侧边栏、目录页、面包屑等等。在满足了结构化之后，写博客应该算得上是一种碎片化的形态，我就给主题添加了分类、标签、归档等等。在满足更方便添加内容上，有了自动生成front matter、批量操作front matter等，更多关于主题的知识从开始使用它去探索吧~~\n\n\n# 主题名称\n\nVdoing，中文大概是维度的意思。起这个名的原因，首先是我看过一个视频《尤雨溪创立vue的心路历程》B站传送 (opens new window)youtube传送 (opens new window)，里面有讲到vue起名的故事，一开始想起的名其实是 Seed.js，但是在npm上被占用了，然后发现vue是一个挺酷的一个词，才决定用 vue。发现大佬起名可以这么酷。再者，这个主题我想它可以多维度的快速寻找一个知识点，要么就叫维度吧，那英文名就用 Vdoing 好了...\n\n尾语\n\n尝试，即是走向成功。\n\n2021-11-01 @Du Wu",normalizedContent:" * 由来\n * 时间线\n * vuepress介绍\n   * 它是如何工作的？\n   * 为什么不是...?\n   * nuxt\n   * docsify / docute\n   * hexo\n   * gitbook\n * vdoing介绍\n   * 主题初衷与诞生\n   * markdown\n   * 知识管理\n   * vuepress\n   * 知识管理&博客主题-vdoing的诞生\n   * 主题名称\n\n\n\n\n# 由来\n\n我曾经在 b 站学习 rabbit 消息中间件时，偶然翻了评论区，看到一位 up 的个人博客推荐。心脏骤然跳动间，进去浏览了一番，发现这个博客的 ui 似曾相识。是我喜欢的风格。经过一番寻找，发现了这是由 vuepress 搭建的。于是我有了搭建个人博客的冲动。也慢慢和本站有了缘分😄；\n\n本站使用了 vuepress 进行搭建，属于 vue 全家桶的一员，它的诞生初衷是为了支持 vue 及其子项目的文档需求；\n\n快速上手后，我使用了 vdoing 主题。基于 vuepress 进行了一些功能添加和主题设计，🚀一款简洁高效的vuepress 知识管理&博客 主题。\n\n\n# 时间线\n\n事件          事件\n本站搭建        2021-10-19 下午\nvdoing 主题   2021-10-20 15:04:53\n\n\n# vuepress介绍\n\n前言\n\n以下内容均来自 vuepress 官网\n\n2021-11-01 @du wu\n\nvuepress 由两部分组成：第一部分是一个极简静态网站生成器 (opens new window)，它包含由 vue 驱动的主题系统和插件 api，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 vue 及其子项目的文档需求。\n\n每一个由 vuepress 生成的页面都带有预渲染好的 html，也因此具有非常好的加载性能和搜索引擎优化（seo）。同时，一旦页面被加载，vue 将接管这些静态内容，并将其转换成一个完整的单页应用（spa），其他的页面则会只在用户浏览到的时候才按需加载。\n\n\n# 它是如何工作的？\n\n事实上，一个 vuepress 网站是一个由 vue (opens new window)、vue router (opens new window)和 webpack (opens new window)驱动的单页应用。如果你以前使用过 vue 的话，当你在开发一个自定义主题的时候，你会感受到非常熟悉的开发体验，你甚至可以使用 vue devtools 去调试你的自定义主题。\n\n在构建时，我们会为应用创建一个服务端渲染（ssr）的版本，然后通过虚拟访问每一条路径来渲染对应的html。这种做法的灵感来源于 nuxt (opens new window)的 nuxt generate 命令，以及其他的一些项目，比如 gatsby (opens new window)。\n\n\n# 为什么不是...?\n\n\n# nuxt\n\nvuepress 能做的事情，nuxt 理论上确实能够胜任，但 nuxt 是为构建应用程序而生的，而 vuepress 则专注在以内容为中心的静态网站上，同时提供了一些为技术文档定制的开箱即用的特性。\n\n\n# docsify / docute\n\n这两个项目同样都是基于 vue，然而它们都是完全的运行时驱动，因此对 seo 不够友好。如果你并不关注 seo，同时也不想安装大量依赖，它们仍然是非常好的选择！\n\n\n# hexo\n\nhexo 一直驱动着 vue 的文档 —— 事实上，在把我们的主站从 hexo 迁移到 vuepress 之前，我们可能还有很长的路要走。hexo 最大的问题在于他的主题系统太过于静态以及过度地依赖纯字符串，而我们十分希望能够好好地利用 vue 来处理我们的布局和交互，同时，hexo 的 markdown 渲染的配置也不是最灵活的。\n\n\n# gitbook\n\n我们的子项目文档一直都在使用 gitbook。gitbook 最大的问题在于当文件很多时，每次编辑后的重新加载时间长得令人无法忍受。它的默认主题导航结构也比较有限制性，并且，主题系统也不是 vue 驱动的。gitbook 背后的团队如今也更专注于将其打造为一个商业产品而不是开源工具。\n\n\n# vdoing介绍\n\nvdoing 全名为 vuepress-theme-vdoing，是一款基于 vuepress 打造的主题\n\n前言\n\n以下内容均来自 vdoing 官网\n\n2021-11-01 @du wu\n\n\n# 主题初衷与诞生\n\n这个主题的初衷是打造一个好用的、面向程序员的知识管理工具。\n\n对于程序员来说，繁杂的知识体系难免会有遗忘的地方。如果有一个方便好用的知识管理工具，可以帮助我们很好的管理知识，并能够快速地把遗忘的知识点找回来。\n\n\n# markdown\n\n最初接触 markdown (opens new window) 的时候，我就被它简洁的语法干净的文本结构吸引住，它的代码块和兼容html标签的能力更是让我爱上它，很高兴找到了一个高效记录学习笔记的工具。\n\n\n# 知识管理\n\n在一段学习的日子里，我尝试过用 txt 记录笔记、云笔记、markdown笔记，并把 markdown 文件上传到 github 进行管理，但总感觉还是不够方便...直到我发现了 vuepress，它似乎可以管理我的学习笔记，并且把站点部署到 gihub pages 不就是一个在线的云笔记网站了吗\n\n\n# vuepress\n\nvuepress (opens new window) 是一个 vue 驱动的静态网站生成器，正是以 markdown 为中心的项目结构，它简洁至上的理念正合我心。对于我这个对vue还算有一些了解的前端，迫不及待的想去使用它来搭建一个我的云笔记网站。\n\n\n# 知识管理&博客主题-vdoing的诞生\n\n我以前的一个领导和我们说过一个好的知识管理可以帮助我们提高开发质量和开发效率，下面这张图就是他想传达的，我表示赞同：\n\n什么是一个好用的知识管理工具呢？其实我也在不断的寻找和思考中。不过我觉得它至少要结构清晰、管理方便，在查找知识点的过程中可以快速的找到，正像上图所说的要在15秒内找到一个知识点，在添加内容的时候可以很方便的添加，并且保证结构清晰。\n\nvuepress 的官方默认主题是专门为写文档而生的，和我心目中的知识库有一些差距，比如在满足结构清晰这点上，每添加一个内容就得手动的添加侧边栏数据，还有在满足 15 秒内找到一个知识点上还是不够好，因此我觉得需要做一些改造。\n\n在知识管理方面，有三种典型的知识形态：\n\n>  * 结构化：看重知识的条理性和实用性，有一定专业背景才能看懂\n>  * 碎片化：描述具体的知识点，通俗易懂\n>  * 体系化：对某一领域的完整解读，通常是某类知识的专业之作\n\n从这三种知识形态出发，我给主题添加了自动生成结构化侧边栏、目录页、面包屑等等。在满足了结构化之后，写博客应该算得上是一种碎片化的形态，我就给主题添加了分类、标签、归档等等。在满足更方便添加内容上，有了自动生成front matter、批量操作front matter等，更多关于主题的知识从开始使用它去探索吧~~\n\n\n# 主题名称\n\nvdoing，中文大概是维度的意思。起这个名的原因，首先是我看过一个视频《尤雨溪创立vue的心路历程》b站传送 (opens new window)youtube传送 (opens new window)，里面有讲到vue起名的故事，一开始想起的名其实是 seed.js，但是在npm上被占用了，然后发现vue是一个挺酷的一个词，才决定用 vue。发现大佬起名可以这么酷。再者，这个主题我想它可以多维度的快速寻找一个知识点，要么就叫维度吧，那英文名就用 vdoing 好了...\n\n尾语\n\n尝试，即是走向成功。\n\n2021-11-01 @du wu",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"自我 - 说明",frontmatter:{title:"自我 - 说明",date:"2021-11-03T01:24:12.000Z",permalink:"/about/me/explain/",titleTag:"原创",private:!0,categories:["关于 - 自我"],tags:["关于"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/03.%E5%85%B3%E4%BA%8E%20-%20%E8%87%AA%E6%88%91/13.%E8%87%AA%E6%88%91%20-%20%E8%AF%B4%E6%98%8E.html",relativePath:"80.关于/03.关于 - 自我/13.自我 - 说明.md",key:"v-597ab59a",path:"/about/me/explain/",headers:[{level:2,title:"关于我",slug:"关于我",normalizedTitle:"关于我",charIndex:45},{level:2,title:"关于它",slug:"关于它",normalizedTitle:"关于它",charIndex:1383}],excerpt:'<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>书写自己，亦是内省自己，重塑根基。</p>\n<div class="custom-block right">\n<p>2021-11-03 @Du Wu</p>\n</div>\n</div>\n',headersStr:"关于我 关于它",content:"序言\n\n书写自己，亦是内省自己，重塑根基。\n\n2021-11-03 @Du Wu\n\n\n# 关于我\n\n我目前是一名大四学生，快毕业了，才有心思搭建博客，欲记录下生活的痕迹。这是我的第一个博客网站，非常值得留下回忆，抒写过去。我会不断把自己的笔记搬到这个网站，也会将生活的点滴留住这里。之前的笔记都放在有道云笔记中，比较零碎，所以需要花时间整理好笔记的结构和排版——重构笔记，也是在重塑知识的根基。\n\n初中时是一名书呆子，模糊印象中的自己，常徘徊于教室和宿舍，沉浸于书香和碎语。初中后段迷上了小说，看的第一本小说是斗破苍穹，当初和一位朋友省下生活费周末跑去书店买书籍，实在怀念。我白纸般的性格，受到这些小说的影响巨深，感谢那些作者，刻画的人物充满正义和坚持。我也喜欢阅读文学，那段时期和另一位朋友畅聊心绪，夜里并行，享尽沉沦。尝试写过诗词，为朋友、为家乡、为亲人、为回忆留下大片的时光笔记，情绪尽扬洒在字里行间。值得感触的是——夜晚飘扬的因子是思绪散发的最好媒介。\n\n高中时开始认真锻炼，从打篮球到跑步，从球场到绿茵场，也从害羞到张扬。虽然实力不怎么样，但是喜欢大汗淋漓的感觉，病态的肆虐身体。小说依然会看，只不过从实体书到了电子书。在时间的冲刷下，我走过了很多不寻常的路，接触了许多电子产品，从揣怀的手机到沉潜的 MP3；从教室的挂钟到左手的银表；从黄金书屋到虚拟世界，让小说、文学、游戏、歌曲慢慢洗涤着自己，留下一地的时间琐屑。此外，我捧起梦想，开始写起了小说，尝试在网站发布小说，却没有坚持下来，而小说体系已经确定下来，非常遗憾。我的第一个实际梦想是当一名作家，我在此路途上记录起了很多风景：有宿舍的大家、有同桌的他们、有故里的家乡、也有眼眸里唯一的她——扬起槟榔树，洒下水珠，坠入行人的发隙，惹出呼声。却唯独没有写过自己——我只是个过客，路过这个世界的旅客。\n\n大学时更加肆意，刚来时满怀期待和热血，第一天当起了志愿者，好奇带有忐忑的同时与学长学姐了解大学的生活。揣怀的对大学的憧憬，我走过校园的每一处，参加过学生会、技术基地、篮球队，却敌不过渐弱的热情，我对外界的平淡猛然出现，触不及防。于是我对虚拟的事物兴趣欲浓，我玩起电脑游戏，徘徊于 Steam、Epic 等平台，天生的游戏欲彻底爆发，游戏恍若真实的世界让我对于现实不再留念。当然，受到性格的影响，忧患时常响在脑海，我从现实走进虚拟的途中，学习过 PS、PR、AE 等 Adobe 成员；涉及过 Word、Excel、PPT 等办公软件；研究过电脑桌面的极致美化、主题壁纸的更迭技术，最后折腾了许多版本，得出结论——美化的尽头是默认，而我的大学尽头是篮球——唯一陪我四年的热爱。\n\n我开始接触 Java 是在 2019 年 11 月份左右，仅仅接触，捧着书看。因为对未来的忧患意识让我必须拥有一项能立足的技能，经过专业和兴趣的考虑，我接触了 Java。而我真正学习 Java，是在疫情爆发期间，记得那时候，病情席卷世界、难声响遍各地、慌张充斥心灵，突然性的迷茫如同棱锥扎进我的世界，我不得不抓住希望的稻草，而 Java 被我抓到了。学到如今，我依然发现，自己仅仅掌握一点知识的皮毛，尚且连冰山一角都不够说。我渴望拥有拨开深处的能力，所以依然在实现我的道路——朝圣的使徒，正在走向编程的至高殿堂。\n\n\n# 关于它\n\n我已经丧失了追求文笔的勇气，迷失在大片诱惑的迷雾里，再也无法氤氲出感性的灵感。我遗落了它，没有能力拾起。\n\n其实我在19年就已经意识到了这个问题。来到大学，相比较高中，犹如脱离静谧的山谷，来到广袤的天地中，但是危险也遍布各地。如懒惰、虚乐。我尝试接触过这些危险，回首时却无法脱身，已然陷入其中而无法自拔。高中的行事规律已被打破，曾经晚自习时的桌子上——白纸黑笔的孓然一身，如今变成了手机里的光影痴迷。夜晚我走在校园的道路上，微风吹过我的发梢，晃动我的心绪，我冷静下来，想起曾经的自己，和现在的自己截然不同。在心中，它已被压在最下面，而上方，不时地不断投放杂物，它已经踹不过气，我无法救自己，更加无法救它。也许生活就是如此，歌颂生活的激扬终将会沉静下来——骊歌响彻心灵，来场告别吧！和它。",normalizedContent:"序言\n\n书写自己，亦是内省自己，重塑根基。\n\n2021-11-03 @du wu\n\n\n# 关于我\n\n我目前是一名大四学生，快毕业了，才有心思搭建博客，欲记录下生活的痕迹。这是我的第一个博客网站，非常值得留下回忆，抒写过去。我会不断把自己的笔记搬到这个网站，也会将生活的点滴留住这里。之前的笔记都放在有道云笔记中，比较零碎，所以需要花时间整理好笔记的结构和排版——重构笔记，也是在重塑知识的根基。\n\n初中时是一名书呆子，模糊印象中的自己，常徘徊于教室和宿舍，沉浸于书香和碎语。初中后段迷上了小说，看的第一本小说是斗破苍穹，当初和一位朋友省下生活费周末跑去书店买书籍，实在怀念。我白纸般的性格，受到这些小说的影响巨深，感谢那些作者，刻画的人物充满正义和坚持。我也喜欢阅读文学，那段时期和另一位朋友畅聊心绪，夜里并行，享尽沉沦。尝试写过诗词，为朋友、为家乡、为亲人、为回忆留下大片的时光笔记，情绪尽扬洒在字里行间。值得感触的是——夜晚飘扬的因子是思绪散发的最好媒介。\n\n高中时开始认真锻炼，从打篮球到跑步，从球场到绿茵场，也从害羞到张扬。虽然实力不怎么样，但是喜欢大汗淋漓的感觉，病态的肆虐身体。小说依然会看，只不过从实体书到了电子书。在时间的冲刷下，我走过了很多不寻常的路，接触了许多电子产品，从揣怀的手机到沉潜的 mp3；从教室的挂钟到左手的银表；从黄金书屋到虚拟世界，让小说、文学、游戏、歌曲慢慢洗涤着自己，留下一地的时间琐屑。此外，我捧起梦想，开始写起了小说，尝试在网站发布小说，却没有坚持下来，而小说体系已经确定下来，非常遗憾。我的第一个实际梦想是当一名作家，我在此路途上记录起了很多风景：有宿舍的大家、有同桌的他们、有故里的家乡、也有眼眸里唯一的她——扬起槟榔树，洒下水珠，坠入行人的发隙，惹出呼声。却唯独没有写过自己——我只是个过客，路过这个世界的旅客。\n\n大学时更加肆意，刚来时满怀期待和热血，第一天当起了志愿者，好奇带有忐忑的同时与学长学姐了解大学的生活。揣怀的对大学的憧憬，我走过校园的每一处，参加过学生会、技术基地、篮球队，却敌不过渐弱的热情，我对外界的平淡猛然出现，触不及防。于是我对虚拟的事物兴趣欲浓，我玩起电脑游戏，徘徊于 steam、epic 等平台，天生的游戏欲彻底爆发，游戏恍若真实的世界让我对于现实不再留念。当然，受到性格的影响，忧患时常响在脑海，我从现实走进虚拟的途中，学习过 ps、pr、ae 等 adobe 成员；涉及过 word、excel、ppt 等办公软件；研究过电脑桌面的极致美化、主题壁纸的更迭技术，最后折腾了许多版本，得出结论——美化的尽头是默认，而我的大学尽头是篮球——唯一陪我四年的热爱。\n\n我开始接触 java 是在 2019 年 11 月份左右，仅仅接触，捧着书看。因为对未来的忧患意识让我必须拥有一项能立足的技能，经过专业和兴趣的考虑，我接触了 java。而我真正学习 java，是在疫情爆发期间，记得那时候，病情席卷世界、难声响遍各地、慌张充斥心灵，突然性的迷茫如同棱锥扎进我的世界，我不得不抓住希望的稻草，而 java 被我抓到了。学到如今，我依然发现，自己仅仅掌握一点知识的皮毛，尚且连冰山一角都不够说。我渴望拥有拨开深处的能力，所以依然在实现我的道路——朝圣的使徒，正在走向编程的至高殿堂。\n\n\n# 关于它\n\n我已经丧失了追求文笔的勇气，迷失在大片诱惑的迷雾里，再也无法氤氲出感性的灵感。我遗落了它，没有能力拾起。\n\n其实我在19年就已经意识到了这个问题。来到大学，相比较高中，犹如脱离静谧的山谷，来到广袤的天地中，但是危险也遍布各地。如懒惰、虚乐。我尝试接触过这些危险，回首时却无法脱身，已然陷入其中而无法自拔。高中的行事规律已被打破，曾经晚自习时的桌子上——白纸黑笔的孓然一身，如今变成了手机里的光影痴迷。夜晚我走在校园的道路上，微风吹过我的发梢，晃动我的心绪，我冷静下来，想起曾经的自己，和现在的自己截然不同。在心中，它已被压在最下面，而上方，不时地不断投放杂物，它已经踹不过气，我无法救自己，更加无法救它。也许生活就是如此，歌颂生活的激扬终将会沉静下来——骊歌响彻心灵，来场告别吧！和它。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 规划",frontmatter:{title:"本站 - 规划",date:"2021-11-01T12:02:37.000Z",permalink:"/about/website/plan/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/02.%E6%9C%AC%E7%AB%99%20-%20%E8%A7%84%E5%88%92.html",relativePath:"80.关于/06.关于 - 本站/02.本站 - 规划.md",key:"v-6566d8f7",path:"/about/website/plan/",headers:[{level:2,title:"规划",slug:"规划",normalizedTitle:"规划",charIndex:3},{level:2,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:9}],excerpt:'<p><div class="table-of-contents"><ul></ul></div></p>\n<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>完整的规划，勾勒未来的笔。</p>\n<div class="custom-block right">\n<p>2021-11-01 @Du Wu</p>\n</div>\n</div>\n',headersStr:"规划 参数",content:" * 规划\n * 参数\n\n\n\n序言\n\n完整的规划，勾勒未来的笔。\n\n2021-11-01 @Du Wu\n\n\n# 规划\n\n这里是本站搭建后的一些构思规划。因为搭建期间包括后面有很多事情要忙，所以先构思一些规划，等到空闲下来，慢慢完成。\n\n后期也会添加更多的规划内容。\n\n规划          完成      构思时间         完成时间                      备注\n添加本站的早期搭建   done    2021-10-20   2021-11-01                \n添加本站的主题搭建   done    2021-10-01   2021-11-07                \n添加本站的部署过程   done    2021-10-20   2021-11-01 ~ 2021-11-02   \n分享本站的插件     doing   2021-10-20   2021-11-29 ~              \n添加音乐自选功能    done    2021-10-20   2021-01-04                \n添加分享功能      none    2021-10-20                             \n动态title功能   done    2021-10-20   2021-01-04                \n网站百宝箱设计     done    2021-11-01   2021-01-04 ~ 2021-01-21   \n网站站点模块      done    2021-12-20   2021-01-01 ~ 2021-01-03   \n\n\n# 参数\n\n * 规划\n   \n   计划未来完成的事件。\n\n * 完成\n   \n   done：已经完成\n   \n   doing：正在完成\n   \n   none：未开始\n\n * 构思时间\n   \n   计划的时间，原本想精确到秒。细想还是到日期即可。\n\n * 完成时间\n   \n   如果完成的时间很长，则是一个范围，否则就是某一天。\n\n * 备注\n   \n   未开始的情况、完成中的情况、完成后的文档链接。",normalizedContent:" * 规划\n * 参数\n\n\n\n序言\n\n完整的规划，勾勒未来的笔。\n\n2021-11-01 @du wu\n\n\n# 规划\n\n这里是本站搭建后的一些构思规划。因为搭建期间包括后面有很多事情要忙，所以先构思一些规划，等到空闲下来，慢慢完成。\n\n后期也会添加更多的规划内容。\n\n规划          完成      构思时间         完成时间                      备注\n添加本站的早期搭建   done    2021-10-20   2021-11-01                \n添加本站的主题搭建   done    2021-10-01   2021-11-07                \n添加本站的部署过程   done    2021-10-20   2021-11-01 ~ 2021-11-02   \n分享本站的插件     doing   2021-10-20   2021-11-29 ~              \n添加音乐自选功能    done    2021-10-20   2021-01-04                \n添加分享功能      none    2021-10-20                             \n动态title功能   done    2021-10-20   2021-01-04                \n网站百宝箱设计     done    2021-11-01   2021-01-04 ~ 2021-01-21   \n网站站点模块      done    2021-12-20   2021-01-01 ~ 2021-01-03   \n\n\n# 参数\n\n * 规划\n   \n   计划未来完成的事件。\n\n * 完成\n   \n   done：已经完成\n   \n   doing：正在完成\n   \n   none：未开始\n\n * 构思时间\n   \n   计划的时间，原本想精确到秒。细想还是到日期即可。\n\n * 完成时间\n   \n   如果完成的时间很长，则是一个范围，否则就是某一天。\n\n * 备注\n   \n   未开始的情况、完成中的情况、完成后的文档链接。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 搭建",frontmatter:{title:"本站 - 搭建",date:"2021-10-31T14:54:34.000Z",permalink:"/about/website/build/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/05.%E6%9C%AC%E7%AB%99%20-%20%E6%90%AD%E5%BB%BA.html",relativePath:"80.关于/06.关于 - 本站/05.本站 - 搭建.md",key:"v-50562c58",path:"/about/website/build/",headers:[{level:2,title:"博客选择",slug:"博客选择",normalizedTitle:"博客选择",charIndex:3},{level:2,title:"文档说明",slug:"文档说明",normalizedTitle:"文档说明",charIndex:11},{level:2,title:"版本要求",slug:"版本要求",normalizedTitle:"版本要求",charIndex:19},{level:2,title:"node和npm更新",slug:"node和npm更新",normalizedTitle:"node和npm更新",charIndex:27},{level:2,title:"vuepress安装",slug:"vuepress安装",normalizedTitle:"vuepress安装",charIndex:41},{level:2,title:"核心配置",slug:"核心配置",normalizedTitle:"核心配置",charIndex:55},{level:2,title:"导航栏",slug:"导航栏",normalizedTitle:"导航栏",charIndex:63},{level:3,title:"导航显示",slug:"导航显示",normalizedTitle:"导航显示",charIndex:72},{level:3,title:"永久连接",slug:"永久连接",normalizedTitle:"永久连接",charIndex:82},{level:2,title:"侧边栏",slug:"侧边栏",normalizedTitle:"侧边栏",charIndex:90},{level:3,title:"自动生成侧边栏",slug:"自动生成侧边栏",normalizedTitle:"自动生成侧边栏",charIndex:99},{level:3,title:"禁用侧边栏",slug:"禁用侧边栏",normalizedTitle:"禁用侧边栏",charIndex:112},{level:2,title:"静态资源配置",slug:"静态资源配置",normalizedTitle:"静态资源配置",charIndex:121}],excerpt:'<p><div class="table-of-contents"><ul></ul></div></p>\n<div class="custom-block note"><p class="custom-block-title">笔记</p>\n<p>本站使用了 VuePress 进行搭建，属于 Vue 全家桶的一员，旨在搭建个人的静态博客。</p>\n<p>我第一次接触 Vue，就喜欢 Vue 的简洁。虽然没有 CSDN 等平台的流量，但我喜欢一个人享受。</p>\n<div class="custom-block right">\n<p>2021-10-31 @Du Wu</p>\n</div>\n</div>\n',headersStr:"博客选择 文档说明 版本要求 node和npm更新 vuepress安装 核心配置 导航栏 导航显示 永久连接 侧边栏 自动生成侧边栏 禁用侧边栏 静态资源配置",content:" * 博客选择\n * 文档说明\n * 版本要求\n * node和npm更新\n * vuepress安装\n * 核心配置\n * 导航栏\n   * 导航显示\n   * 永久连接\n * 侧边栏\n   * 自动生成侧边栏\n   * 禁用侧边栏\n * 静态资源配置\n\n\n\n笔记\n\n本站使用了 VuePress 进行搭建，属于 Vue 全家桶的一员，旨在搭建个人的静态博客。\n\n我第一次接触 Vue，就喜欢 Vue 的简洁。虽然没有 CSDN 等平台的流量，但我喜欢一个人享受。\n\n2021-10-31 @Du Wu\n\n\n# 博客选择\n\n * 平台博客有：CSDN、博客园、简书、掘金、知乎、微博、豆瓣等\n\n * 个人博客有：Wordpress、Typecho、Hexo、VuePress 等\n\n平台博客具有高流量，更新便捷、社区活跃、多主题模板、UI 成熟、社交完善等功能。不喜欢折腾可以选择该类。\n\n个人博客具有可定制性高、有独立域名、自由等功能、缺点是维护繁琐、上限极高，下限极低，博客设计的好坏与否很大程度上依赖搭建者自身的审美水平。\n\n建议使用个人博客的伙伴，多去看其他优秀个人博客的 UI、功能等设计，汲取营养。\n\n\n# 文档说明\n\n本文档仅仅是 VuePress 的快速搭建，并未涉及到本站的主题搭建，根据本文搭建的博客风格与本站略有所区别。\n\nVuePress 本身并未提供作者信息、面包屑、主题模式、右侧目录等功能，而本站所用的主题已经实现了这一些优秀的功能以及其他功能。\n\n主题的搭建具体看 本站 - 主题\n\n注意\n\n主题的搭建是基于 VuePress，所以前提是至少会 VuePress 的基本使用和默认主题的基本配置。\n\n2021-11-01 @Du Wu\n\n\n# 版本要求\n\n要求\n\nVuePress 要求你的 Noed.js 版本 >= 8.6\n\n2021-10-31 @Du Wu\n\n\n# node和npm更新\n\n * 更新 npm\n   \n   npm undate -g\n   \n   \n   1\n   \n\n * 更新node\n   \n   1. 安装 node 版本管理工具 n\n      \n      npm install n -g\n      \n      \n      1\n      \n   \n   2. 使用 n 进行更新\n      \n      # 安装node最新版本\n      n stable  \n      \n      # 安装node指定版本10.14.1\n      n v10.14.1\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n\n\n# vuepress安装\n\n * 全局安装 VuePress\n   \n   yarn global add vuepress\n   \n   \n   1\n   \n   \n   npm install -g vuepress\n   \n   \n   1\n   \n\n * 创建一个文件夹当作博客的根目录\n   \n   mkdir vuepress-doc\n   # 该目录作为博客的项目目录\n   # 名字自定义，我的是 myNotes\n   \n   \n   1\n   2\n   3\n   \n\n * 进入该目录进行初始化\n   \n   cd vuepress-doc\n   yarn init -y # 或者 npm init -y\n   \n   \n   1\n   2\n   \n   \n   初始化后在根目录下生成一个 package.json 文件\n\n接下来要知道官方推荐的目录结构，下面的内容都是基于目录结构创建的\n\n根目录 (vuepress-doc)\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │ \n│   ├── README.md\n│   ├── guide\n│   │   └── README.md\n│   └── config.md\n│ \n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n目录介绍\n * docs/.vuepress: 用于存放全局的配置、组件、静态资源等。\n * docs/.vuepress/components: 该目录中的 Vue 组件将会被自动注册为全局组件。\n * docs/.vuepress/theme: 用于存放本地主题。\n * docs/.vuepress/styles: 用于存放样式相关的文件。\n * docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。\n * docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\n * docs/.vuepress/public: 静态资源目录。\n * docs/.vuepress/templates: 存储 HTML 模板文件。\n * docs/.vuepress/templates/dev.html: 用于开发环境的 HTML 模板文件。\n * docs/.vuepress/templates/ssr.html: 构建时基于 Vue SSR 的 HTML 模板文件。\n * docs/.vuepress/config.js: 配置文件的入口文件，也可以是 YML 或 toml。\n * docs/.vuepress/enhanceApp.js: 客户端应用的增强。\n\n * 在根目录下创建 dosc 目录\n   \n   mkdir docs\n   # 主要存放博客的配置或者文档\n   \n   \n   1\n   2\n   \n\n * 进入 docs 目录，创建 README.md 文档。内容如下：\n   \n   ---\n   home: true\n   heroImage: /logo.jpg\n   actionText: 快速上手 →\n   actionLink: /zh/guide/\n   features:\n   - title: 简洁至上\n     details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n   - title: Vue驱动\n     details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。\n   - title: 高性能\n     details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。\n   footer: MIT Licensed | Copyright © 2018-present Evan You\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   你会发现，内容对应着 VuePress 官网的入口页面\n\n\n# 核心配置\n\n注意\n\n熟记上方官方推荐的目录结构，下面的内容都是基于目录结构创建的。\n\n2021-10-31 @Du Wu\n\n * 在 docs 目录下创建 .vuepress 目录\n   \n   cd docs\n   mkdir .vuepress\n   \n   \n   1\n   2\n   \n\n * 新建总配置文件config.js\n   \n   cd .vuepress\n   touch config.js\n   \n   \n   1\n   2\n   \n   \n   config 是整个项目的核心配置文件，所有菜单、栏目相关的配置均配置在该模块中。\n\n * config.js 添加内容：（记得看注释）\n   \n   module.exports = {\n       title: 'Young Kbt Blog',  // 首页居中标题\n       description: '这个舞台将会被你的才华踩在脚下，同时你也会把它带到一个新的高度！', // 首页居中文字\n       base: '/', // 格式：'/<仓库名>/'， 默认'/'\n       dest: './dist',  // 打包够的位置。这里是 .vuepress 目录下\n       port: '6486',\t // 端口\n       markdown: {\n           lineNumbers: true, // 显示代码块的行号\n       },\n       head:[\n           ['link', { rel: 'icon', href: '/img/favicon.ico' }], // public目录下的img目录内的图标\n           ['meta',{\n               name: 'keywords',\n               content: 'Young Kbt个人博客，VuePress搭建，学习Java、web、框架、微服务、工具、前端等相关知识',\n           },\n           ],\n       ],\n       themeConfig: {\n           nav: [\n               { text: '关于', link: '/abuot/' } // 右上角导航栏，link 是跳转路径，相当于 a 标签\n           ],\n           sidebar: {'/java/':[\t// 跳转到该路径后，左边的侧边显示内容如下\n               {\n                   title:'关于 - 自我',  // 参考左边的侧边栏\n                   collapsable: true,\n                   children:[\n                       '/about/me/one', // 会去这个路径里找到 one.md 文档，并显示内容。.md 可以省略\n                   ]\n               },\n               {\n                   title:'关于 - 本站',\n                   collapsable: true,\n                   children:[\n                       '/about/build/one', //  会去这个路径里找到 one.md 文档，并显示内容。路径处于dosc目录下\n                   ]\n               }\n           ]\n                    },\n           sidebarDepth: 2,  // 侧边栏显示深度，默认1，最大2（显示到h3标题）\n           lastUpdated: 'Last Updated',  // 开启更新时间，并配置前缀文字  (取值为git提交时间)\n           searchMaxSuggestoins: 10,\t// 搜索结果显示最大数\n           editLinks: true,\t// 启用编辑\n           editLinkText: '编辑此页 '\n       },\n       plugins: [  // 插件相关配置\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   \n\n * 在命令行运行项目\n   \n   vuepress dev docs\n   \n   \n   1\n   \n   \n   yarn run dev\n   \n   \n   1\n   \n   \n   如果 VSCode命令行 无法执行，打开 package.json 文件，手动在 scripts 里填入\n   \n   \"dev\": \"vuepress dev docs\"\n   \n   \n   1\n   \n   \n   \n   \n   再次执行命令即可\n\n\n# 导航栏\n\n笔记\n\n内容分为两部分：\n\n第一部分：如何在网页上显示导航，以及导航的内容；\n\n第二部分：如何实现跳转。\n\n2021-10-31 @Du Wu\n\n\n# 导航显示\n\n上方的 config.js 有一个例子，但是由于导航栏随着后期会逐渐增多，所以需要创建一个 nav.js 文件，专门处理导航栏的内容。（PS：同理包括 themeConfig、head、plugins）\n\n * 首先在 .vuepress 目录创建 nav.js ，然后在 config.js 里引入\n   \n   const nav = require('./nav.js'); // 在 .vuepress 目录下\n   \n   module.exports = {\n       // ...\n       nav, //  等价于 nav: nav，第二个 nav 是上方引入的的名字，因为 ES6 语法，可以实现简写。项目常用\n       // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 在 nav.js 里加入内容\n   \n   // Java导航栏\n   module.exports = {\n       text: '索引', link: '/archives/',  // 跳转链接\n       items: [\n           {\n               text: '本站',\n               items: [\n                   { text: '分类', link: '/categories/' },\n                   { text: '标签', link: '/tags/' },\n                   { text: '归档', link: '/archives/' },\n               ]\n           },\n           {\n               text: '我的',\n               items: [\n                   { text: '收藏', link: '/whell/web/' },\n                   { text: '关于', link: '/about/me/' },\n               ]\n           },\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   * text：栏目名（导航名）\n   * link：链接，可以指向本地目录或 http 地址，必须由 / 结尾，如 /about/me 跳转的是为 /about/me.html，而不是 /about/me/\n   * items：可以包含多个 text 和 link ，可以继续反复套用组成复杂的菜单\n   \n   上方代码和图片进行对比，理解更加清晰\n   \n   \n\n\n# 永久连接\n\nlink 的实现有两种方式：\n\n 1. 本地文件目录(基于 docs 下)\n 2. http地址(基于项目地址后)\n\n我推荐第 2 种方式，因为使用第 1 种方式时，如果随着文档的增多，分类必不可少。一旦分类，目录会发生改变，导致都要修改link。所以给一个 markdown 文档指定唯一的http地址，这样无论怎么改变目录位置，都不会影响文件的访问。\n\n * 永久链接用到 Front Matter，即在每个 markdown 文件最上方指定一些内容。具体内容看官网\n   \n   ---\n   title: 本站搭建\n   permalink: /about/build/\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   提示\n   \n   这里的 permalink 指的是项目后的地址，如请看此时的网页地址，应该为 项目地址/about/build/#永久连接\n\n这时，只要在 nav.js 文件让一个 text 加上 link: /about/build/，这样在导航栏点击该 text 标签，即可获取到该 markdown 文档的内容\n\nmodule.exports = {\n    // ...\n    text: '本站搭建', link: '/about/build/',  // 跳转链接\n\t// ...\n}\n\n\n1\n2\n3\n4\n5\n\n\n笔记\n\n你点击 关于 的时候，就是触发此链接，跳转并显示我写的这篇 markdown 文档。\n\n😺已更改，点击后链接跳转到 本站 - 介绍 的 markdown 文档，能理解就好。\n\n2021-10-31 @Du Wu\n\n\n# 侧边栏\n\n笔记\n\n侧边栏我并没有自己配置，是自动读取的，因为配置侧边栏，把需要的 markdown 文档的一级 ~ 三级标题再复制一份到另一个文档。\n\n相当于再创建一个 markdown 文档，专门存放侧边栏标题。所以说配置侧边栏至少需要两份 markdown 文档。\n\n2021-10-31 @Du Wu\n\nsidebar 侧边栏设置处于 themeConfig 里。上方的 config.js 有一个例子\n\n侧边栏例子：（看注释）\n\nmodule.exports = {\n  themeConfig: {\n    sidebar: {\n      '/java/': [\n        'init',  // 查找 /docs/java/init.md 文档，.md可以省略\n      ],\n\n      '/about/build/': [\n        '',      // 代表 README.md 文档\n      ],\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果要配置侧边栏，建议把侧边栏文档和写的文档放在同一个目录下\n\n\n# 自动生成侧边栏\n\n如果不想手动配置侧边栏，也可以让系统自动读取文档的标题。缺陷是自动生成一个仅仅包含了当前页面标题（headers）链接的侧边栏。\n\n * 配置文件统一配置，全局文档生效\n\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    sidebar: 'auto'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 某个文档单独配置，在该文档 Front Matter 处配置\n\n---\nsidebar: auto\n---\n\n\n1\n2\n3\n\n\n\n# 禁用侧边栏\n\n你可以通过 Front Matter 来禁用指定页面的侧边栏：\n\n---\nsidebar: false\n---\n\n\n1\n2\n3\n\n\n\n# 静态资源配置\n\n前言\n\n静态资源如图片、css 等内容请存放在 /docs/.vuepress/public 目录下。\n\n2021-11-01 @Du Wu\n\n * 图片\n   \n   /docs/README.md 文档里指定首页的图片\n   \n   heroImage: /logo.jpg  # public 下的logo.jpg\n   \n   \n   1\n   \n   \n   图片配置的 / 代表 public 目录，文档配置的 / 代表 docs 目录。项目会自动识别属于哪一类配置\n\n * css 同理，在 .vuepress 目录下创建 css 目录\n   \n   cd public\n   mkdir css\n   touch style.css\n   \n   \n   1\n   2\n   3\n   \n   \n   给 style.css 加样式，然后修改config.js的 head\n   \n   head: [\n       ['link', {rel: 'icon', href: '/logo.jpg'}],\n       [\"link\", { rel: \"stylesheet\", href: \"/css/style.css\" }]\n   ],\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n尾语\n\n加油，你已经成功了一半！\n\n2021-11-01 @Du Wu",normalizedContent:" * 博客选择\n * 文档说明\n * 版本要求\n * node和npm更新\n * vuepress安装\n * 核心配置\n * 导航栏\n   * 导航显示\n   * 永久连接\n * 侧边栏\n   * 自动生成侧边栏\n   * 禁用侧边栏\n * 静态资源配置\n\n\n\n笔记\n\n本站使用了 vuepress 进行搭建，属于 vue 全家桶的一员，旨在搭建个人的静态博客。\n\n我第一次接触 vue，就喜欢 vue 的简洁。虽然没有 csdn 等平台的流量，但我喜欢一个人享受。\n\n2021-10-31 @du wu\n\n\n# 博客选择\n\n * 平台博客有：csdn、博客园、简书、掘金、知乎、微博、豆瓣等\n\n * 个人博客有：wordpress、typecho、hexo、vuepress 等\n\n平台博客具有高流量，更新便捷、社区活跃、多主题模板、ui 成熟、社交完善等功能。不喜欢折腾可以选择该类。\n\n个人博客具有可定制性高、有独立域名、自由等功能、缺点是维护繁琐、上限极高，下限极低，博客设计的好坏与否很大程度上依赖搭建者自身的审美水平。\n\n建议使用个人博客的伙伴，多去看其他优秀个人博客的 ui、功能等设计，汲取营养。\n\n\n# 文档说明\n\n本文档仅仅是 vuepress 的快速搭建，并未涉及到本站的主题搭建，根据本文搭建的博客风格与本站略有所区别。\n\nvuepress 本身并未提供作者信息、面包屑、主题模式、右侧目录等功能，而本站所用的主题已经实现了这一些优秀的功能以及其他功能。\n\n主题的搭建具体看 本站 - 主题\n\n注意\n\n主题的搭建是基于 vuepress，所以前提是至少会 vuepress 的基本使用和默认主题的基本配置。\n\n2021-11-01 @du wu\n\n\n# 版本要求\n\n要求\n\nvuepress 要求你的 noed.js 版本 >= 8.6\n\n2021-10-31 @du wu\n\n\n# node和npm更新\n\n * 更新 npm\n   \n   npm undate -g\n   \n   \n   1\n   \n\n * 更新node\n   \n   1. 安装 node 版本管理工具 n\n      \n      npm install n -g\n      \n      \n      1\n      \n   \n   2. 使用 n 进行更新\n      \n      # 安装node最新版本\n      n stable  \n      \n      # 安装node指定版本10.14.1\n      n v10.14.1\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n\n\n# vuepress安装\n\n * 全局安装 vuepress\n   \n   yarn global add vuepress\n   \n   \n   1\n   \n   \n   npm install -g vuepress\n   \n   \n   1\n   \n\n * 创建一个文件夹当作博客的根目录\n   \n   mkdir vuepress-doc\n   # 该目录作为博客的项目目录\n   # 名字自定义，我的是 mynotes\n   \n   \n   1\n   2\n   3\n   \n\n * 进入该目录进行初始化\n   \n   cd vuepress-doc\n   yarn init -y # 或者 npm init -y\n   \n   \n   1\n   2\n   \n   \n   初始化后在根目录下生成一个 package.json 文件\n\n接下来要知道官方推荐的目录结构，下面的内容都是基于目录结构创建的\n\n根目录 (vuepress-doc)\n├── docs\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceapp.js (可选的)\n│   │ \n│   ├── readme.md\n│   ├── guide\n│   │   └── readme.md\n│   └── config.md\n│ \n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n目录介绍\n * docs/.vuepress: 用于存放全局的配置、组件、静态资源等。\n * docs/.vuepress/components: 该目录中的 vue 组件将会被自动注册为全局组件。\n * docs/.vuepress/theme: 用于存放本地主题。\n * docs/.vuepress/styles: 用于存放样式相关的文件。\n * docs/.vuepress/styles/index.styl: 将会被自动应用的全局样式文件，会生成在最终的 css 文件结尾，具有比默认样式更高的优先级。\n * docs/.vuepress/styles/palette.styl: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。\n * docs/.vuepress/public: 静态资源目录。\n * docs/.vuepress/templates: 存储 html 模板文件。\n * docs/.vuepress/templates/dev.html: 用于开发环境的 html 模板文件。\n * docs/.vuepress/templates/ssr.html: 构建时基于 vue ssr 的 html 模板文件。\n * docs/.vuepress/config.js: 配置文件的入口文件，也可以是 yml 或 toml。\n * docs/.vuepress/enhanceapp.js: 客户端应用的增强。\n\n * 在根目录下创建 dosc 目录\n   \n   mkdir docs\n   # 主要存放博客的配置或者文档\n   \n   \n   1\n   2\n   \n\n * 进入 docs 目录，创建 readme.md 文档。内容如下：\n   \n   ---\n   home: true\n   heroimage: /logo.jpg\n   actiontext: 快速上手 →\n   actionlink: /zh/guide/\n   features:\n   - title: 简洁至上\n     details: 以 markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n   - title: vue驱动\n     details: 享受 vue + webpack 的开发体验，在 markdown 中使用 vue 组件，同时可以使用 vue 来开发自定义主题。\n   - title: 高性能\n     details: vuepress 为每个页面预渲染生成静态的 html，同时在页面被加载的时候，将作为 spa 运行。\n   footer: mit licensed | copyright © 2018-present evan you\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n   \n   你会发现，内容对应着 vuepress 官网的入口页面\n\n\n# 核心配置\n\n注意\n\n熟记上方官方推荐的目录结构，下面的内容都是基于目录结构创建的。\n\n2021-10-31 @du wu\n\n * 在 docs 目录下创建 .vuepress 目录\n   \n   cd docs\n   mkdir .vuepress\n   \n   \n   1\n   2\n   \n\n * 新建总配置文件config.js\n   \n   cd .vuepress\n   touch config.js\n   \n   \n   1\n   2\n   \n   \n   config 是整个项目的核心配置文件，所有菜单、栏目相关的配置均配置在该模块中。\n\n * config.js 添加内容：（记得看注释）\n   \n   module.exports = {\n       title: 'young kbt blog',  // 首页居中标题\n       description: '这个舞台将会被你的才华踩在脚下，同时你也会把它带到一个新的高度！', // 首页居中文字\n       base: '/', // 格式：'/<仓库名>/'， 默认'/'\n       dest: './dist',  // 打包够的位置。这里是 .vuepress 目录下\n       port: '6486',\t // 端口\n       markdown: {\n           linenumbers: true, // 显示代码块的行号\n       },\n       head:[\n           ['link', { rel: 'icon', href: '/img/favicon.ico' }], // public目录下的img目录内的图标\n           ['meta',{\n               name: 'keywords',\n               content: 'young kbt个人博客，vuepress搭建，学习java、web、框架、微服务、工具、前端等相关知识',\n           },\n           ],\n       ],\n       themeconfig: {\n           nav: [\n               { text: '关于', link: '/abuot/' } // 右上角导航栏，link 是跳转路径，相当于 a 标签\n           ],\n           sidebar: {'/java/':[\t// 跳转到该路径后，左边的侧边显示内容如下\n               {\n                   title:'关于 - 自我',  // 参考左边的侧边栏\n                   collapsable: true,\n                   children:[\n                       '/about/me/one', // 会去这个路径里找到 one.md 文档，并显示内容。.md 可以省略\n                   ]\n               },\n               {\n                   title:'关于 - 本站',\n                   collapsable: true,\n                   children:[\n                       '/about/build/one', //  会去这个路径里找到 one.md 文档，并显示内容。路径处于dosc目录下\n                   ]\n               }\n           ]\n                    },\n           sidebardepth: 2,  // 侧边栏显示深度，默认1，最大2（显示到h3标题）\n           lastupdated: 'last updated',  // 开启更新时间，并配置前缀文字  (取值为git提交时间)\n           searchmaxsuggestoins: 10,\t// 搜索结果显示最大数\n           editlinks: true,\t// 启用编辑\n           editlinktext: '编辑此页 '\n       },\n       plugins: [  // 插件相关配置\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   \n\n * 在命令行运行项目\n   \n   vuepress dev docs\n   \n   \n   1\n   \n   \n   yarn run dev\n   \n   \n   1\n   \n   \n   如果 vscode命令行 无法执行，打开 package.json 文件，手动在 scripts 里填入\n   \n   \"dev\": \"vuepress dev docs\"\n   \n   \n   1\n   \n   \n   \n   \n   再次执行命令即可\n\n\n# 导航栏\n\n笔记\n\n内容分为两部分：\n\n第一部分：如何在网页上显示导航，以及导航的内容；\n\n第二部分：如何实现跳转。\n\n2021-10-31 @du wu\n\n\n# 导航显示\n\n上方的 config.js 有一个例子，但是由于导航栏随着后期会逐渐增多，所以需要创建一个 nav.js 文件，专门处理导航栏的内容。（ps：同理包括 themeconfig、head、plugins）\n\n * 首先在 .vuepress 目录创建 nav.js ，然后在 config.js 里引入\n   \n   const nav = require('./nav.js'); // 在 .vuepress 目录下\n   \n   module.exports = {\n       // ...\n       nav, //  等价于 nav: nav，第二个 nav 是上方引入的的名字，因为 es6 语法，可以实现简写。项目常用\n       // ...\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 在 nav.js 里加入内容\n   \n   // java导航栏\n   module.exports = {\n       text: '索引', link: '/archives/',  // 跳转链接\n       items: [\n           {\n               text: '本站',\n               items: [\n                   { text: '分类', link: '/categories/' },\n                   { text: '标签', link: '/tags/' },\n                   { text: '归档', link: '/archives/' },\n               ]\n           },\n           {\n               text: '我的',\n               items: [\n                   { text: '收藏', link: '/whell/web/' },\n                   { text: '关于', link: '/about/me/' },\n               ]\n           },\n       ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n   * text：栏目名（导航名）\n   * link：链接，可以指向本地目录或 http 地址，必须由 / 结尾，如 /about/me 跳转的是为 /about/me.html，而不是 /about/me/\n   * items：可以包含多个 text 和 link ，可以继续反复套用组成复杂的菜单\n   \n   上方代码和图片进行对比，理解更加清晰\n   \n   \n\n\n# 永久连接\n\nlink 的实现有两种方式：\n\n 1. 本地文件目录(基于 docs 下)\n 2. http地址(基于项目地址后)\n\n我推荐第 2 种方式，因为使用第 1 种方式时，如果随着文档的增多，分类必不可少。一旦分类，目录会发生改变，导致都要修改link。所以给一个 markdown 文档指定唯一的http地址，这样无论怎么改变目录位置，都不会影响文件的访问。\n\n * 永久链接用到 front matter，即在每个 markdown 文件最上方指定一些内容。具体内容看官网\n   \n   ---\n   title: 本站搭建\n   permalink: /about/build/\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   \n   \n   提示\n   \n   这里的 permalink 指的是项目后的地址，如请看此时的网页地址，应该为 项目地址/about/build/#永久连接\n\n这时，只要在 nav.js 文件让一个 text 加上 link: /about/build/，这样在导航栏点击该 text 标签，即可获取到该 markdown 文档的内容\n\nmodule.exports = {\n    // ...\n    text: '本站搭建', link: '/about/build/',  // 跳转链接\n\t// ...\n}\n\n\n1\n2\n3\n4\n5\n\n\n笔记\n\n你点击 关于 的时候，就是触发此链接，跳转并显示我写的这篇 markdown 文档。\n\n😺已更改，点击后链接跳转到 本站 - 介绍 的 markdown 文档，能理解就好。\n\n2021-10-31 @du wu\n\n\n# 侧边栏\n\n笔记\n\n侧边栏我并没有自己配置，是自动读取的，因为配置侧边栏，把需要的 markdown 文档的一级 ~ 三级标题再复制一份到另一个文档。\n\n相当于再创建一个 markdown 文档，专门存放侧边栏标题。所以说配置侧边栏至少需要两份 markdown 文档。\n\n2021-10-31 @du wu\n\nsidebar 侧边栏设置处于 themeconfig 里。上方的 config.js 有一个例子\n\n侧边栏例子：（看注释）\n\nmodule.exports = {\n  themeconfig: {\n    sidebar: {\n      '/java/': [\n        'init',  // 查找 /docs/java/init.md 文档，.md可以省略\n      ],\n\n      '/about/build/': [\n        '',      // 代表 readme.md 文档\n      ],\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果要配置侧边栏，建议把侧边栏文档和写的文档放在同一个目录下\n\n\n# 自动生成侧边栏\n\n如果不想手动配置侧边栏，也可以让系统自动读取文档的标题。缺陷是自动生成一个仅仅包含了当前页面标题（headers）链接的侧边栏。\n\n * 配置文件统一配置，全局文档生效\n\n// .vuepress/config.js\nmodule.exports = {\n  themeconfig: {\n    sidebar: 'auto'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 某个文档单独配置，在该文档 front matter 处配置\n\n---\nsidebar: auto\n---\n\n\n1\n2\n3\n\n\n\n# 禁用侧边栏\n\n你可以通过 front matter 来禁用指定页面的侧边栏：\n\n---\nsidebar: false\n---\n\n\n1\n2\n3\n\n\n\n# 静态资源配置\n\n前言\n\n静态资源如图片、css 等内容请存放在 /docs/.vuepress/public 目录下。\n\n2021-11-01 @du wu\n\n * 图片\n   \n   /docs/readme.md 文档里指定首页的图片\n   \n   heroimage: /logo.jpg  # public 下的logo.jpg\n   \n   \n   1\n   \n   \n   图片配置的 / 代表 public 目录，文档配置的 / 代表 docs 目录。项目会自动识别属于哪一类配置\n\n * css 同理，在 .vuepress 目录下创建 css 目录\n   \n   cd public\n   mkdir css\n   touch style.css\n   \n   \n   1\n   2\n   3\n   \n   \n   给 style.css 加样式，然后修改config.js的 head\n   \n   head: [\n       ['link', {rel: 'icon', href: '/logo.jpg'}],\n       [\"link\", { rel: \"stylesheet\", href: \"/css/style.css\" }]\n   ],\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n尾语\n\n加油，你已经成功了一半！\n\n2021-11-01 @du wu",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 主题",frontmatter:{title:"本站 - 主题",date:"2021-11-07T17:32:31.000Z",permalink:"/about/website/theme/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/07.%E6%9C%AC%E7%AB%99%20-%20%E4%B8%BB%E9%A2%98.html",relativePath:"80.关于/06.关于 - 本站/07.本站 - 主题.md",key:"v-1effc226",path:"/about/website/theme/",headers:[{level:2,title:"主题介绍",slug:"主题介绍",normalizedTitle:"主题介绍",charIndex:50},{level:2,title:"获取途径",slug:"获取途径",normalizedTitle:"获取途径",charIndex:58},{level:2,title:"目录结构",slug:"目录结构",normalizedTitle:"目录结构",charIndex:66},{level:2,title:"使用过程",slug:"使用过程",normalizedTitle:"使用过程",charIndex:74},{level:2,title:"级别说明",slug:"级别说明",normalizedTitle:"级别说明",charIndex:82},{level:2,title:"创建文档",slug:"创建文档",normalizedTitle:"创建文档",charIndex:90},{level:2,title:"Front Matter",slug:"front-matter",normalizedTitle:"front matter",charIndex:98},{level:2,title:"碎片化文档",slug:"碎片化文档",normalizedTitle:"碎片化文档",charIndex:114}],headersStr:"主题介绍 获取途径 目录结构 使用过程 级别说明 创建文档 Front Matter 碎片化文档",content:"前言\n\n使用主题的一些总结，并非完整的教程，如果看完整的教程，请去 Vdoing 官网\n\n\n\n * 主题介绍\n * 获取途径\n * 目录结构\n * 使用过程\n * 级别说明\n * 创建文档\n * Front Matter\n * 碎片化文档\n\n\n\n\n# 主题介绍\n\n本站使用的主题是 Vdoing，它是一款简洁高效的 VuePress 知识管理&博客主题，初衷是打造一个好用的、面向程序员的知识管理工具。\n\n主题千千万，我选择这个主题的原因之一是因为它对于文档的命名约定要求非常符合我的想法，即要有两位序号，分清楚顺序，从 00 或 01 开始累计，如 01.文件夹、02.文件.md。如果日后进行文档的梳理也是非常方便的，一眼望去，结构明了。\n\n\n# 获取途径\n\n这里是主题的获取途径。\n\n途径一：主题作者的源代码 GitHub 地址：点击跳转。\n\n途径二：主题官网提供的命令下载：\n\n# 克隆项目，也就是下载项目到本地\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing.git\n\n# 进入项目的根目录下\ncd vuepress-theme-vdoing\n\n# 安装项目需要的依赖包\nnpm install # or yarn install\n\n# 启动项目\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 克隆项目，也就是下载项目到本地\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing-doc.git\n\n# 进入项目的根目录下\ncd vuepress-theme-vdoing-doc\n\n# 安装项目需要的依赖包\nnpm install # or yarn install\n\n# 启动项目\nrun dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n知识库兼博客风格预设配置：指的是主题作者自己的博客项目内容，也就是作者正在用的博客。\n\n文档风格预设配置：指的是该主题的基本配置项目，不包含作者个人的最新文章更新。\n\n途径三：前往使用该主题的博主 GitHub 地址进行克隆(下载)到本地，如我的地址：跳转地址。\n\n\n# 目录结构\n\n通过获取途径获取到了主题的代码时，它的结构大致如下：\n\n知识库兼博客风格预设配置目录结构：\n\n.\n├── .github   (可选，GitHub Actions 所需文件)\n│   ├── workflows\n│   │   ├── baiduPush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── theme-vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editFrontmatter.js (可选，批量操作front matter工具)\n├── baiduPush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n结构说明\n * docs 文件夹名称请不要修改\n * docs/.vuepress 用于存放全局的配置、样式、静态资源等，同官方，查看 详情(opens new window)\n * docs/@pages 此文件夹是自动生成的，存放分类页、标签页、归档页对应的.md文件，一般不需要改动\n * docs/_posts 专门用于存放碎片化博客文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n * docs/<结构化目录> 请查看《构建结构化站点的核心配置和约定》。\n * docs/index.md 首页\n * theme-vdoing 存放在本地的vdoing主题文件，如果你想深度的修改主题，首先要在docs/.vuepress/config.js中配置使用的主题指向这个文件。\n\n文档风格预设配置目录结构：\n\n.\n├── .github   (可选，GitHub Actions 所需文件)\n│   ├── workflows\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editFrontmatter.js (可选，批量操作front matter工具)\n├── deploy.sh (可选，部署命令脚本)\n│—— base.js (可选，指定部署项目根目录)\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 使用过程\n\n * 获取项目后，首先建议先把 .github/workflows/baiduPush.yml 去掉，这是百度推送相关的，部署时不填入自己的百度信息会报错，后期需要再加入\n\n * 打开 docs/.vuepress/config 目录下的 themeConfig.js 文件，滑到最下方，把 htmlModules 注释掉，这是首页右下方的广告：二维码广告\n\n * 如果不使用本地的 Vdoing 主题，把 theme-vdoing 去掉。theme-vdoing 目录下，可以修改很多的主题样式等，但是使用本地主题就等于放弃了后续的升级服务，所以建议去掉这个。用「在线」的官网主题，即默认\n\n * 因为主题已经配置了很多的内容，所以大部分是不需要自己修改的，建议去 .vuepress 目录下把一些 .js 文件看下，都有注释讲解，里面也有个人信息的配置，以及个性签名，页面的背景图等配置。先启动项目，再看注释配合页面，理解的效果更佳\n\n * 如果想修改首页的上方的背景图，主题默认是黑色栅格背景，请打开 docs/index.md 文档，在 features 同级下加入 bannerBg 属性，这个属性就是配置背景图，如 bannerBg: /img/index/bg.jpg 代表 docs/.vuepress/public/img/index 下的 bg.jpg 图片\n\n * 如果想修改首页的整个大背景图，打开 themeConfig.js 文件，找到被注释的 bodyBgImg 和 bodyBgImgOpacity，并在前者加入大背景图的图片路径，他会覆盖首页上方的背景图，使其失效。后者是大背景图的透明度，范围：0-1\n\n * 如果目录页不想扫描到本身的文档(目录页文档)，则放到专门存放目录页的目录如 00.目录页 下\n\n * 不一定按照导航栏创建文件夹目录，如我的导航栏中，框架下的微服务目录，就是和框架目录同级别，为了不让导航栏那么广，所以放在了框架导航栏里面\n\n * @Pages 目录下三个文档是主题自带的三个功能，删除任意一个文档，都会导致该文档的 url 链接无法访问，如果不需要某个功能，可以删除\n\n * 需要稍微修改主题的样式，打开 docs/.vuepress/styles/index.styl 文件进行样式添加\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 README.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录v1.6.0 +\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《JavaScript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.JavaScript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 创建文档\n\n创建文档必须按照级别说明的约定，比如想创建 Java 的知识体系文档，则在 docs 下创建一级目录，名为 01.Java，再进入 01.Java 目录，创建两个二级目录，分别名为 01.Java基础、02.Java进阶，接着进入 01.Java基础 目录，创建文档 01.Java入门.md。依次类推。\n\n> 注意：一个目录下的文件不能出现相同序号\n\n启动项目时，会根据序号顺序在侧边栏进行排序，最小的在最上方\n\n> 建议序号要有间隔，如00、05、10、15，方便日后在中间插入新的文档。\n\n\n# Front Matter\n\nfront matter 指的是 markdown 文档最上方的一些 yaml 配置，在主题下 front matter 有更多的参数配置。\n\n提供三个模板：（记得去掉注释）\n\n---\npageComponent: \n  name: Catalogue   # 目录页必须为 Catalogue\n  data: \n    path: 01.java # 扫描文档的目录路径，直接指定 docs 下的目录，无需有 / 开头\n    imgUrl: /   # 目录页标题旁边的图片，开头必须有 /：代表.vupress的public目录\n    description: # 目录页的描述 \ntitle: 本站 - 主题 # 目录页的标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /     # 指定 url 跳转地址，跳转到该url，就获取该文档内容\nsidebar: false     # 是否生成侧边栏，默认为 true\narticle: false\t\t# 是否为文章页，默认为 true，下方有说明\ncomment: false\t\t# 是否生成评论区，默认为 true\neditLink: false\t\t# 是否可以编辑，默认为 true\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n---\ntitle: 本站 - 主题 # 文章页标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /  # 指定 url 跳转地址，点击该url，获取该文档内容\ncategories:\n  -   # 文章目录，在首页的文章分类出现\ntags: \n  -    # 标签，在首页的热门标签出现\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n---\ntitle: 本站 - 主题 # 文章页标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /  # 指定 url 跳转地址，点击该url，获取该文档内容\narticle: false\t# 是否为文章页，默认为 true，下方有说明\ncategories:\n  -   # 文章目录，在首页的文章分类出现\ntags: \n  -    # 标签，在首页的热门标签出现\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n目录页：自动扫描 path 的路径下的文档，生成目录，此时你点击我的 Java 导航，弹出的就是目录页，如果不想自身被扫描到，请放到专门存放目录页的目录如 00.目录页 下\n\n文章页：有内容、个人信息，文档目录信息、日期、面包屑的文档，此时看的内容就是文章页，为了区别目录页。不加sidebar、article、comment、editLink 是因为默认为 true。\n\n非文章页非目录页：一般用于友情连接，转载连接等不包含个人信息的页面，并且不存入归档时间线内，以及首页下方的更新目录中。\n\n面包屑：文档所在的路径。滑到最上方，如果看到 关于/关于 - 本站，这就是面包屑，代表该文档的一级目录为关于，二级目录也就是文档名为关于 - 本站。\n\n特别说明：\n\narticle 为 false 时，则是非文章页非目录页。默认为 true。\n\n例子1：滑到最上方，如果看到 关于/关于 - 本站、Young Kbt、2021-11-07，则代表这是文章页，即 article 为 true。\n\n例子2：打开更多导航的友情链接，这是一个非文章页非目录页，代表 article 为false。\n\n例子3：点击 Java 导航，弹出的页面就是目录页。\n\n\n# 碎片化文档\n\n碎片化文档是放在 _posts 目录下，比如主题自带的随笔。特点：\n\n * 不遵守命名约定，即不需要有序号前缀\n * 无法通过导航栏进行跳转，只能通过首页的文章分类或者热门标签进行查看。或者 url 地址直接跳转\n * 没有面包屑功能\n * 侧边栏只有自己的大纲标题，无法扫描目录下的其他文档\n * 不构成体系化。记录零碎的生活痕迹、技术感想都可以用到碎片化文档\n\n笔记\n\n部分内容摘录于 Vdoing 主题官网\n\n2021-11-07 @Du Wu",normalizedContent:"前言\n\n使用主题的一些总结，并非完整的教程，如果看完整的教程，请去 vdoing 官网\n\n\n\n * 主题介绍\n * 获取途径\n * 目录结构\n * 使用过程\n * 级别说明\n * 创建文档\n * front matter\n * 碎片化文档\n\n\n\n\n# 主题介绍\n\n本站使用的主题是 vdoing，它是一款简洁高效的 vuepress 知识管理&博客主题，初衷是打造一个好用的、面向程序员的知识管理工具。\n\n主题千千万，我选择这个主题的原因之一是因为它对于文档的命名约定要求非常符合我的想法，即要有两位序号，分清楚顺序，从 00 或 01 开始累计，如 01.文件夹、02.文件.md。如果日后进行文档的梳理也是非常方便的，一眼望去，结构明了。\n\n\n# 获取途径\n\n这里是主题的获取途径。\n\n途径一：主题作者的源代码 github 地址：点击跳转。\n\n途径二：主题官网提供的命令下载：\n\n# 克隆项目，也就是下载项目到本地\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing.git\n\n# 进入项目的根目录下\ncd vuepress-theme-vdoing\n\n# 安装项目需要的依赖包\nnpm install # or yarn install\n\n# 启动项目\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 克隆项目，也就是下载项目到本地\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing-doc.git\n\n# 进入项目的根目录下\ncd vuepress-theme-vdoing-doc\n\n# 安装项目需要的依赖包\nnpm install # or yarn install\n\n# 启动项目\nrun dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n知识库兼博客风格预设配置：指的是主题作者自己的博客项目内容，也就是作者正在用的博客。\n\n文档风格预设配置：指的是该主题的基本配置项目，不包含作者个人的最新文章更新。\n\n途径三：前往使用该主题的博主 github 地址进行克隆(下载)到本地，如我的地址：跳转地址。\n\n\n# 目录结构\n\n通过获取途径获取到了主题的代码时，它的结构大致如下：\n\n知识库兼博客风格预设配置目录结构：\n\n.\n├── .github   (可选，github actions 所需文件)\n│   ├── workflows\n│   │   ├── baidupush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── theme-vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editfrontmatter.js (可选，批量操作front matter工具)\n├── baidupush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n结构说明\n * docs 文件夹名称请不要修改\n * docs/.vuepress 用于存放全局的配置、样式、静态资源等，同官方，查看 详情(opens new window)\n * docs/@pages 此文件夹是自动生成的，存放分类页、标签页、归档页对应的.md文件，一般不需要改动\n * docs/_posts 专门用于存放碎片化博客文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n * docs/<结构化目录> 请查看《构建结构化站点的核心配置和约定》。\n * docs/index.md 首页\n * theme-vdoing 存放在本地的vdoing主题文件，如果你想深度的修改主题，首先要在docs/.vuepress/config.js中配置使用的主题指向这个文件。\n\n文档风格预设配置目录结构：\n\n.\n├── .github   (可选，github actions 所需文件)\n│   ├── workflows\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editfrontmatter.js (可选，批量操作front matter工具)\n├── deploy.sh (可选，部署命令脚本)\n│—— base.js (可选，指定部署项目根目录)\n└── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 使用过程\n\n * 获取项目后，首先建议先把 .github/workflows/baidupush.yml 去掉，这是百度推送相关的，部署时不填入自己的百度信息会报错，后期需要再加入\n\n * 打开 docs/.vuepress/config 目录下的 themeconfig.js 文件，滑到最下方，把 htmlmodules 注释掉，这是首页右下方的广告：二维码广告\n\n * 如果不使用本地的 vdoing 主题，把 theme-vdoing 去掉。theme-vdoing 目录下，可以修改很多的主题样式等，但是使用本地主题就等于放弃了后续的升级服务，所以建议去掉这个。用「在线」的官网主题，即默认\n\n * 因为主题已经配置了很多的内容，所以大部分是不需要自己修改的，建议去 .vuepress 目录下把一些 .js 文件看下，都有注释讲解，里面也有个人信息的配置，以及个性签名，页面的背景图等配置。先启动项目，再看注释配合页面，理解的效果更佳\n\n * 如果想修改首页的上方的背景图，主题默认是黑色栅格背景，请打开 docs/index.md 文档，在 features 同级下加入 bannerbg 属性，这个属性就是配置背景图，如 bannerbg: /img/index/bg.jpg 代表 docs/.vuepress/public/img/index 下的 bg.jpg 图片\n\n * 如果想修改首页的整个大背景图，打开 themeconfig.js 文件，找到被注释的 bodybgimg 和 bodybgimgopacity，并在前者加入大背景图的图片路径，他会覆盖首页上方的背景图，使其失效。后者是大背景图的透明度，范围：0-1\n\n * 如果目录页不想扫描到本身的文档(目录页文档)，则放到专门存放目录页的目录如 00.目录页 下\n\n * 不一定按照导航栏创建文件夹目录，如我的导航栏中，框架下的微服务目录，就是和框架目录同级别，为了不让导航栏那么广，所以放在了框架导航栏里面\n\n * @pages 目录下三个文档是主题自带的三个功能，删除任意一个文档，都会导致该文档的 url 链接无法访问，如果不需要某个功能，可以删除\n\n * 需要稍微修改主题的样式，打开 docs/.vuepress/styles/index.styl 文件进行样式添加\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 readme.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录v1.6.0 +\n   1. 该级别下只能放.md文件。\n   2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《javascript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.javascript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 创建文档\n\n创建文档必须按照级别说明的约定，比如想创建 java 的知识体系文档，则在 docs 下创建一级目录，名为 01.java，再进入 01.java 目录，创建两个二级目录，分别名为 01.java基础、02.java进阶，接着进入 01.java基础 目录，创建文档 01.java入门.md。依次类推。\n\n> 注意：一个目录下的文件不能出现相同序号\n\n启动项目时，会根据序号顺序在侧边栏进行排序，最小的在最上方\n\n> 建议序号要有间隔，如00、05、10、15，方便日后在中间插入新的文档。\n\n\n# front matter\n\nfront matter 指的是 markdown 文档最上方的一些 yaml 配置，在主题下 front matter 有更多的参数配置。\n\n提供三个模板：（记得去掉注释）\n\n---\npagecomponent: \n  name: catalogue   # 目录页必须为 catalogue\n  data: \n    path: 01.java # 扫描文档的目录路径，直接指定 docs 下的目录，无需有 / 开头\n    imgurl: /   # 目录页标题旁边的图片，开头必须有 /：代表.vupress的public目录\n    description: # 目录页的描述 \ntitle: 本站 - 主题 # 目录页的标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /     # 指定 url 跳转地址，跳转到该url，就获取该文档内容\nsidebar: false     # 是否生成侧边栏，默认为 true\narticle: false\t\t# 是否为文章页，默认为 true，下方有说明\ncomment: false\t\t# 是否生成评论区，默认为 true\neditlink: false\t\t# 是否可以编辑，默认为 true\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n---\ntitle: 本站 - 主题 # 文章页标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /  # 指定 url 跳转地址，点击该url，获取该文档内容\ncategories:\n  -   # 文章目录，在首页的文章分类出现\ntags: \n  -    # 标签，在首页的热门标签出现\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n---\ntitle: 本站 - 主题 # 文章页标题\ndate: 2021-11-07 21:15:53  # 文章页生成时间\npermalink: /  # 指定 url 跳转地址，点击该url，获取该文档内容\narticle: false\t# 是否为文章页，默认为 true，下方有说明\ncategories:\n  -   # 文章目录，在首页的文章分类出现\ntags: \n  -    # 标签，在首页的热门标签出现\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n目录页：自动扫描 path 的路径下的文档，生成目录，此时你点击我的 java 导航，弹出的就是目录页，如果不想自身被扫描到，请放到专门存放目录页的目录如 00.目录页 下\n\n文章页：有内容、个人信息，文档目录信息、日期、面包屑的文档，此时看的内容就是文章页，为了区别目录页。不加sidebar、article、comment、editlink 是因为默认为 true。\n\n非文章页非目录页：一般用于友情连接，转载连接等不包含个人信息的页面，并且不存入归档时间线内，以及首页下方的更新目录中。\n\n面包屑：文档所在的路径。滑到最上方，如果看到 关于/关于 - 本站，这就是面包屑，代表该文档的一级目录为关于，二级目录也就是文档名为关于 - 本站。\n\n特别说明：\n\narticle 为 false 时，则是非文章页非目录页。默认为 true。\n\n例子1：滑到最上方，如果看到 关于/关于 - 本站、young kbt、2021-11-07，则代表这是文章页，即 article 为 true。\n\n例子2：打开更多导航的友情链接，这是一个非文章页非目录页，代表 article 为false。\n\n例子3：点击 java 导航，弹出的页面就是目录页。\n\n\n# 碎片化文档\n\n碎片化文档是放在 _posts 目录下，比如主题自带的随笔。特点：\n\n * 不遵守命名约定，即不需要有序号前缀\n * 无法通过导航栏进行跳转，只能通过首页的文章分类或者热门标签进行查看。或者 url 地址直接跳转\n * 没有面包屑功能\n * 侧边栏只有自己的大纲标题，无法扫描目录下的其他文档\n * 不构成体系化。记录零碎的生活痕迹、技术感想都可以用到碎片化文档\n\n笔记\n\n部分内容摘录于 vdoing 主题官网\n\n2021-11-07 @du wu",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 网站部署",frontmatter:{title:"本站 - 网站部署",date:"2021-11-01T15:32:38.000Z",permalink:"/about/website/deploy/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/10.%E6%9C%AC%E7%AB%99%20-%20%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2.html",relativePath:"80.关于/06.关于 - 本站/10.本站 - 网站部署.md",key:"v-3fcbe812",path:"/about/website/deploy/",headers:[{level:2,title:"手动部署",slug:"手动部署",normalizedTitle:"手动部署",charIndex:58},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:68},{level:3,title:"优势",slug:"优势",normalizedTitle:"优势",charIndex:76},{level:3,title:"限制",slug:"限制",normalizedTitle:"限制",charIndex:84},{level:3,title:"开始使用",slug:"开始使用",normalizedTitle:"开始使用",charIndex:92},{level:3,title:"上传代码",slug:"上传代码",normalizedTitle:"上传代码",charIndex:102},{level:2,title:"开启部署",slug:"开启部署",normalizedTitle:"开启部署",charIndex:110},{level:2,title:"脚本部署",slug:"脚本部署",normalizedTitle:"脚本部署",charIndex:118},{level:2,title:"自动化部署",slug:"自动化部署",normalizedTitle:"自动化部署",charIndex:126},{level:3,title:"介绍",slug:"介绍-2",normalizedTitle:"介绍",charIndex:68},{level:3,title:"生成token",slug:"生成token",normalizedTitle:"生成token",charIndex:145},{level:3,title:"配置密钥",slug:"配置密钥",normalizedTitle:"配置密钥",charIndex:158},{level:3,title:"自动化文件",slug:"自动化文件",normalizedTitle:"自动化文件",charIndex:168},{level:3,title:"自动化文件流程",slug:"自动化文件流程",normalizedTitle:"自动化文件流程",charIndex:179},{level:2,title:"问答",slug:"问答",normalizedTitle:"问答",charIndex:190},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:196},{level:2,title:"更新base",slug:"更新base",normalizedTitle:"更新base",charIndex:202},{level:2,title:"自定义域名",slug:"自定义域名",normalizedTitle:"自定义域名",charIndex:212}],excerpt:'<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>部署，打造自己的「身份证」。</p>\n<p>自动化，时间管理的福利。</p>\n<div class="custom-block right">\n<p>2021-11-01 @Du Wu</p>\n</div>\n</div>\n',headersStr:"手动部署 介绍 优势 限制 开始使用 上传代码 开启部署 脚本部署 自动化部署 介绍 生成token 配置密钥 自动化文件 自动化文件流程 问答 问题 更新base 自定义域名",content:'序言\n\n部署，打造自己的「身份证」。\n\n自动化，时间管理的福利。\n\n2021-11-01 @Du Wu\n\n\n\n * 手动部署\n   * 介绍\n   * 优势\n   * 限制\n   * 开始使用\n   * 上传代码\n * 开启部署\n * 脚本部署\n * 自动化部署\n   * 介绍\n   * 生成token\n   * 配置密钥\n   * 自动化文件\n   * 自动化文件流程\n * 问答\n * 问题\n * 更新base\n * 自定义域名\n\n\n\n\n# 手动部署\n\n\n# 介绍\n\nGitHub Pages 是一个静态站点托管服务。\n\n如果你想记录生活、抒发情感、分享见解，这一切都离不开一个可以承载文字的平台，一个独立的、由自己掌控的平台，而 GitHub Pages 就是这么一个平台。\n\n在这个平台里你可以使用自己的个性域名；可以在海量的主题里挑选最适合你的那一款，如果你技术极客，也可以根据自己的喜好，设计属于自己的个性化页面；你既可以在线创建和发布网站，也可以在本地通过客户端工具或者命令行进行网站和内容的管理。\n\n你完全可以通过 GitHub Pages 展示和输出自身价值，甚至可以把它打造成属于自己的互联网「身份证」。\n\n如果你想仔细了解 GitHub Pages，点击这里\n\n\n# 优势\n\n * GitHub Pages 完全免费，不需要个人购买服务器、域名\n * 官方文档详细，不需要强大的编程能力，只需要一步一步按着操作来使用\n * 支持的功能多，你可以绑定你的域名、使用免费的 HTTPS、自己 DIY 网站的主题、使用他人开发好的插件等等\n * 完成搭建后，只需要专注于文章即可，其他诸如环境搭建、系统维护、文件存储的事情一概不用操心，都由 GitHub Pages 处理\n\n......\n\n\n# 限制\n\n * GitHub Pages 源仓库建议限制为 1GB；\n * 发布的 GitHub Pages 网站可能不超过 1GB；\n * GitHub Pages 网站每月的带宽限制为 100GB；\n * GitHub Pages 网站每小时限制 10 个软件。\n\n\n# 开始使用\n\n * 首先，你必须拥有一个 GitHub 账号，注册点击这里\n\n * 创建一个仓库用于存放自己的博客项目，如图：点击右上角的 + 号\n   \n   \n\n * 填写自己的仓库信息\n   \n   \n   \n   如我的博客仓库名就叫 notes-blog，因为我打算创建一个生活博客，类似于 live-blog，所以对博客名进行分类\n   \n   防止图片失效，这里记录步骤和gitignore文件内容\n    1. 填写仓库名\n    2. 填写仓库描述，可以不写\n    3. 选择公有 Public\n    4. 建议选择 Add a README file，添加README文档\n    5. Add .gitignore 是添加 .gitignore 文件，如果不知道文件内容，可以不选。则需要手动在自己的博客目录下创建 .gitignore文档，填入如下内容：\n   \n   # npm\n   package-lock.json\n   node_modules\n   \n   # yarn\n   yarn.lock\n   \n   # vscode\n   .vscode\n   \n   # vuepress\n   docs/.vuepress/dist\n   \n   # 百度链接推送\n   urls.txt\n   \n   # mac\n   .DS_Store\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n * 创建仓库后，进入仓库，然后创建一个分支，名字必须叫做gh-pages，可以理解为默认只识别这个名字\n   \n   * 创建好的仓库默认主支是 master 或者 main，现在 GitHub 逐渐让 main 作为默认的主支名\n   * 主支用于仓库的文件汇总，分支则是每一个用户上传到仓库的通道，最终合并到主支\n   \n   \n   \n   防止图片失效，这里记录步骤\n    1. 点击 master，弹出拉下框\n    2. 搜索 gh-pages，必须是这个\n    3. 创建 gh-pages。搜索后，会显示 Create branch：gh-pages from master，点击即可创建\n\n说明\n\n为什么创建 gh-pages 分支呢？因为 master 主支放的是博客源码，而 gh-pages 分支放的是主支打包后的博客代码。\n\n不理解打包，可以这么认为：写的 markdown 文档是源码，要想显示到网页上，需要变成 html 文件，打包就是变成 html 的过程。\n\n2021-11-01 @Du Wu\n\n\n# 上传代码\n\n * 初始化项目根目录\n   \n   git init\n   \n   \n   1\n   \n   \n   如果早期你的项目体系是从其他人的仓库克隆的，说明你不需要初始化根目录，而是需要修改 GitHub 的提交地址，因为提交地址目前是其他人的\n   \n   修改提交地址\n   \n   方法一：\n   \n   执行如下命令进行更改：\n   \n   git remote rm origin  # 删除远程地址\n   git remote add origin URL  #  URL 填写自己的仓库地址，如我的就是 https://github.com/Kele-Bingtang/notes-blog\n   \n   \n   1\n   2\n   \n   \n   方法二：（执行方法一，其实就会自动执行方法二）\n   \n   打开根目录下的 .git 文件夹，因为这个文件夹默认隐藏，所以需要设置显示隐藏文件\n   \n   \n   \n   进入 .git目录后，打开 config 文件，手动添入信息：url、fetch\n   \n   \n\n提交项目的源码和项目的打包文件\n\n * 提交项目源码到仓库里\n   \n   git add -A  # 把项目的所有文件添加到本地仓库\n   git commit -m ""  # 双引号里是对于添加文件的描述\n   git push   # 将本地仓库提交到远程仓库，也就是你的 GitHub 仓库，地址默认上方 config 文件的 url，具体看上方图片\n   # 你也可以 git push URL     # URL就是你的仓库地址\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 进入项目的根目录，打包项目\n   \n   yarn run build  # build是package.json的规定，你的不一定是build\n   \n   \n   1\n   \n   \n   vuepress build docs\n   \n   \n   1\n   \n\n * 上传打包项目到 gh-pages 分支，我的是在 .vuepress 目录下的 dist\n   \n   git add -A  # 把项目的所有文件添加到本地仓库\n   git commit -m ""  # 双引号里是对于添加文件的描述\n   git push -f URL master:gh-pages # URL就是你的仓库地址,推送到github gh-pages分支 \n   \n   \n   1\n   2\n   3\n   \n   \n   -f 是必须的，意味着覆盖原来的内容\n\n自此，如果可以在仓库 master 下看到源码，gh-pages 下看到打包后的文件，代表成功了\n\n\n# 开启部署\n\n笔记\n\n这一内容为开启 Github Page 或者 Gitee Page，是为了连接手动部署成功后的操作，如果手动部署失败或者想直接使用脚本部署，则至少二选一成功了再来进行本内容的操作。\n\n自动化部署前需要先开启 Github Page 或者 Gitee Page。\n\n2021-11-01 @Du Wu\n\n当部署成功时，没有看到想要的成果，我相信不会有人继续进行枯燥的操作。下面将开启 Github Page 或者 Gitee Page，见证自己的部署成功页面。\n\nGitHub Page\n\n\n\n防止图片失效，这里记录步骤\n 1. 进入仓库，点击 Settings\n 2. 找到 Pages 选项\n 3. 选择要部署的分支，一定是 gh-pages 分支\n 4. 绿色框的地址，就是所有人都能访问的地址，访问之后，就能看到你的博客\n\nGitee Page\n\n\n\n第一步，点击服务的时候，会有 6 个选项，选择第一个 Gitee Pages\n\n防止图片失效，这里记录步骤\n 1. 进入仓库，点击服务，弹出选择列表，选择 Gitee Pages\n 2. 选择要部署的分支，一定是 gh-pages 分支\n 3. 部署目录默认整个 gh-pages分支\n 4. HTTP5 可选可不选，我选了\n 5. 按下确定按钮，等待不久，显示地址，所有人访问这个地址就能进入你的博客\n\n注意\n\nGithub 一旦更新 gh-pages 分支内容，会自动重新部署，所以访问页面是最新的。\n\nGitee 一旦更新 gh-pages 分支内容，需要手动点击上图的更新按钮，访问的页面才是最新的。要想自动更新部署。要花钱。\n\n2021-11-02 @Du Wu\n\n\n# 脚本部署\n\n注意\n\n脚本部署仅适用于把打包后的文件推送到 GitHub 仓库的 gh-pages 分支下，不适用把项目源码推送到 master 主支上。\n\n所以还得手动执行命令把源码推送到 GitHub 仓库。当然自动化部署，可以全部解决。\n\n2021-11-01 @Du Wu\n\n每次写完文档，如果都需要像上面上传代码中手动打包，无疑是繁琐且耗费时间的，学会使用脚本解决频繁的问题，能更加专注于文章。\n\nshell 脚本，请自行学习，日后我更新了 shell 的学习文档，这里会提供跳转地址 「*记录」。\n\n该脚本是推送项目到 GitHub，如果推送到 Gitee，修改仓库地址即可，脚本名叫 deploy.sh，请放在项目的根目录下。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果手运行该脚本，则执行if里的，如果是GitHub自动执行该脚本，则是else里的\nif [ -z "$GITHUB_TOKEN" ]; then\n msg=\'deploy\'\n githubUrl=git@github.com:Kele-Bingtang/notes-blog.git  # 替换自己的 GitHub 仓库地址，SSH格式\nelse\n msg=\'来自github actions的自动部署\'\n # 替换自己的 GitHub 仓库地址，更改的是 @后面的地址 以及 把Kele-Bingtang 改为自己用户名\n githubUrl=https://Kele-Bingtang:${GITHUB_TOKEN}@github.com/Kele-Bingtang/notes-blog.git \n git config --global user.name "Kele_Bingtang"   # 修改为自己的 GitHub 用户名\n git config --global user.email "2456019588@qq.com"  # 修改为自己的 GitHub 邮箱，注册时绑定的邮箱\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github gh-pages分支\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在项目根目录打开 bash 命令窗口或者 Git Bash Here 窗口，执行该脚本\n\nsh deploy.sh  # 假设你的脚本叫 deploy.sh\n\n\n1\n\n\n> 注意：Windows下的 cmd 无法执行 shell 脚本\n\n\n# 自动化部署\n\n注意\n\nGithub 一旦推送了新代码，则会自动化部署。\n\nGitee 一旦推送了新代码，不会自动化部署，需要手动点击更新按钮。如实现自动化，需要收费，99元/年。\n\n2021-11-01 @Du Wu\n\n使用了脚本部署，相比较手动部署，少了打包的过程，节省了时间，但是还要手动执行两次过程：\n\n 1. 敲打命令推送项目源码到仓库的 master 上\n 2. 执行 shell 脚本，自动打包并推送打包内容到仓库的 gh-pages 上\n\n自动化部署利用了 GitHub Actions ，仅需实现过程1：推送项目源码到 master，即可自动实现过程 2\n\n过程 1 可以写一个脚本执行。这样执行一个脚本，即可实现自动化，下方有该脚本，名叫 push.sh\n\n\n# 介绍\n\nGitHub Actions 是 GitHub 的持续集成服务，于 2018 年 10 月推出。\n\nGitHub Actions 入门教程\n\nGitHub Actions 商城\n\n\n# 生成token\n\n首先，获取 token，这是 GitHub 的另一种授权方式，即不需要用户名和密码\n\n * 进入 GitHub，点击头像，找到 setting\n   \n   \n\n * 找到 Developer settings 并点击\n   \n   \n\n * 点击 Persional access tokens，然后点击 Generate new token 生成toke\n   \n   \n\n * 填写 Note，即 token 的描述，并选择 repo，其他不用选\n   \n   \n\n如果不想你的 token 过期，在 Expiration 选中 No expiration 即可\n\ntoken 生成后，记得保存下来，因为页面一旦关闭，token 不会在显示\n\n\n# 配置密钥\n\n拿到了 token，需要将该 token 进行配置，赋予某仓库权限\n\n内容分为三步，其中第三步看需求，第一、二步则是必须。\n\n第一步：配置 ACCESS_TOKEN；\n\n第二步：配置 SSH key\n\n第三步：配置 GITEE_RSA_PRIVATE_KEY和 GITEE_PASSWORD。\n\n配置 ACCESS_TOKEN\n\n配置密钥是因为自动化部署过程，需要 GitHub 权限，没有 token，就没有权限部署\n\nACCESS_TOKEN 是固定的，名字要和下方脚本使用的名对应上。如果需要改，双方都要改\n\n * 找到仓库的 Settings ，并点击 Secrets\n\n\n\n点击 New repository secret 并进行配置，其中 Name 是 ACCESS_TOKEN，Value 是之前生成的 token\n\n\n\n点击 Add secret 即可该密钥添加成功\n\n配置 SSH Key\n\n * 打开 Git Bash 查看电脑上是否已经存在 SSH 密钥。如果有，请直接看第三步\n   \n   cd ~/.ssh\n   \n   \n   1\n   \n   \n   或者前往C:\\Users\\你的用户名下找 .ssh 文件夹\n\n * 如果没有则需要创建新的 ssh key，打开 Git Bash Here，输入：\n   \n   ssh-keygen -t rsa -C "你的绑定GitHub邮箱"\n   \n   \n   1\n   \n   \n   1s 左右执行会停止，提示你选中文件保存路径，直接按 Enter 即可，即路径就在C:\\Users\\你的用户名下\n   \n   1s 左右执行又会停止，提示你输入密码，这里不用输入，直接按 Enter 即可\n\n * 在C:\\Users\\你的用户名目录下生成 .ssh 文件夹，去文件夹里找到两个文件：id_rsa 和 id_rsa.pub\n   \n   * id_rsa.pub 为公钥，可以多地方使用\n   * id_rsa 为私钥，提供私钥能找到所有的公钥\n\n * 复制 id_rsa.pub 的内容，进入 Github 的 Settings 设置里，找到 SSH and GPG keys，然后点击 New SSH Key 进行配置\n   \n   \n   \n   点击 New SSH Key 并进行配置：\n   \n   \n   \n   Title 就是 SSh Key 的标题；Key 填入 id_rsa.pub 的内容，如果 Key 不对，说明打开该文件的编码格式有问题\n\n * 测试 SSH 是否连接到 GitHub\n   \n   ssh -T git@github.com\n   \n   \n   1\n   \n   \n   成功连接标志：You\'ve sucessfully ...,but Github ... access\n\n可选步骤：配置 GITEE_RSA_PRIVATE_KEY 和 GITEE_PASSWORD\n\n提示\n\n如果需要 GitHub 的仓库同步到 Gitee 上，则执行这步骤。\n\n下方的自动化文件里，有 GitHub 仓库同步到 Gitee 的实现代码，如果不需要，请注释或者删除。\n\n2021-11-01 @Du Wu\n\n * 在 Gitee 创建仓库，名字要和 Github 的项目仓库一致，包括新建 gh-master 分支\n   \n   \n\n * 新建 gh-pages 分支\n\n\n\n\n\n * 复制 id_rsa.pub 的内容，进入 Gitee 的设置里，找到 SSH 公钥，进行配置\n   \n   \n\n * 测试 SSH 是否连接到 Gitee\n   \n   ssh -T git@gitee.com\n   \n   \n   1\n   \n   \n   成功连接标志：You\'ve sucessfully ...,but Github ... access\n\n * 重新执行配置 ACCESS_TOKEN 步骤，即进入 GitHub 仓库，点击 Settings -> Secrets -> New repository secret\n   \n   * Name 为 GITEE_PASSWORD，Value 为你的 Gitee 密码\n   \n   * Name 为 GITEE_RSA_PRIVATE_KEY，Value为 id_rsa 文件的内容\n     \n     > 注意：是 id_rsa 私钥，而不是 id_rsa.pub 公钥\n\n自此，完成了密钥的配置。\n\n\n# 自动化文件\n\nGitHub Actions 的实现需要一个 yml 文件，在根目录下创建两个文件夹和一个文件：/.github/workflows/ci.yml\n\n\n\nmyNote 是我的博客根目录。ci.yml 的 ci 可自定义\n\nci.yml 文件内容以及过程：（我已经写好了注释）\n\nname: CI\n\n#on: [push]\n\n# 在 master 分支发生 push 事件时触发。\non: \n  push:\n    branches:\n      - master\n      \nenv: # 设置环境变量\n  TZ: Asia/Shanghai # 时区（设置时区可使页面中的 最近更新时间 使用时区时间）\n\njobs: # 工作流\n  build: # 自定义名称\n    runs-on: ubuntu-latest # 必填，运行在虚拟机环境 ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps: # 步骤1\n      - name: Checkout # 步骤1，拉取代码\n      # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n        uses: actions/checkout@v1 \n      \n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n\n      - name: run deploy.sh # 步骤3：执行脚本 deploy.sh\n        env: # 设置环境变量，未设置则不运行\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # token \n          SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }} # 私钥\n        run: npm install && npm run deploy  # 执行 deploy.sh 脚本，位于项目根目录\n\n      - name: Push Matser To Gitee  # 步骤4：GitHub 内容同步到 Gitee，同步仓库是 master\n        uses: wearerequired/git-mirror-action@master\n        env:\n          SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }}\n        with:  # 从源到目的地\n          source-repo: \'git@github.com:Kele-Bingtang/notes-blog.git\'    #Github 仓库地址\n          destination-repo: \'git@gitee.com:kele-bingtang/notes-blog.git\'    #Gitee 仓库地址\n\n      - name: Build Gitee Pages # 步骤5：自动部署到 Gitee Pages\n        uses: yanglbme/gitee-pages-action@master\n        with:\n          # 注意替换为你的 Gitee 用户名\n          gitee-username: Kele-Bingtang\n          # 注意在 Settings -> Secrets 配置 GITEE_PASSWORD\n          gitee-password: ${{ secrets.GITEE_PASSWORD }}\n          # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错\n          gitee-repo: Kele-Bingtang/notes-blog\n          # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）\n          branch: gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n点击打开，一些参数解释\n\n * name 是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名，可自定义，查看步骤时显示的代号，叫 aa 都可以，描述步骤功能即可\n\n * on 指定触发 workflow 的条件，通常是某些事件，也可以是事件的数组。如上方就是 push 到 master 后触发\n\n * jobs 里面，需要写出每一项任务的 job_id，具体名称自定义。job_id里面的 name 字段是任务的说明\n\n * runs-on 指定运行所需要的虚拟机环境。它是必填字段\n\n * steps 指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定三个字段：name、run、env\n\n * uses 用的就是别人写好的插件，持续集成由很多操作组成，GitHub 因此允许其他人把写好的插件共享到插件市场，以便他人使用。因此如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可。、。官网自带的格式：action/功能名@xx，别人写好的 users 格式为：作者名/功能名@xx。作者名别改成自己的名字，我犯过这个错误，无需纠结为什么叫这个，我之前纠结过，人家规定的不可变的名字。类似于一个写好的命令脚本\n   \n   要想找多个其他 users 脚本，前往GitHub Actions 商城\n\n * env 指环境变量，也就是运行时需要的一些参数，如密钥，仓库地址等\n\n * with 表示传给插件的参数\n\n内容的 steps 里的步骤详细如下：（一个 name 代表一步）\n\n 1. 拉取代码。不需要修改\n 2. 检查 Node.js 版本，安装指定的 Nodejs 版本，如果版本对了，则会跳过这一步。不需要修改\n 3. 执行脚本 deploy.sh。也就是脚本部署的脚本，这个脚本会打包项目到 gh-pages 目录下。需要配置密钥，env 读取的就是密钥。上方说过密钥为什么固定是ACCESS_TOKEN这些，因为这里读取的就是这些名字，如需修改，双方都要改\n 4. GitHub 仓库同步到 Gitee，同步仓库是 master，如果没有这个打算，则注释或者删除掉，包括第五步\n 5. Gitee 获得最新的代码后，不会重新部署新的代码。因为免费的 Gitee Page 需要手动点击更新，而 Github Page 自动😸。所以需要别人写好的 users: yanglbme/gitee-pages-action@master 帮助点击更新\n\n文件内容需要改的是仓库地址，以及 Gitee 用户名\n\n编写提交项目到 master 仓库的脚本，叫 push.sh\n\n#!/usr/bin/env sh\n\n# 本脚本为自动部署的入口脚本，只需执行该脚本，即可实现GitHub的自动部署，以及 push 到 GitHub 的所有文件同步到 Gitee 中\n\nGITHUB_REPO=git@github.com:Kele-Bingtang/notes-blog.git\n\ncomment=$1\n\nif [ ! $comment ]; then\ncomment="更新内容+action自动部署"\nfi\n\ngit add -A\n\ngit commit -m "${comment}"    # $1 是启动该脚本传来的参数，如 sh push.sh hello，其中 hello 就会插入到 $1 处，如果想两个参数，则加 $2\n\ngit push $GITHUB_REPO   \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在根目录下用 Git Bash Here 打开，并执行该脚本\n\nsh push.sh\n\n\n1\n\n\n一旦该脚本执行成功后，静待五六分钟，会发现 master 主支更新了项目源码，gh-pages 分支更新的项目打包后的代码。\n\nGitee 对应的仓库 master 主支也更新了项目源码，gh-pages 分支也更新的项目打包后的代码。\n\n\n# 自动化文件流程\n\nyml 被执行流程\n\n当第一次提交项目到仓库时，Github 会自动在项目根目录找到 /.github/workflows/ 下的 yml 文件，如 ci.yml，并且执行该 ci.yml 文件；\n\n当第二次乃至后面提交项目到仓库时，Github 判断 ci.yml 内容是否发送变化，没有则执行仓库的 ci.yml 文件，有则先更新文件再执行。\n\nyml 执行流程\n\n当把项目源码推送到仓库的 master 主支时，该 yml 文件开始执行。该文件执行的第三步，就会执行 deploy.sh 脚本部署文件，完成把打包文件提交到 gh-pages 分支下，该文件的第四步，则是把 Github 仓库的代码同步到 Gitee 仓库里，包括 gh-pages分支（双方仓库名字要一致），该文件第五步，则是手动点击了 Gitee 的更新部署按钮。（Gitee 自动更新部署需要 99元/年，没钱只能利用脚本手动点击按钮更新）\n\n\n# 问答\n\nQ1 - 能概括一下本内容吗？\n\n可以，概括的过程包括 GitHub 和 Gitee，如果只选择一方，选择性另一方忽略即可。\n\n 1. Github 和 Gitee 分别创建一个仓库，并且分别创建 gh-pages 分支，仓库名要一致\n 2. 将写好的项目源码提交到 master 主支，打包后的项目文件放到 gh-pages 分支，主支名即 default\n 3. 开启 Github Pages 和 Gitee Pages，两者都有自己的部署地址，前者网速慢，后者网速快\n 4. 实现脚本部署，节省步骤 2 的打包项目提交时间，但是无法节省项目源码提交时间\n 5. 首先生成 token，然后生成公钥私钥，公钥分别配置在 Github 和 Gitee 网站上，token、私钥、Gitee 密码都配置在项目仓库上\n 6. 配置 yml 文件，在 根目录/.github/workflows/ 下创建 ci.yml 文件，填写好内容\n 7. 编写 push.sh 脚本，填写好内容，每次写完文档后执行该脚本，即可实现完成自动化部署\n\n----------------------------------------\n\nQ2 - 实现自动化部署有多少个脚本？\n\n3个\n\npush.sh：提交源码到 master 主支；\n\ndeploy：提交打包文件到 gh-pages 分支；\n\nci.yml：同步 Github 仓库到 Gitee 仓库。\n\n----------------------------------------\n\nQ3 - 为什么配置密钥内容好乱？\n\n其实配置密钥总结就是：给 Github 项目仓库配置 token、Gitee 密码、私钥，给 Github、Gitee 配置公钥。\n\nQ4 - 为什么给仓库配置 token？\n\n因为项目仓库要实现自动化部署，需要权限，而权限来自于 token，可以理解为它是另一种用户名密码，所以别泄露 token。\n\n----------------------------------------\n\nQ5 - 为什么分别给 GitHub 网站和 Gitee 网站配置 id_rsa.pub 公钥，又给 Github 的项目仓库配置 id_rsa 私钥？\n\n因为配置好自动化文件后，Github 要想同步仓库代码到 Gitee，则必须需要搭建桥梁。这个桥梁就是公钥，所以双方都要配好公钥。而私钥则是打开、通往桥梁的钥匙。\n\n比如提交了代码到 GitHub 仓库，Github 要想同步到 Gitee，首先找到和自己相吻合的公钥，也就是 Gitee 的公钥，然后通过 GitHub Actions 入口前往 Gitee，前往的路上为什么能保证数据的不丢失，就是私钥在指引道路。\n\n多个仓库都可以配置一个公钥，而某一仓库前往这些多个仓库，则需要私钥当作通行证和方向盘。\n\n----------------------------------------\n\nQ6 - 如果项目不想放在 Github 仓库，想放在 Gitee 仓库怎么做？\n\n可以把 Gitee 理解为 Github 的中文版，知道了如何在 Github 自动化部署项目，并且同步到 Gitee。转换一下语言，我相信也是很容易的。\n\n比如双方都配好公钥、Gitee 拿着私钥去找 Github 同步仓库也是可以的。\n\n----------------------------------------\n\nQ7 - 如果只想把项目放在 Github 或者 Gitee 任一网站上，需要都 token、密钥都配置吗？\n\n不需要，只需要在项目部署的网站配置好 token 和 SSH Key 即可，然后去 ci.yml 里把步骤 4 和步骤 5 注释或者去掉。\n\n有些人只需要配置 token 即可，不需要配置 SSH Key，因为曾经配置过了，我建议都需要重新配置，防止意外。\n\n----------------------------------------\n\nQ8 - 为什么一定同步到 Gitee？\n\n刚开始我只部署到 GitHub Page，但是毕竟是国外，网速慢，所以就考虑部署到 Gitee，但是又不舍得 GitHub，于是重心依然放在 GitHub，只需要同步到 Gitee Pages 即可。其实我访问博客，一直访问的是 Gitee Pages 提供的地址。还是比较快。\n\n\n# 问题\n\n记录我在部署的过程中遇到的问题，这些问题卡了我挺长时间：\n\n 1. 生成 token 和 Secrets 设置\n 2. 配置 .git/conig 内容以及指令一样\n 3. .github/**.yml 设计\n 4. GitHub 自动部署，而 Gitee 需要手动\n 5. shell 脚本设计\n\n\n# 更新base\n\n因为一些原因，我把 base 由仓库名改为了 /，从而导致部署后访问的地址带有仓库名失效，正确做法：\n\n * GitHub 仓库修改仓库名为：<username>.github.io，这样直接访问 https://<username>.github.io 就会生效\n   \n   \n\n * Github 仓库修改路径，仓库名不重要，可改可不改，改为 <username>.gitee.io\n   \n   \n\nci.yml 文件把原来的仓库地址修改为更新后的地址：\n\nname: CI\n\n#on: [push]\n\n# 在 master 分支发生 push 事件时触发。\non: \n  push:\n    branches:\n      - master\n\njobs: # 工作流\n  build: # 自定义名称\n    runs-on: ubuntu-latest # 必填，运行在虚拟机环境 ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps: \n      - name: Checkout # 步骤1，拉取代码\n      # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n        uses: actions/checkout@v1 \n      \n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n\n      - name: run deploy.sh # 步骤3：执行脚本 deploy.sh\n        env: # 设置环境变量，未设置则不运行\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # token \n          SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }} # 私钥\n        run: npm install && npm run deploy  # 执行 deploy.sh 脚本，位于项目根目录\n\n      - name: Push Matser To Gitee  # 步骤4：GitHub 内容同步到 Gitee，同步仓库是 master\n        uses: wearerequired/git-mirror-action@master\n        env:\n          SSH_PRIVATE_KEY: ${{ secrets.GITEE_RSA_PRIVATE_KEY }}\n        with:  # 从源到目的地\n          source-repo: \'git@github.com:Kele-Bingtang/Kele-Bingtang.github.io.git\'    #Github 仓库地址\n          destination-repo: \'git@gitee.com:kele-bingtang/Kele-Bingtang.gitee.io.git\'    #Gitee 仓库地址\n\n      - name: Build Gitee Pages # 步骤5：自动部署到 Gitee Pages\n        uses: yanglbme/gitee-pages-action@master\n        with:\n          # 注意替换为你的 Gitee 用户名\n          gitee-username: Kele-Bingtang\n          # 注意在 Settings -> Secrets 配置 GITEE_PASSWORD\n          gitee-password: ${{ secrets.GITEE_PASSWORD }}\n          # 注意替换为你的 Gitee 仓库地址，仓库名严格区分大小写，一般地址和仓库名一致，如果地址改了，仓库名不改，要以地址为准（地址仅需后缀，即 https://gitee.com/<username>/xxx 的 xxx 即可）\n          gitee-repo: Kele-Bingtang/Kele-Bingtang.gitee.io\n          # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）\n          branch: gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n值得注意的是 51 行的 gitee-repo 不是 Gitee 的仓库名字，而是修改的地址名：<username>.gitee.io。\n\n\n# 自定义域名\n\n这里以 GitHub 举例，Gitee 同理。\n\n前往你的域名解析处，进入如下配置：\n\n\n\n然后进入 GitHub 绑定自定义的域名\n\n\n\n注意\n\nGitee 的仓库不要改为 <username>.gitee.io，而是直接改为 <username> 即可。\n\n2021-01-04 @Du Wu\n\n套用 Gitee 官方的一句话：\n\n如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，你需要建立一个与自己个性地址同名的仓库，如 https://gitee.com/ipvb 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以ipvb.gitee.io直接访问，那么他就可以创建一个名字为ipvb的仓库 https://gitee.com/ipvb/ipvb 部署完成后，就可以以 https://ipvb.gitee.io 进行访问了。',normalizedContent:'序言\n\n部署，打造自己的「身份证」。\n\n自动化，时间管理的福利。\n\n2021-11-01 @du wu\n\n\n\n * 手动部署\n   * 介绍\n   * 优势\n   * 限制\n   * 开始使用\n   * 上传代码\n * 开启部署\n * 脚本部署\n * 自动化部署\n   * 介绍\n   * 生成token\n   * 配置密钥\n   * 自动化文件\n   * 自动化文件流程\n * 问答\n * 问题\n * 更新base\n * 自定义域名\n\n\n\n\n# 手动部署\n\n\n# 介绍\n\ngithub pages 是一个静态站点托管服务。\n\n如果你想记录生活、抒发情感、分享见解，这一切都离不开一个可以承载文字的平台，一个独立的、由自己掌控的平台，而 github pages 就是这么一个平台。\n\n在这个平台里你可以使用自己的个性域名；可以在海量的主题里挑选最适合你的那一款，如果你技术极客，也可以根据自己的喜好，设计属于自己的个性化页面；你既可以在线创建和发布网站，也可以在本地通过客户端工具或者命令行进行网站和内容的管理。\n\n你完全可以通过 github pages 展示和输出自身价值，甚至可以把它打造成属于自己的互联网「身份证」。\n\n如果你想仔细了解 github pages，点击这里\n\n\n# 优势\n\n * github pages 完全免费，不需要个人购买服务器、域名\n * 官方文档详细，不需要强大的编程能力，只需要一步一步按着操作来使用\n * 支持的功能多，你可以绑定你的域名、使用免费的 https、自己 diy 网站的主题、使用他人开发好的插件等等\n * 完成搭建后，只需要专注于文章即可，其他诸如环境搭建、系统维护、文件存储的事情一概不用操心，都由 github pages 处理\n\n......\n\n\n# 限制\n\n * github pages 源仓库建议限制为 1gb；\n * 发布的 github pages 网站可能不超过 1gb；\n * github pages 网站每月的带宽限制为 100gb；\n * github pages 网站每小时限制 10 个软件。\n\n\n# 开始使用\n\n * 首先，你必须拥有一个 github 账号，注册点击这里\n\n * 创建一个仓库用于存放自己的博客项目，如图：点击右上角的 + 号\n   \n   \n\n * 填写自己的仓库信息\n   \n   \n   \n   如我的博客仓库名就叫 notes-blog，因为我打算创建一个生活博客，类似于 live-blog，所以对博客名进行分类\n   \n   防止图片失效，这里记录步骤和gitignore文件内容\n    1. 填写仓库名\n    2. 填写仓库描述，可以不写\n    3. 选择公有 public\n    4. 建议选择 add a readme file，添加readme文档\n    5. add .gitignore 是添加 .gitignore 文件，如果不知道文件内容，可以不选。则需要手动在自己的博客目录下创建 .gitignore文档，填入如下内容：\n   \n   # npm\n   package-lock.json\n   node_modules\n   \n   # yarn\n   yarn.lock\n   \n   # vscode\n   .vscode\n   \n   # vuepress\n   docs/.vuepress/dist\n   \n   # 百度链接推送\n   urls.txt\n   \n   # mac\n   .ds_store\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n * 创建仓库后，进入仓库，然后创建一个分支，名字必须叫做gh-pages，可以理解为默认只识别这个名字\n   \n   * 创建好的仓库默认主支是 master 或者 main，现在 github 逐渐让 main 作为默认的主支名\n   * 主支用于仓库的文件汇总，分支则是每一个用户上传到仓库的通道，最终合并到主支\n   \n   \n   \n   防止图片失效，这里记录步骤\n    1. 点击 master，弹出拉下框\n    2. 搜索 gh-pages，必须是这个\n    3. 创建 gh-pages。搜索后，会显示 create branch：gh-pages from master，点击即可创建\n\n说明\n\n为什么创建 gh-pages 分支呢？因为 master 主支放的是博客源码，而 gh-pages 分支放的是主支打包后的博客代码。\n\n不理解打包，可以这么认为：写的 markdown 文档是源码，要想显示到网页上，需要变成 html 文件，打包就是变成 html 的过程。\n\n2021-11-01 @du wu\n\n\n# 上传代码\n\n * 初始化项目根目录\n   \n   git init\n   \n   \n   1\n   \n   \n   如果早期你的项目体系是从其他人的仓库克隆的，说明你不需要初始化根目录，而是需要修改 github 的提交地址，因为提交地址目前是其他人的\n   \n   修改提交地址\n   \n   方法一：\n   \n   执行如下命令进行更改：\n   \n   git remote rm origin  # 删除远程地址\n   git remote add origin url  #  url 填写自己的仓库地址，如我的就是 https://github.com/kele-bingtang/notes-blog\n   \n   \n   1\n   2\n   \n   \n   方法二：（执行方法一，其实就会自动执行方法二）\n   \n   打开根目录下的 .git 文件夹，因为这个文件夹默认隐藏，所以需要设置显示隐藏文件\n   \n   \n   \n   进入 .git目录后，打开 config 文件，手动添入信息：url、fetch\n   \n   \n\n提交项目的源码和项目的打包文件\n\n * 提交项目源码到仓库里\n   \n   git add -a  # 把项目的所有文件添加到本地仓库\n   git commit -m ""  # 双引号里是对于添加文件的描述\n   git push   # 将本地仓库提交到远程仓库，也就是你的 github 仓库，地址默认上方 config 文件的 url，具体看上方图片\n   # 你也可以 git push url     # url就是你的仓库地址\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 进入项目的根目录，打包项目\n   \n   yarn run build  # build是package.json的规定，你的不一定是build\n   \n   \n   1\n   \n   \n   vuepress build docs\n   \n   \n   1\n   \n\n * 上传打包项目到 gh-pages 分支，我的是在 .vuepress 目录下的 dist\n   \n   git add -a  # 把项目的所有文件添加到本地仓库\n   git commit -m ""  # 双引号里是对于添加文件的描述\n   git push -f url master:gh-pages # url就是你的仓库地址,推送到github gh-pages分支 \n   \n   \n   1\n   2\n   3\n   \n   \n   -f 是必须的，意味着覆盖原来的内容\n\n自此，如果可以在仓库 master 下看到源码，gh-pages 下看到打包后的文件，代表成功了\n\n\n# 开启部署\n\n笔记\n\n这一内容为开启 github page 或者 gitee page，是为了连接手动部署成功后的操作，如果手动部署失败或者想直接使用脚本部署，则至少二选一成功了再来进行本内容的操作。\n\n自动化部署前需要先开启 github page 或者 gitee page。\n\n2021-11-01 @du wu\n\n当部署成功时，没有看到想要的成果，我相信不会有人继续进行枯燥的操作。下面将开启 github page 或者 gitee page，见证自己的部署成功页面。\n\ngithub page\n\n\n\n防止图片失效，这里记录步骤\n 1. 进入仓库，点击 settings\n 2. 找到 pages 选项\n 3. 选择要部署的分支，一定是 gh-pages 分支\n 4. 绿色框的地址，就是所有人都能访问的地址，访问之后，就能看到你的博客\n\ngitee page\n\n\n\n第一步，点击服务的时候，会有 6 个选项，选择第一个 gitee pages\n\n防止图片失效，这里记录步骤\n 1. 进入仓库，点击服务，弹出选择列表，选择 gitee pages\n 2. 选择要部署的分支，一定是 gh-pages 分支\n 3. 部署目录默认整个 gh-pages分支\n 4. http5 可选可不选，我选了\n 5. 按下确定按钮，等待不久，显示地址，所有人访问这个地址就能进入你的博客\n\n注意\n\ngithub 一旦更新 gh-pages 分支内容，会自动重新部署，所以访问页面是最新的。\n\ngitee 一旦更新 gh-pages 分支内容，需要手动点击上图的更新按钮，访问的页面才是最新的。要想自动更新部署。要花钱。\n\n2021-11-02 @du wu\n\n\n# 脚本部署\n\n注意\n\n脚本部署仅适用于把打包后的文件推送到 github 仓库的 gh-pages 分支下，不适用把项目源码推送到 master 主支上。\n\n所以还得手动执行命令把源码推送到 github 仓库。当然自动化部署，可以全部解决。\n\n2021-11-01 @du wu\n\n每次写完文档，如果都需要像上面上传代码中手动打包，无疑是繁琐且耗费时间的，学会使用脚本解决频繁的问题，能更加专注于文章。\n\nshell 脚本，请自行学习，日后我更新了 shell 的学习文档，这里会提供跳转地址 「*记录」。\n\n该脚本是推送项目到 github，如果推送到 gitee，修改仓库地址即可，脚本名叫 deploy.sh，请放在项目的根目录下。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# 如果手运行该脚本，则执行if里的，如果是github自动执行该脚本，则是else里的\nif [ -z "$github_token" ]; then\n msg=\'deploy\'\n githuburl=git@github.com:kele-bingtang/notes-blog.git  # 替换自己的 github 仓库地址，ssh格式\nelse\n msg=\'来自github actions的自动部署\'\n # 替换自己的 github 仓库地址，更改的是 @后面的地址 以及 把kele-bingtang 改为自己用户名\n githuburl=https://kele-bingtang:${github_token}@github.com/kele-bingtang/notes-blog.git \n git config --global user.name "kele_bingtang"   # 修改为自己的 github 用户名\n git config --global user.email "2456019588@qq.com"  # 修改为自己的 github 邮箱，注册时绑定的邮箱\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github gh-pages分支\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在项目根目录打开 bash 命令窗口或者 git bash here 窗口，执行该脚本\n\nsh deploy.sh  # 假设你的脚本叫 deploy.sh\n\n\n1\n\n\n> 注意：windows下的 cmd 无法执行 shell 脚本\n\n\n# 自动化部署\n\n注意\n\ngithub 一旦推送了新代码，则会自动化部署。\n\ngitee 一旦推送了新代码，不会自动化部署，需要手动点击更新按钮。如实现自动化，需要收费，99元/年。\n\n2021-11-01 @du wu\n\n使用了脚本部署，相比较手动部署，少了打包的过程，节省了时间，但是还要手动执行两次过程：\n\n 1. 敲打命令推送项目源码到仓库的 master 上\n 2. 执行 shell 脚本，自动打包并推送打包内容到仓库的 gh-pages 上\n\n自动化部署利用了 github actions ，仅需实现过程1：推送项目源码到 master，即可自动实现过程 2\n\n过程 1 可以写一个脚本执行。这样执行一个脚本，即可实现自动化，下方有该脚本，名叫 push.sh\n\n\n# 介绍\n\ngithub actions 是 github 的持续集成服务，于 2018 年 10 月推出。\n\ngithub actions 入门教程\n\ngithub actions 商城\n\n\n# 生成token\n\n首先，获取 token，这是 github 的另一种授权方式，即不需要用户名和密码\n\n * 进入 github，点击头像，找到 setting\n   \n   \n\n * 找到 developer settings 并点击\n   \n   \n\n * 点击 persional access tokens，然后点击 generate new token 生成toke\n   \n   \n\n * 填写 note，即 token 的描述，并选择 repo，其他不用选\n   \n   \n\n如果不想你的 token 过期，在 expiration 选中 no expiration 即可\n\ntoken 生成后，记得保存下来，因为页面一旦关闭，token 不会在显示\n\n\n# 配置密钥\n\n拿到了 token，需要将该 token 进行配置，赋予某仓库权限\n\n内容分为三步，其中第三步看需求，第一、二步则是必须。\n\n第一步：配置 access_token；\n\n第二步：配置 ssh key\n\n第三步：配置 gitee_rsa_private_key和 gitee_password。\n\n配置 access_token\n\n配置密钥是因为自动化部署过程，需要 github 权限，没有 token，就没有权限部署\n\naccess_token 是固定的，名字要和下方脚本使用的名对应上。如果需要改，双方都要改\n\n * 找到仓库的 settings ，并点击 secrets\n\n\n\n点击 new repository secret 并进行配置，其中 name 是 access_token，value 是之前生成的 token\n\n\n\n点击 add secret 即可该密钥添加成功\n\n配置 ssh key\n\n * 打开 git bash 查看电脑上是否已经存在 ssh 密钥。如果有，请直接看第三步\n   \n   cd ~/.ssh\n   \n   \n   1\n   \n   \n   或者前往c:\\users\\你的用户名下找 .ssh 文件夹\n\n * 如果没有则需要创建新的 ssh key，打开 git bash here，输入：\n   \n   ssh-keygen -t rsa -c "你的绑定github邮箱"\n   \n   \n   1\n   \n   \n   1s 左右执行会停止，提示你选中文件保存路径，直接按 enter 即可，即路径就在c:\\users\\你的用户名下\n   \n   1s 左右执行又会停止，提示你输入密码，这里不用输入，直接按 enter 即可\n\n * 在c:\\users\\你的用户名目录下生成 .ssh 文件夹，去文件夹里找到两个文件：id_rsa 和 id_rsa.pub\n   \n   * id_rsa.pub 为公钥，可以多地方使用\n   * id_rsa 为私钥，提供私钥能找到所有的公钥\n\n * 复制 id_rsa.pub 的内容，进入 github 的 settings 设置里，找到 ssh and gpg keys，然后点击 new ssh key 进行配置\n   \n   \n   \n   点击 new ssh key 并进行配置：\n   \n   \n   \n   title 就是 ssh key 的标题；key 填入 id_rsa.pub 的内容，如果 key 不对，说明打开该文件的编码格式有问题\n\n * 测试 ssh 是否连接到 github\n   \n   ssh -t git@github.com\n   \n   \n   1\n   \n   \n   成功连接标志：you\'ve sucessfully ...,but github ... access\n\n可选步骤：配置 gitee_rsa_private_key 和 gitee_password\n\n提示\n\n如果需要 github 的仓库同步到 gitee 上，则执行这步骤。\n\n下方的自动化文件里，有 github 仓库同步到 gitee 的实现代码，如果不需要，请注释或者删除。\n\n2021-11-01 @du wu\n\n * 在 gitee 创建仓库，名字要和 github 的项目仓库一致，包括新建 gh-master 分支\n   \n   \n\n * 新建 gh-pages 分支\n\n\n\n\n\n * 复制 id_rsa.pub 的内容，进入 gitee 的设置里，找到 ssh 公钥，进行配置\n   \n   \n\n * 测试 ssh 是否连接到 gitee\n   \n   ssh -t git@gitee.com\n   \n   \n   1\n   \n   \n   成功连接标志：you\'ve sucessfully ...,but github ... access\n\n * 重新执行配置 access_token 步骤，即进入 github 仓库，点击 settings -> secrets -> new repository secret\n   \n   * name 为 gitee_password，value 为你的 gitee 密码\n   \n   * name 为 gitee_rsa_private_key，value为 id_rsa 文件的内容\n     \n     > 注意：是 id_rsa 私钥，而不是 id_rsa.pub 公钥\n\n自此，完成了密钥的配置。\n\n\n# 自动化文件\n\ngithub actions 的实现需要一个 yml 文件，在根目录下创建两个文件夹和一个文件：/.github/workflows/ci.yml\n\n\n\nmynote 是我的博客根目录。ci.yml 的 ci 可自定义\n\nci.yml 文件内容以及过程：（我已经写好了注释）\n\nname: ci\n\n#on: [push]\n\n# 在 master 分支发生 push 事件时触发。\non: \n  push:\n    branches:\n      - master\n      \nenv: # 设置环境变量\n  tz: asia/shanghai # 时区（设置时区可使页面中的 最近更新时间 使用时区时间）\n\njobs: # 工作流\n  build: # 自定义名称\n    runs-on: ubuntu-latest # 必填，运行在虚拟机环境 ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps: # 步骤1\n      - name: checkout # 步骤1，拉取代码\n      # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n        uses: actions/checkout@v1 \n      \n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n\n      - name: run deploy.sh # 步骤3：执行脚本 deploy.sh\n        env: # 设置环境变量，未设置则不运行\n          github_token: ${{ secrets.access_token }} # token \n          ssh_private_key: ${{ secrets.gitee_rsa_private_key }} # 私钥\n        run: npm install && npm run deploy  # 执行 deploy.sh 脚本，位于项目根目录\n\n      - name: push matser to gitee  # 步骤4：github 内容同步到 gitee，同步仓库是 master\n        uses: wearerequired/git-mirror-action@master\n        env:\n          ssh_private_key: ${{ secrets.gitee_rsa_private_key }}\n        with:  # 从源到目的地\n          source-repo: \'git@github.com:kele-bingtang/notes-blog.git\'    #github 仓库地址\n          destination-repo: \'git@gitee.com:kele-bingtang/notes-blog.git\'    #gitee 仓库地址\n\n      - name: build gitee pages # 步骤5：自动部署到 gitee pages\n        uses: yanglbme/gitee-pages-action@master\n        with:\n          # 注意替换为你的 gitee 用户名\n          gitee-username: kele-bingtang\n          # 注意在 settings -> secrets 配置 gitee_password\n          gitee-password: ${{ secrets.gitee_password }}\n          # 注意替换为你的 gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错\n          gitee-repo: kele-bingtang/notes-blog\n          # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）\n          branch: gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n点击打开，一些参数解释\n\n * name 是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名，可自定义，查看步骤时显示的代号，叫 aa 都可以，描述步骤功能即可\n\n * on 指定触发 workflow 的条件，通常是某些事件，也可以是事件的数组。如上方就是 push 到 master 后触发\n\n * jobs 里面，需要写出每一项任务的 job_id，具体名称自定义。job_id里面的 name 字段是任务的说明\n\n * runs-on 指定运行所需要的虚拟机环境。它是必填字段\n\n * steps 指定每个 job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定三个字段：name、run、env\n\n * uses 用的就是别人写好的插件，持续集成由很多操作组成，github 因此允许其他人把写好的插件共享到插件市场，以便他人使用。因此如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可。、。官网自带的格式：action/功能名@xx，别人写好的 users 格式为：作者名/功能名@xx。作者名别改成自己的名字，我犯过这个错误，无需纠结为什么叫这个，我之前纠结过，人家规定的不可变的名字。类似于一个写好的命令脚本\n   \n   要想找多个其他 users 脚本，前往github actions 商城\n\n * env 指环境变量，也就是运行时需要的一些参数，如密钥，仓库地址等\n\n * with 表示传给插件的参数\n\n内容的 steps 里的步骤详细如下：（一个 name 代表一步）\n\n 1. 拉取代码。不需要修改\n 2. 检查 node.js 版本，安装指定的 nodejs 版本，如果版本对了，则会跳过这一步。不需要修改\n 3. 执行脚本 deploy.sh。也就是脚本部署的脚本，这个脚本会打包项目到 gh-pages 目录下。需要配置密钥，env 读取的就是密钥。上方说过密钥为什么固定是access_token这些，因为这里读取的就是这些名字，如需修改，双方都要改\n 4. github 仓库同步到 gitee，同步仓库是 master，如果没有这个打算，则注释或者删除掉，包括第五步\n 5. gitee 获得最新的代码后，不会重新部署新的代码。因为免费的 gitee page 需要手动点击更新，而 github page 自动😸。所以需要别人写好的 users: yanglbme/gitee-pages-action@master 帮助点击更新\n\n文件内容需要改的是仓库地址，以及 gitee 用户名\n\n编写提交项目到 master 仓库的脚本，叫 push.sh\n\n#!/usr/bin/env sh\n\n# 本脚本为自动部署的入口脚本，只需执行该脚本，即可实现github的自动部署，以及 push 到 github 的所有文件同步到 gitee 中\n\ngithub_repo=git@github.com:kele-bingtang/notes-blog.git\n\ncomment=$1\n\nif [ ! $comment ]; then\ncomment="更新内容+action自动部署"\nfi\n\ngit add -a\n\ngit commit -m "${comment}"    # $1 是启动该脚本传来的参数，如 sh push.sh hello，其中 hello 就会插入到 $1 处，如果想两个参数，则加 $2\n\ngit push $github_repo   \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在根目录下用 git bash here 打开，并执行该脚本\n\nsh push.sh\n\n\n1\n\n\n一旦该脚本执行成功后，静待五六分钟，会发现 master 主支更新了项目源码，gh-pages 分支更新的项目打包后的代码。\n\ngitee 对应的仓库 master 主支也更新了项目源码，gh-pages 分支也更新的项目打包后的代码。\n\n\n# 自动化文件流程\n\nyml 被执行流程\n\n当第一次提交项目到仓库时，github 会自动在项目根目录找到 /.github/workflows/ 下的 yml 文件，如 ci.yml，并且执行该 ci.yml 文件；\n\n当第二次乃至后面提交项目到仓库时，github 判断 ci.yml 内容是否发送变化，没有则执行仓库的 ci.yml 文件，有则先更新文件再执行。\n\nyml 执行流程\n\n当把项目源码推送到仓库的 master 主支时，该 yml 文件开始执行。该文件执行的第三步，就会执行 deploy.sh 脚本部署文件，完成把打包文件提交到 gh-pages 分支下，该文件的第四步，则是把 github 仓库的代码同步到 gitee 仓库里，包括 gh-pages分支（双方仓库名字要一致），该文件第五步，则是手动点击了 gitee 的更新部署按钮。（gitee 自动更新部署需要 99元/年，没钱只能利用脚本手动点击按钮更新）\n\n\n# 问答\n\nq1 - 能概括一下本内容吗？\n\n可以，概括的过程包括 github 和 gitee，如果只选择一方，选择性另一方忽略即可。\n\n 1. github 和 gitee 分别创建一个仓库，并且分别创建 gh-pages 分支，仓库名要一致\n 2. 将写好的项目源码提交到 master 主支，打包后的项目文件放到 gh-pages 分支，主支名即 default\n 3. 开启 github pages 和 gitee pages，两者都有自己的部署地址，前者网速慢，后者网速快\n 4. 实现脚本部署，节省步骤 2 的打包项目提交时间，但是无法节省项目源码提交时间\n 5. 首先生成 token，然后生成公钥私钥，公钥分别配置在 github 和 gitee 网站上，token、私钥、gitee 密码都配置在项目仓库上\n 6. 配置 yml 文件，在 根目录/.github/workflows/ 下创建 ci.yml 文件，填写好内容\n 7. 编写 push.sh 脚本，填写好内容，每次写完文档后执行该脚本，即可实现完成自动化部署\n\n----------------------------------------\n\nq2 - 实现自动化部署有多少个脚本？\n\n3个\n\npush.sh：提交源码到 master 主支；\n\ndeploy：提交打包文件到 gh-pages 分支；\n\nci.yml：同步 github 仓库到 gitee 仓库。\n\n----------------------------------------\n\nq3 - 为什么配置密钥内容好乱？\n\n其实配置密钥总结就是：给 github 项目仓库配置 token、gitee 密码、私钥，给 github、gitee 配置公钥。\n\nq4 - 为什么给仓库配置 token？\n\n因为项目仓库要实现自动化部署，需要权限，而权限来自于 token，可以理解为它是另一种用户名密码，所以别泄露 token。\n\n----------------------------------------\n\nq5 - 为什么分别给 github 网站和 gitee 网站配置 id_rsa.pub 公钥，又给 github 的项目仓库配置 id_rsa 私钥？\n\n因为配置好自动化文件后，github 要想同步仓库代码到 gitee，则必须需要搭建桥梁。这个桥梁就是公钥，所以双方都要配好公钥。而私钥则是打开、通往桥梁的钥匙。\n\n比如提交了代码到 github 仓库，github 要想同步到 gitee，首先找到和自己相吻合的公钥，也就是 gitee 的公钥，然后通过 github actions 入口前往 gitee，前往的路上为什么能保证数据的不丢失，就是私钥在指引道路。\n\n多个仓库都可以配置一个公钥，而某一仓库前往这些多个仓库，则需要私钥当作通行证和方向盘。\n\n----------------------------------------\n\nq6 - 如果项目不想放在 github 仓库，想放在 gitee 仓库怎么做？\n\n可以把 gitee 理解为 github 的中文版，知道了如何在 github 自动化部署项目，并且同步到 gitee。转换一下语言，我相信也是很容易的。\n\n比如双方都配好公钥、gitee 拿着私钥去找 github 同步仓库也是可以的。\n\n----------------------------------------\n\nq7 - 如果只想把项目放在 github 或者 gitee 任一网站上，需要都 token、密钥都配置吗？\n\n不需要，只需要在项目部署的网站配置好 token 和 ssh key 即可，然后去 ci.yml 里把步骤 4 和步骤 5 注释或者去掉。\n\n有些人只需要配置 token 即可，不需要配置 ssh key，因为曾经配置过了，我建议都需要重新配置，防止意外。\n\n----------------------------------------\n\nq8 - 为什么一定同步到 gitee？\n\n刚开始我只部署到 github page，但是毕竟是国外，网速慢，所以就考虑部署到 gitee，但是又不舍得 github，于是重心依然放在 github，只需要同步到 gitee pages 即可。其实我访问博客，一直访问的是 gitee pages 提供的地址。还是比较快。\n\n\n# 问题\n\n记录我在部署的过程中遇到的问题，这些问题卡了我挺长时间：\n\n 1. 生成 token 和 secrets 设置\n 2. 配置 .git/conig 内容以及指令一样\n 3. .github/**.yml 设计\n 4. github 自动部署，而 gitee 需要手动\n 5. shell 脚本设计\n\n\n# 更新base\n\n因为一些原因，我把 base 由仓库名改为了 /，从而导致部署后访问的地址带有仓库名失效，正确做法：\n\n * github 仓库修改仓库名为：<username>.github.io，这样直接访问 https://<username>.github.io 就会生效\n   \n   \n\n * github 仓库修改路径，仓库名不重要，可改可不改，改为 <username>.gitee.io\n   \n   \n\nci.yml 文件把原来的仓库地址修改为更新后的地址：\n\nname: ci\n\n#on: [push]\n\n# 在 master 分支发生 push 事件时触发。\non: \n  push:\n    branches:\n      - master\n\njobs: # 工作流\n  build: # 自定义名称\n    runs-on: ubuntu-latest # 必填，运行在虚拟机环境 ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [14.x]\n\n    steps: \n      - name: checkout # 步骤1，拉取代码\n      # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n        uses: actions/checkout@v1 \n      \n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n\n      - name: run deploy.sh # 步骤3：执行脚本 deploy.sh\n        env: # 设置环境变量，未设置则不运行\n          github_token: ${{ secrets.access_token }} # token \n          ssh_private_key: ${{ secrets.gitee_rsa_private_key }} # 私钥\n        run: npm install && npm run deploy  # 执行 deploy.sh 脚本，位于项目根目录\n\n      - name: push matser to gitee  # 步骤4：github 内容同步到 gitee，同步仓库是 master\n        uses: wearerequired/git-mirror-action@master\n        env:\n          ssh_private_key: ${{ secrets.gitee_rsa_private_key }}\n        with:  # 从源到目的地\n          source-repo: \'git@github.com:kele-bingtang/kele-bingtang.github.io.git\'    #github 仓库地址\n          destination-repo: \'git@gitee.com:kele-bingtang/kele-bingtang.gitee.io.git\'    #gitee 仓库地址\n\n      - name: build gitee pages # 步骤5：自动部署到 gitee pages\n        uses: yanglbme/gitee-pages-action@master\n        with:\n          # 注意替换为你的 gitee 用户名\n          gitee-username: kele-bingtang\n          # 注意在 settings -> secrets 配置 gitee_password\n          gitee-password: ${{ secrets.gitee_password }}\n          # 注意替换为你的 gitee 仓库地址，仓库名严格区分大小写，一般地址和仓库名一致，如果地址改了，仓库名不改，要以地址为准（地址仅需后缀，即 https://gitee.com/<username>/xxx 的 xxx 即可）\n          gitee-repo: kele-bingtang/kele-bingtang.gitee.io\n          # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）\n          branch: gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n值得注意的是 51 行的 gitee-repo 不是 gitee 的仓库名字，而是修改的地址名：<username>.gitee.io。\n\n\n# 自定义域名\n\n这里以 github 举例，gitee 同理。\n\n前往你的域名解析处，进入如下配置：\n\n\n\n然后进入 github 绑定自定义的域名\n\n\n\n注意\n\ngitee 的仓库不要改为 <username>.gitee.io，而是直接改为 <username> 即可。\n\n2021-01-04 @du wu\n\n套用 gitee 官方的一句话：\n\n如果你想你的 pages 首页访问地址不带二级目录，如ipvb.gitee.io，你需要建立一个与自己个性地址同名的仓库，如 https://gitee.com/ipvb 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以ipvb.gitee.io直接访问，那么他就可以创建一个名字为ipvb的仓库 https://gitee.com/ipvb/ipvb 部署完成后，就可以以 https://ipvb.gitee.io 进行访问了。',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 服务器部署",frontmatter:{title:"本站 - 服务器部署",date:"2021-12-03T12:23:14.000Z",permalink:"/about/website/server/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/12.%E6%9C%AC%E7%AB%99%20-%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2.html",relativePath:"80.关于/06.关于 - 本站/12.本站 - 服务器部署.md",key:"v-1980a5d5",path:"/about/website/server/",headers:[{level:2,title:"原理介绍",slug:"原理介绍",normalizedTitle:"原理介绍",charIndex:135},{level:2,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:143},{level:2,title:"环境安装",slug:"环境安装",normalizedTitle:"环境安装",charIndex:151},{level:2,title:"环境用户",slug:"环境用户",normalizedTitle:"环境用户",charIndex:159},{level:2,title:"环境启动",slug:"环境启动",normalizedTitle:"环境启动",charIndex:167},{level:3,title:"Nginx启动",slug:"nginx启动",normalizedTitle:"nginx启动",charIndex:177},{level:3,title:"PHP启动",slug:"php启动",normalizedTitle:"php启动",charIndex:190},{level:2,title:"环境配置",slug:"环境配置",normalizedTitle:"环境配置",charIndex:199},{level:3,title:"Nginx配置",slug:"nginx配置",normalizedTitle:"nginx配置",charIndex:209},{level:3,title:"PHP配置",slug:"php配置",normalizedTitle:"php配置",charIndex:222},{level:2,title:"环境重启",slug:"环境重启",normalizedTitle:"环境重启",charIndex:231},{level:2,title:"环境测试",slug:"环境测试",normalizedTitle:"环境测试",charIndex:239},{level:2,title:"Git环境",slug:"git环境",normalizedTitle:"git环境",charIndex:247},{level:3,title:"宿主机配置Git",slug:"宿主机配置git",normalizedTitle:"宿主机配置git",charIndex:258},{level:3,title:"PHP容器配置Git",slug:"php容器配置git",normalizedTitle:"php容器配置git",charIndex:272},{level:3,title:"项目访问",slug:"项目访问",normalizedTitle:"项目访问",charIndex:288},{level:2,title:"自动化部署",slug:"自动化部署",normalizedTitle:"自动化部署",charIndex:296},{level:3,title:"Gitee脚本",slug:"gitee脚本",normalizedTitle:"gitee脚本",charIndex:307},{level:3,title:"Github脚本",slug:"github脚本",normalizedTitle:"github脚本",charIndex:320},{level:3,title:"WebHook配置",slug:"webhook配置",normalizedTitle:"webhook配置",charIndex:334},{level:2,title:"问答",slug:"问答",normalizedTitle:"问答",charIndex:347}],headersStr:"原理介绍 环境准备 环境安装 环境用户 环境启动 Nginx启动 PHP启动 环境配置 Nginx配置 PHP配置 环境重启 环境测试 Git环境 宿主机配置Git PHP容器配置Git 项目访问 自动化部署 Gitee脚本 Github脚本 WebHook配置 问答",content:'笔记\n\n如果你不打算部署在 Github Pages 或者 Gitee Pages 上，而是部署在自己的服务器上，又或者三个都想自动同步部署，那么本内容就是带你如何在服务器部署项目，同时也有 Docker 的一次实战。\n\n2021-11-03 @Du Wu\n\n\n\n * 原理介绍\n * 环境准备\n * 环境安装\n * 环境用户\n * 环境启动\n   * Nginx启动\n   * PHP启动\n * 环境配置\n   * Nginx配置\n   * PHP配置\n * 环境重启\n * 环境测试\n * Git环境\n   * 宿主机配置Git\n   * PHP容器配置Git\n   * 项目访问\n * 自动化部署\n   * Gitee脚本\n   * Github脚本\n   * WebHook配置\n * 问答\n\n\n\n\n# 原理介绍\n\n实现服务器自动化部署，我们使用的是 WebHook 技术，这个技术 Github 和 Gitee 都有，不难理解。\n\n首先要知道为什么使用 WebHook？如果我每次克隆项目，需要手动实现 git clone 命令，但是每次别人 push 新代码，我必须手动克隆或者拉取最新的代码，那么有没有一种技术，别人 push 新代码，我发个呆，然后 push 的新代码自动被我的服务器克隆下来呢。这个技术就是 WebHook。\n\nWebHook 可以理解为一个仓库的触发器。\n\n * 什么时候这个触发器被触发呢：由你决定，可以在 push 新代码之后，可以在分支合并之后\n\n * 触发的内容是什么：WebHook 会主动发送一个 POST 请求到你配置的地址，这个地址是我们服务器的脚本。一旦请求我们写的脚本，就会触发脚本，脚本里的内容就是执行 git clone 等命令拉取仓库代码\n\n所以总结就是：当我们 push 项目到仓库，仓库触发 WebHook，发送 POST 请求到我们的服务器，这个请求触发我们写的脚本，脚本执行 git clone 等命令拉取项目代码。\n\n\n\n所以确保提供给 GitHub 或 Gitee 的请求能访问并触发编写的脚本。而如何访问并触发脚本，就是本内容要介绍的。\n\n\n# 环境准备\n\n * CentOS 系统（其他系统也可以）\n\n * 一个普通用户（强烈建议）\n\n * Docker 容器（可选）\n\n * OpenResty，可以理解为 Nginx 和 Lua 的集成，使用 Nginx 也可以\n\n * PHP 环境（PHP 脚本必须）\n\n注意：这里是使用 Docker 容器进行管理，如果没用过或者不打算用 Docker，也可以参考：Docker 是一个容器，容器里的每一个环境可以理解为一个 CentOS 系统，比如 Docker 里的 Nginx 就是一个安装了 Nginx 的 CentOS 系统，Docker 里的 PHP 就是安装了 PHP 的 CentOS 系统。（实际上不完全是 CentOS 系统，取决于供应商的设计，这里为了解释说明）\n\n\n\n有人疑惑了，可不可以在 Docker 里的 Nginx 环境安装 PHP，毕竟 Nginx 所在的也是一个 CentOS 系统，额(⊙﹏⊙)，不建议，还是老老实实安装 PHP 吧。Docker 的出现就是为了隔离每一个环境，但是又不影响彼此的联系。\n\n如果你不使用 Docker，请下意识把 Docker 这一层因素去掉即可。关于 Nginx 和 PHP 的步骤是完全一样，不会因为 Docker 而被影响。\n\n我是先进入服务器，然后从服务器进入 Docker，接着从 Docker 进入 Nginx 和 PHP。而你不用 Docker，只需要进入服务器即可，因为不用 Dcoerk，Nginx 和 PHP 就处在服务器里。\n\n\n# 环境安装\n\n关于 Docker 的安装，我已经写在 Docker 的知识体系中，点击传送。\n\n关于 OpenResty（Nginx）在 Docker 安装，我已经写在 Nginx 的知识体系中，点击传送。\n\n如果你已经安装过 Docker，并且 Docker 里安装了 OpenResty 或者 Nginx，则不需要重新安装。\n\n笔记\n\n这里再次说明，没接触过 OpenResty 的也不慌，这里的它的作用就是 Nginx 的作用，所以本文提到的 OpenResty，请在脑海里替换为 Nginx 即可。\n\n2021-11-03 @Du Wu\n\n安装完 Docker 和 OpenResty（Nginx）后，我们需要下载 PHP 镜像，服务器部署的脚本是使用 PHP 编写，所以需要 PHP 的运行环境。\n\n查看 PHP 版本 传送门\n\n建议下载带有 fpm 的版本，我下载的是 7.3-fpm 版本。\n\n\n\ndocker pull php:7.3.33-fpm\n\n\n1\n\n\n\n# 环境用户\n\n强烈建议 Nginx、PHP 或者其他的容器不要用 root 用户，这里创建一个普通用户来进行操作，这也是实际生产上需要做的。\n\n创建 kbt 普通用户（用户名自己决定）\n\nuseradd kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n\n\n将 kbt 用户放入 docker 组，这样 kbt 用户才能使用 docker 的相关命令（如果不用 docker，请忽略）\n\nusermod -a -G docker kbt  # 将 kbt 用户加入到 docker 用户组中\n\nsystemctl restart docker  # 重启 docker\n\n\n1\n2\n3\n\n\n-a 是追加，普通用户加入 docker 组后，不会退出原来所在的组。\n\n-G 是指定组名。\n\n\n# 环境启动\n\n安装完 Docker、OpenResty 或 Nginx、PHP 后，接下来就启动它们。\n\nDocker 的启动很简单，但是也很麻烦，简单在于命令是固定的，麻烦在于数据卷的考虑，到底放在宿主机的哪个路径下。\n\n如果不用 docker，请忽略。\n\n\n# Nginx启动\n\nOpenResty 或 Nginx 的启动时，需要将配置文件目录、静态文件目录、日志文件目录给挂载出来，方便备份和修改。\n\n这里只是说明我的路径，你的路径请根据你的需求修改，只需要修改路径即可。\n\n * Nginx 的配置文件挂载在 /docker/openresty/conf 目录下\n\n * Nginx 的静态文件目录挂载在 /docker/openresty/html 目录下\n\n * Nginx 的日志文件目录挂载在 /docker/openresty/logs 目录下\n\n因为我打算把所有的挂载目录都放在 /docker 目录下，如 node 镜像挂载目录是 /docker/node，tomcat 镜像挂载目录在 /docker/tomcat ...... 类推\n\n首先创建根路径：\n\nmkdir /docker/openresty\n\n\n1\n\n\n这里说明一下，我们需要把 Nginx 容器里的这些目录拷贝出来，为什么呢？因为一旦挂载成功，宿主机的目录会覆盖容器的目录，想想此时刚刚创建的宿主机的目录都为空，一旦挂载后，容器里的目录被覆盖，也为空。所以我们事先从容器拿出这些目录，放到根路径下，再挂载，这样覆盖的目录就是拷贝出来的目录。\n\n先简单启动一个 OpenResty 容器。容器名叫 nginx，启动的镜像名是 OpenResty，版本为 latest。\n\ndocker run -d --name nginx OpenResty:latest\n\n\n1\n\n\n将容器需要的挂载目录拷贝出来\n\ndocker cp nginx:/etc/nginx/conf.d /docker/openresty/conf\ndocker cp nginx:/usr/local/openresty/nginx/html /docker/openresty/html\ndocker cp nginx:/usr/local/openresty/nginx/logs /docker/openresty/logs\n\n\n1\n2\n3\n\n\n我拷贝的 conf.d 目录是 简易版 配置文件所在的目录，并将 conf.d 改为 conf，你可以不改，我只是不喜欢 .d。而静态文件目录和日志文件目录名不变。\n\n完整版 的配置文件在容器的 /usr/local/openresty/nginx/conf 路径下，文件名叫 nginx.conf。\n\n为什么不使用完整版？\n\n「简易版」只能写 server 块，「完整版」不仅可以写 server 块，还能写 http 块。因为「完整版」的 http 块利用 include 指令引入「简易版」配置文件所在的目录，所以我们只需要在「简易版」目录下添加任意 .conf 文件，则自动会被引入到「完整版」，避免直接修改「完整版」引起安全问题。\n\n\n\n拿出来三个目录后就可以删除这个容器，为完整版的容器做准备。\n\ndocker rm -f nginx\n\n\n1\n\n\n启动最终版的 OpenResty 容器前，我们需要创建一个网桥，避免过多的容器积压在默认网桥上，也为了 Nginx 能和 PHP 等容器进行通信。\n\n网桥就是网络，我喜欢称呼网桥\n\n默认网桥无法直接通信，必须使用 IP 或者 --link 进行通信，所以很麻烦，我们就创建一个网桥，解决所有问题。如果还不懂，请看原理：点击跳转\n\n2021-11-09 @Du Wu\n\n创建一个叫做 web 的网桥\n\ndocker network create web\n\n\n1\n\n\n最后启动 OpenResty 容器，实现挂载\n\ndocker run -d --name nginx -p 80:80 --restart always \\\n-v /docker/openresty/conf:/etc/nginx/conf.d \\\n-v /docker/openresty/html:/usr/local/openresty/nginx/html \\\n-v /docker/openresty/logs:/usr/local/openresty/nginx/logs \\\n-v /home/kbt:/home/kbt \\\n--network web --network-alias nginx \\\nOpenResty:latest\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/home/kbt 是后面 PHP 环境需要，因为 PHP 不允许 root 用户操作，所以我们使用前面创建的 kbt 用作为操作 PHP 的权限用户。\n\n--network-alias 是给所在的网桥起个别名，这个别名是自己所在网桥的一种标识，方便相同网桥的其他容器如 Nginx 通过别名找到你。尽量和容器名一致。\n\n\n# PHP启动\n\nPHP 容器启动很简单，我们需要注意的是 PHP 脚本的「住处」，我把脚本放在 /home/kbt 处，因为 PHP 环境使用 kbt 用户，所以脚本也要放在 kbt 用户的目录下，防止外界恶意访问执行脚本，引起严重后果。\n\n如果你是 xxx 用户，则请将脚本放在 /home/xxx 目录下。\n\ndocker run -d --name php -v /home/kbt:/home/kbt --network web --network-alias php php:7.3-fpm\n\n\n1\n\n\nNgxin 启动的时候也挂载了这个 /home/kbt 目录。\n\n此时 /home/kbt 目录相当于一个「中转站」，连接着 Nginx 和 PHP，这样 Nginx 就能通过这个「中转站」访问 PHP 的脚本了。当然这样直接访问还远远不够，我们还需要在 Nginx 的配置文件进行配置，指定 PHP 的脚本在 home/kbt 下。\n\n\n# 环境配置\n\n我们需要修改 Nginx 的用户权限为 kbt，以及 PHP 的用户权限也为 kbt，这样为了防止外界恶意访问 Nginx，植入恶意脚本，因为 root 的权限太大，拥有了 root 权限，容易被植入恶意脚本。所以不要一味的追求 root。\n\n不要忽略这一步，哪怕你不用 docker，你只需要把 docker 相关的命令无视掉。\n\n\n# Nginx配置\n\n我们需要配置 Nginx 的用户权限、PHP 脚本的访问路径、以及静态资源的缓存等。\n\n> 配置 PHP 脚本的访问路径\n\n首先打开 /docker/openresty/conf 的「简易版」配置文件，名字叫 default.conf\n\nvim /docker/openresty/conf/default.conf\n\n\n1\n\n\n添加如下内容：\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n\n    # ...... 其他配置\n    location ~ \\.php$ {   # 访问 .php 后缀的请求\n        root           /home/kbt;\t# 脚本的根目录\n        fastcgi_pass   php:9000;\t# 通过 php 网桥别名的 9000 端口连接上 PHP容器\n        fastcgi_index  index.php;\t# 默认首页\n        fastcgi_param  SCRIPT_FILENAME  /home/kbt$fastcgi_script_name;  # 脚本的根目录\n        include        fastcgi_params;\n    }\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n第 7 行改为 /home/kbt 目录，这是我们放置脚本的根目录。\n\n第 8 行的 php 就是我们启动 PHP 容器指定的网桥别名，Nginx 和 PHP 都处于 web 网桥，那么可以通过网桥别名找到彼此。9000 是 PHP 容器的默认端口。\n\n第 9 行的 /home/kbt$fastcgi_script_name 指的是，启动 PHP 环境来运行 /home/kbt 目录下的脚本，否则脚本无法启动。如果你不是 /home/kbt，则自行修改。\n\n注意\n\n不能在 $fastcgi 前加 /。\n\n2021-11-09 @Du Wu\n\n如果不使用 docker，则内容为\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n    \n    # ...... 其他配置\n    location ~ \\.php$ {\n    \tproxy_pass   http://127.0.0.1;\n    }\n\n    location ~ \\.php$ {\n        root           /home/kbt;\n        fastcgi_pass   localhost:9000;\n        fastcgi_index  index.php;\n        fastcgi_param  SCRIPT_FILENAME  /home/kbt$fastcgi_script_name;  # 脚本的根目录\n        include        fastcgi_params;\n    }\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n先转发到本地（127.0.0.1），然后触发 12 行的 localhost，找到 9000 端口的 PHP 环境。\n\n> 安装 vim\n\n因为 Nginx 容器并不带 vim 和 vi 命令，所以我们需要安装 vim，安装前需要更新 apt-get（容器没有 yum）\n\n# 进入 Nginx 容器\ndocker exec -it nginx bash\n\n\n1\n2\n\n\n下载前需要修改下载源为国内源，默认的国外源太慢。\n\n# 进入 apt-get 配置目录\ncd /etc/apt\n\n# 执行备份命令，避免修改失败无法使用\ncp sources.list sources.list.bak\n\n# 同时执行 echo下的 4 行命令，修改成国内镜像源\necho "">sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/ buster main">>sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/debian-security buster/updates main">>sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/debian buster-updates main">>sources.list\n\n# 执行更新命令 apt-get update\napt-get update\n# 下载 vim\napt-get install -y vim\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n你可以将安装完 vim 的新容器，变成新的镜像，不然每次启动初始的镜像，都要更新 apt-get 和安装 vim\n\ndocker commit nginx nginx:1.0\n\n\n1\n\n\n第一个 nginx 是打包的容器名，而 nginx:1.0 则是打包成新镜像的名字和版本。构建新镜像后，可以把初始的镜像删除掉，保留也可以。\n\n> 配置 Nginx 用户权限和缓存等。\n\n进入 Nginx 容器\n\ndocker exec -it nginx bash\n\n\n1\n\n\n创建 kbt 用户，设置密码，要和宿主机创建的用户保持一致\n\ngroupadd kbt;\nuseradd -g kbt kbt # 创建用户，并加入组，都是 kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n4\n\n\n创建完用户后，接着修改「完整版」配置文件\n\nvim /usr/local/openresty/nginx/conf/nginx.conf\n\n\n1\n\n\n将 user 改为 kbt，\n\nuser kbt;\n\n\n1\n\n\n如图：\n\n\n\n顺便配置一下优化代码，提高 Nginx 的访问效率。\n\n在 events 块添加：（已经存在的 events 块）\n\nevents{\n\tworker_connections 1024;\t \n    accept_mutex on;\t\t\t # 开启 Nginx 网络连接序列化\n    multi_accept on;\t\t\t # 开启同时接收多个网络连接\n    use epoll;\t\t\t\t\t # 使用 epoll 函数来优化 Nginx\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n在 http 块添加：（已经存在的 http 块）\n\nhttp {\n    # ...... 其他配置\n\tsendfile on;\t\t\t\t # 开启高效的文件传输模式\n    tcp_nopush on;\t\t\t\t # 提升网络包的传输「效率」\n    tcp_nodelay on;\t\t\t\t # 高网络包传输的「实时性」\n    \n    keepalive_timeout 65;\t\t # 连接超时时间\n    \n    gzip on;  \t\t\t   \t\t # 开启 Gzip 功能\n    gzip_types *;\t\t   \t \t # 压缩源文件类型,根据具体的访问资源类型设定\n    gzip_comp_level 6;\t   \t\t # Gzip 压缩级别\n    gzip_min_length 1k;          # 进行压缩响应页面的最小长度，content-length\n    gzip_buffers 4 16K;\t         # 缓存空间大小\n    gzip_http_version 1.1;       # 指定压缩响应所需要的最低 HTTP 请求版本\n    gzip_vary  on;\t\t         # 往头信息中添加压缩标识\n    gzip_disable "MSIE [1-6]\\."; # 对 IE6 以下的版本都不进行压缩\n    gzip_proxied  off;           # Nginx 作为反向代理压缩服务端返回数据的条件\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# PHP配置\n\n> 创建普通用户\n\n首先进入 PHP 容器\n\ndocker exec -it php bash\n\n\n1\n\n\n创建 kbt 用户，设置密码，要和宿主机创建的用户保持一致\n\ngroupadd kbt;\nuseradd -g kbt kbt # 创建用户，并加入组，都是 kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n4\n\n\n> 安装 vim\n\n我已经在 Ngixn 配置写了如何安装 vim，请按照 Nginx 配置的安装 vim，进行安装，就在上面不远处。\n\n> 配置 PHP 环境的用户权限\n\n修改配置文件的用户\n\nvim /usr/local/etc/php-fpm.d/www.conf\n\n\n1\n\n\n大概在 23 - 24 行，改为：\n\nuser = kbt\ngroup = kbt\n\n\n1\n2\n\n\n\n\n\n# 环境重启\n\n笔记\n\n重启按顺序：PHP、Nginx，因为 Nginx 配置文件依赖 PHP 脚本，所以先启动 PHP，再启动 Nginx。\n\n2021-11-09 @Younng Kbt\n\ndocker restart php\ndocker restart nginx\n\n\n1\n2\n\n\n\n# 环境测试\n\n测试 Nginx 是否能访问 PHP 脚本，我们在宿主机的 /home/kbt，创建 index.php 文件\n\nvim /home/kbt/index.php\n\n\n1\n\n\n添加内容：\n\n<?\n    echo phpinfo();\n?>\n\n\n1\n2\n3\n\n\n然后访问你的网站：ip:port/index.php，如图：\n\n\n\n此时 /home/kbt 就是你 PHP 脚本的根路径，如果你想对 PHP 脚本分类，可以在根路径下创建一个文件夹，如我创建 test 文件夹，将 index.php 放入该文件夹里，接着访问的时候，加上文件夹名即可。如下：\n\n\n\n\n# Git环境\n\n环境准备就绪，现在进入正题。我们需要安装 Git，来实现自动部署。\n\n分别在宿主机和 PHP 容器安装 Git\n\n * 宿主机安装 Git 是为了配置 SSH 公钥\n   \n   不理解公钥？我们克隆的项目地址有 HTTPS 方式，也有 SSH 方式。\n   \n   \n   \n   而 SSH 方式需要配置公钥，我们在自己的服务器生成 SSH 公钥，然后交给 Github 或者 Gitee，这样它们才能通过公钥「连接」我们的服务器。才能拉取项目。\n\n * PHP 容器安装 Git 是因为我们执行 PHP 脚本，然后 PHP 容器会根据脚本使用 Git 拉取仓库的项目。\n\n> 为什么不在 PHP 容器配置公钥？\n\n一个服务器可以生成一个公钥，尽量不要在容器内生成，因为服务器的公钥是公用的，任何容器都可以使用。但是只在一个容器内生产，其他容器可能出现无法使用的问题。\n\n\n# 宿主机配置Git\n\n宿主机安装 Git，可以直接使用 yum 来下载\n\nyun -y install git\n\n\n1\n\n\n查看 Git 版本\n\ngit --version\n\n\n1\n\n\n配置全局用户信息\n\ngit config --global user.name "你的用户名" \t\t# 定义全局的用户名\ngit config --global user.email "你的邮箱" \t\t # 定义全局的邮件地址\ngit config --list \t\t\t\t\t\t\t\t# 查看配置信息是否成功\n\n\n1\n2\n3\n\n\n切换 kbt 用户\n\nsu kbt\n\n\n1\n\n\n警告\n\n必须切换 kbt 用户，因为我们 PHP 环境使用的是 kbt 用户，拉取代码时，不仅验证 SSH 公钥，也会验证生成 SSH 公钥的用户名。\n\n如果是 root 用户配置公钥，则 PHP 容器没有权限拉取 Git 项目。\n\n2021-11-09 @Du Wu\n\n生成公钥（确保已经切换了和 PHP 环境一致的用户）\n\nssh-keygen -t rsa -C "xxx@xx.com"  # 填写正确的你的邮箱\n\n\n1\n\n\n按三次回车即可生成 SSH 公钥。\n\n生成 SSH 公钥后，会告诉你生成的目录：Your public key has been saved in /home/lkbt/.ssh/id_rsa.pub.\n\ncat /home/kbt/.ssh/id_rsa.pub\n\n\n1\n\n\n查看文件后获取（复制）SSH 公钥，添加到 Github 或者 Gitee 中。如果不知道如何添加，请看 配置 SSH Key，该内容有三步，配置 SSH 公钥在第二步。\n\n验证是否配置生效\n\nssh -T git@github.com    # GitHub\nssh -T git@gitee.com\t# Gitee\n\n\n1\n2\n\n\n建议 Github 和 Gitee 都配置 SSH 公钥。\n\n\n# PHP容器配置Git\n\n首先进入 PHP 容器\n\ndocker exec -it php bash\n\n\n1\n\n\n确保你的 apt-get 已经是最新的，如果不是，请更新。因为 apt-get 初始版本库里的 Git 版本很低。\n\napt-get update\n\n\n1\n\n\n安装 Git\n\napt-get -y install git\n\n\n1\n\n\n查看 Git 版本\n\ngit --version\n\n\n1\n\n\n配置全局用户信息\n\ngit config --global user.name "你的用户名" \t\t# 定义全局的用户名\ngit config --global user.email "你的邮箱" \t\t # 定义全局的邮件地址\ngit config --list \t\t\t\t\t\t\t\t# 查看配置信息是否成功\n\n\n1\n2\n3\n\n\n初次使用，先克隆一次项目，放在 /home/kbt 目录下\n\ncd /home/kbt\ngit clone -b ga-pages <仓库 SSH 地址>\n\n\n1\n2\n\n\n-b 指定克隆的分支。不指定默认是默认分支 master。\n\n警告\n\n建议在 PHP 容器克隆项目，或者在宿主机切换到 kbt 用户再克隆项目，如果在宿主机以 root 用户克隆项目，那么 PHP 容器将没有权限操作这个项目。\n\n2021-11-11 @Du Wu\n\n\n# 项目访问\n\n此时你访问你的服务器，会发现访问不了你克隆的项目，因为项目克隆在 /home/kbt 目录下，而这个目录目前仅仅是 PHP 脚本的根路径，不是非 PHP 脚本的路径，我们还需要修改 Nginx 的配置文件，让它跳转到这个目录。\n\nvim /docker/openresty/conf/default.conf\n\n\n1\n\n\n假设我的项目名是 notes，则配置一个 localtion。\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n    \n    location /notes {\n    \troot /home/kbt;\t\t# /notes 会拼接到这后面\n        index index.html;\t# 默认访问 idnex.html 页面\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此时访问你的服务器 ip:port/notes，Nginx 就会去 /home/kbt 下找到 notes 目录，然后在这个目录下获取 idnex.html 页面返回，你就会成功看到你的项目页面。\n\n\n# 自动化部署\n\n我们使用的是 webhook 技术。\n\n这里使用 PHP 脚本进行自动化部署，用到 PHP 的 shell_exec 函数，而开放 shell_exec 这个 PHP 函数是非常危险的，因此切记不要在生产环境开放这个函数，更加不能用 root 权限去执行 PHP。当然我们只是简单的个人博客，不是什么大公司，所以危害很低。\n\n我们首先在 /home/kbt 目录下创建一个文件夹，专门存储 webhook 的 PHP 脚本。比如叫 deploy。\n\n在 deploy 文件夹下创建 PHP 脚本\n\n\n# Gitee脚本\n\n<?php\n \n$git = "git"; // 默认是用 Git 全局变量，有的环境可能要指明具体安装路径\n$source = "Gitee";\t// 项目仓库源，如 GitHub 或 Gitee\n$branch = "gh-pages"; // 指定仓库分支，为空就是 master 分支\n$logName = "logs/deploy"; // 本地日志名称，与当前 php 文件在同一目录，不需要加 .log\n$savePath = "/home/kbt/deploy"; // 网站根目录，初次克隆确保目录为空\n$gitSSHPath  = "git@gitee.com:kele-bingtang/notes-blog.git";// 代码仓库 SSH 地址\n$password = "你在 WebHook 设置的密码"; // WebHook 设置的密码\n$name  = "你的用户名";// 仓库用户名\n$email = "你的邮箱";// 用户仓库邮箱\n$isCloned = true;// 设置是否已经 clone 到本地。true：已经 clone,直接 pull，false：先 clone\n$is_test = false;// 测试模式，无需密码。true 打开，平时 false 关闭\n\n// 如果已经 clone 过，则直接拉去代码\nif ($isCloned) {\n    $requestBody = file_get_contents("php://input"); // 获取请求体的数据\n    if (empty($requestBody) && empty($is_test)) {   // empty(var) 如果 var 为空或 false，则返回 true\n        die(\'发送到仓库的请求失败\');   // die 代表输出一条消息，并退出当前脚本\n    }\n \n    // 解析发过来的 JSON 信息\n    $content = json_decode($requestBody, true);\n    // 若是指定的分支且提交数大于 0，且密码正确\n    if($content[\'password\'] == $password || !empty($is_test)){\n        if($content[\'total_commits_count\'] > 0 || !empty($is_test)) {\n            if ($content[\'ref\'] == "refs/heads/$branch" || !$branch || !empty($is_test)) {\n                $res_log = "------------------------- [PULL START] -------------------------" . PHP_EOL;  // PHP_EOL 是换行符\n                $cmd = "rm -rf $savePath && $git clone -b $branch $gitSSHPath $savePath && echo \'拉取项目并部署成功\'";\n                $result = shell_exec($cmd); // shell_exec 关键命令，执行拉取代码\n                if(!empty($is_test)){\n                    $res_log .= date(\'Y-m-d H:i:s\') . \'执行测试！\'. PHP_EOL; // .= 代表追加到后面，不会覆盖前面\n                }else{\n                    $res_log .= "[" . date(\'Y-m-d H:i:s\', time() + 8 * 60 * 60) . \'] - 拉取 \' . $content[\'repository\'][\'name\'] . \' 仓库的 \' . $content[\'ref\'] . \' 分支代码进行部署\' . PHP_EOL;\n                }\n                if(!$result){\n                    $result = "拉取项目失败" . PHP_EOL;\n                }\n                $res_log .= "[项目源] - $source" . PHP_EOL;\n                $res_log .= "[执行命令] - " . $cmd . PHP_EOL;\n                $res_log .= "[结果] - " . $result;\n                $res_log .= "-------------------------- [PULL END] --------------------------" . PHP_EOL;\n                $res_log .= PHP_EOL . PHP_EOL;\n                file_put_contents($logName.".log", $res_log, FILE_APPEND); // 写入日志\n                echo $result;\n            }\n        }\n    } else {\n        file_put_contents($logName.".log", \'[Gitee] 密码错误!\' . PHP_EOL, FILE_APPEND);\n        echo \'密码错误！\';\n    }\n}else {\t\t// 如果没有 clone，则先克隆代码\n    $res = "[ CLONE START ----------------- ]".PHP_EOL;\n    // 如果配置全局信息过，则会覆盖\n    $res .= shell_exec("$git config --global user.email $email").PHP_EOL;\n    $res .= shell_exec("$git config --global user.name $name").PHP_EOL;\n    $res .= shell_exec("$git clone $gitSSHPath $savePath").PHP_EOL;\n    $res .= "[ CLONE END ----------------- ]".PHP_EOL;\n    file_put_contents($logName.".log", $res, FILE_APPEND); // 写入日志\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n具体的内容我已经都注释好了，同时也会生成日志文件，第 39 - 44 都是输入日志的数据，你可以适当根据喜好修改。\n\n相信我，你只需要修改第 3 - 11 行的数据为你的数据即可，我把需要的变量都拿出来了，其他不会出错。\n\n29 行代码是核心命令，该脚本执行这个命令，去克隆仓库代码。所以这也是为什么 PHP 环境要安装 Git，不然无法克隆。\n\n说明一下 29 行代码为什么要这样写，因为我们的博客是打包后生成的一大堆 html、css、js 文件，源码修改一点内容，打包后都会引起这些文件的位置、内容变化，所以我们需要把原来克隆的项目删除掉，再重新克隆。\n\n有人想，能不能执行 git pull 命令，只拉取最新的代码，这里告诉你，我测试过了，哪怕我提交到仓库的打包项目没有任何修改， pull 下来的代码全是和原来的代码冲突，需要手动处理合并。想想就麻烦，所以只能先删除再克隆新的。\n\n如果你 git pull 成功，请留言告诉我，可能我当初的方法不对。\n\n\n# Github脚本\n\n<?php\n \n$git = "git"; // 默认是用 Git 全局变量，有的环境可能要指明具体安装路径\n$source = "GitHub";\t// 项目仓库源，如 GitHub 或 Gitee\n$branch = "gh-pages"; // 指定仓库分支，为空就是 master 分支\n$logName = "logs/deploy"; // 本地日志名称，与当前 php 文件在同一目录，不需要加 .log\n$savePath = "/home/kbt/deploy"; // 网站根目录，初次克隆确保目录为空\n$gitSSHPath  = "git@github.com:Kele-Bingtang/notes-blog.git";// 代码仓库 SSH 地址\n$password = "你在 WebHook 设置的密码"; // WebHook 设置的密码\n$name  = "你的用户名";// 仓库用户名\n$email = "你的邮箱";// 用户仓库邮箱\n$isCloned = true;// 设置是否已经 clone 到本地。true：已经 clone,直接 pull，false：先 clone\n$is_test = false;// 测试模式，无需密码。true 打开，平时 false 关闭\n    \n// 如果已经 clone 过，则直接拉去代码\nif ($isCloned) {\n    $requestBody = file_get_contents("php://input"); // 获取请求体的数据\n    if (empty($requestBody) && empty($is_test)) {   // empty(var) 如果 var 为空或 false，则返回 true\n        die(\'发送到仓库的请求失败\');   // die 代表输出一条消息，并退出当前脚本\n    }\n    // 获取 GitHub 的加密令牌 Secret\n    $signature = $_SERVER[\'HTTP_X_HUB_SIGNATURE_256\'];\n    // GitHub 的令牌被 sha256 加密了，所以对 $secret 相同方式加密\n    $encyptSecret = "sha256=" . hash_hmac(\'sha256\', $requestBody, $secret);\n    \n    // 先对 URL 解码，再解析为 JSON 数组\n    $content = json_decode(strstr(urldecode($requestBody),"{"),true);\n    // 若是指定的分支且提交数大于 0，且密码正确\n    if(strcmp($signature, $encyptSecret) == 0 || !empty($is_test)){  // strcmp 函数比较两个字符串\n        if ($content[\'ref\'] == "refs/heads/$branch" || !$branch || !empty($is_test)) {\n            $res_log = "------------------------- [PULL START] -------------------------" . PHP_EOL;  // PHP_EOL 是换行符\n            $cmd = "rm -rf $savePath && $git clone -b $branch $gitSSHPath $savePath && echo \'拉取项目并部署成功\'";\n            $result = shell_exec($cmd); // shell_exec 关键命令，执行拉取代码\n            if(!empty($is_test)){\n                $res_log .= "[" . date(\'Y-m-d H:i:s\') . \'] 执行测试！\'. PHP_EOL; // .= 代表追加到后面，不会覆盖前面\n            }else{\n                $res_log .= "[" . date(\'Y-m-d H:i:s\', time() + 8 * 60 * 60) . \'] - 拉取 \' . $content[\'repository\'][\'name\'] . \' 仓库的 \' . $content[\'ref\'] . \' 分支代码进行部署\' . PHP_EOL;\n            }\n            if(!$result){\n                $result = "拉取项目失败" . PHP_EOL;\n            }\n            $res_log .= "[项目源] - $source" . PHP_EOL;\n            $res_log .= "[执行命令] - " . $cmd . PHP_EOL;\n            $res_log .= "[结果] - " . $result;\n            $res_log .= "-------------------------- [PULL END] --------------------------" . PHP_EOL;\n            $res_log .= PHP_EOL . PHP_EOL;\n            file_put_contents($logName.".log", $res_log, FILE_APPEND); // 写入日志\n            echo $result;\n        }\n    } else {\n        file_put_contents($logName.".log", \'[GitHub] 密码错误!\' . PHP_EOL, FILE_APPEND);\n        echo \'密码错误！\';\n    }\n}else {\t\t// 如果没有 clone，则先克隆代码\n    $res = "[ CLONE START ----------------- ]".PHP_EOL;\n    // 如果配置全局信息过，则会覆盖\n    $res .= shell_exec("$git config --global user.email $email").PHP_EOL;\n    $res .= shell_exec("$git config --global user.name $name").PHP_EOL;\n    $res .= shell_exec("$git clone $gitSSHPath $savePath").PHP_EOL;\n    $res .= "[ CLONE END ----------------- ]".PHP_EOL;\n    file_put_contents($logName.".log", $res, FILE_APPEND); // 写入日志\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\nGitHub 的脚本和 Gitee 脚本的内容不是一样的，首先 Github 返回的令牌是 sha256 加密的，而 Gitee 返回的是不加密的，所以我们需要对本地的令牌进行 sha256 加密，然后再进行两者的判定，是否相等。\n\n其次 GitHub 返回的请求是经过编码过的，如这种 %7B%22ref%22%3A%22refs%2Fheads%2Fgh-pages%，所以我们获取后需要解码，请看 29 代码。\n\n日志文件如下：\n\n\n\n\n# WebHook配置\n\n讲了那么多，都不懂 WebHook 如何配置，现在开始配置。\n\n> Github配置\n\n进入仓库里，然后 Github 点击 setting，找到 Webhooks，然后点击 Add webhook 进行配置。\n\n\n\n然后填写 PHP 脚本地址以及令牌。\n\n\n\n令牌要对应上我提供脚本的 $secre 变量值。\n\n脚本访问地址：比如脚本放在 /home/kbt/ 下的 deploy 目录下，脚本名叫做 deploy.php，那么地址是 ip:port/deploy/deploy.php。\n\n为什么地址没有 /home/kbt，因为上面我已经配置过了，这个目录是脚本的根路径，所以 ip:port/xxx.php 就是访问根目录下的 xxx.php，有目录则加上目录即可。\n\n> Gitee\n\n其实就是中文版的 Github，所以位置完全一样\n\n\n\n\n\n密码要对应上脚本的密码。\n\n添加 WebHook 后，可以不断发送请求进行测试。\n\n笔记\n\n只需选择 push 事件触发即可，push 事件是指仓库的 任意分支 被 push 了都会触发，并非只有 master 分支触发。\n\n2021-11-09 @Du Wu\n\n\n# 问答\n\nQ1 - 能否总结本内容步骤？\n\n 1.  安装 Docker，然后利用 Docker 安装 Nginx 和 PHP 镜像\n 2.  创建 kbt 普通用户，加入 docker 组\n 3.  启动 Nginx 容器，将配置文件目录、静态文件目录、日志文件目录拷贝出来，然后关闭 Nginx 容器\n 4.  Docker 创建网桥，给两个容器通信\n 5.  启动 Nginx 容器，将拷贝的出来的三个目录和容器的三个目录进行挂载，以及与 kbt 用户的目录挂载\n 6.  启动 PHP 容器，与 kbt 用户的目录挂载，PHP 容器的挂载目录和 kbt 用户的目录路径一致\n 7.  在 Nginx 容器创建 kbt 普通用户和组，然后修改 nginx.conf 配置文件的 user 为 kbt，即 Nginx 的访问权限仅限于 kbt 的权限\n 8.  修改挂载出来的配置文件目录里的 default.conf 文件，指定 PHP 脚本所在的根路径为 kbt 的用户目录\n 9.  在 PHP 容器创建 kbt 普通用户和组，然后修改 www.conf 配置文件的 user 和 group 为 kbt，即 PHP 脚本运行权限仅限于 kbt 的权限\n 10. 两个容器配置完后，按顺序重启 PHP、Nginx 容器\n 11. 宿主机安装 Git，并配置 SSH 公钥给 Github 或者 Gitee。PHP 安装 Git，在 kbt 用户目录克隆项目\n 12. 修改挂载出来的配置文件目录里的 default.conf 文件，添加 location，能访问克隆项目的目录\n 13. 编写 PHP 脚本，然后在 Github 或者 Gitee 上开启 WebHook，配置脚本的 URL 访问地址和令牌、密码\n\n----------------------------------------\n\nQ2 - 为什么 Nginx 的静态文件目录、日志文件目录没有用到？\n\n我要求启动 Nginx 容器的时候，将这些目录挂载出来，是因为这是实际生产开发需要的，不一定是本内容需要的，这里只是打好预防针，留个印象。\n\n我当初部署的时候确实是把 PHP 脚本和克隆的项目放在静态文件目录下，但是不安全，这些目录是 root 用户管理的，所以我就创建了普通用户 kbt，将 PHP 脚本和克隆的项目放到该普通用户的目录下，即 /home/kbt。而放到该目录后，就要在 Nginx 和 PHP 创建 kbt 用户，并且挂载到 kbt 用户目录下，实现三者的同一个目录互通。如下图：\n\n\n\nQ3 - 一定要在 Nginx 和 PHP 容器创建普通用户 kbt 吗？\n\n如果不创建普通用户 kbt，那么就需要一个目录实现上方图的三者互通，那么这个目录就属于 root 用户。\n\n----------------------------------------\n\nQ4 - 两个容器创建的 kbt 用户和宿主机的 kbt 用户一样吗？\n\n不一样，但是我现在部署的时候就是这样创建的，我只把我成功的案例说出来。你也可以试试只在宿主机创建 kbt 用户，两个容器使用默认的用户（不创建 kbt 用户），我认为这样也可以。\n\n是可以的，据我了解，在宿主机以普通用户 kbt 启动 Docker 容器，那么容器里虽然显示 root 用户，但是这个 root 用户的权限其实就是宿主机启动的用户权限，所以需要切换到普通用户，并给普通用户使用 Docker 的权限，然后启动。\n\n----------------------------------------\n\nQ5 - 不使用 Docker 如何操作？\n\n其实熟悉 Docker 了，发现本内容 Docker 操作两个容器，其实就相当于在两台电脑分别安装 Nginx 和 PHP，然后进行操作，Docker 只是实现了两者在同一台电脑的互通（配置同一个网桥）。\n\n不使用 Docker，会发现服务器部署非常方便，步骤大抵如下：\n\n 1. 在服务器安装 Nginx 和 PHP 的环境\n\n 2. 在服务器创建普通用户 kbt，生成 /home/kbt 路径\n\n 3. 修改 Nginx 的配置文件和 PHP 的配置文件，将用户权限改为 kbt\n\n 4. 修改 Nginx 的配置文件，实现于 PHP 的互通，以及设置 PHP 脚本的根路径\n\n 5. 安装 Git，配置信息，生成 SSH 公钥给 Github 或 Gitee\n\n 6. 编写 PHP 脚本，然后在 Github 或 Gitee 开启 WebHook，填写脚本的 URL 访问地址\n\n此时会发现少了 Docker 的网桥配置，因为处于同一个服务器，本身就能通信。少了 Docker，也不需要在两个容器创建普通用户 kbt，只需要在宿主机创建即可。\n\n----------------------------------------\n\nQ6 - PHP 容器不安装 Git 行吗，只在宿主机安装？\n\n不行的，因为 PHP 脚本执行后，使用的 git 命令是脚本所在的环境存在的，不安装即无法克隆项目代码，说其实的，如果曾经已经配置过宿主机的 SSH 公钥，则不需要在宿主机安装 Git。宿主机安装 Git 的目的仅仅是生成 SSH 公钥，而 PHP 容器才是使用 Git 相关的命令。\n\n----------------------------------------\n\nQ7 - PHP 容器不挂载出来可以吗？\n\n可以的，但是不建议。Docker 挂载的目的就是实现宿主机和容器的数据同步，也就是说两个挂载目录，只要有一方发生修改，则另一方同步修改。而实际上，我们应该禁止容器的挂载目录能被手动修改数据，这样，只修改宿主机的挂载目录数据，安全大大提高的同时，容器的数据也会同步改变。\n\n而如果不挂载出来，就必须进入到容器内部，创建脚本，修改脚本，违背了容器能修改数据的原则，再想想容器万一不小心删除了，则数据全没了。而服务器只有过期、被入侵。两者相比优势清晰明了。',normalizedContent:'笔记\n\n如果你不打算部署在 github pages 或者 gitee pages 上，而是部署在自己的服务器上，又或者三个都想自动同步部署，那么本内容就是带你如何在服务器部署项目，同时也有 docker 的一次实战。\n\n2021-11-03 @du wu\n\n\n\n * 原理介绍\n * 环境准备\n * 环境安装\n * 环境用户\n * 环境启动\n   * nginx启动\n   * php启动\n * 环境配置\n   * nginx配置\n   * php配置\n * 环境重启\n * 环境测试\n * git环境\n   * 宿主机配置git\n   * php容器配置git\n   * 项目访问\n * 自动化部署\n   * gitee脚本\n   * github脚本\n   * webhook配置\n * 问答\n\n\n\n\n# 原理介绍\n\n实现服务器自动化部署，我们使用的是 webhook 技术，这个技术 github 和 gitee 都有，不难理解。\n\n首先要知道为什么使用 webhook？如果我每次克隆项目，需要手动实现 git clone 命令，但是每次别人 push 新代码，我必须手动克隆或者拉取最新的代码，那么有没有一种技术，别人 push 新代码，我发个呆，然后 push 的新代码自动被我的服务器克隆下来呢。这个技术就是 webhook。\n\nwebhook 可以理解为一个仓库的触发器。\n\n * 什么时候这个触发器被触发呢：由你决定，可以在 push 新代码之后，可以在分支合并之后\n\n * 触发的内容是什么：webhook 会主动发送一个 post 请求到你配置的地址，这个地址是我们服务器的脚本。一旦请求我们写的脚本，就会触发脚本，脚本里的内容就是执行 git clone 等命令拉取仓库代码\n\n所以总结就是：当我们 push 项目到仓库，仓库触发 webhook，发送 post 请求到我们的服务器，这个请求触发我们写的脚本，脚本执行 git clone 等命令拉取项目代码。\n\n\n\n所以确保提供给 github 或 gitee 的请求能访问并触发编写的脚本。而如何访问并触发脚本，就是本内容要介绍的。\n\n\n# 环境准备\n\n * centos 系统（其他系统也可以）\n\n * 一个普通用户（强烈建议）\n\n * docker 容器（可选）\n\n * openresty，可以理解为 nginx 和 lua 的集成，使用 nginx 也可以\n\n * php 环境（php 脚本必须）\n\n注意：这里是使用 docker 容器进行管理，如果没用过或者不打算用 docker，也可以参考：docker 是一个容器，容器里的每一个环境可以理解为一个 centos 系统，比如 docker 里的 nginx 就是一个安装了 nginx 的 centos 系统，docker 里的 php 就是安装了 php 的 centos 系统。（实际上不完全是 centos 系统，取决于供应商的设计，这里为了解释说明）\n\n\n\n有人疑惑了，可不可以在 docker 里的 nginx 环境安装 php，毕竟 nginx 所在的也是一个 centos 系统，额(⊙﹏⊙)，不建议，还是老老实实安装 php 吧。docker 的出现就是为了隔离每一个环境，但是又不影响彼此的联系。\n\n如果你不使用 docker，请下意识把 docker 这一层因素去掉即可。关于 nginx 和 php 的步骤是完全一样，不会因为 docker 而被影响。\n\n我是先进入服务器，然后从服务器进入 docker，接着从 docker 进入 nginx 和 php。而你不用 docker，只需要进入服务器即可，因为不用 dcoerk，nginx 和 php 就处在服务器里。\n\n\n# 环境安装\n\n关于 docker 的安装，我已经写在 docker 的知识体系中，点击传送。\n\n关于 openresty（nginx）在 docker 安装，我已经写在 nginx 的知识体系中，点击传送。\n\n如果你已经安装过 docker，并且 docker 里安装了 openresty 或者 nginx，则不需要重新安装。\n\n笔记\n\n这里再次说明，没接触过 openresty 的也不慌，这里的它的作用就是 nginx 的作用，所以本文提到的 openresty，请在脑海里替换为 nginx 即可。\n\n2021-11-03 @du wu\n\n安装完 docker 和 openresty（nginx）后，我们需要下载 php 镜像，服务器部署的脚本是使用 php 编写，所以需要 php 的运行环境。\n\n查看 php 版本 传送门\n\n建议下载带有 fpm 的版本，我下载的是 7.3-fpm 版本。\n\n\n\ndocker pull php:7.3.33-fpm\n\n\n1\n\n\n\n# 环境用户\n\n强烈建议 nginx、php 或者其他的容器不要用 root 用户，这里创建一个普通用户来进行操作，这也是实际生产上需要做的。\n\n创建 kbt 普通用户（用户名自己决定）\n\nuseradd kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n\n\n将 kbt 用户放入 docker 组，这样 kbt 用户才能使用 docker 的相关命令（如果不用 docker，请忽略）\n\nusermod -a -g docker kbt  # 将 kbt 用户加入到 docker 用户组中\n\nsystemctl restart docker  # 重启 docker\n\n\n1\n2\n3\n\n\n-a 是追加，普通用户加入 docker 组后，不会退出原来所在的组。\n\n-g 是指定组名。\n\n\n# 环境启动\n\n安装完 docker、openresty 或 nginx、php 后，接下来就启动它们。\n\ndocker 的启动很简单，但是也很麻烦，简单在于命令是固定的，麻烦在于数据卷的考虑，到底放在宿主机的哪个路径下。\n\n如果不用 docker，请忽略。\n\n\n# nginx启动\n\nopenresty 或 nginx 的启动时，需要将配置文件目录、静态文件目录、日志文件目录给挂载出来，方便备份和修改。\n\n这里只是说明我的路径，你的路径请根据你的需求修改，只需要修改路径即可。\n\n * nginx 的配置文件挂载在 /docker/openresty/conf 目录下\n\n * nginx 的静态文件目录挂载在 /docker/openresty/html 目录下\n\n * nginx 的日志文件目录挂载在 /docker/openresty/logs 目录下\n\n因为我打算把所有的挂载目录都放在 /docker 目录下，如 node 镜像挂载目录是 /docker/node，tomcat 镜像挂载目录在 /docker/tomcat ...... 类推\n\n首先创建根路径：\n\nmkdir /docker/openresty\n\n\n1\n\n\n这里说明一下，我们需要把 nginx 容器里的这些目录拷贝出来，为什么呢？因为一旦挂载成功，宿主机的目录会覆盖容器的目录，想想此时刚刚创建的宿主机的目录都为空，一旦挂载后，容器里的目录被覆盖，也为空。所以我们事先从容器拿出这些目录，放到根路径下，再挂载，这样覆盖的目录就是拷贝出来的目录。\n\n先简单启动一个 openresty 容器。容器名叫 nginx，启动的镜像名是 openresty，版本为 latest。\n\ndocker run -d --name nginx openresty:latest\n\n\n1\n\n\n将容器需要的挂载目录拷贝出来\n\ndocker cp nginx:/etc/nginx/conf.d /docker/openresty/conf\ndocker cp nginx:/usr/local/openresty/nginx/html /docker/openresty/html\ndocker cp nginx:/usr/local/openresty/nginx/logs /docker/openresty/logs\n\n\n1\n2\n3\n\n\n我拷贝的 conf.d 目录是 简易版 配置文件所在的目录，并将 conf.d 改为 conf，你可以不改，我只是不喜欢 .d。而静态文件目录和日志文件目录名不变。\n\n完整版 的配置文件在容器的 /usr/local/openresty/nginx/conf 路径下，文件名叫 nginx.conf。\n\n为什么不使用完整版？\n\n「简易版」只能写 server 块，「完整版」不仅可以写 server 块，还能写 http 块。因为「完整版」的 http 块利用 include 指令引入「简易版」配置文件所在的目录，所以我们只需要在「简易版」目录下添加任意 .conf 文件，则自动会被引入到「完整版」，避免直接修改「完整版」引起安全问题。\n\n\n\n拿出来三个目录后就可以删除这个容器，为完整版的容器做准备。\n\ndocker rm -f nginx\n\n\n1\n\n\n启动最终版的 openresty 容器前，我们需要创建一个网桥，避免过多的容器积压在默认网桥上，也为了 nginx 能和 php 等容器进行通信。\n\n网桥就是网络，我喜欢称呼网桥\n\n默认网桥无法直接通信，必须使用 ip 或者 --link 进行通信，所以很麻烦，我们就创建一个网桥，解决所有问题。如果还不懂，请看原理：点击跳转\n\n2021-11-09 @du wu\n\n创建一个叫做 web 的网桥\n\ndocker network create web\n\n\n1\n\n\n最后启动 openresty 容器，实现挂载\n\ndocker run -d --name nginx -p 80:80 --restart always \\\n-v /docker/openresty/conf:/etc/nginx/conf.d \\\n-v /docker/openresty/html:/usr/local/openresty/nginx/html \\\n-v /docker/openresty/logs:/usr/local/openresty/nginx/logs \\\n-v /home/kbt:/home/kbt \\\n--network web --network-alias nginx \\\nopenresty:latest\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/home/kbt 是后面 php 环境需要，因为 php 不允许 root 用户操作，所以我们使用前面创建的 kbt 用作为操作 php 的权限用户。\n\n--network-alias 是给所在的网桥起个别名，这个别名是自己所在网桥的一种标识，方便相同网桥的其他容器如 nginx 通过别名找到你。尽量和容器名一致。\n\n\n# php启动\n\nphp 容器启动很简单，我们需要注意的是 php 脚本的「住处」，我把脚本放在 /home/kbt 处，因为 php 环境使用 kbt 用户，所以脚本也要放在 kbt 用户的目录下，防止外界恶意访问执行脚本，引起严重后果。\n\n如果你是 xxx 用户，则请将脚本放在 /home/xxx 目录下。\n\ndocker run -d --name php -v /home/kbt:/home/kbt --network web --network-alias php php:7.3-fpm\n\n\n1\n\n\nngxin 启动的时候也挂载了这个 /home/kbt 目录。\n\n此时 /home/kbt 目录相当于一个「中转站」，连接着 nginx 和 php，这样 nginx 就能通过这个「中转站」访问 php 的脚本了。当然这样直接访问还远远不够，我们还需要在 nginx 的配置文件进行配置，指定 php 的脚本在 home/kbt 下。\n\n\n# 环境配置\n\n我们需要修改 nginx 的用户权限为 kbt，以及 php 的用户权限也为 kbt，这样为了防止外界恶意访问 nginx，植入恶意脚本，因为 root 的权限太大，拥有了 root 权限，容易被植入恶意脚本。所以不要一味的追求 root。\n\n不要忽略这一步，哪怕你不用 docker，你只需要把 docker 相关的命令无视掉。\n\n\n# nginx配置\n\n我们需要配置 nginx 的用户权限、php 脚本的访问路径、以及静态资源的缓存等。\n\n> 配置 php 脚本的访问路径\n\n首先打开 /docker/openresty/conf 的「简易版」配置文件，名字叫 default.conf\n\nvim /docker/openresty/conf/default.conf\n\n\n1\n\n\n添加如下内容：\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n\n\n\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n\n    # ...... 其他配置\n    location ~ \\.php$ {   # 访问 .php 后缀的请求\n        root           /home/kbt;\t# 脚本的根目录\n        fastcgi_pass   php:9000;\t# 通过 php 网桥别名的 9000 端口连接上 php容器\n        fastcgi_index  index.php;\t# 默认首页\n        fastcgi_param  script_filename  /home/kbt$fastcgi_script_name;  # 脚本的根目录\n        include        fastcgi_params;\n    }\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n第 7 行改为 /home/kbt 目录，这是我们放置脚本的根目录。\n\n第 8 行的 php 就是我们启动 php 容器指定的网桥别名，nginx 和 php 都处于 web 网桥，那么可以通过网桥别名找到彼此。9000 是 php 容器的默认端口。\n\n第 9 行的 /home/kbt$fastcgi_script_name 指的是，启动 php 环境来运行 /home/kbt 目录下的脚本，否则脚本无法启动。如果你不是 /home/kbt，则自行修改。\n\n注意\n\n不能在 $fastcgi 前加 /。\n\n2021-11-09 @du wu\n\n如果不使用 docker，则内容为\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n    \n    # ...... 其他配置\n    location ~ \\.php$ {\n    \tproxy_pass   http://127.0.0.1;\n    }\n\n    location ~ \\.php$ {\n        root           /home/kbt;\n        fastcgi_pass   localhost:9000;\n        fastcgi_index  index.php;\n        fastcgi_param  script_filename  /home/kbt$fastcgi_script_name;  # 脚本的根目录\n        include        fastcgi_params;\n    }\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n先转发到本地（127.0.0.1），然后触发 12 行的 localhost，找到 9000 端口的 php 环境。\n\n> 安装 vim\n\n因为 nginx 容器并不带 vim 和 vi 命令，所以我们需要安装 vim，安装前需要更新 apt-get（容器没有 yum）\n\n# 进入 nginx 容器\ndocker exec -it nginx bash\n\n\n1\n2\n\n\n下载前需要修改下载源为国内源，默认的国外源太慢。\n\n# 进入 apt-get 配置目录\ncd /etc/apt\n\n# 执行备份命令，避免修改失败无法使用\ncp sources.list sources.list.bak\n\n# 同时执行 echo下的 4 行命令，修改成国内镜像源\necho "">sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/ buster main">>sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/debian-security buster/updates main">>sources.list \\\necho "deb http://ftp2.cn.debian.org/debian/debian buster-updates main">>sources.list\n\n# 执行更新命令 apt-get update\napt-get update\n# 下载 vim\napt-get install -y vim\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n你可以将安装完 vim 的新容器，变成新的镜像，不然每次启动初始的镜像，都要更新 apt-get 和安装 vim\n\ndocker commit nginx nginx:1.0\n\n\n1\n\n\n第一个 nginx 是打包的容器名，而 nginx:1.0 则是打包成新镜像的名字和版本。构建新镜像后，可以把初始的镜像删除掉，保留也可以。\n\n> 配置 nginx 用户权限和缓存等。\n\n进入 nginx 容器\n\ndocker exec -it nginx bash\n\n\n1\n\n\n创建 kbt 用户，设置密码，要和宿主机创建的用户保持一致\n\ngroupadd kbt;\nuseradd -g kbt kbt # 创建用户，并加入组，都是 kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n4\n\n\n创建完用户后，接着修改「完整版」配置文件\n\nvim /usr/local/openresty/nginx/conf/nginx.conf\n\n\n1\n\n\n将 user 改为 kbt，\n\nuser kbt;\n\n\n1\n\n\n如图：\n\n\n\n顺便配置一下优化代码，提高 nginx 的访问效率。\n\n在 events 块添加：（已经存在的 events 块）\n\nevents{\n\tworker_connections 1024;\t \n    accept_mutex on;\t\t\t # 开启 nginx 网络连接序列化\n    multi_accept on;\t\t\t # 开启同时接收多个网络连接\n    use epoll;\t\t\t\t\t # 使用 epoll 函数来优化 nginx\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n在 http 块添加：（已经存在的 http 块）\n\nhttp {\n    # ...... 其他配置\n\tsendfile on;\t\t\t\t # 开启高效的文件传输模式\n    tcp_nopush on;\t\t\t\t # 提升网络包的传输「效率」\n    tcp_nodelay on;\t\t\t\t # 高网络包传输的「实时性」\n    \n    keepalive_timeout 65;\t\t # 连接超时时间\n    \n    gzip on;  \t\t\t   \t\t # 开启 gzip 功能\n    gzip_types *;\t\t   \t \t # 压缩源文件类型,根据具体的访问资源类型设定\n    gzip_comp_level 6;\t   \t\t # gzip 压缩级别\n    gzip_min_length 1k;          # 进行压缩响应页面的最小长度，content-length\n    gzip_buffers 4 16k;\t         # 缓存空间大小\n    gzip_http_version 1.1;       # 指定压缩响应所需要的最低 http 请求版本\n    gzip_vary  on;\t\t         # 往头信息中添加压缩标识\n    gzip_disable "msie [1-6]\\."; # 对 ie6 以下的版本都不进行压缩\n    gzip_proxied  off;           # nginx 作为反向代理压缩服务端返回数据的条件\n    # ...... 其他配置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# php配置\n\n> 创建普通用户\n\n首先进入 php 容器\n\ndocker exec -it php bash\n\n\n1\n\n\n创建 kbt 用户，设置密码，要和宿主机创建的用户保持一致\n\ngroupadd kbt;\nuseradd -g kbt kbt # 创建用户，并加入组，都是 kbt\npasswd kbt\n# 然后这里填 kbt 用户的密码\n\n\n1\n2\n3\n4\n\n\n> 安装 vim\n\n我已经在 ngixn 配置写了如何安装 vim，请按照 nginx 配置的安装 vim，进行安装，就在上面不远处。\n\n> 配置 php 环境的用户权限\n\n修改配置文件的用户\n\nvim /usr/local/etc/php-fpm.d/www.conf\n\n\n1\n\n\n大概在 23 - 24 行，改为：\n\nuser = kbt\ngroup = kbt\n\n\n1\n2\n\n\n\n\n\n# 环境重启\n\n笔记\n\n重启按顺序：php、nginx，因为 nginx 配置文件依赖 php 脚本，所以先启动 php，再启动 nginx。\n\n2021-11-09 @younng kbt\n\ndocker restart php\ndocker restart nginx\n\n\n1\n2\n\n\n\n# 环境测试\n\n测试 nginx 是否能访问 php 脚本，我们在宿主机的 /home/kbt，创建 index.php 文件\n\nvim /home/kbt/index.php\n\n\n1\n\n\n添加内容：\n\n<?\n    echo phpinfo();\n?>\n\n\n1\n2\n3\n\n\n然后访问你的网站：ip:port/index.php，如图：\n\n\n\n此时 /home/kbt 就是你 php 脚本的根路径，如果你想对 php 脚本分类，可以在根路径下创建一个文件夹，如我创建 test 文件夹，将 index.php 放入该文件夹里，接着访问的时候，加上文件夹名即可。如下：\n\n\n\n\n# git环境\n\n环境准备就绪，现在进入正题。我们需要安装 git，来实现自动部署。\n\n分别在宿主机和 php 容器安装 git\n\n * 宿主机安装 git 是为了配置 ssh 公钥\n   \n   不理解公钥？我们克隆的项目地址有 https 方式，也有 ssh 方式。\n   \n   \n   \n   而 ssh 方式需要配置公钥，我们在自己的服务器生成 ssh 公钥，然后交给 github 或者 gitee，这样它们才能通过公钥「连接」我们的服务器。才能拉取项目。\n\n * php 容器安装 git 是因为我们执行 php 脚本，然后 php 容器会根据脚本使用 git 拉取仓库的项目。\n\n> 为什么不在 php 容器配置公钥？\n\n一个服务器可以生成一个公钥，尽量不要在容器内生成，因为服务器的公钥是公用的，任何容器都可以使用。但是只在一个容器内生产，其他容器可能出现无法使用的问题。\n\n\n# 宿主机配置git\n\n宿主机安装 git，可以直接使用 yum 来下载\n\nyun -y install git\n\n\n1\n\n\n查看 git 版本\n\ngit --version\n\n\n1\n\n\n配置全局用户信息\n\ngit config --global user.name "你的用户名" \t\t# 定义全局的用户名\ngit config --global user.email "你的邮箱" \t\t # 定义全局的邮件地址\ngit config --list \t\t\t\t\t\t\t\t# 查看配置信息是否成功\n\n\n1\n2\n3\n\n\n切换 kbt 用户\n\nsu kbt\n\n\n1\n\n\n警告\n\n必须切换 kbt 用户，因为我们 php 环境使用的是 kbt 用户，拉取代码时，不仅验证 ssh 公钥，也会验证生成 ssh 公钥的用户名。\n\n如果是 root 用户配置公钥，则 php 容器没有权限拉取 git 项目。\n\n2021-11-09 @du wu\n\n生成公钥（确保已经切换了和 php 环境一致的用户）\n\nssh-keygen -t rsa -c "xxx@xx.com"  # 填写正确的你的邮箱\n\n\n1\n\n\n按三次回车即可生成 ssh 公钥。\n\n生成 ssh 公钥后，会告诉你生成的目录：your public key has been saved in /home/lkbt/.ssh/id_rsa.pub.\n\ncat /home/kbt/.ssh/id_rsa.pub\n\n\n1\n\n\n查看文件后获取（复制）ssh 公钥，添加到 github 或者 gitee 中。如果不知道如何添加，请看 配置 ssh key，该内容有三步，配置 ssh 公钥在第二步。\n\n验证是否配置生效\n\nssh -t git@github.com    # github\nssh -t git@gitee.com\t# gitee\n\n\n1\n2\n\n\n建议 github 和 gitee 都配置 ssh 公钥。\n\n\n# php容器配置git\n\n首先进入 php 容器\n\ndocker exec -it php bash\n\n\n1\n\n\n确保你的 apt-get 已经是最新的，如果不是，请更新。因为 apt-get 初始版本库里的 git 版本很低。\n\napt-get update\n\n\n1\n\n\n安装 git\n\napt-get -y install git\n\n\n1\n\n\n查看 git 版本\n\ngit --version\n\n\n1\n\n\n配置全局用户信息\n\ngit config --global user.name "你的用户名" \t\t# 定义全局的用户名\ngit config --global user.email "你的邮箱" \t\t # 定义全局的邮件地址\ngit config --list \t\t\t\t\t\t\t\t# 查看配置信息是否成功\n\n\n1\n2\n3\n\n\n初次使用，先克隆一次项目，放在 /home/kbt 目录下\n\ncd /home/kbt\ngit clone -b ga-pages <仓库 ssh 地址>\n\n\n1\n2\n\n\n-b 指定克隆的分支。不指定默认是默认分支 master。\n\n警告\n\n建议在 php 容器克隆项目，或者在宿主机切换到 kbt 用户再克隆项目，如果在宿主机以 root 用户克隆项目，那么 php 容器将没有权限操作这个项目。\n\n2021-11-11 @du wu\n\n\n# 项目访问\n\n此时你访问你的服务器，会发现访问不了你克隆的项目，因为项目克隆在 /home/kbt 目录下，而这个目录目前仅仅是 php 脚本的根路径，不是非 php 脚本的路径，我们还需要修改 nginx 的配置文件，让它跳转到这个目录。\n\nvim /docker/openresty/conf/default.conf\n\n\n1\n\n\n假设我的项目名是 notes，则配置一个 localtion。\n\nserver {\n    listen 80;\n    server_name 你的服务器域名;\n    \n    location /notes {\n    \troot /home/kbt;\t\t# /notes 会拼接到这后面\n        index index.html;\t# 默认访问 idnex.html 页面\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n此时访问你的服务器 ip:port/notes，nginx 就会去 /home/kbt 下找到 notes 目录，然后在这个目录下获取 idnex.html 页面返回，你就会成功看到你的项目页面。\n\n\n# 自动化部署\n\n我们使用的是 webhook 技术。\n\n这里使用 php 脚本进行自动化部署，用到 php 的 shell_exec 函数，而开放 shell_exec 这个 php 函数是非常危险的，因此切记不要在生产环境开放这个函数，更加不能用 root 权限去执行 php。当然我们只是简单的个人博客，不是什么大公司，所以危害很低。\n\n我们首先在 /home/kbt 目录下创建一个文件夹，专门存储 webhook 的 php 脚本。比如叫 deploy。\n\n在 deploy 文件夹下创建 php 脚本\n\n\n# gitee脚本\n\n<?php\n \n$git = "git"; // 默认是用 git 全局变量，有的环境可能要指明具体安装路径\n$source = "gitee";\t// 项目仓库源，如 github 或 gitee\n$branch = "gh-pages"; // 指定仓库分支，为空就是 master 分支\n$logname = "logs/deploy"; // 本地日志名称，与当前 php 文件在同一目录，不需要加 .log\n$savepath = "/home/kbt/deploy"; // 网站根目录，初次克隆确保目录为空\n$gitsshpath  = "git@gitee.com:kele-bingtang/notes-blog.git";// 代码仓库 ssh 地址\n$password = "你在 webhook 设置的密码"; // webhook 设置的密码\n$name  = "你的用户名";// 仓库用户名\n$email = "你的邮箱";// 用户仓库邮箱\n$iscloned = true;// 设置是否已经 clone 到本地。true：已经 clone,直接 pull，false：先 clone\n$is_test = false;// 测试模式，无需密码。true 打开，平时 false 关闭\n\n// 如果已经 clone 过，则直接拉去代码\nif ($iscloned) {\n    $requestbody = file_get_contents("php://input"); // 获取请求体的数据\n    if (empty($requestbody) && empty($is_test)) {   // empty(var) 如果 var 为空或 false，则返回 true\n        die(\'发送到仓库的请求失败\');   // die 代表输出一条消息，并退出当前脚本\n    }\n \n    // 解析发过来的 json 信息\n    $content = json_decode($requestbody, true);\n    // 若是指定的分支且提交数大于 0，且密码正确\n    if($content[\'password\'] == $password || !empty($is_test)){\n        if($content[\'total_commits_count\'] > 0 || !empty($is_test)) {\n            if ($content[\'ref\'] == "refs/heads/$branch" || !$branch || !empty($is_test)) {\n                $res_log = "------------------------- [pull start] -------------------------" . php_eol;  // php_eol 是换行符\n                $cmd = "rm -rf $savepath && $git clone -b $branch $gitsshpath $savepath && echo \'拉取项目并部署成功\'";\n                $result = shell_exec($cmd); // shell_exec 关键命令，执行拉取代码\n                if(!empty($is_test)){\n                    $res_log .= date(\'y-m-d h:i:s\') . \'执行测试！\'. php_eol; // .= 代表追加到后面，不会覆盖前面\n                }else{\n                    $res_log .= "[" . date(\'y-m-d h:i:s\', time() + 8 * 60 * 60) . \'] - 拉取 \' . $content[\'repository\'][\'name\'] . \' 仓库的 \' . $content[\'ref\'] . \' 分支代码进行部署\' . php_eol;\n                }\n                if(!$result){\n                    $result = "拉取项目失败" . php_eol;\n                }\n                $res_log .= "[项目源] - $source" . php_eol;\n                $res_log .= "[执行命令] - " . $cmd . php_eol;\n                $res_log .= "[结果] - " . $result;\n                $res_log .= "-------------------------- [pull end] --------------------------" . php_eol;\n                $res_log .= php_eol . php_eol;\n                file_put_contents($logname.".log", $res_log, file_append); // 写入日志\n                echo $result;\n            }\n        }\n    } else {\n        file_put_contents($logname.".log", \'[gitee] 密码错误!\' . php_eol, file_append);\n        echo \'密码错误！\';\n    }\n}else {\t\t// 如果没有 clone，则先克隆代码\n    $res = "[ clone start ----------------- ]".php_eol;\n    // 如果配置全局信息过，则会覆盖\n    $res .= shell_exec("$git config --global user.email $email").php_eol;\n    $res .= shell_exec("$git config --global user.name $name").php_eol;\n    $res .= shell_exec("$git clone $gitsshpath $savepath").php_eol;\n    $res .= "[ clone end ----------------- ]".php_eol;\n    file_put_contents($logname.".log", $res, file_append); // 写入日志\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n具体的内容我已经都注释好了，同时也会生成日志文件，第 39 - 44 都是输入日志的数据，你可以适当根据喜好修改。\n\n相信我，你只需要修改第 3 - 11 行的数据为你的数据即可，我把需要的变量都拿出来了，其他不会出错。\n\n29 行代码是核心命令，该脚本执行这个命令，去克隆仓库代码。所以这也是为什么 php 环境要安装 git，不然无法克隆。\n\n说明一下 29 行代码为什么要这样写，因为我们的博客是打包后生成的一大堆 html、css、js 文件，源码修改一点内容，打包后都会引起这些文件的位置、内容变化，所以我们需要把原来克隆的项目删除掉，再重新克隆。\n\n有人想，能不能执行 git pull 命令，只拉取最新的代码，这里告诉你，我测试过了，哪怕我提交到仓库的打包项目没有任何修改， pull 下来的代码全是和原来的代码冲突，需要手动处理合并。想想就麻烦，所以只能先删除再克隆新的。\n\n如果你 git pull 成功，请留言告诉我，可能我当初的方法不对。\n\n\n# github脚本\n\n<?php\n \n$git = "git"; // 默认是用 git 全局变量，有的环境可能要指明具体安装路径\n$source = "github";\t// 项目仓库源，如 github 或 gitee\n$branch = "gh-pages"; // 指定仓库分支，为空就是 master 分支\n$logname = "logs/deploy"; // 本地日志名称，与当前 php 文件在同一目录，不需要加 .log\n$savepath = "/home/kbt/deploy"; // 网站根目录，初次克隆确保目录为空\n$gitsshpath  = "git@github.com:kele-bingtang/notes-blog.git";// 代码仓库 ssh 地址\n$password = "你在 webhook 设置的密码"; // webhook 设置的密码\n$name  = "你的用户名";// 仓库用户名\n$email = "你的邮箱";// 用户仓库邮箱\n$iscloned = true;// 设置是否已经 clone 到本地。true：已经 clone,直接 pull，false：先 clone\n$is_test = false;// 测试模式，无需密码。true 打开，平时 false 关闭\n    \n// 如果已经 clone 过，则直接拉去代码\nif ($iscloned) {\n    $requestbody = file_get_contents("php://input"); // 获取请求体的数据\n    if (empty($requestbody) && empty($is_test)) {   // empty(var) 如果 var 为空或 false，则返回 true\n        die(\'发送到仓库的请求失败\');   // die 代表输出一条消息，并退出当前脚本\n    }\n    // 获取 github 的加密令牌 secret\n    $signature = $_server[\'http_x_hub_signature_256\'];\n    // github 的令牌被 sha256 加密了，所以对 $secret 相同方式加密\n    $encyptsecret = "sha256=" . hash_hmac(\'sha256\', $requestbody, $secret);\n    \n    // 先对 url 解码，再解析为 json 数组\n    $content = json_decode(strstr(urldecode($requestbody),"{"),true);\n    // 若是指定的分支且提交数大于 0，且密码正确\n    if(strcmp($signature, $encyptsecret) == 0 || !empty($is_test)){  // strcmp 函数比较两个字符串\n        if ($content[\'ref\'] == "refs/heads/$branch" || !$branch || !empty($is_test)) {\n            $res_log = "------------------------- [pull start] -------------------------" . php_eol;  // php_eol 是换行符\n            $cmd = "rm -rf $savepath && $git clone -b $branch $gitsshpath $savepath && echo \'拉取项目并部署成功\'";\n            $result = shell_exec($cmd); // shell_exec 关键命令，执行拉取代码\n            if(!empty($is_test)){\n                $res_log .= "[" . date(\'y-m-d h:i:s\') . \'] 执行测试！\'. php_eol; // .= 代表追加到后面，不会覆盖前面\n            }else{\n                $res_log .= "[" . date(\'y-m-d h:i:s\', time() + 8 * 60 * 60) . \'] - 拉取 \' . $content[\'repository\'][\'name\'] . \' 仓库的 \' . $content[\'ref\'] . \' 分支代码进行部署\' . php_eol;\n            }\n            if(!$result){\n                $result = "拉取项目失败" . php_eol;\n            }\n            $res_log .= "[项目源] - $source" . php_eol;\n            $res_log .= "[执行命令] - " . $cmd . php_eol;\n            $res_log .= "[结果] - " . $result;\n            $res_log .= "-------------------------- [pull end] --------------------------" . php_eol;\n            $res_log .= php_eol . php_eol;\n            file_put_contents($logname.".log", $res_log, file_append); // 写入日志\n            echo $result;\n        }\n    } else {\n        file_put_contents($logname.".log", \'[github] 密码错误!\' . php_eol, file_append);\n        echo \'密码错误！\';\n    }\n}else {\t\t// 如果没有 clone，则先克隆代码\n    $res = "[ clone start ----------------- ]".php_eol;\n    // 如果配置全局信息过，则会覆盖\n    $res .= shell_exec("$git config --global user.email $email").php_eol;\n    $res .= shell_exec("$git config --global user.name $name").php_eol;\n    $res .= shell_exec("$git clone $gitsshpath $savepath").php_eol;\n    $res .= "[ clone end ----------------- ]".php_eol;\n    file_put_contents($logname.".log", $res, file_append); // 写入日志\n}\n?>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\ngithub 的脚本和 gitee 脚本的内容不是一样的，首先 github 返回的令牌是 sha256 加密的，而 gitee 返回的是不加密的，所以我们需要对本地的令牌进行 sha256 加密，然后再进行两者的判定，是否相等。\n\n其次 github 返回的请求是经过编码过的，如这种 %7b%22ref%22%3a%22refs%2fheads%2fgh-pages%，所以我们获取后需要解码，请看 29 代码。\n\n日志文件如下：\n\n\n\n\n# webhook配置\n\n讲了那么多，都不懂 webhook 如何配置，现在开始配置。\n\n> github配置\n\n进入仓库里，然后 github 点击 setting，找到 webhooks，然后点击 add webhook 进行配置。\n\n\n\n然后填写 php 脚本地址以及令牌。\n\n\n\n令牌要对应上我提供脚本的 $secre 变量值。\n\n脚本访问地址：比如脚本放在 /home/kbt/ 下的 deploy 目录下，脚本名叫做 deploy.php，那么地址是 ip:port/deploy/deploy.php。\n\n为什么地址没有 /home/kbt，因为上面我已经配置过了，这个目录是脚本的根路径，所以 ip:port/xxx.php 就是访问根目录下的 xxx.php，有目录则加上目录即可。\n\n> gitee\n\n其实就是中文版的 github，所以位置完全一样\n\n\n\n\n\n密码要对应上脚本的密码。\n\n添加 webhook 后，可以不断发送请求进行测试。\n\n笔记\n\n只需选择 push 事件触发即可，push 事件是指仓库的 任意分支 被 push 了都会触发，并非只有 master 分支触发。\n\n2021-11-09 @du wu\n\n\n# 问答\n\nq1 - 能否总结本内容步骤？\n\n 1.  安装 docker，然后利用 docker 安装 nginx 和 php 镜像\n 2.  创建 kbt 普通用户，加入 docker 组\n 3.  启动 nginx 容器，将配置文件目录、静态文件目录、日志文件目录拷贝出来，然后关闭 nginx 容器\n 4.  docker 创建网桥，给两个容器通信\n 5.  启动 nginx 容器，将拷贝的出来的三个目录和容器的三个目录进行挂载，以及与 kbt 用户的目录挂载\n 6.  启动 php 容器，与 kbt 用户的目录挂载，php 容器的挂载目录和 kbt 用户的目录路径一致\n 7.  在 nginx 容器创建 kbt 普通用户和组，然后修改 nginx.conf 配置文件的 user 为 kbt，即 nginx 的访问权限仅限于 kbt 的权限\n 8.  修改挂载出来的配置文件目录里的 default.conf 文件，指定 php 脚本所在的根路径为 kbt 的用户目录\n 9.  在 php 容器创建 kbt 普通用户和组，然后修改 www.conf 配置文件的 user 和 group 为 kbt，即 php 脚本运行权限仅限于 kbt 的权限\n 10. 两个容器配置完后，按顺序重启 php、nginx 容器\n 11. 宿主机安装 git，并配置 ssh 公钥给 github 或者 gitee。php 安装 git，在 kbt 用户目录克隆项目\n 12. 修改挂载出来的配置文件目录里的 default.conf 文件，添加 location，能访问克隆项目的目录\n 13. 编写 php 脚本，然后在 github 或者 gitee 上开启 webhook，配置脚本的 url 访问地址和令牌、密码\n\n----------------------------------------\n\nq2 - 为什么 nginx 的静态文件目录、日志文件目录没有用到？\n\n我要求启动 nginx 容器的时候，将这些目录挂载出来，是因为这是实际生产开发需要的，不一定是本内容需要的，这里只是打好预防针，留个印象。\n\n我当初部署的时候确实是把 php 脚本和克隆的项目放在静态文件目录下，但是不安全，这些目录是 root 用户管理的，所以我就创建了普通用户 kbt，将 php 脚本和克隆的项目放到该普通用户的目录下，即 /home/kbt。而放到该目录后，就要在 nginx 和 php 创建 kbt 用户，并且挂载到 kbt 用户目录下，实现三者的同一个目录互通。如下图：\n\n\n\nq3 - 一定要在 nginx 和 php 容器创建普通用户 kbt 吗？\n\n如果不创建普通用户 kbt，那么就需要一个目录实现上方图的三者互通，那么这个目录就属于 root 用户。\n\n----------------------------------------\n\nq4 - 两个容器创建的 kbt 用户和宿主机的 kbt 用户一样吗？\n\n不一样，但是我现在部署的时候就是这样创建的，我只把我成功的案例说出来。你也可以试试只在宿主机创建 kbt 用户，两个容器使用默认的用户（不创建 kbt 用户），我认为这样也可以。\n\n是可以的，据我了解，在宿主机以普通用户 kbt 启动 docker 容器，那么容器里虽然显示 root 用户，但是这个 root 用户的权限其实就是宿主机启动的用户权限，所以需要切换到普通用户，并给普通用户使用 docker 的权限，然后启动。\n\n----------------------------------------\n\nq5 - 不使用 docker 如何操作？\n\n其实熟悉 docker 了，发现本内容 docker 操作两个容器，其实就相当于在两台电脑分别安装 nginx 和 php，然后进行操作，docker 只是实现了两者在同一台电脑的互通（配置同一个网桥）。\n\n不使用 docker，会发现服务器部署非常方便，步骤大抵如下：\n\n 1. 在服务器安装 nginx 和 php 的环境\n\n 2. 在服务器创建普通用户 kbt，生成 /home/kbt 路径\n\n 3. 修改 nginx 的配置文件和 php 的配置文件，将用户权限改为 kbt\n\n 4. 修改 nginx 的配置文件，实现于 php 的互通，以及设置 php 脚本的根路径\n\n 5. 安装 git，配置信息，生成 ssh 公钥给 github 或 gitee\n\n 6. 编写 php 脚本，然后在 github 或 gitee 开启 webhook，填写脚本的 url 访问地址\n\n此时会发现少了 docker 的网桥配置，因为处于同一个服务器，本身就能通信。少了 docker，也不需要在两个容器创建普通用户 kbt，只需要在宿主机创建即可。\n\n----------------------------------------\n\nq6 - php 容器不安装 git 行吗，只在宿主机安装？\n\n不行的，因为 php 脚本执行后，使用的 git 命令是脚本所在的环境存在的，不安装即无法克隆项目代码，说其实的，如果曾经已经配置过宿主机的 ssh 公钥，则不需要在宿主机安装 git。宿主机安装 git 的目的仅仅是生成 ssh 公钥，而 php 容器才是使用 git 相关的命令。\n\n----------------------------------------\n\nq7 - php 容器不挂载出来可以吗？\n\n可以的，但是不建议。docker 挂载的目的就是实现宿主机和容器的数据同步，也就是说两个挂载目录，只要有一方发生修改，则另一方同步修改。而实际上，我们应该禁止容器的挂载目录能被手动修改数据，这样，只修改宿主机的挂载目录数据，安全大大提高的同时，容器的数据也会同步改变。\n\n而如果不挂载出来，就必须进入到容器内部，创建脚本，修改脚本，违背了容器能修改数据的原则，再想想容器万一不小心删除了，则数据全没了。而服务器只有过期、被入侵。两者相比优势清晰明了。',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 自定义样式模块",frontmatter:{title:"本站 - 自定义样式模块",date:"2022-01-01T20:15:16.000Z",permalink:"/about/website/style/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/18.%E6%9C%AC%E7%AB%99%20-%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/18.本站 - 自定义样式模块.md",key:"v-fe63d31a",path:"/about/website/style/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:125},{level:2,title:"样式代码",slug:"样式代码",normalizedTitle:"样式代码",charIndex:131},{level:2,title:"插件样式",slug:"插件样式",normalizedTitle:"插件样式",charIndex:139}],headersStr:"前言 样式代码 插件样式",content:'笔记\n\n如果你喜欢加粗的 绿色、`` 包裹的 英文高亮 abcd、<mark></mark> 包裹的 文字高亮、深色模式的各种颜色（点击右下角的衣服图标，切换深色模式）等等，那么可以参考下面的文章。\n\n2022-01-01 @Du Wu\n\n\n\n * 前言\n * 样式代码\n * 插件样式\n\n\n\n\n# 前言\n\n> 本模块已经提取 Vdoing 主题常用的元素选择器，并写好了注释，方便阅读。\n> \n> 你如果不满意我的颜色样式，想改成自己喜欢的颜色，直接在提取的元素选择器提供 Color 即可。\n\n如果你细心观察，你就会发现本站的一些样式和主题自带的样式有所区别。\n\n\n\n在浅色主题，也就是默认主题下，我修改了一些内容：\n\n * 代码块背景色\n * 代码块行数颜色\n * 代码高亮背景色\n * 代码高亮颜色\n * 加粗颜色\n\n......\n\n在深色主题下，我修改了一些内容：\n\n * 代码块背景色\n * 代码块行数颜色\n * 代码高亮背景色\n * 代码高亮颜色\n * 加粗颜色\n * 页面背景色\n * 导航栏颜色\n * 侧边栏颜色\n * 表格背景色\n * 表格偶数行颜色\n\n......\n\n如果你喜欢我的一些样式，可以参考下面的代码。\n\n又或者你想定制自己的样式，也可以修改颜色，基本的选择器都已经写好了，只需要更改颜色即可。\n\n\n# 样式代码\n\n打开 docs 目录下的 .vuepress 目录下的 style 目录下的 palette.styl 文件，添加如下内容：\n\n//***vdoing主题-样式变量***//\n\n// 以下注释的变量仅供参考，主题使用的最新变量请查看：https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/theme-vdoing/styles/palette.styl\n// 你可以在这个文件内修改这些变量的值\n\n// 主题调色板\n\n// 原主题预设变量\n// 颜色\n// $accentColor = #3eaf7c\n// $textColor = #2c3e50\n// $borderColor = #eaecef\n// $codeBgColor = #282c34\n// $arrowBgColor = #ccc\n// $badgeTipColor = #42b983\n// $badgeWarningColor = darken(#ffe564, 35%)\n// $badgeErrorColor = #DA5961\n// 布局\n// $navbarHeight = 3.6rem\n// $sidebarWidth = 20rem\n// $contentWidth = 740px\n// $homePageWidth = 960px\n// 代码块\n// $lineNumbersWrapperWidth = 3.5rem\n\n\n//***vdoing主题-变量***//\n\n// 颜色\n\n$bannerTextColor = #fff // 首页 banner 区(博客标题)文本颜色\n$accentColor = #11A8CD\n$activeColor = #ff5722\n$arrowBgColor = #ccc\n$badgeTipColor = #42b983\n$badgeWarningColor = darken(#ffe564, 35%)\n$badgeErrorColor = #DA5961\n\n// 布局\n$navbarHeight = 3.6rem\n$sidebarWidth = 18rem\n$contentWidth = 860px\n$homePageWidth = 1100px\n$rightMenuWidth = 230px // 右侧菜单\n\n// 代码块\n$lineNumbersWrapperWidth = 2.5rem\n\n// Young Kbt\n// 代码块的行数字颜色\ndiv[class*="language-"]\n  &.line-numbers-mode\n    .line-numbers-wrapper\n      color #9e9e9e\n\n// 加粗字体颜色\nstrong\n  // color \n  color #00A55A\n\n.suggestions\n  max-height 800 px\n  overflow-y scroll\n.suggestions .highlight\n  color #64acff\n  font-weight bold\n\n.footer {\n  color: #fff;\n}\n\n// 解决目录页和标题冲突问题，新版已经解决，这里是旧版的j（2022-4-16）\n// .theme-vdoing-content:not(.custom) > h1,\n// .theme-vdoing-content:not(.custom) > h2,\n// .theme-vdoing-content:not(.custom) > h3,\n// .theme-vdoing-content:not(.custom) > h4,\n// .theme-vdoing-content:not(.custom) > h5,\n// .theme-vdoing-content:not(.custom) > h6 {\n//  margin-top: -1.1rem;\n//  padding-top: 2.6rem;\n// }\n\n.theme-mode-light\n  --bodyBg: #f4f4f4\n  --mainBg: rgba(255,255,255,1)\n  --sidebarBg: rgba(255,255,255,.8)\n  --blurBg: rgba(255,255,255,.9)\n  --customBlockBg: #fff\n  --textColor: #00323c\n  --textLightenColor: #d63200     // `` 高亮，原来是 #0085AD\n  --borderColor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  //--codeBg: #f6f8fa\n  //--codeColor: #24292e\n  //codeThemeLight()\n  // 行高亮颜色，和代码块浅色主题一起使用，一起注释\n  //div[class*="language-"]\n  //  .highlight-lines\n  //    .highlighted\n  //      background-color rgba(200,200,200,.4)\n  //  &.line-numbers-mode\n  //    .highlight-lines .highlighted\n  //      &:before\n  //        background-color rgba(200,200,200,.4)\n  // 代码块深色主题\n  --codeBg: #282C34\n  --codeColor: #D4D4D4\n  codeThemeDark()\n  // 行高亮颜色，和代码块深色主题一起使用，一起注释\n  div[class*="language-"]\n    .highlight-lines\n      .highlighted\n        background-color rgba(0,0,0,.66)\n    &.line-numbers-mode\n      .highlight-lines .highlighted\n        &:before\n          background-color rgba(0,0,0,.66)\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n   // 下面代码块深色和浅色通用\n   // `` 包裹的背景色\n  .theme-vdoing-content\n    code\n      background-color #fff5f5\n      //background-color transparent\n  // 引用的颜色\n  blockquote\n    background-color #fdefee\n    border-left .25rem solid #e95f59\n    padding 10px 16px\n    opacity .9\n  // 选中代码块的颜色\n  pre[class*="language-"]::selection, pre[class*="language-"] ::selection,\n  code[class*="language-"]::selection, code[class*="language-"] ::selection {\n    text-shadow none\n    background-color #0A62C9\n  }\n  // mark 标签配置\n  mark\n    color #d63200\n    border .1em solid #d63200\n    background-color transparent\n    padding .1rem .5rem\n    border-radius 2rem\n    margin 0 .2rem\n    font-size .95rem\n  // ::: details 的边框\n  .custom-block.details\n    border solid 1px #ddd\n\n// 深色模式\n.theme-mode-dark\n  --bodyBg: rgba(40,40,56,1)\n  --mainBg: rgba(40,40,56,1)\n  --sidebarBg: rgba(40,40,56,.8)\n  --blurBg: rgba(40,40,56,.9)\n  --customBlockBg: rgba(25,25,49,0.53)\n  --textColor: #acb7c4\n  --textLightenColor: #b160ea   // `` 包裹的文字颜色\n  --borderColor: #1d1d26\n  --codeBg: #1d1d26\n  --codeColor: #A9B7C6\n  codeThemeDark()\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n  // `` 包裹的背景色\n  .theme-vdoing-content\n    code\n      background-color transparent\n  // 引用的颜色\n  blockquote\n    background-color rgba(25, 25, 49, 0.53)\n    border-left .25rem solid #904ac2\n    padding 10px 16px\n  // 首页每一个模块的边框\n  .card-box\n    border-radius: 5px;\n    background var(--mainBg);\n    box-shadow 0 2px 10px 0 rgba(0,0,0,.20);\n    transition box-shadow 0.5s;\n  .card-box:hover\n    box-shadow 2px 2px 15px 2px rgba(0,0,0,.40);\n  // mark 标签配置\n  mark\n    color #b160ea\n    border .1em solid #b160ea\n    background-color transparent\n    padding .1rem .5rem\n    border-radius 2rem\n    margin 0 .2rem\n    font-size .95rem\n  // 表格的样式\n  table\n    border-color #1d1d26\n    thead\n      background-color #2c2c47\n      font-size 1.02rem\n  tr:nth-child(2n)\n    background-color #2c2c47\n  // 信息框容器颜色\n  .custom-block.tip,\n  .custom-block.warning,\n  .custom-block.danger,\n  .custom-block.note\n    background-color rgba(25,25,49,0.53)\n  .custom-block.danger\n    color #ff4545\n    .custom-block-title\n      color #ff4545\n  .custom-block.note\n    color #28a1de\n  // 鼠标悬停、a 标签颜色，主题默认颜色 #11a8cd\n  .nav-item > a:not(.external):hover,\n  .nav-item > a:not(.external).router-link-active,\n  .nav-item .dropdown-title a:hover,    // 导航栏悬停\n  .nav-item .dropdown-title a.router-link-active,\n  .dropdown-wrapper .dropdown-title .title:hover    // 导航栏非 a 标签\n    border-bottom 2px solid #b160ea\n\n  a.sidebar-link.active     // 侧边栏当前标题\n    color #b160ea\n    border-left-color #b160ea\n\n  .post-list .post .title-wrapper a:hover,   // 首页文章列表悬停\n  .blogger-wrapper .icons a:hover,     // 首页头像下的图标悬停\n  .categories-wrapper .categories a:not(.active):hover,   // 文章分类悬停\n  .pagination span:hover,       // 首页的上一页和下一页悬停\n  a.sidebar-link:hover,   // 侧边栏悬停\n  .right-menu-wrapper .right-menu-content .right-menu-item.active a,  // 文章右侧当前标题\n  .right-menu-wrapper .right-menu-content .right-menu-item a:hover,   // 文章右侧标题悬停\n  .dropdown-wrapper .nav-dropdown .dropdown-item a:hover,   // 导航栏的二级导航悬停\n  .dropdown-wrapper .nav-dropdown .dropdown-item a.router-link-active,   // 导航栏的选中二级导航\n  .buttons .button .select-box li.active,    // 当前主题模式\n  .buttons .button .select-box li:hover,      // 三个主题模式悬停 \n  .archives-page .theme-vdoing-wrapper li a:hover,   // 归档列表悬停\n  .search-box .suggestions .focused a:hover,   // 搜索框内容鼠标悬停\n  .custom-block.details summary:hover     // ::: details 的标题悬停\n    color #b160ea\n\n  .categories-wrapper .categories a:not(.active):hover,   // 文章分类悬停\n  .right-menu-wrapper .right-menu-content .right-menu-item.active,\n  .search-box input:focus   // 搜索框获取焦点\n    border-color #b160ea\n\n  .buttons .button:hover      // 右下角三个图标\n    background #904ac2\n    box-shadow 0 0 15px #904ac2\n  .pagination .pagination-list span.active,     // 分页的当前页\n  .search-box .suggestions .parent-page-title   // 搜索框的标题\n    background #904ac2\n\n  // vuepress-plugin-tabs 插件的背景色\n  .tabs-component-tab,\n  .tabs-component-panels\n    background-color rgba(25,25,49,0.53)\n    border none\n  // vuepress-plugin-tabs 插件的标题选中颜色\n  .tabs-component-tab.is-active       \n    color #b160ea\n\n// 阅读模式\n.theme-mode-read\n  --bodyBg: rgb(236,236,204)\n  --mainBg: rgba(245,245,213,1)\n  --sidebarBg: rgba(245,245,213,.8)\n  --blurBg: rgba(245,245,213,.9)\n  --customBlockBg: rgb(236,236,204)\n  --textColor: #704214\n  --textLightenColor: #996633\n  --borderColor: rgba(0,0,0,.15)\n  --codeBg: #282c34\n  --codeColor: #fff\n  codeThemeDark()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n\n\n\n# 插件样式\n\n目前本站使用了 vuepress-plugin-reading-progress 插件，该插件能显示一个页面的进度条（位于顶部的紫色进度条），下面是我用的样式（放在 palette.styl 里）：\n\n// 顶部进度条插件\n $readingBgColor = transparent\n $readingZIndex = 1000\n $readingSize = 3px\n $readingProgressColor = #b160ea\n $readingProgressImage = none\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装这个插件的命令：\n\nyarn add vuepress-plugin-reading-progress\n\n\n1\n\n\n然后在 config.js 的 plugins 中，添加如下内容：\n\nmodule.exports =[\n    [\n        \'reading-progress\'\n    ]\n],\n\n\n1\n2\n3\n4\n5\n\n\n启动后就会生效。',normalizedContent:'笔记\n\n如果你喜欢加粗的 绿色、`` 包裹的 英文高亮 abcd、<mark></mark> 包裹的 文字高亮、深色模式的各种颜色（点击右下角的衣服图标，切换深色模式）等等，那么可以参考下面的文章。\n\n2022-01-01 @du wu\n\n\n\n * 前言\n * 样式代码\n * 插件样式\n\n\n\n\n# 前言\n\n> 本模块已经提取 vdoing 主题常用的元素选择器，并写好了注释，方便阅读。\n> \n> 你如果不满意我的颜色样式，想改成自己喜欢的颜色，直接在提取的元素选择器提供 color 即可。\n\n如果你细心观察，你就会发现本站的一些样式和主题自带的样式有所区别。\n\n\n\n在浅色主题，也就是默认主题下，我修改了一些内容：\n\n * 代码块背景色\n * 代码块行数颜色\n * 代码高亮背景色\n * 代码高亮颜色\n * 加粗颜色\n\n......\n\n在深色主题下，我修改了一些内容：\n\n * 代码块背景色\n * 代码块行数颜色\n * 代码高亮背景色\n * 代码高亮颜色\n * 加粗颜色\n * 页面背景色\n * 导航栏颜色\n * 侧边栏颜色\n * 表格背景色\n * 表格偶数行颜色\n\n......\n\n如果你喜欢我的一些样式，可以参考下面的代码。\n\n又或者你想定制自己的样式，也可以修改颜色，基本的选择器都已经写好了，只需要更改颜色即可。\n\n\n# 样式代码\n\n打开 docs 目录下的 .vuepress 目录下的 style 目录下的 palette.styl 文件，添加如下内容：\n\n//***vdoing主题-样式变量***//\n\n// 以下注释的变量仅供参考，主题使用的最新变量请查看：https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/theme-vdoing/styles/palette.styl\n// 你可以在这个文件内修改这些变量的值\n\n// 主题调色板\n\n// 原主题预设变量\n// 颜色\n// $accentcolor = #3eaf7c\n// $textcolor = #2c3e50\n// $bordercolor = #eaecef\n// $codebgcolor = #282c34\n// $arrowbgcolor = #ccc\n// $badgetipcolor = #42b983\n// $badgewarningcolor = darken(#ffe564, 35%)\n// $badgeerrorcolor = #da5961\n// 布局\n// $navbarheight = 3.6rem\n// $sidebarwidth = 20rem\n// $contentwidth = 740px\n// $homepagewidth = 960px\n// 代码块\n// $linenumberswrapperwidth = 3.5rem\n\n\n//***vdoing主题-变量***//\n\n// 颜色\n\n$bannertextcolor = #fff // 首页 banner 区(博客标题)文本颜色\n$accentcolor = #11a8cd\n$activecolor = #ff5722\n$arrowbgcolor = #ccc\n$badgetipcolor = #42b983\n$badgewarningcolor = darken(#ffe564, 35%)\n$badgeerrorcolor = #da5961\n\n// 布局\n$navbarheight = 3.6rem\n$sidebarwidth = 18rem\n$contentwidth = 860px\n$homepagewidth = 1100px\n$rightmenuwidth = 230px // 右侧菜单\n\n// 代码块\n$linenumberswrapperwidth = 2.5rem\n\n// young kbt\n// 代码块的行数字颜色\ndiv[class*="language-"]\n  &.line-numbers-mode\n    .line-numbers-wrapper\n      color #9e9e9e\n\n// 加粗字体颜色\nstrong\n  // color \n  color #00a55a\n\n.suggestions\n  max-height 800 px\n  overflow-y scroll\n.suggestions .highlight\n  color #64acff\n  font-weight bold\n\n.footer {\n  color: #fff;\n}\n\n// 解决目录页和标题冲突问题，新版已经解决，这里是旧版的j（2022-4-16）\n// .theme-vdoing-content:not(.custom) > h1,\n// .theme-vdoing-content:not(.custom) > h2,\n// .theme-vdoing-content:not(.custom) > h3,\n// .theme-vdoing-content:not(.custom) > h4,\n// .theme-vdoing-content:not(.custom) > h5,\n// .theme-vdoing-content:not(.custom) > h6 {\n//  margin-top: -1.1rem;\n//  padding-top: 2.6rem;\n// }\n\n.theme-mode-light\n  --bodybg: #f4f4f4\n  --mainbg: rgba(255,255,255,1)\n  --sidebarbg: rgba(255,255,255,.8)\n  --blurbg: rgba(255,255,255,.9)\n  --customblockbg: #fff\n  --textcolor: #00323c\n  --textlightencolor: #d63200     // `` 高亮，原来是 #0085ad\n  --bordercolor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  //--codebg: #f6f8fa\n  //--codecolor: #24292e\n  //codethemelight()\n  // 行高亮颜色，和代码块浅色主题一起使用，一起注释\n  //div[class*="language-"]\n  //  .highlight-lines\n  //    .highlighted\n  //      background-color rgba(200,200,200,.4)\n  //  &.line-numbers-mode\n  //    .highlight-lines .highlighted\n  //      &:before\n  //        background-color rgba(200,200,200,.4)\n  // 代码块深色主题\n  --codebg: #282c34\n  --codecolor: #d4d4d4\n  codethemedark()\n  // 行高亮颜色，和代码块深色主题一起使用，一起注释\n  div[class*="language-"]\n    .highlight-lines\n      .highlighted\n        background-color rgba(0,0,0,.66)\n    &.line-numbers-mode\n      .highlight-lines .highlighted\n        &:before\n          background-color rgba(0,0,0,.66)\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n   // 下面代码块深色和浅色通用\n   // `` 包裹的背景色\n  .theme-vdoing-content\n    code\n      background-color #fff5f5\n      //background-color transparent\n  // 引用的颜色\n  blockquote\n    background-color #fdefee\n    border-left .25rem solid #e95f59\n    padding 10px 16px\n    opacity .9\n  // 选中代码块的颜色\n  pre[class*="language-"]::selection, pre[class*="language-"] ::selection,\n  code[class*="language-"]::selection, code[class*="language-"] ::selection {\n    text-shadow none\n    background-color #0a62c9\n  }\n  // mark 标签配置\n  mark\n    color #d63200\n    border .1em solid #d63200\n    background-color transparent\n    padding .1rem .5rem\n    border-radius 2rem\n    margin 0 .2rem\n    font-size .95rem\n  // ::: details 的边框\n  .custom-block.details\n    border solid 1px #ddd\n\n// 深色模式\n.theme-mode-dark\n  --bodybg: rgba(40,40,56,1)\n  --mainbg: rgba(40,40,56,1)\n  --sidebarbg: rgba(40,40,56,.8)\n  --blurbg: rgba(40,40,56,.9)\n  --customblockbg: rgba(25,25,49,0.53)\n  --textcolor: #acb7c4\n  --textlightencolor: #b160ea   // `` 包裹的文字颜色\n  --bordercolor: #1d1d26\n  --codebg: #1d1d26\n  --codecolor: #a9b7c6\n  codethemedark()\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n  // `` 包裹的背景色\n  .theme-vdoing-content\n    code\n      background-color transparent\n  // 引用的颜色\n  blockquote\n    background-color rgba(25, 25, 49, 0.53)\n    border-left .25rem solid #904ac2\n    padding 10px 16px\n  // 首页每一个模块的边框\n  .card-box\n    border-radius: 5px;\n    background var(--mainbg);\n    box-shadow 0 2px 10px 0 rgba(0,0,0,.20);\n    transition box-shadow 0.5s;\n  .card-box:hover\n    box-shadow 2px 2px 15px 2px rgba(0,0,0,.40);\n  // mark 标签配置\n  mark\n    color #b160ea\n    border .1em solid #b160ea\n    background-color transparent\n    padding .1rem .5rem\n    border-radius 2rem\n    margin 0 .2rem\n    font-size .95rem\n  // 表格的样式\n  table\n    border-color #1d1d26\n    thead\n      background-color #2c2c47\n      font-size 1.02rem\n  tr:nth-child(2n)\n    background-color #2c2c47\n  // 信息框容器颜色\n  .custom-block.tip,\n  .custom-block.warning,\n  .custom-block.danger,\n  .custom-block.note\n    background-color rgba(25,25,49,0.53)\n  .custom-block.danger\n    color #ff4545\n    .custom-block-title\n      color #ff4545\n  .custom-block.note\n    color #28a1de\n  // 鼠标悬停、a 标签颜色，主题默认颜色 #11a8cd\n  .nav-item > a:not(.external):hover,\n  .nav-item > a:not(.external).router-link-active,\n  .nav-item .dropdown-title a:hover,    // 导航栏悬停\n  .nav-item .dropdown-title a.router-link-active,\n  .dropdown-wrapper .dropdown-title .title:hover    // 导航栏非 a 标签\n    border-bottom 2px solid #b160ea\n\n  a.sidebar-link.active     // 侧边栏当前标题\n    color #b160ea\n    border-left-color #b160ea\n\n  .post-list .post .title-wrapper a:hover,   // 首页文章列表悬停\n  .blogger-wrapper .icons a:hover,     // 首页头像下的图标悬停\n  .categories-wrapper .categories a:not(.active):hover,   // 文章分类悬停\n  .pagination span:hover,       // 首页的上一页和下一页悬停\n  a.sidebar-link:hover,   // 侧边栏悬停\n  .right-menu-wrapper .right-menu-content .right-menu-item.active a,  // 文章右侧当前标题\n  .right-menu-wrapper .right-menu-content .right-menu-item a:hover,   // 文章右侧标题悬停\n  .dropdown-wrapper .nav-dropdown .dropdown-item a:hover,   // 导航栏的二级导航悬停\n  .dropdown-wrapper .nav-dropdown .dropdown-item a.router-link-active,   // 导航栏的选中二级导航\n  .buttons .button .select-box li.active,    // 当前主题模式\n  .buttons .button .select-box li:hover,      // 三个主题模式悬停 \n  .archives-page .theme-vdoing-wrapper li a:hover,   // 归档列表悬停\n  .search-box .suggestions .focused a:hover,   // 搜索框内容鼠标悬停\n  .custom-block.details summary:hover     // ::: details 的标题悬停\n    color #b160ea\n\n  .categories-wrapper .categories a:not(.active):hover,   // 文章分类悬停\n  .right-menu-wrapper .right-menu-content .right-menu-item.active,\n  .search-box input:focus   // 搜索框获取焦点\n    border-color #b160ea\n\n  .buttons .button:hover      // 右下角三个图标\n    background #904ac2\n    box-shadow 0 0 15px #904ac2\n  .pagination .pagination-list span.active,     // 分页的当前页\n  .search-box .suggestions .parent-page-title   // 搜索框的标题\n    background #904ac2\n\n  // vuepress-plugin-tabs 插件的背景色\n  .tabs-component-tab,\n  .tabs-component-panels\n    background-color rgba(25,25,49,0.53)\n    border none\n  // vuepress-plugin-tabs 插件的标题选中颜色\n  .tabs-component-tab.is-active       \n    color #b160ea\n\n// 阅读模式\n.theme-mode-read\n  --bodybg: rgb(236,236,204)\n  --mainbg: rgba(245,245,213,1)\n  --sidebarbg: rgba(245,245,213,.8)\n  --blurbg: rgba(245,245,213,.9)\n  --customblockbg: rgb(236,236,204)\n  --textcolor: #704214\n  --textlightencolor: #996633\n  --bordercolor: rgba(0,0,0,.15)\n  --codebg: #282c34\n  --codecolor: #fff\n  codethemedark()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n\n\n\n# 插件样式\n\n目前本站使用了 vuepress-plugin-reading-progress 插件，该插件能显示一个页面的进度条（位于顶部的紫色进度条），下面是我用的样式（放在 palette.styl 里）：\n\n// 顶部进度条插件\n $readingbgcolor = transparent\n $readingzindex = 1000\n $readingsize = 3px\n $readingprogresscolor = #b160ea\n $readingprogressimage = none\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装这个插件的命令：\n\nyarn add vuepress-plugin-reading-progress\n\n\n1\n\n\n然后在 config.js 的 plugins 中，添加如下内容：\n\nmodule.exports =[\n    [\n        \'reading-progress\'\n    ]\n],\n\n\n1\n2\n3\n4\n5\n\n\n启动后就会生效。',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 评论模块",frontmatter:{title:"本站 - 评论模块",date:"2021-10-29T16:13:12.000Z",permalink:"/about/website/comment/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/14.%E6%9C%AC%E7%AB%99%20-%20%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/14.本站 - 评论模块.md",key:"v-1ecc7688",path:"/about/website/comment/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:82},{level:2,title:"Gitalk 搭建",slug:"gitalk-搭建",normalizedTitle:"gitalk 搭建",charIndex:88},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:103},{level:3,title:"Gitalk 使用",slug:"gitalk-使用",normalizedTitle:"gitalk 使用",charIndex:111},{level:3,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:126},{level:2,title:"Valine 搭建",slug:"valine-搭建",normalizedTitle:"valine 搭建",charIndex:132},{level:2,title:"Twikoo 搭建",slug:"twikoo-搭建",normalizedTitle:"twikoo 搭建",charIndex:145},{level:3,title:"Vercel 部署",slug:"vercel-部署",normalizedTitle:"vercel 部署",charIndex:160},{level:3,title:"Vdoing 集成",slug:"vdoing-集成",normalizedTitle:"vdoing 集成",charIndex:175},{level:3,title:"管理面板",slug:"管理面板",normalizedTitle:"管理面板",charIndex:190},{level:3,title:"反垃圾配置",slug:"反垃圾配置",normalizedTitle:"反垃圾配置",charIndex:200},{level:3,title:"邮件配置",slug:"邮件配置",normalizedTitle:"邮件配置",charIndex:211},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:221},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:227}],headersStr:"前言 Gitalk 搭建 安装 Gitalk 使用 问题 Valine 搭建 Twikoo 搭建 Vercel 部署 Vdoing 集成 管理面板 反垃圾配置 邮件配置 其他 结束语",content:"笔记\n\n本站使用过 Gitalk、Valine、Twikoo 三个评论系统，目前在使用 Twikoo 评论系统。\n\n2021-10-29 @Du Wu\n\n\n\n * 前言\n * Gitalk 搭建\n   * 安装\n   * Gitalk 使用\n   * 问题\n * Valine 搭建\n * Twikoo 搭建\n   * Vercel 部署\n   * Vdoing 集成\n   * 管理面板\n   * 反垃圾配置\n   * 邮件配置\n   * 其他\n * 结束语\n\n\n\n\n# 前言\n\n本站使用过 Gitalk、Valine、Twikoo 三个评论系统，目前在使用 Twikoo 评论系统。\n\n * Gitalk 评论系统基于 GitHub 的 Issue\n * Valine 评论系统基于 LeanCloud\n * Twikoo 评论系统是我目前正在使用的评论系统，也是功能性非常强大的评论系统，我看重的第一点是读者评论后会通过邮箱发送给博主，博主回复后也会通过邮箱发送给读者；其次博主的评论是标识的\n\nGitalk、Valine 通过使用 vuepress-plugin-comment 进行搭建。它既支持 Gitalk 应用也支持 Valine。\n\nTwikoo 的搭建比较麻烦，根据官网介绍，如果想搭建免费的评论系统，则需要注册 MongoDB、Vercel、Akismet、国外邮箱四大账号（前提你都没有）。\n\n\n# Gitalk 搭建\n\nGitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。所以你需要创建一个 GitHub 库，利用该库的 issues 存储评论信息。\n\n如果你已经有一个 GitHub 的仓库存储你的博客文件。那么可以直接使用该库的 issues 存储评论信息。毕竟分类就是把关联的东西放在一起，更好管理。\n\n建议先把自己的博客部署到 Github Actions 下，不然本地运行的话，评论区只能自己评论，自己看哦~~~ 😸部署传送门\n\n记得关闭其他评论系统的插件，下面让我们一起搭建评论区吧。\n\n\n# 安装\n\nyarn add vuepress-plugin-comment -D\n\n\n1\n\n\nnpm install vuepress-plugin-comment -D\n\n\n1\n\n\n\n# Gitalk 使用\n\n插件需要 GitHub Application，即权限。如果没有，点击这里申请\n\n如图：\n\n\n\n参数说明\n * Application name：你授权时对外的应用名字\n * Homepage URL：你应用的根url地址，类似于首页地址，不带任何参数\n * Application description：应用的描述\n * Authorization callback URL：对你的应用进行了操作后的回调地址，因为评论区绑定了博客，评论后的信息存储在博客的issues里\n\n申请完成就会得 Client ID 和 Client Secret\n\n\n\n前往配置文件，填入你的两个参数和其他信息，如下：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'c042********01c7',  // 你的client ID\n          clientSecret: 'b77b38cf72**********45d0a0',  // 你的client secret\n           repo: 'notes-blog', // GitHub 仓库\n            owner: 'Kele-Bingtang', // GitHub仓库所有者\n            admin: ['Kele-Bingtang'], // 对仓库有写权限的人\n            // distractionFreeMode: true,\n            pagerDirection: 'last', // 'first'正序 | 'last'倒序\n            // 下面的不用修改，默认这些即可\n            id: '<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>', //  页面的唯一标识,长度不能超过50\n            title: '「评论」<%- frontmatter.title %>', // GitHub issue 的标题\n            labels: ['Gitalk', 'Comment'], // GitHub issue 的标签\n            body:\n              '页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>', // GitHub issue 的内容\n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n配置好后，重启项目，然后打开某个文档，滑到最下方\n\n可以看到\n\n\n\n点击 使用 GitHub 登录，然后会要求授权，确定后评论功能实现啦\n\n\n# 问题\n\n 1. 评论区出现 Error: Validation Failed.\n\n分析：可能页面的链接过长，超过 50，请求 Issues 失败。所以手动设置 id 取值，限制长度不超过 50\n\n 2. 切换页面后评论区内容还是上一个页面的评论\n\n分析：frontmatter.to.path 没有即时获取 path\n\n两个问题的解决：\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n笔记\n\n其实上方代码在前面的参数配置时，已经加上，这里只是演示问题\n\n 3. 点击使用 GitHub 登录，跳转别的页面\n    \n    \n\n分析：申请 GitHub Application 时候，填错了Authorization callback URL地址，点击使用 GitHub 登录其实就是跳转到Authorization callback URL的填写地址。\n\n解决:Authorization callback URL 地址填好自己的博客链接\n\n\n# Valine 搭建\n\nValine 诞生于 2017 年 8 月 7 日，是一款基于 LeanCloud 的快速、简洁且高效的无后端评论系统。官网：https://valine.js.org/。\n\nValine 相比较 Gitalk 的优势：\n\n * Valine 是基于 LeanCloud 构建，Gitalk 是基于 Github 的 Issue 构建\n * Valine 使用简单，可以自定义名字、头像后发表评论，无需登录任何账户，Gitalk 必须登录自己的 Github 账号才能发表评论\n * Valine 支持自定义 emoji，如 B 站，微博等的表情\n\n......\n\n我开始使用 Valine 的时间（2022-01-04），目前使用 Twikoo（2022-02-16）\n\n记得关闭其他评论系统的插件。\n\n> 注册或登录 LeanCloud\n\n请先注册一个 LeanCloud 的账号，然后创建应用，填写基本信息，然后进入应用，点击设置，点击应用凭证，如图：\n\n\n\n获取你的 AppID 和 AppKey，然后在使用 comment 评论插件：\n\nmodule.exports = {\n    plugins: [\n        [\n            'vuepress-plugin-comment',\n            {\n                // 具体参数请看官网：https://valine.js.org/\n                choosen: 'valine',\n                // options 选项中的所有参数，会传给 Valine 的配置\n                options: {\n                    el: '#valine-vuepress-comment',\n                    appId: '你的 AppID',\n                    appKey: '你的 AppKey',\n                    placeholder: '请留下你的足迹 ~~',\n                    // 有 URL、''、mp、identicon、monsterid、wavatar、retro、robohash、hide 头像选择，具体头像是什么样子，请访问 https://valine.js.org/avatar.html\n                    avatar: 'mp',\t// 默认头像\n                    pageSize: 10,   // 评论列表分页，每页条数\n                    visitor: true,    // 文章访问量统计\n                    recordIP: false,   // 是否记录评论者 IP\n                    enableQQ: true,   // 是否启用昵称框自动获取 QQ 昵称和 QQ 头像, 默认关闭\n                }\n            }\n        ]\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n更多配置参数请访问 Valine 官网。\n\n\n# Twikoo 搭建\n\n官网地址：https://twikoo.js.org/。\n\n> 本搭建内容一部分来自官网。\n\n这里直接介绍使用 MongeDB、Vercel、Akismet 进行评论系统搭建（官方提供的免费版），如果想要付费的则是 MongeDB、腾讯云开发环境，付费搭建具体看官网。\n\n记得关闭其他评论系统的插件。\n\n\n# Vercel 部署\n\n注意\n\nVercel 部署的环境需配合 1.4.0 以上版本的 twikoo.js 使用\n\n视频教程（推荐），注意：因为 MongoDB 新版本原因，视频第三步的 Clusters 位置发生改变，记得回来配合文字教程进行操作。\n\n> 文字教程\n\n 1. 申请 MongoDB 账号，因为评论的数据都放在 MongoDB 数据库里\n\n 2. 创建免费 MongoDB 数据库和数据库用户，区域推荐选择 AWS / N. Virginia (us-east-1)\n\n 3. 点击左侧菜单的 Databases 列表，找到 Clusters 并点击右侧的 CONNECT，按步骤设置允许所有 IP 地址的连接（为什么？），然后点击第二个 Connect your application 并记录数据库连接字符串，请将连接字符串中的 <password> 修改为 数据库密码，其他不变（如 myFirstDatabase）\n\n 4. 申请 Vercel 账号\n\n 5. 点击以下按钮将 Twikoo 一键部署到 Vercel（确保登录了 Vercel，且网页未关闭）\n\n 6. 进入 Settings - Environment Variables，添加环境变量 MONGODB_URI，值为第 3 步的数据库连接字符串，然后 重新部署 deployed\n\n 7. 进入 Overview，点击 Domains 下方的链接，如果环境配置正确，可以看到「Twikoo 云函数运行正常」的提示\n\n 8. Vercel Domains（包含 https:// 前缀，例如 https://xxx.vercel.app）即为您的环境 id\n\n> 看不懂？如果想看有图文字教程，可以看其他博客，如：https://blog.csdn.net/weixin_58068682/article/details/122770936\n\n\n# Vdoing 集成\n\n打开 docs/.vuepress/config.js（新版是 config.ts），在 head 里添加如下内容（在 <head> 引入在线 script）：\n\n['script', { src: 'https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js' }],\n\n\n1\n\n\n1.6.7 是版本号，当时我使用的最新版是 1.6.7，可以去官网查看最新版本：点击跳转。\n\n在 docs/.vuepress/components 目录下创建 Vue 组件：Twikoo.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template>\n    <div id=\"tcomment\"></div>\n</template>\n<script>\nlet waitTime = 700; // 页面加载后多少毫秒后加载评论区（如果是 0ms，可能会报错）\nexport default {\n  data() {\n    return {\n      twikoo: \"\",\n      firstLoad: true,\n    };\n  },\n  mounted() {\n    // 不初始化评论区的页面：frontmatter 的 comment: false 的文章页、首页、归档页、404 页面\n    if (\n      (this.$frontmatter.comment == undefined || this.$frontmatter.comment) &&\n      this.$route.path != \"/\" &&\n      !this.otherPage(this.$route) &&\n      !this.isFourZeroFour(this.$route)\n    ) {\n      setTimeout(() => {\n        this.twikooInit();\n      }, waitTime);\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 404 页面、不同的标题会触发路由，禁止掉\n      if (\n        this.$route.path == \"/\" ||\n        this.otherPage(this.$route) ||\n        this.$route.hash != \"\" ||\n        this.isFourZeroFour(to)\n      ) {\n        return;\n      }\n      // 进入首页、进入 frontmatter 的 comment: false 页面，删除评论区\n      if (to.path == \"/\" || this.getCommentByFrontmatter(to) == false) {\n        this.deleteComment();\n        return;\n      }\n      // 初始化评论条件：来自首页，来自归档页、来自 frontmatter 的 comment: true 的文章页\n      if (\n        from.path == \"/\" ||\n        this.otherPage(from) ||\n        !this.getCommentByFrontmatter(from)\n      ) {\n        this.firstLoad\n          ? setTimeout(() => {\n              this.twikooInit();\n              this.firstLoad = false;\n            }, waitTime)\n          : this.twikooInit(); // 如果加载过一次评论区，则直接获取\n      } else if (this.$route.path != \"/\" && this.$route.hash == \"\") {\n        // 文章页之间跳转，重新获取评论\n        setTimeout(() => {\n          this.updateComment();\n        }, waitTime);\n      }\n    },\n  },\n  methods: {\n    twikooInit() {\n      twikoo\n        .init({\n          // envId 要切换成自己的，这是评论区的 ID，一个博客只能有一个评论区 ID，用别人的评论区 ID，导致读者评论时或发送到别人的评论区里\n          envId: \"https://twikoo.youngkbt.cn/\",\n          el: \"#tcomment\",\n          // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数\n          // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数\n          // lang: 'zh-CN', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/dev/src/js/utils/i18n/index.js\n          // onCommentLoaded: function () {\n          // console.log(\"评论加载或评论成功\");\n          // },\n        })\n        .then(() => {\n          this.loadTwikoo();\n        });\n    },\n    // 初始化加载或者跳转新页面重新加载 Twikoo 评论区\n    loadTwikoo() {\n      let page = document.getElementsByClassName(\"page\")[0];\n      let comment = document.getElementById(\"twikoo\");\n      // comment 不存在代表曾初始化过，后面被删除\n      comment ? (this.twikoo = comment) : (comment = this.twikoo);\n      page\n        ? comment\n          ? page.appendChild(comment)\n          : page.appendChild(this.twikoo)\n        : \"\";\n      this.updateComment();\n    },\n    // 跳转新页面，重新获取当前页面的评论信息\n    updateComment() {\n      let tk_icon = document.getElementsByClassName(\"tk-icon\")[0];\n      tk_icon ? tk_icon.click() : undefined;\n    },\n    // 删除 frontmatter:comment: false 页面的数据\n    deleteComment() {\n      let comment = document.getElementById(\"twikoo\");\n      comment ? comment.parentNode.removeChild(comment) : \"\";\n    },\n    // 获取 frontmatter 的 comment\n    getCommentByFrontmatter(route) {\n      let comment = true;\n      this.$site.pages.forEach((item) => {\n        if (item.path == route.path) {\n          comment = item.frontmatter.comment;\n        }\n      });\n      return comment;\n    },\n    // 判定当前页面是不是 404\n    isFourZeroFour(route) {\n      let flag = true;\n      this.$site.pages.forEach((item) => {\n        if (item.path == route.path) {\n          flag = false;\n        }\n      });\n      return flag;\n    },\n    // 其他页面\n    otherPage(route) {\n      if(\n        route.path == \"/archives/\" ||\n        route.path == \"/categories/\" ||\n        route.path == \"/tags/\"\n      ) {\n        return true;\n      }else {\n        return false;\n      }\n    }\n  },\n};\n<\/script>\n\n<style>\n.twikoo .tk-comments {\n    margin-top: 20px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n\n\n注意\n\n * 67 行的 evnId 换成自己的，即 Vercel 部署 Twikoo 的地址 Vercel Domains，如 https://xxx.vercel.app\n\n * 目前（2021-08-30）的 evnId 如果填写的是 Vercel 提供的地址（如 https://xxx.vercel.app），则评论区无法显示评论，原因是遭到国内的拦截\n\n * 目前官方给的解决是 evnId 填写自己的域名，即填写的域名需要进行域名解析，映射到 Vercel 提供的地址。和配置域名访问博客一个道理，只不过换成配置域名访问 Twikoo。\n\n2022-08-30 @Du Wu\n\n> 如果你不想在某个页面出现评论区，有两种方法：\n> \n>  * 文档里的 frontmatter 里设置 comment 为 false\n>  * 修改源码，位于 126 - 128 行那里（参考），route.path 需要强制判断某个页面的 premilink，等于则评论区不出现在该页面里\n\n写完 Vue 组件，接下来注册使用，在 config.js（新版是 config.ts）的 plugins 模块下，添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: 'custom-plugins',\n            globalUIComponents: [\"Twikoo\"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from 'vuepress/config'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: 'custom-plugins',\n        \tglobalUIComponents: [\"Twikoo\"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 管理面板\n\n下面来认识 Twikoo 的管理面板，配置好上面的内容，就可以启动项目，然后看看效果。在评论区的右边发现有一个「蓝色小齿轮」，这就是管理面板，第一次 点击小齿轮后会让你注册 登录密码，请记住它，如果忘记了密码，请去直接的 MongoDB 数据库修改。\n\n管理面板的用处：\n\n * 可以查看、删除、隐藏、显示、置顶任意的评论\n * 配置你的个人信息，登录管理面板后评论系统能识别你的身份（博主）\n * 配置反垃圾模块，防止别人发送不雅的评论\n * 配置邮件通知，别人的评论会通过邮件发送给你\n\n......\n\n到了这一步，就能实现 Gitalk 和 Valine 的评论功能，也就是别人评论 + 你回复，但是这并不是我们选择 Twikoo 的原因。\n\nTwikoo 吸引人的地方在于 反垃圾评论 和 邮件功能提醒，往下看。\n\n\n# 反垃圾配置\n\n这里使用 Akismet 反垃圾服务（免费）。\n\nAkismet (Automattic Kismet) 是应用广泛的一个垃圾留言过滤系统，其作者是大名鼎鼎的 WordPress 创始人 Matt Mullenweg，Akismet 也是 WordPress 默认安装的插件，其使用非常广泛，设计目标便是帮助博客网站来过滤垃圾留言。\n\n 1. 注册 akismet.com\n 2. 选择 Akismet Personal 订阅，复制得到的 Akismet API Key，到 Twikoo 管理面板「反垃圾」模块中配置\n\n反垃圾测试\n\n请填写 viagra-test-123 作为昵称，或填写 akismet-guaranteed-spam@example.com 作为邮箱，发表评论，这条评论将一定会被视为垃圾评论。\n\n需要注意的是，由于 Akismet 服务响应速度较慢（大约 6 秒），影响用户体验，Twikoo 采取 “先放行，后检测” 的策略，垃圾评论会在发表后短暂可见。\n\n垃圾评论不会被删除，只是把评论状态变成 审核中。\n\n审核中 的评论，代表只有发言人和博主能看到，其他人无法看到，原因：\n\n * 被 Akismet 认为是垃圾评论\n * 博主隐藏了发言人的评论，所以只能发言人和博主看到\n\n解决：\n\n * 让博主在管理面板 显示 自己的评论\n\n如何在新的客户端（浏览器）进行登录\n\n * 博主：在管理面板进行登录\n * 读者：输入曾发表评论时用到的昵称和邮箱\n\n\n# 邮件配置\n\n如果是 Vercel 部署的 Twikoo，请配置国外邮件服务商，避免被邮件服务商判定为垃圾邮件行为，也就是别人的评论不会通过国内的邮箱发送给你，因为 Vercel 位于国外。\n\n> PS：邮箱记得开启 POP3、IMAP/SMTP 服务，否则无法通过第三方如 Twikoo 进行登录。\n\n\n# 其他\n\n更多的配置请自行查看管理面板的文字提示，如果想要支持公式、图片之类的（默认支持的空间大小有限制），请看官网的教程。\n\n如果你觉得配置免费版的 Twikoo 很麻烦，那么可以考虑腾讯云开发环境配置（6.9元/月），因为腾讯云自带反垃圾（代替 Akismet）、部署（代替 Vercel）、支持国内邮箱的功能，所以只需要 MongoDB + 腾讯云即可。\n\n目前我没有使用过腾讯云开发环境，所以大家看官网的教程，自行研究。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！",normalizedContent:"笔记\n\n本站使用过 gitalk、valine、twikoo 三个评论系统，目前在使用 twikoo 评论系统。\n\n2021-10-29 @du wu\n\n\n\n * 前言\n * gitalk 搭建\n   * 安装\n   * gitalk 使用\n   * 问题\n * valine 搭建\n * twikoo 搭建\n   * vercel 部署\n   * vdoing 集成\n   * 管理面板\n   * 反垃圾配置\n   * 邮件配置\n   * 其他\n * 结束语\n\n\n\n\n# 前言\n\n本站使用过 gitalk、valine、twikoo 三个评论系统，目前在使用 twikoo 评论系统。\n\n * gitalk 评论系统基于 github 的 issue\n * valine 评论系统基于 leancloud\n * twikoo 评论系统是我目前正在使用的评论系统，也是功能性非常强大的评论系统，我看重的第一点是读者评论后会通过邮箱发送给博主，博主回复后也会通过邮箱发送给读者；其次博主的评论是标识的\n\ngitalk、valine 通过使用 vuepress-plugin-comment 进行搭建。它既支持 gitalk 应用也支持 valine。\n\ntwikoo 的搭建比较麻烦，根据官网介绍，如果想搭建免费的评论系统，则需要注册 mongodb、vercel、akismet、国外邮箱四大账号（前提你都没有）。\n\n\n# gitalk 搭建\n\ngitalk 是一个基于 github issue 和 preact 开发的评论插件。所以你需要创建一个 github 库，利用该库的 issues 存储评论信息。\n\n如果你已经有一个 github 的仓库存储你的博客文件。那么可以直接使用该库的 issues 存储评论信息。毕竟分类就是把关联的东西放在一起，更好管理。\n\n建议先把自己的博客部署到 github actions 下，不然本地运行的话，评论区只能自己评论，自己看哦~~~ 😸部署传送门\n\n记得关闭其他评论系统的插件，下面让我们一起搭建评论区吧。\n\n\n# 安装\n\nyarn add vuepress-plugin-comment -d\n\n\n1\n\n\nnpm install vuepress-plugin-comment -d\n\n\n1\n\n\n\n# gitalk 使用\n\n插件需要 github application，即权限。如果没有，点击这里申请\n\n如图：\n\n\n\n参数说明\n * application name：你授权时对外的应用名字\n * homepage url：你应用的根url地址，类似于首页地址，不带任何参数\n * application description：应用的描述\n * authorization callback url：对你的应用进行了操作后的回调地址，因为评论区绑定了博客，评论后的信息存储在博客的issues里\n\n申请完成就会得 client id 和 client secret\n\n\n\n前往配置文件，填入你的两个参数和其他信息，如下：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'c042********01c7',  // 你的client id\n          clientsecret: 'b77b38cf72**********45d0a0',  // 你的client secret\n           repo: 'notes-blog', // github 仓库\n            owner: 'kele-bingtang', // github仓库所有者\n            admin: ['kele-bingtang'], // 对仓库有写权限的人\n            // distractionfreemode: true,\n            pagerdirection: 'last', // 'first'正序 | 'last'倒序\n            // 下面的不用修改，默认这些即可\n            id: '<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>', //  页面的唯一标识,长度不能超过50\n            title: '「评论」<%- frontmatter.title %>', // github issue 的标题\n            labels: ['gitalk', 'comment'], // github issue 的标签\n            body:\n              '页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>', // github issue 的内容\n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n配置好后，重启项目，然后打开某个文档，滑到最下方\n\n可以看到\n\n\n\n点击 使用 github 登录，然后会要求授权，确定后评论功能实现啦\n\n\n# 问题\n\n 1. 评论区出现 error: validation failed.\n\n分析：可能页面的链接过长，超过 50，请求 issues 失败。所以手动设置 id 取值，限制长度不超过 50\n\n 2. 切换页面后评论区内容还是上一个页面的评论\n\n分析：frontmatter.to.path 没有即时获取 path\n\n两个问题的解决：\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n笔记\n\n其实上方代码在前面的参数配置时，已经加上，这里只是演示问题\n\n 3. 点击使用 github 登录，跳转别的页面\n    \n    \n\n分析：申请 github application 时候，填错了authorization callback url地址，点击使用 github 登录其实就是跳转到authorization callback url的填写地址。\n\n解决:authorization callback url 地址填好自己的博客链接\n\n\n# valine 搭建\n\nvaline 诞生于 2017 年 8 月 7 日，是一款基于 leancloud 的快速、简洁且高效的无后端评论系统。官网：https://valine.js.org/。\n\nvaline 相比较 gitalk 的优势：\n\n * valine 是基于 leancloud 构建，gitalk 是基于 github 的 issue 构建\n * valine 使用简单，可以自定义名字、头像后发表评论，无需登录任何账户，gitalk 必须登录自己的 github 账号才能发表评论\n * valine 支持自定义 emoji，如 b 站，微博等的表情\n\n......\n\n我开始使用 valine 的时间（2022-01-04），目前使用 twikoo（2022-02-16）\n\n记得关闭其他评论系统的插件。\n\n> 注册或登录 leancloud\n\n请先注册一个 leancloud 的账号，然后创建应用，填写基本信息，然后进入应用，点击设置，点击应用凭证，如图：\n\n\n\n获取你的 appid 和 appkey，然后在使用 comment 评论插件：\n\nmodule.exports = {\n    plugins: [\n        [\n            'vuepress-plugin-comment',\n            {\n                // 具体参数请看官网：https://valine.js.org/\n                choosen: 'valine',\n                // options 选项中的所有参数，会传给 valine 的配置\n                options: {\n                    el: '#valine-vuepress-comment',\n                    appid: '你的 appid',\n                    appkey: '你的 appkey',\n                    placeholder: '请留下你的足迹 ~~',\n                    // 有 url、''、mp、identicon、monsterid、wavatar、retro、robohash、hide 头像选择，具体头像是什么样子，请访问 https://valine.js.org/avatar.html\n                    avatar: 'mp',\t// 默认头像\n                    pagesize: 10,   // 评论列表分页，每页条数\n                    visitor: true,    // 文章访问量统计\n                    recordip: false,   // 是否记录评论者 ip\n                    enableqq: true,   // 是否启用昵称框自动获取 qq 昵称和 qq 头像, 默认关闭\n                }\n            }\n        ]\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n更多配置参数请访问 valine 官网。\n\n\n# twikoo 搭建\n\n官网地址：https://twikoo.js.org/。\n\n> 本搭建内容一部分来自官网。\n\n这里直接介绍使用 mongedb、vercel、akismet 进行评论系统搭建（官方提供的免费版），如果想要付费的则是 mongedb、腾讯云开发环境，付费搭建具体看官网。\n\n记得关闭其他评论系统的插件。\n\n\n# vercel 部署\n\n注意\n\nvercel 部署的环境需配合 1.4.0 以上版本的 twikoo.js 使用\n\n视频教程（推荐），注意：因为 mongodb 新版本原因，视频第三步的 clusters 位置发生改变，记得回来配合文字教程进行操作。\n\n> 文字教程\n\n 1. 申请 mongodb 账号，因为评论的数据都放在 mongodb 数据库里\n\n 2. 创建免费 mongodb 数据库和数据库用户，区域推荐选择 aws / n. virginia (us-east-1)\n\n 3. 点击左侧菜单的 databases 列表，找到 clusters 并点击右侧的 connect，按步骤设置允许所有 ip 地址的连接（为什么？），然后点击第二个 connect your application 并记录数据库连接字符串，请将连接字符串中的 <password> 修改为 数据库密码，其他不变（如 myfirstdatabase）\n\n 4. 申请 vercel 账号\n\n 5. 点击以下按钮将 twikoo 一键部署到 vercel（确保登录了 vercel，且网页未关闭）\n\n 6. 进入 settings - environment variables，添加环境变量 mongodb_uri，值为第 3 步的数据库连接字符串，然后 重新部署 deployed\n\n 7. 进入 overview，点击 domains 下方的链接，如果环境配置正确，可以看到「twikoo 云函数运行正常」的提示\n\n 8. vercel domains（包含 https:// 前缀，例如 https://xxx.vercel.app）即为您的环境 id\n\n> 看不懂？如果想看有图文字教程，可以看其他博客，如：https://blog.csdn.net/weixin_58068682/article/details/122770936\n\n\n# vdoing 集成\n\n打开 docs/.vuepress/config.js（新版是 config.ts），在 head 里添加如下内容（在 <head> 引入在线 script）：\n\n['script', { src: 'https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js' }],\n\n\n1\n\n\n1.6.7 是版本号，当时我使用的最新版是 1.6.7，可以去官网查看最新版本：点击跳转。\n\n在 docs/.vuepress/components 目录下创建 vue 组件：twikoo.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template>\n    <div id=\"tcomment\"></div>\n</template>\n<script>\nlet waittime = 700; // 页面加载后多少毫秒后加载评论区（如果是 0ms，可能会报错）\nexport default {\n  data() {\n    return {\n      twikoo: \"\",\n      firstload: true,\n    };\n  },\n  mounted() {\n    // 不初始化评论区的页面：frontmatter 的 comment: false 的文章页、首页、归档页、404 页面\n    if (\n      (this.$frontmatter.comment == undefined || this.$frontmatter.comment) &&\n      this.$route.path != \"/\" &&\n      !this.otherpage(this.$route) &&\n      !this.isfourzerofour(this.$route)\n    ) {\n      settimeout(() => {\n        this.twikooinit();\n      }, waittime);\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 404 页面、不同的标题会触发路由，禁止掉\n      if (\n        this.$route.path == \"/\" ||\n        this.otherpage(this.$route) ||\n        this.$route.hash != \"\" ||\n        this.isfourzerofour(to)\n      ) {\n        return;\n      }\n      // 进入首页、进入 frontmatter 的 comment: false 页面，删除评论区\n      if (to.path == \"/\" || this.getcommentbyfrontmatter(to) == false) {\n        this.deletecomment();\n        return;\n      }\n      // 初始化评论条件：来自首页，来自归档页、来自 frontmatter 的 comment: true 的文章页\n      if (\n        from.path == \"/\" ||\n        this.otherpage(from) ||\n        !this.getcommentbyfrontmatter(from)\n      ) {\n        this.firstload\n          ? settimeout(() => {\n              this.twikooinit();\n              this.firstload = false;\n            }, waittime)\n          : this.twikooinit(); // 如果加载过一次评论区，则直接获取\n      } else if (this.$route.path != \"/\" && this.$route.hash == \"\") {\n        // 文章页之间跳转，重新获取评论\n        settimeout(() => {\n          this.updatecomment();\n        }, waittime);\n      }\n    },\n  },\n  methods: {\n    twikooinit() {\n      twikoo\n        .init({\n          // envid 要切换成自己的，这是评论区的 id，一个博客只能有一个评论区 id，用别人的评论区 id，导致读者评论时或发送到别人的评论区里\n          envid: \"https://twikoo.youngkbt.cn/\",\n          el: \"#tcomment\",\n          // region: 'ap-guangzhou', // 环境地域，默认为 ap-shanghai，如果您的环境地域不是上海，需传此参数\n          // path: 'window.location.pathname', // 用于区分不同文章的自定义 js 路径，如果您的文章路径不是 location.pathname，需传此参数\n          // lang: 'zh-cn', // 用于手动设定评论区语言，支持的语言列表 https://github.com/imaegoo/twikoo/blob/dev/src/js/utils/i18n/index.js\n          // oncommentloaded: function () {\n          // console.log(\"评论加载或评论成功\");\n          // },\n        })\n        .then(() => {\n          this.loadtwikoo();\n        });\n    },\n    // 初始化加载或者跳转新页面重新加载 twikoo 评论区\n    loadtwikoo() {\n      let page = document.getelementsbyclassname(\"page\")[0];\n      let comment = document.getelementbyid(\"twikoo\");\n      // comment 不存在代表曾初始化过，后面被删除\n      comment ? (this.twikoo = comment) : (comment = this.twikoo);\n      page\n        ? comment\n          ? page.appendchild(comment)\n          : page.appendchild(this.twikoo)\n        : \"\";\n      this.updatecomment();\n    },\n    // 跳转新页面，重新获取当前页面的评论信息\n    updatecomment() {\n      let tk_icon = document.getelementsbyclassname(\"tk-icon\")[0];\n      tk_icon ? tk_icon.click() : undefined;\n    },\n    // 删除 frontmatter:comment: false 页面的数据\n    deletecomment() {\n      let comment = document.getelementbyid(\"twikoo\");\n      comment ? comment.parentnode.removechild(comment) : \"\";\n    },\n    // 获取 frontmatter 的 comment\n    getcommentbyfrontmatter(route) {\n      let comment = true;\n      this.$site.pages.foreach((item) => {\n        if (item.path == route.path) {\n          comment = item.frontmatter.comment;\n        }\n      });\n      return comment;\n    },\n    // 判定当前页面是不是 404\n    isfourzerofour(route) {\n      let flag = true;\n      this.$site.pages.foreach((item) => {\n        if (item.path == route.path) {\n          flag = false;\n        }\n      });\n      return flag;\n    },\n    // 其他页面\n    otherpage(route) {\n      if(\n        route.path == \"/archives/\" ||\n        route.path == \"/categories/\" ||\n        route.path == \"/tags/\"\n      ) {\n        return true;\n      }else {\n        return false;\n      }\n    }\n  },\n};\n<\/script>\n\n<style>\n.twikoo .tk-comments {\n    margin-top: 20px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n\n\n注意\n\n * 67 行的 evnid 换成自己的，即 vercel 部署 twikoo 的地址 vercel domains，如 https://xxx.vercel.app\n\n * 目前（2021-08-30）的 evnid 如果填写的是 vercel 提供的地址（如 https://xxx.vercel.app），则评论区无法显示评论，原因是遭到国内的拦截\n\n * 目前官方给的解决是 evnid 填写自己的域名，即填写的域名需要进行域名解析，映射到 vercel 提供的地址。和配置域名访问博客一个道理，只不过换成配置域名访问 twikoo。\n\n2022-08-30 @du wu\n\n> 如果你不想在某个页面出现评论区，有两种方法：\n> \n>  * 文档里的 frontmatter 里设置 comment 为 false\n>  * 修改源码，位于 126 - 128 行那里（参考），route.path 需要强制判断某个页面的 premilink，等于则评论区不出现在该页面里\n\n写完 vue 组件，接下来注册使用，在 config.js（新版是 config.ts）的 plugins 模块下，添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: 'custom-plugins',\n            globaluicomponents: [\"twikoo\"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from 'vuepress/config'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: 'custom-plugins',\n        \tglobaluicomponents: [\"twikoo\"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 管理面板\n\n下面来认识 twikoo 的管理面板，配置好上面的内容，就可以启动项目，然后看看效果。在评论区的右边发现有一个「蓝色小齿轮」，这就是管理面板，第一次 点击小齿轮后会让你注册 登录密码，请记住它，如果忘记了密码，请去直接的 mongodb 数据库修改。\n\n管理面板的用处：\n\n * 可以查看、删除、隐藏、显示、置顶任意的评论\n * 配置你的个人信息，登录管理面板后评论系统能识别你的身份（博主）\n * 配置反垃圾模块，防止别人发送不雅的评论\n * 配置邮件通知，别人的评论会通过邮件发送给你\n\n......\n\n到了这一步，就能实现 gitalk 和 valine 的评论功能，也就是别人评论 + 你回复，但是这并不是我们选择 twikoo 的原因。\n\ntwikoo 吸引人的地方在于 反垃圾评论 和 邮件功能提醒，往下看。\n\n\n# 反垃圾配置\n\n这里使用 akismet 反垃圾服务（免费）。\n\nakismet (automattic kismet) 是应用广泛的一个垃圾留言过滤系统，其作者是大名鼎鼎的 wordpress 创始人 matt mullenweg，akismet 也是 wordpress 默认安装的插件，其使用非常广泛，设计目标便是帮助博客网站来过滤垃圾留言。\n\n 1. 注册 akismet.com\n 2. 选择 akismet personal 订阅，复制得到的 akismet api key，到 twikoo 管理面板「反垃圾」模块中配置\n\n反垃圾测试\n\n请填写 viagra-test-123 作为昵称，或填写 akismet-guaranteed-spam@example.com 作为邮箱，发表评论，这条评论将一定会被视为垃圾评论。\n\n需要注意的是，由于 akismet 服务响应速度较慢（大约 6 秒），影响用户体验，twikoo 采取 “先放行，后检测” 的策略，垃圾评论会在发表后短暂可见。\n\n垃圾评论不会被删除，只是把评论状态变成 审核中。\n\n审核中 的评论，代表只有发言人和博主能看到，其他人无法看到，原因：\n\n * 被 akismet 认为是垃圾评论\n * 博主隐藏了发言人的评论，所以只能发言人和博主看到\n\n解决：\n\n * 让博主在管理面板 显示 自己的评论\n\n如何在新的客户端（浏览器）进行登录\n\n * 博主：在管理面板进行登录\n * 读者：输入曾发表评论时用到的昵称和邮箱\n\n\n# 邮件配置\n\n如果是 vercel 部署的 twikoo，请配置国外邮件服务商，避免被邮件服务商判定为垃圾邮件行为，也就是别人的评论不会通过国内的邮箱发送给你，因为 vercel 位于国外。\n\n> ps：邮箱记得开启 pop3、imap/smtp 服务，否则无法通过第三方如 twikoo 进行登录。\n\n\n# 其他\n\n更多的配置请自行查看管理面板的文字提示，如果想要支持公式、图片之类的（默认支持的空间大小有限制），请看官网的教程。\n\n如果你觉得配置免费版的 twikoo 很麻烦，那么可以考虑腾讯云开发环境配置（6.9元/月），因为腾讯云自带反垃圾（代替 akismet）、部署（代替 vercel）、支持国内邮箱的功能，所以只需要 mongodb + 腾讯云即可。\n\n目前我没有使用过腾讯云开发环境，所以大家看官网的教程，自行研究。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 记录曾阅读位置模块",frontmatter:{title:"本站 - 记录曾阅读位置模块",date:"2022-01-04T15:44:12.000Z",permalink:"/about/website/lastReading/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/20.%E6%9C%AC%E7%AB%99%20-%20%E8%AE%B0%E5%BD%95%E9%98%85%E8%AF%BB%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/20.本站 - 记录阅读文章模块.md",key:"v-0367b534",path:"/about/website/lastReading/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:72},{level:2,title:"组件添加",slug:"组件添加",normalizedTitle:"组件添加",charIndex:78},{level:2,title:"路由监听",slug:"路由监听",normalizedTitle:"路由监听",charIndex:86},{level:2,title:"本地插件配置",slug:"本地插件配置",normalizedTitle:"本地插件配置",charIndex:94},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:104}],headersStr:"前言 组件添加 路由监听 本地插件配置 结束语",content:'笔记\n\n本站实现了一个记住阅读文章的本地插件，方便下次访问本站时，可选择跳转曾经阅读的文章。\n\n2022-01-04 @Du Wu\n\n\n\n * 前言\n * 组件添加\n * 路由监听\n * 本地插件配置\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n不需要安装任何插件，只需要在本地添加三段代码即可。\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 文件夹下创建 LastReadingPopup.vue 文件，如果没有 components 文件夹，请创建。\n\n添加如下内容：\n\n<template>\n  <transition name="sw-update-popup">\n    <div v-if="show" class="sw-update-popup">\n      {{ message }}\n\n      <br />\n\n      <button @click="goto">\n        {{ sureButtonText }}\n      </button>\n      <button @click="dontgoto">\n        {{ cancelButtonText }}\n      </button>\n    </div>\n  </transition>\n</template>\n\n<script>\nexport default {\n  name: "LastReadingPopup",\n\n  data() {\n    return {\n      lastReading: null,\n      show: false,\n    };\n  },\n\n  computed: {\n    popupConfig() {\n      const popupConfig = {\n        "/": {\n          // message: "Go back to the last reading.",\n          // buttonText: "Go to",\n          message: "检测到您上一次阅读的位置，是否移至该位置？",\n          sureButtonText: "确定",\n          cancelButtonText: "取消",\n        },\n        "/zh/": {\n          message: "检测到您上一次阅读的位置，是否移至该位置？",\n          sureButtonText: "前往",\n          cancelButtonText: "取消",\n        },\n      };\n      const lang = this.$lang.split("-")[0];\n      return (\n        popupConfig[`/${lang}/`] || popupConfig[this.$localePath] || popupConfig\n      );\n    },\n    // 提示消息\n    message() {\n      const c = this.popupConfig;\n      return (c && c.message) || c["/"].message;\n    },\n    // 确认按钮\n    sureButtonText() {\n      const c = this.popupConfig;\n      return (c && c.sureButtonText) || c["/"].sureButtonText;\n    },\n    // 取消按钮\n    cancelButtonText() {\n      const c = this.popupConfig;\n      return (c && c.cancelButtonText) || c["/"].cancelButtonText;\n    },\n  },\n\n  // 如果不想使用该文件的效果，注释掉即可 mouted 函数的所有内容即可\n  mounted() {\n    if (!!window.ActiveXObject || "ActiveXObject" in window) {\n      setTimeout(() => {\n        window.addEventListener("load", this.init()); // for IE\n      }, 1000);\n    } else {\n      setTimeout(() => {\n        window.addEventListener("load", this.init);\n      }, 1000);\n    }\n  },\n\n  methods: {\n    init() {\n      this.lastReading = JSON.parse(localStorage.getItem("lastReading"));\n\n      if (this.lastReading) {\n        if (this.$route.path === this.lastReading.path) {\n          this.goto();\n        } else {\n          this.show = true;\n          10000 && setTimeout(this.clean, 10000);\n        }\n      }\n    },\n\n    goto() {\n      if (this.$route.path !== this.lastReading.path) {\n        this.$router.replace(this.lastReading.path).then(() => {\n          document.documentElement.scrollTop = this.lastReading.scrollTop;\n          this.clean();\n        });\n      } else {\n        this.$nextTick(() => {\n          document.documentElement.scrollTop = this.lastReading.scrollTop;\n          // this.clean();\n        });\n      }\n    },\n\n    dontgoto() {\n      this.clean();\n    },\n\n    clean() {\n      this.show = false;\n      localStorage.removeItem("lastReading");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.sw-update-popup {\n  position: fixed;\n  right: 1em;\n  bottom: 1em;\n  padding: 1em;\n  border: 1px solid #3eaf7c;\n  border-radius: 3px;\n  background: #fff;\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);\n  text-align: center;\n  z-index: 12;\n}\n\n.sw-update-popup > button {\n  margin-top: 0.5em;\n  padding: 0.25em 2em;\n}\n\n.sw-update-popup-enter-active,\n.sw-update-popup-leave-active {\n  transition: opacity 0.3s, transform 0.3s;\n}\n\n.sw-update-popup-enter,\n.sw-update-popup-leave-to {\n  opacity: 0;\n  transform: translate(0, 50%) scale(0.5);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\n单语言你可以修改 35 - 37 的代码，多语言则包括了 40 - 42 行代码。\n\n\n# 路由监听\n\n在 docs/.vuepress/enhanceApp.js 文件里添加如下内容：\n\nimport LastReadingPopup from \'./components/LastReadingPopup.vue\'\n\nexport default ({\n  Vue, // VuePress 正在使用的 Vue 构造函数\n  options, // 附加到根实例的一些选项\n  router, // 当前应用的路由实例\n  siteData, // 站点元数据\n  isServer // 当前应用配置是处于 服务端渲染 或 客户端\n}) => {\n  // 判断是否绑定时间是否绑定成功\n  let isMounted = false;\n  // 最后一次阅读位置跳转\n  Vue.component(LastReadingPopup.name, LastReadingPopup);\n  Vue.mixin({\n    // 有多少个 Vue 组件（md 文档），就执行多少次 mounted()，所以利用 if 判断只允许执行一次\n    mounted() {\n      if (!isMounted) {\n        window.addEventListener(\'unload\', this.saveLastReading);  // 卸载窗口前，将数据存储，方便下次可以直接跳转位置\n        isMounted = true;\n      }\n    },\n    methods: {\n      saveLastReading() {\n        localStorage.setItem(\'lastReading\', JSON.stringify({\n          path: this.$route.path,\n          scrollTop: document.documentElement.scrollTop,\n          timestamp: new Date().getTime(),\n        }))\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 本地插件配置\n\n添加插件配置，在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globalUIComponents: ["LastReadingPopup"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from \'vuepress/config\'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobalUIComponents: ["LastReadingPopup"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles。\n\n\n# 结束语\n\n添加完三步的代码后，如何测试呢？\n\n首先随便进入一个文章页里，然后关闭浏览器，然后重新打开浏览器访问主页，就会看到右下角出现提示，是否跳转过去。如果重新访问的是原来的文章页，则会自动移到之前的阅读位置。\n\n参考：https://github.com/tolking/vuepress-plugin-last-reading\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n本站实现了一个记住阅读文章的本地插件，方便下次访问本站时，可选择跳转曾经阅读的文章。\n\n2022-01-04 @du wu\n\n\n\n * 前言\n * 组件添加\n * 路由监听\n * 本地插件配置\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n不需要安装任何插件，只需要在本地添加三段代码即可。\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 文件夹下创建 lastreadingpopup.vue 文件，如果没有 components 文件夹，请创建。\n\n添加如下内容：\n\n<template>\n  <transition name="sw-update-popup">\n    <div v-if="show" class="sw-update-popup">\n      {{ message }}\n\n      <br />\n\n      <button @click="goto">\n        {{ surebuttontext }}\n      </button>\n      <button @click="dontgoto">\n        {{ cancelbuttontext }}\n      </button>\n    </div>\n  </transition>\n</template>\n\n<script>\nexport default {\n  name: "lastreadingpopup",\n\n  data() {\n    return {\n      lastreading: null,\n      show: false,\n    };\n  },\n\n  computed: {\n    popupconfig() {\n      const popupconfig = {\n        "/": {\n          // message: "go back to the last reading.",\n          // buttontext: "go to",\n          message: "检测到您上一次阅读的位置，是否移至该位置？",\n          surebuttontext: "确定",\n          cancelbuttontext: "取消",\n        },\n        "/zh/": {\n          message: "检测到您上一次阅读的位置，是否移至该位置？",\n          surebuttontext: "前往",\n          cancelbuttontext: "取消",\n        },\n      };\n      const lang = this.$lang.split("-")[0];\n      return (\n        popupconfig[`/${lang}/`] || popupconfig[this.$localepath] || popupconfig\n      );\n    },\n    // 提示消息\n    message() {\n      const c = this.popupconfig;\n      return (c && c.message) || c["/"].message;\n    },\n    // 确认按钮\n    surebuttontext() {\n      const c = this.popupconfig;\n      return (c && c.surebuttontext) || c["/"].surebuttontext;\n    },\n    // 取消按钮\n    cancelbuttontext() {\n      const c = this.popupconfig;\n      return (c && c.cancelbuttontext) || c["/"].cancelbuttontext;\n    },\n  },\n\n  // 如果不想使用该文件的效果，注释掉即可 mouted 函数的所有内容即可\n  mounted() {\n    if (!!window.activexobject || "activexobject" in window) {\n      settimeout(() => {\n        window.addeventlistener("load", this.init()); // for ie\n      }, 1000);\n    } else {\n      settimeout(() => {\n        window.addeventlistener("load", this.init);\n      }, 1000);\n    }\n  },\n\n  methods: {\n    init() {\n      this.lastreading = json.parse(localstorage.getitem("lastreading"));\n\n      if (this.lastreading) {\n        if (this.$route.path === this.lastreading.path) {\n          this.goto();\n        } else {\n          this.show = true;\n          10000 && settimeout(this.clean, 10000);\n        }\n      }\n    },\n\n    goto() {\n      if (this.$route.path !== this.lastreading.path) {\n        this.$router.replace(this.lastreading.path).then(() => {\n          document.documentelement.scrolltop = this.lastreading.scrolltop;\n          this.clean();\n        });\n      } else {\n        this.$nexttick(() => {\n          document.documentelement.scrolltop = this.lastreading.scrolltop;\n          // this.clean();\n        });\n      }\n    },\n\n    dontgoto() {\n      this.clean();\n    },\n\n    clean() {\n      this.show = false;\n      localstorage.removeitem("lastreading");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.sw-update-popup {\n  position: fixed;\n  right: 1em;\n  bottom: 1em;\n  padding: 1em;\n  border: 1px solid #3eaf7c;\n  border-radius: 3px;\n  background: #fff;\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);\n  text-align: center;\n  z-index: 12;\n}\n\n.sw-update-popup > button {\n  margin-top: 0.5em;\n  padding: 0.25em 2em;\n}\n\n.sw-update-popup-enter-active,\n.sw-update-popup-leave-active {\n  transition: opacity 0.3s, transform 0.3s;\n}\n\n.sw-update-popup-enter,\n.sw-update-popup-leave-to {\n  opacity: 0;\n  transform: translate(0, 50%) scale(0.5);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\n单语言你可以修改 35 - 37 的代码，多语言则包括了 40 - 42 行代码。\n\n\n# 路由监听\n\n在 docs/.vuepress/enhanceapp.js 文件里添加如下内容：\n\nimport lastreadingpopup from \'./components/lastreadingpopup.vue\'\n\nexport default ({\n  vue, // vuepress 正在使用的 vue 构造函数\n  options, // 附加到根实例的一些选项\n  router, // 当前应用的路由实例\n  sitedata, // 站点元数据\n  isserver // 当前应用配置是处于 服务端渲染 或 客户端\n}) => {\n  // 判断是否绑定时间是否绑定成功\n  let ismounted = false;\n  // 最后一次阅读位置跳转\n  vue.component(lastreadingpopup.name, lastreadingpopup);\n  vue.mixin({\n    // 有多少个 vue 组件（md 文档），就执行多少次 mounted()，所以利用 if 判断只允许执行一次\n    mounted() {\n      if (!ismounted) {\n        window.addeventlistener(\'unload\', this.savelastreading);  // 卸载窗口前，将数据存储，方便下次可以直接跳转位置\n        ismounted = true;\n      }\n    },\n    methods: {\n      savelastreading() {\n        localstorage.setitem(\'lastreading\', json.stringify({\n          path: this.$route.path,\n          scrolltop: document.documentelement.scrolltop,\n          timestamp: new date().gettime(),\n        }))\n      }\n    }\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 本地插件配置\n\n添加插件配置，在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globaluicomponents: ["lastreadingpopup"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from \'vuepress/config\'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobaluicomponents: ["lastreadingpopup"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles。\n\n\n# 结束语\n\n添加完三步的代码后，如何测试呢？\n\n首先随便进入一个文章页里，然后关闭浏览器，然后重新打开浏览器访问主页，就会看到右下角出现提示，是否跳转过去。如果重新访问的是原来的文章页，则会自动移到之前的阅读位置。\n\n参考：https://github.com/tolking/vuepress-plugin-last-reading\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 站点信息模块",frontmatter:{title:"本站 - 站点信息模块",date:"2021-12-30T21:44:18.000Z",permalink:"/about/website/info/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/16.%E6%9C%AC%E7%AB%99%20-%20%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/16.本站 - 站点信息模块.md",key:"v-60ac27e4",path:"/about/website/info/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:62},{level:2,title:"添加meta",slug:"添加meta",normalizedTitle:"添加meta",charIndex:68},{level:2,title:"添加在线图标",slug:"添加在线图标",normalizedTitle:"添加在线图标",charIndex:78},{level:2,title:"Vue模板",slug:"vue模板",normalizedTitle:"vue模板",charIndex:88},{level:2,title:"主题选择",slug:"主题选择",normalizedTitle:"主题选择",charIndex:97},{level:2,title:"在线主题",slug:"在线主题",normalizedTitle:"在线主题",charIndex:105},{level:3,title:"网站信息工具代码",slug:"网站信息工具代码",normalizedTitle:"网站信息工具代码",charIndex:115},{level:3,title:"站点信息代码",slug:"站点信息代码",normalizedTitle:"站点信息代码",charIndex:129},{level:3,title:"站点信息配置",slug:"站点信息配置",normalizedTitle:"站点信息配置",charIndex:141},{level:2,title:"本地主题",slug:"本地主题",normalizedTitle:"本地主题",charIndex:151},{level:3,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:161},{level:3,title:"Vue组件创建",slug:"vue组件创建",normalizedTitle:"vue组件创建",charIndex:170},{level:3,title:"Vue组件引用",slug:"vue组件引用",normalizedTitle:"vue组件引用",charIndex:183},{level:3,title:"核心配置文件",slug:"核心配置文件",normalizedTitle:"核心配置文件",charIndex:196},{level:3,title:"配置站点信息",slug:"配置站点信息",normalizedTitle:"配置站点信息",charIndex:208},{level:2,title:"属性配置",slug:"属性配置",normalizedTitle:"属性配置",charIndex:218},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:226}],headersStr:"前言 添加meta 添加在线图标 Vue模板 主题选择 在线主题 网站信息工具代码 站点信息代码 站点信息配置 本地主题 工具类 Vue组件创建 Vue组件引用 核心配置文件 配置站点信息 属性配置 结束语",content:'笔记\n\n本内容介绍如何搭建本站首页的站点信息，以及每篇文章的浏览量统计。\n\n2021-12-30 @Du Wu\n\n\n\n * 前言\n * 添加meta\n * 添加在线图标\n * Vue模板\n * 主题选择\n * 在线主题\n   * 网站信息工具代码\n   * 站点信息代码\n   * 站点信息配置\n * 本地主题\n   * 工具类\n   * Vue组件创建\n   * Vue组件引用\n   * 核心配置文件\n   * 配置站点信息\n * 属性配置\n * 结束语\n\n\n\n\n# 前言\n\n本内容将在首页和每篇的文章页加入了一些元素，目前适用版本是 Vdoing v1.x。\n\n> 如果你想集成到其他 Vuepress 主题，那么要添加卡片样式，修改挂载元素即可（建议先按照步骤完成一次再考虑集成）。\n> \n>  * 为什么添加卡片样式？本模块的站点信息是基于 Vdoing 自带的卡片样式，模块并没有添加任何卡片样式，所以想集成到其他主题，则需要参考 Vdoing 卡片样式进行添加，或者按照自己喜欢的样式进行添加\n>  * 为什么修改挂载元素？本模块的挂载元素是基于 Vdoing 标签提供的 class 或 id，而其他主题的标签不一样，所以自行进行调试\n> \n> 本模块的所有 功能 支持大部分 Vuepress 主题，但是如何将所有功能展示到其他主题页面合适的地方，以及展示的样式等 DOM 技术，需要自己适配。\n\n效果如下：\n\n\n\n\n\n本站的访问量和文章的浏览量使用了 不蒜子，本地启动的 localhost 有很多人访问过，但无需担心实际部署后的访问量。\n\n不蒜子官网地址\n\n不蒜子文档地址\n\n注意\n\n问题：本模块目前有一个功能依赖于 git 的 lastUpdated 功能，该功能已经内置 Vuepress，所以无需担心，唯一值得注意的是：在本地添加了新的文件，最后活动时间的数据可能为 NaN（无法获取的意思）。\n\n解决：只需要在博客项目部署的过程中执行 git commit 命令，因为该命令将会获取一个准确的时间代替 NaN，给本模块使用。\n\n2022-01-17 @Du Wu\n\n\n# 添加meta\n\n为什么添加 meta 头信息呢，因为在 Chrome 85 版本中，为了保护用户的隐私，默认的 Referrer Policy 则变成了 strict-origin-when-cross-origin。\n\n所以必须添加 meta，否则文章统计访问量的数据则不正确。\n\n在 docs/.vuepress/config.js 下的 head 中添加如下内容：\n\n[\'meta\', { name: \'referrer\', content: \'no-referrer-when-downgrade\' }],\n\n\n1\n\n\n如图：\n\n\n\n\n# 添加在线图标\n\n这里使用的是阿里矢量库。\n\n地址：https://www.iconfont.cn/\n\n添加了五个图标\n\n\n\n如果你不想使用自己的矢量库项目（不害怕我删图标跑路🤣），那么可以使用我的图标项目网址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n在 config.js 下的 head 中文件添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'https://at.alicdn.com/t/font_3077305_pt8umhrn4k9.css\' }]\n\n\n1\n\n\n如图：（图片的内容不一定是最新的，以上方代码块为准）\n\n\n\n\n# Vue模板\n\n这里先提供一个在 Vue 里常用的模板代码，即通用代码（了解即可）：\n\n<template>\n  <div class="busuanzi">\n    <span id="busuanzi_container_site_pv" style="display:none">\n      本站总访问量\n      <span id="busuanzi_value_site_pv"></span>次\n      <span class="post-meta-divider">|</span>\n    </span>\n    <span id="busuanzi_container_site_uv" style="display:none">\n      本站访客数\n      <span id="busuanzi_value_site_uv"></span>人\n    </span>\n  </div>\n</template>\n \n<script>\nlet script;\nexport default {\n  mounted() {\n    script = require("busuanzi.pure.js");\n  },\n  // 监听，当路由发生变化的时候执行\n  watch: {\n    $route(to, from) {\n      if (to.path != from.path) {\n        script.fetch();\n      }\n    }\n  }\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 主题选择\n\n下面有两种配置方式可以选，分别为：\n\n * 在线主题：NPM 主题，采用监听路由、插入式的代码\n * 本地主题：站点信息模块与页面一起渲染出来，没有延迟\n\n本地主题不好的一点就是版本升级后曾修改的内容被重置，所以需要记好修改位置、备份，比较麻烦。好处是根据自己的需求在基础上拓展。\n\n在线主题具有通用性，即在任意环境（如本地主题）都有效果。\n\n\n# 在线主题\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n不管使不使用本地主题，都可以配置在线主题的站点模块。\n\n\n# 网站信息工具代码\n\n添加网站信息需要的计算代码、获取字数代码等工具类。\n\n首先进入 docs/.vuepress 目录，创建 webSiteInfo 文件夹\n\n\n\n然后在 webSiteInfo 目录下创建 busuanzi.js 文件，这个文件用于 获取访问量。\n\nvar bszCaller, bszTag, scriptTag, ready;\n\nvar t,\n  e,\n  n,\n  a = !1,\n  c = [];\n\n// 修复Node同构代码的问题\nif (typeof document !== "undefined") {\n  (ready = function (t) {\n    return (\n      a ||\n      "interactive" === document.readyState ||\n      "complete" === document.readyState\n        ? t.call(document)\n        : c.push(function () {\n            return t.call(this);\n          }),\n      this\n    );\n  }),\n    (e = function () {\n      for (var t = 0, e = c.length; t < e; t++) c[t].apply(document);\n      c = [];\n    }),\n    (n = function () {\n      a ||\n        ((a = !0),\n        e.call(window),\n        document.removeEventListener\n          ? document.removeEventListener("DOMContentLoaded", n, !1)\n          : document.attachEvent &&\n            (document.detachEvent("onreadystatechange", n),\n            window == window.top && (clearInterval(t), (t = null))));\n    }),\n    document.addEventListener\n      ? document.addEventListener("DOMContentLoaded", n, !1)\n      : document.attachEvent &&\n        (document.attachEvent("onreadystatechange", function () {\n          /loaded|complete/.test(document.readyState) && n();\n        }),\n        window == window.top &&\n          (t = setInterval(function () {\n            try {\n              a || document.documentElement.doScroll("left");\n            } catch (t) {\n              return;\n            }\n            n();\n          }, 5)));\n}\n\nbszCaller = {\n  fetch: function (t, e) {\n    var n = "BusuanziCallback_" + Math.floor(1099511627776 * Math.random());\n    t = t.replace("=BusuanziCallback", "=" + n);\n    (scriptTag = document.createElement("SCRIPT")),\n      (scriptTag.type = "text/javascript"),\n      (scriptTag.defer = !0),\n      (scriptTag.src = t),\n      document.getElementsByTagName("HEAD")[0].appendChild(scriptTag);\n    window[n] = this.evalCall(e);\n  },\n  evalCall: function (e) {\n    return function (t) {\n      ready(function () {\n        try {\n          e(t),\n            scriptTag &&\n              scriptTag.parentElement &&\n              scriptTag.parentElement.removeChild &&\n              scriptTag.parentElement.removeChild(scriptTag);\n        } catch (t) {\n          console.log(t), bszTag.hides();\n        }\n      });\n    };\n  },\n};\n\nbszTag = {\n  bszs: ["site_pv", "page_pv", "site_uv"],\n  texts: function (n) {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_value_" + t);\n      e && (e.innerHTML = n[t]);\n    });\n  },\n  hides: function () {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_container_" + t);\n      e && (e.style.display = "none");\n    });\n  },\n  shows: function () {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_container_" + t);\n      e && (e.style.display = "inline");\n    });\n  },\n};\n\nexport default () => {\n  bszTag && bszTag.hides();\n  bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", function (t) {\n    bszTag.texts(t), bszTag.shows();\n  })\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n\n\n然后创建 readFile.js 或者 readFile.ts 文件，这个文件用于 统计文章数目 和 网站总字数 等。\n\n添加如下内容：\n\nconst fs = require(\'fs\'); // 文件模块\nconst path = require(\'path\'); // 路径模块\nconst matter = require(\'gray-matter\'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst chalk = require(\'chalk\') // 命令行打印美化\nconst log = console.log\nconst docsRoot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readFileList(excludeFiles = [\'\'], dir = docsRoot, filesList = []) {\n  const files = fs.readdirSync(dir);\n  files.forEach((item, index) => {\n    let filePath = path.join(dir, item);\n    const stat = fs.statSync(filePath);\n    if (!(excludeFiles instanceof Array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludeFiles.forEach((excludeFile) => {\n      if (stat.isDirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludeFile) {\n        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const fileNameArr = path.basename(filePath).split(\'.\')\n          let name = null, type = null;\n          if (fileNameArr.length === 2) { // 没有序号的文件\n            name = fileNameArr[0]\n            type = fileNameArr[1]\n          } else if (fileNameArr.length === 3) { // 有序号的文件\n            name = fileNameArr[1]\n            type = fileNameArr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            filesList.push({\n              name,\n              filePath\n            });\n          }\n        }\n      }\n    });\n  });\n  return filesList;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readTotalFileWords(excludeFiles = [\'\']) {\n  const filesList = readFileList(excludeFiles);\n  var wordCount = 0;\n  filesList.forEach((item) => {\n    const content = getContent(item.filePath);\n    var len = counter(content);\n    wordCount += len[0] + len[1];\n  });\n  if (wordCount < 1000) {\n    return wordCount;\n  }\n  return Math.round(wordCount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readEachFileWords(excludeFiles = [\'\'], cn, en) {\n  const filesListWords = [];\n  const filesList = readFileList(excludeFiles);\n  filesList.forEach((item) => {\n    const content = getContent(item.filePath);\n    var len = counter(content);\n    // 计算预计的阅读时间\n    var readingTime = readTime(len, cn, en);\n    var wordsCount = 0;\n    wordsCount = len[0] + len[1];\n    if (wordsCount >= 1000) {\n      wordsCount = Math.round(wordsCount / 100) / 10 + \'k\';\n    }\n    // fileMatterObj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const fileMatterObj = matter(content, {});\n    const matterData = fileMatterObj.data;\n    filesListWords.push({ ...item, wordsCount, readingTime, ...matterData });\n  });\n  return filesListWords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readTime(len, cn = 300, en = 160) {\n  var readingTime = len[0] / cn + len[1] / en;\n  if (readingTime > 60 && readingTime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = parseInt(readingTime / 60);\n    let minute = parseInt((readingTime - hour * 60));\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingTime > 60 * 24) {      // 大于一天\n    let day = parseInt(readingTime / (60 * 24));\n    let hour = parseInt((readingTime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingTime < 1 ? \'1\' : parseInt((readingTime * 10)) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getContent(filePath) {\n  return fs.readFileSync(filePath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content) {\n  const cn = (content.match(/[\\u4E00-\\u9FA5]/g) || []).length;\n  const en = (content.replace(/[\\u4E00-\\u9FA5]/g, \'\').match(/[a-zA-Z0-9_\\u0392-\\u03c9\\u0400-\\u04FF]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|[\\u00E4\\u00C4\\u00E5\\u00C5\\u00F6\\u00D6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nmodule.exports = {\n  readFileList,\n  readTotalFileWords,\n  readEachFileWords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\nimport fs from \'fs\'; // 文件模块\nimport path from \'path\'; // 路径模块\nimport matter from \'gray-matter\'; // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nimport chalk from \'chalk\' // 命令行打印美化\nconst log = console.log\nconst docsRoot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readFileList(excludeFiles: Array<string> = [\'\'], dir: string = docsRoot, filesList: Array<Object> = []) {\n  const files = fs.readdirSync(dir);\n  files.forEach((item, index) => {\n    let filePath = path.join(dir, item);\n    const stat = fs.statSync(filePath);\n    if (!(excludeFiles instanceof Array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludeFiles.forEach((excludeFile) => {\n      if (stat.isDirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludeFile) {\n        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const fileNameArr = path.basename(filePath).split(\'.\')\n          let name = null, type = null;\n          if (fileNameArr.length === 2) { // 没有序号的文件\n            name = fileNameArr[0]\n            type = fileNameArr[1]\n          } else if (fileNameArr.length === 3) { // 有序号的文件\n            name = fileNameArr[1]\n            type = fileNameArr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            filesList.push({\n              name,\n              filePath\n            });\n          }\n        }\n      }\n    });\n  });\n  return filesList;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readTotalFileWords(excludeFiles = [\'\']) {\n  const filesList = readFileList(excludeFiles);\n  let wordCount = 0;\n  filesList.forEach((item: any) => {\n    const content = getContent(item.filePath);\n    let len = counter(content);\n    wordCount += len[0] + len[1];\n  });\n  if (wordCount < 1000) {\n    return wordCount;\n  }\n  return Math.round(wordCount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readEachFileWords(excludeFiles: Array<string> = [\'\'], cn: number, en: number) {\n  const filesListWords = [];\n  const filesList = readFileList(excludeFiles);\n  filesList.forEach((item: any) => {\n    const content = getContent(item.filePath);\n    let len = counter(content);\n    // 计算预计的阅读时间\n    let readingTime = readTime(len, cn, en);\n    let wordsCount: any = 0;\n    wordsCount = len[0] + len[1];\n    if (wordsCount >= 1000) {\n      wordsCount = Math.round(wordsCount / 100) / 10 + \'k\';\n    }\n    // fileMatterObj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const fileMatterObj = matter(content, {});\n    const matterData = fileMatterObj.data;\n    filesListWords.push({ ...item, wordsCount, readingTime, ...matterData });\n  });\n  return filesListWords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readTime(len: Array<number>, cn: number = 300, en: number = 160) {\n  let readingTime = len[0] / cn + len[1] / en;\n  if (readingTime > 60 && readingTime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = Math.trunc(readingTime / 60);\n    let minute = Math.trunc(readingTime - hour * 60);\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingTime > 60 * 24) {      // 大于一天\n    let day = Math.trunc(readingTime / (60 * 24));\n    let hour = Math.trunc((readingTime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingTime < 1 ? \'1\' : Math.trunc(readingTime * 10) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getContent(filePath: string) {\n  return fs.readFileSync(filePath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content: string) {\n  const cn = (content.match(/[\\u4E00-\\u9FA5]/g) || []).length;\n  const en = (content.replace(/[\\u4E00-\\u9FA5]/g, \'\').match(/[a-zA-Z0-9_\\u0392-\\u03c9\\u0400-\\u04FF]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|[\\u00E4\\u00C4\\u00E5\\u00C5\\u00F6\\u00D6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nexport {\n  readFileList,\n  readTotalFileWords,\n  readEachFileWords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n接着继续在该目录下创建第三个文件 utils.js，该文件用于计算 已运行时间 和 最后活动时间。\n\n添加如下内容：\n\n// 日期格式化(只获取年月日)\nexport function dateFormat(date) {\n  if (!(date instanceof Date)) {\n    date = new Date(date);\n  }\n  return `${date.getUTCFullYear()}-${zero(date.getUTCMonth() + 1)}-${zero(date.getUTCDate())}`;\n}\n\n// 小于10补0\nexport function zero(d) {\n  return d.toString().padStart(2, \'0\');\n}\n\n/**\n * 计算最后活动时间\n */\nexport function lastUpdatePosts(posts) {\n  posts.sort((prev, next) => {\n    return compareDate(prev, next);\n  });\n  return posts;\n}\n\n// 获取时间的时间戳\nexport function getTimeNum(post) {\n  let dateStr = post.lastUpdated || post.frontmatter.date;\n  let date = new Date(dateStr);\n  if (date == "Invalid Date" && dateStr) { // 修复new Date()在Safari下出现Invalid Date的问题\n    date = new Date(dateStr.replace(/-/g, \'/\'));\n  }\n  return date.getTime();\n}\n\n// 比对时间\nexport function compareDate(a, b) {\n  return getTimeNum(b) - getTimeNum(a);\n}\n\n/**\n * 获取两个日期相差多少天\n */\nexport function dayDiff(startDate, endDate) {\n  if (!endDate) {\n    endDate = startDate;\n    startDate = new Date();\n  }\n  startDate = dateFormat(startDate);\n  endDate = dateFormat(endDate);\n  let day = parseInt(Math.abs(new Date(startDate) - new Date(endDate)) / (1000 * 60 * 60 * 24));\n  return day;\n}\n\n/**\n * 计算相差多少年/月/日/时/分/秒\n */\nexport function timeDiff(startDate, endDate) {\n  if (!endDate) {\n    endDate = startDate;\n    startDate = new Date();\n  }\n  if (!(startDate instanceof Date)) {\n    startDate = new Date(startDate);\n  }\n  if (!(endDate instanceof Date)) {\n    endDate = new Date(endDate);\n  }\n  // 计算时间戳的差\n  const diffValue = parseInt((Math.abs(endDate - startDate) / 1000));\n  if (diffValue == 0) {\n    return \'刚刚\';\n  } else if (diffValue < 60) {\n    return diffValue + \' 秒\';\n  } else if (parseInt(diffValue / 60) < 60) {\n    return parseInt(diffValue / 60) + \' 分\';\n  } else if (parseInt(diffValue / (60 * 60)) < 24) {\n    return parseInt(diffValue / (60 * 60)) + \' 时\';\n  } else if (parseInt(diffValue / (60 * 60 * 24)) < getDays(startDate.getMonth, startDate.getFullYear)) {\n    return parseInt(diffValue / (60 * 60 * 24)) + \' 天\';\n  } else if (parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) < 12) {\n    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) + \' 月\';\n  } else {\n    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear) * 12)) + \' 年\';\n  }\n}\n\n/**\n * 判断当前月的天数（28、29、30、31）\n */\nexport function getDays(mouth, year) {\n  let days = 30;\n  if (mouth === 2) {\n    days = year % 4 === 0 ? 29 : 28;\n  } else if (mouth === 1 || mouth === 3 || mouth === 5 || mouth === 7 || mouth === 8 || mouth === 10 || mouth === 12) {\n    // 月份为：1,3,5,7,8,10,12 时，为大月.则天数为 31；\n    days = 31;\n  }\n  return days;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n目前就三个文件，最终效果如图：\n\n\n\n\n# 站点信息代码\n\n这一步的文件目录不能随便移动，因为该目录是 Vuepress 规定的。\n\n首先进入 docs/.vuepress 目录，创建 components 文件夹\n\n\n\n创建一个 vue 文件：WebInfo.vue，这就是首页的站点信息模块。\n\n并添加如下内容：\n\n<template>\n  \x3c!-- Young Kbt --\x3e\n  <div class="web-info card-box">\n    <div class="webinfo-title">\n      <i\n        class="iconfont icon-award"\n        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"\n      ></i>\n      <span>站点信息</span>\n    </div>\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">文章数目：</div>\n      <div class="webinfo-content">{{ mdFileCount }} 篇</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">已运行时间：</div>\n      <div class="webinfo-content">\n        {{ createToNowDay != 0 ? createToNowDay + " 天" : "不到一天" }}\n      </div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">本站总字数：</div>\n      <div class="webinfo-content">{{ totalWords }} 字</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">最后活动时间：</div>\n      <div class="webinfo-content">\n        {{ lastActiveDate == "刚刚" ? "刚刚" : lastActiveDate + "前" }}\n      </div>\n    </div>\n\n    <div v-if="indexView" class="webinfo-item">\n      <div class="webinfo-item-title">本站被访问了：</div>\n      <div class="webinfo-content">\n        <span id="busuanzi_value_site_pv" class="web-site-pv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        次\n      </div>\n    </div>\n\n    <div v-if="indexView" class="webinfo-item">\n      <div class="webinfo-item-title">您的访问排名：</div>\n      <div class="webinfo-content busuanzi">\n        <span id="busuanzi_value_site_uv" class="web-site-uv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        名\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { dayDiff, timeDiff, lastUpdatePosts } from "../webSiteInfo/utils";\nimport fetch from "../webSiteInfo/busuanzi"; // 统计量\nexport default {\n  data() {\n    return {\n      // Young Kbt\n      mdFileCount: 0, // markdown 文档总数\n      createToNowDay: 0, // 博客创建时间距今多少天\n      lastActiveDate: "", // 最后活动时间\n      totalWords: 0, // 本站总字数\n      indexView: true, // 开启访问量和排名统计\n    };\n  },\n  computed: {\n    $lastUpdatePosts() {\n      return lastUpdatePosts(this.$filterPosts);\n    },\n  },\n  mounted() {\n    // Young Kbt\n    if (Object.keys(this.$themeConfig.blogInfo).length > 0) {\n      const {\n        blogCreate,\n        mdFileCountType,\n        totalWords,\n        moutedEvent,\n        eachFileWords,\n        indexIteration,\n        indexView,\n      } = this.$themeConfig.blogInfo;\n      this.createToNowDay = dayDiff(blogCreate);\n      if (mdFileCountType != "archives") {\n        this.mdFileCount = mdFileCountType.length;\n      } else {\n        this.mdFileCount = this.$filterPosts.length;\n      }\n      if (totalWords == "archives" && eachFileWords) {\n        let archivesWords = 0;\n        eachFileWords.forEach((itemFile) => {\n          if (itemFile.wordsCount < 1000) {\n            archivesWords += itemFile.wordsCount;\n          } else {\n            let wordsCount = itemFile.wordsCount.slice(\n              0,\n              itemFile.wordsCount.length - 1\n            );\n            archivesWords += wordsCount * 1000;\n          }\n        });\n        this.totalWords = Math.round(archivesWords / 100) / 10 + "k";\n      } else if (totalWords == "archives") {\n        this.totalWords = 0;\n        console.log(\n          "如果 totalWords = \'archives\'，必须传入 eachFileWords，显然您并没有传入！"\n        );\n      } else {\n        this.totalWords = totalWords;\n      }\n      // 最后一次活动时间\n      this.lastActiveDate = timeDiff(this.$lastUpdatePosts[0].lastUpdated);\n      this.mountedWebInfo(moutedEvent);\n      // 获取访问量和排名\n      this.indexView = indexView == undefined ? true : indexView;\n      if (this.indexView) {\n        this.getIndexViewCouter(indexIteration);\n      }\n    }\n  },\n  methods: {\n    /**\n     * 挂载站点信息模块\n     */\n    mountedWebInfo(moutedEvent = ".tags-wrapper") {\n      let interval = setInterval(() => {\n        const tagsWrapper = document.querySelector(moutedEvent);\n        const webInfo = document.querySelector(".web-info");\n        if (tagsWrapper && webInfo) {\n          if (!this.isSiblilngNode(tagsWrapper, webInfo)) {\n            tagsWrapper.parentNode.insertBefore(\n              webInfo,\n              tagsWrapper.nextSibling\n            );\n            clearInterval(interval);\n          }\n        }\n      }, 200);\n    },\n    /**\n     * 挂载在兄弟元素后面，说明当前组件是 siblingNode 变量\n     */\n    isSiblilngNode(element, siblingNode) {\n      if (element.siblingNode == siblingNode) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    /**\n     * 首页的统计量\n     */\n    getIndexViewCouter(iterationTime = 3000) {\n      fetch();\n      var i = 0;\n      var defaultCouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 setTimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 setTimeout 的时间（需求调节），setTimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      setTimeout(() => {\n        let indexUv = document.querySelector(".web-site-pv");\n        let indexPv = document.querySelector(".web-site-uv");\n        if (\n          indexPv &&\n          indexUv &&\n          indexPv.innerText == "" &&\n          indexUv.innerText == ""\n        ) {\n          let interval = setInterval(() => {\n            // 再次判断原因：防止进入 setInterval 的瞬间，访问量获取成功\n            if (\n              indexPv &&\n              indexUv &&\n              indexPv.innerText == "" &&\n              indexUv.innerText == ""\n            ) {\n              i += iterationTime;\n              if (i > iterationTime * 5) {\n                indexPv.innerText = defaultCouter;\n                indexUv.innerText = defaultCouter;\n                clearInterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (indexPv.innerText == "" && indexUv.innerText == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearInterval(interval);\n              }\n            } else {\n              clearInterval(interval);\n            }\n          }, iterationTime);\n          // 绑定 beforeDestroy 生命钩子，清除定时器\n          this.$once("hook:beforeDestroy", () => {\n            clearInterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationTime);\n    },\n    beforeMount() {\n      let webInfo = document.querySelector(".web-info");\n      webInfo && webInfo.parentNode.removeChild(webInfo);\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.web-info {\n  font-size: 0.875rem;\n  padding: 0.95rem;\n}\n.webinfo-title {\n  text-align: center;\n  color: #888;\n  font-weight: bold;\n  padding: 0 0 10px 0;\n}\n.webinfo-item {\n  padding: 8px 0 0;\n  margin: 0;\n}\n.webinfo-item-title {\n  display: inline-block;\n}\n.webinfo-content {\n  display: inline-block;\n  float: right;\n}\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n\n\n继续创建一个 vue 文件：PageInfo.vue，这就是文章页的信息模块：文章浏览量、字数代码、预阅读时间。\n\n<template></template>\n\n<script>\nimport fetch from "../webSiteInfo/busuanzi";\nexport default {\n  mounted() {\n    // 首页不初始页面信息\n    if (this.$route.path != "/") {\n      this.initPageInfo();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 如果页面是非首页，# 号也会触发路由变化，这里要排除掉\n      if (\n        to.path !== "/" &&\n        to.path !== from.path &&\n        this.$themeConfig.blogInfo\n      ) {\n        this.initPageInfo();\n      }\n    },\n  },\n  methods: {\n    /**\n     * 初始化页面信息\n     */\n    initPageInfo() {\n      if (this.$frontmatter.article == undefined || this.$frontmatter.article) {\n        // 排除掉 article 为 false 的文章\n        const { eachFileWords, pageView, pageIteration, readingTime } =\n          this.$themeConfig.blogInfo;\n        // 下面两个 if 可以调换位置，从而让文章的浏览量和字数交换位置\n        if (eachFileWords) {\n          try {\n            eachFileWords.forEach((itemFile) => {\n              if (itemFile.permalink == this.$frontmatter.permalink) {\n                // this.addPageWordsCount 和 if 可以调换位置，从而让文章的字数和预阅读时间交换位置\n                this.addPageWordsCount(itemFile.wordsCount);\n                if (readingTime || readingTime == undefined) {\n                  this.addReadTimeCount(itemFile.readingTime);\n                }\n                throw new Error();\n              }\n            });\n          } catch (error) {}\n        }\n        if (pageView || pageView == undefined) {\n          this.addPageView();\n          this.getPageViewCouter(pageIteration);\n        }\n        return;\n      }\n    },\n    /**\n     * 文章页的访问量\n     */\n    getPageViewCouter(iterationTime = 3000) {\n      fetch();\n      let i = 0;\n      var defaultCouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 setTimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 setTimeout 的时间（需求调节），setTimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      setTimeout(() => {\n        let pageView = document.querySelector(".view-data");\n        if (pageView && pageView.innerText == "") {\n          let interval = setInterval(() => {\n            // 再次判断原因：防止进入 setInterval 的瞬间，访问量获取成功\n            if (pageView && pageView.innerText == "") {\n              i += iterationTime;\n              if (i > iterationTime * 5) {\n                pageView.innerText = defaultCouter;\n                clearInterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (pageView.innerText == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearInterval(interval);\n              }\n            } else {\n              clearInterval(interval);\n            }\n          }, iterationTime);\n          // 绑定 beforeDestroy 生命钩子，清除定时器\n          this.$once("hook:beforeDestroy", () => {\n            clearInterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationTime);\n    },\n    /**\n     * 添加浏览量元素\n     */\n    addPageView() {\n      let pageView = document.querySelector(".page-view");\n      if (pageView) {\n        pageView.innerHTML =\n          \'<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>\';\n      } else {\n        // 创建访问量的元素\n        let template = document.createElement("div");\n        template.title = "浏览量";\n        template.className = "page-view iconfont icon-view";\n        template.style.float = "left";\n        template.style.marginLeft = "20px";\n        template.style.fontSize = "0.8rem";\n        template.innerHTML =\n          \'<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>\';\n        // 添加 loading 效果\n        let style = document.createElement("style");\n        style.innerHTML = `@keyframes turn {\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n      }\n      .loading {\n        display: inline-block;\n        animation: turn 1s linear infinite;\n        -webkit-animation: turn 1s linear infinite;\n      }`;\n        document.head.appendChild(style);\n        this.mountedView(template);\n      }\n    },\n    /**\n     * 添加当前文章页的字数元素\n     */\n    addPageWordsCount(wordsCount = 0) {\n      let words = document.querySelector(".book-words");\n      if (words) {\n        words.innerHTML = `<a href="javascript:;" style="margin-left: 3px; color: #888">${wordsCount}</a>`;\n      } else {\n        let template = document.createElement("div");\n        template.title = "文章字数";\n        template.className = "book-words iconfont icon-book";\n        template.style.float = "left";\n        template.style.marginLeft = "20px";\n        template.style.fontSize = "0.8rem";\n\n        template.innerHTML = `<a href="javascript:;" style="margin-left: 3px; color: #888">${wordsCount}</a>`;\n        this.mountedView(template);\n      }\n    },\n    /**\n     * 添加预计的阅读时间\n     */\n    addReadTimeCount(readTimeCount = 0) {\n      let reading = document.querySelector(".reading-time");\n      if (reading) {\n        reading.innerHTML = `<a href="javascript:;" style="margin-left: 3px; color: #888">${readTimeCount}</a>`;\n      } else {\n        let template = document.createElement("div");\n        template.title = "预阅读时长";\n        template.className = "reading-time iconfont icon-shijian";\n        template.style.float = "left";\n        template.style.marginLeft = "20px";\n        template.style.fontSize = "0.8rem";\n        template.innerHTML = `<a href="javascript:;" style="margin-left: 3px; color: #888">${readTimeCount}</a>`;\n        this.mountedView(template);\n      }\n    },\n    /**\n     * 挂载目标到页面上\n     */\n    mountedView(\n      template,\n      mountedIntervalTime = 100,\n      moutedParentEvent = ".articleInfo-wrap > .articleInfo > .info"\n    ) {\n      let i = 0;\n      let parentElement = document.querySelector(moutedParentEvent);\n      if (parentElement) {\n        if (!this.isMountedView(template, parentElement)) {\n          parentElement.appendChild(template);\n        }\n      } else {\n        let interval = setInterval(() => {\n          parentElement = document.querySelector(moutedParentEvent);\n          if (parentElement) {\n            if (!this.isMountedView(template, parentElement)) {\n              parentElement.appendChild(template);\n              clearInterval(interval);\n            }\n          } else if (i > 1 * 10) {\n            // 10 秒后清除\n            clearInterval(interval);\n          }\n        }, mountedIntervalTime);\n        // 绑定 beforeDestroy 生命钩子，清除定时器\n        this.$once("hook:beforeDestroy", () => {\n          clearInterval(interval);\n          interval = null;\n        });\n      }\n    },\n    /**\n     * 如果元素存在，则删除\n     */\n    removeElement(selector) {\n      var element = document.querySelector(selector);\n      element && element.parentNode.removeChild(element);\n    },\n    /**\n     * 目标是否已经挂载在页面上\n     */\n    isMountedView(element, parentElement) {\n      if (element.parentNode == parentElement) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n  },\n  // 防止重写编译时，导致页面信息重复出现问题\n  beforeMount() {\n    clearInterval(this.interval);\n    this.removeElement(".page-view");\n    this.removeElement(".book-words");\n    this.removeElement(".reading-time");\n  },\n};\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n\n\n最终效果如图：\n\n\n\n创建好了两个 vue 组件，我们需要使用它们。\n\n> 使用 WebInfo.vue 组件\n\n打开 docs/index.md\n\n\n\n移到最下方，添加如下内容：\n\n<ClientOnly>\n  <WebInfo/>\n</ClientOnly>\n\n\n1\n2\n3\n\n\n> 使用 PageInfo.vue 组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加配置。\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globalUIComponents: ["PageInfo"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n        }\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from \'vuepress/config\'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobalUIComponents: ["PageInfo"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 站点信息配置\n\n上面都按照步骤写好代码、使用组件了，那么就可以走最后一步配置我们的站点信息。\n\n进入到 docs/.vuepress/config.js（新版为 config.ts）文件。\n\n引入之前写好的工具代码文件：（路径要准确，这里仅仅是模板）\n\nconst { readFileList, readTotalFileWords, readEachFileWords } = require(\'./webSiteInfo/readFile\');\n\n\n1\n\n\nimport { readFileList, readTotalFileWords, readEachFileWords } from \'./webSiteInfo/readFile\';\n\n\n1\n\n\n如图（演示 JS 代码块）：\n\n\n\n在 themeConfig 中添加如下内容：\n\n// 站点配置（首页 & 文章页）\nblogInfo: {\n  blogCreate: \'2021-10-19\', // 博客创建时间\n  indexView: true,  // 开启首页的访问量和排名统计，默认 true（开启）\n  pageView: true,  // 开启文章页的浏览量统计，默认 true（开启）\n  readingTime: true,  // 开启文章页的预计阅读时间，条件：开启 eachFileWords，默认 true（开启）。可在 eachFileWords 的 readEachFileWords 的第二个和第三个参数自定义，默认 1 分钟 300 中文、160 英文\n  eachFileWords: readEachFileWords([\'\'], 300, 160),  // 开启每个文章页的字数。readEachFileWords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数。无默认值。readEachFileWords() 方法默认排除了 article 为 false 的文章\n  mdFileCountType: \'archives\',  // 开启文档数。1. archives 获取归档的文档数（默认）。2. 数组 readFileList([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文档数。提示：readFileList() 获取 docs 下所有的 md 文档（除了 `.vuepress` 和 `@pages` 目录下的文档）\n  totalWords: \'archives\',  // 开启本站文档总字数。1. archives 获取归档的文档数（使用 archives 条件：传入 eachFileWords，否则报错）。2. readTotalFileWords([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数。无默认值\n  moutedEvent: \'.tags-wrapper\',   // 首页的站点模块挂载在某个元素后面（支持多种选择器），指的是挂载在哪个兄弟元素的后面，默认是热门标签 \'.tags-wrapper\' 下面，提示：\'.categories-wrapper\' 会挂载在文章分类下面。\'.blogger-wrapper\' 会挂载在博客头像模块下面\n  // 下面两个选项：第一次获取访问量失败后的迭代时间\n  indexIteration: 2500,   // 如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  pageIteration: 2500,    // 如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  // 说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如图（图片内容不一定是最新，最新的是代码块内容）：\n\n\n\n属性配置的具体介绍请看 属性配置。\n\n\n# 本地主题\n\n如果已经看完了在线主题的内容，其实本内容的大小不变，只是位置变换、一些代码重组。\n\n配置了在线主题，就不需要配置本地主题，反之亦然。\n\n\n# 工具类\n\n在 vdoing/util 目录下创建 webSiteInfo.js，添加如下内容：\n\n// 日期格式化(只获取年月日)\nexport function dateFormat(date) {\n  if (!(date instanceof Date)) {\n    date = new Date(date);\n  }\n  return `${date.getUTCFullYear()}-${zero(date.getUTCMonth() + 1)}-${zero(date.getUTCDate())}`;\n}\n\n// 小于10补0\nexport function zero(d) {\n  return d.toString().padStart(2, \'0\');\n}\n\n/**\n * 计算最后活动时间\n */\nexport function lastUpdatePosts(posts) {\n  posts.sort((prev, next) => {\n    return compareDate(prev, next);\n  });\n  return posts;\n}\n\n// 获取时间的时间戳\nexport function getTimeNum(post) {\n  let dateStr = post.lastUpdated || post.frontmatter.date;\n  let date = new Date(dateStr);\n  if (date == "Invalid Date" && dateStr) { // 修复new Date()在Safari下出现Invalid Date的问题\n    date = new Date(dateStr.replace(/-/g, \'/\'));\n  }\n  return date.getTime();\n}\n\n// 比对时间\nexport function compareDate(a, b) {\n  return getTimeNum(b) - getTimeNum(a);\n}\n\n/**\n * 获取两个日期相差多少天\n */\nexport function dayDiff(startDate, endDate) {\n  if (!endDate) {\n    endDate = startDate;\n    startDate = new Date();\n  }\n  startDate = dateFormat(startDate);\n  endDate = dateFormat(endDate);\n  let day = parseInt(Math.abs(new Date(startDate) - new Date(endDate)) / (1000 * 60 * 60 * 24));\n  return day;\n}\n\n/**\n * 计算相差多少年/月/日/时/分/秒\n */\nexport function timeDiff(startDate, endDate) {\n  if (!endDate) {\n    endDate = startDate;\n    startDate = new Date();\n  }\n  if (!(startDate instanceof Date)) {\n    startDate = new Date(startDate);\n  }\n  if (!(endDate instanceof Date)) {\n    endDate = new Date(endDate);\n  }\n  // 计算时间戳的差\n  const diffValue = parseInt((Math.abs(endDate - startDate) / 1000));\n  if (diffValue == 0) {\n    return \'刚刚\';\n  } else if (diffValue < 60) {\n    return diffValue + \' 秒\';\n  } else if (parseInt(diffValue / 60) < 60) {\n    return parseInt(diffValue / 60) + \' 分\';\n  } else if (parseInt(diffValue / (60 * 60)) < 24) {\n    return parseInt(diffValue / (60 * 60)) + \' 时\';\n  } else if (parseInt(diffValue / (60 * 60 * 24)) < getDays(startDate.getMonth, startDate.getFullYear)) {\n    return parseInt(diffValue / (60 * 60 * 24)) + \' 天\';\n  } else if (parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) < 12) {\n    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear))) + \' 月\';\n  } else {\n    return parseInt(diffValue / (60 * 60 * 24 * getDays(startDate.getMonth, startDate.getFullYear) * 12)) + \' 年\';\n  }\n}\n\n/**\n * 判断当前月的天数（28、29、30、31）\n */\nexport function getDays(mouth, year) {\n  let days = 30;\n  if (mouth === 2) {\n    days = year % 4 === 0 ? 29 : 28;\n  } else if (mouth === 1 || mouth === 3 || mouth === 5 || mouth === 7 || mouth === 8 || mouth === 10 || mouth === 12) {\n    // 月份为：1,3,5,7,8,10,12 时，为大月.则天数为 31；\n    days = 31;\n  }\n  return days;\n}\n\n/**\n * 已运行时间低于一天显示时分秒\n * 目前该函数没有使用，低于一天直接显示不到一天\n */\nexport function getTime(startDate, endDate) {\n  if (day < 0) {\n    let hour = parseInt(Math.abs(new Date(startDate) - new Date(endDate)) / (1000 * 60 * 60));\n    if (hour > 0) {\n      let minute = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000) / (1000 * 60));\n      if (minute > 0) {\n        let second = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));\n        if (second != 0) {\n          return hour + \' 小时 \' + minute + \' 分钟 \' + second + \' 秒\';\n        } else {\n          return hour + \' 小时 \' + minute + \' 分钟 \';\n        }\n      } else {\n        return hour + \' 小时 \';\n      }\n    } else {\n      let minute = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000) / (1000 * 60));\n      if (minute > 0) {\n        let second = parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));\n        if (second != 0) {\n          return + minute + \' 分钟 \' + second + \' 秒\';\n        } else {\n          return minute + \' 分钟 \';\n        }\n      } else {\n        return parseInt(Math.abs(new Date(startDate) - new Date(endDate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000)) + \' 秒 \';\n      }\n    }\n  }\n}\n\nvar bszCaller, bszTag, scriptTag, ready;\n\nvar t,\n  e,\n  n,\n  a = !1,\n  c = [];\n\n// 修复Node同构代码的问题\nif (typeof document !== "undefined") {\n  (ready = function (t) {\n    return (\n      a ||\n      "interactive" === document.readyState ||\n      "complete" === document.readyState\n        ? t.call(document)\n        : c.push(function () {\n            return t.call(this);\n          }),\n      this\n    );\n  }),\n    (e = function () {\n      for (var t = 0, e = c.length; t < e; t++) c[t].apply(document);\n      c = [];\n    }),\n    (n = function () {\n      a ||\n        ((a = !0),\n        e.call(window),\n        document.removeEventListener\n          ? document.removeEventListener("DOMContentLoaded", n, !1)\n          : document.attachEvent &&\n            (document.detachEvent("onreadystatechange", n),\n            window == window.top && (clearInterval(t), (t = null))));\n    }),\n    document.addEventListener\n      ? document.addEventListener("DOMContentLoaded", n, !1)\n      : document.attachEvent &&\n        (document.attachEvent("onreadystatechange", function () {\n          /loaded|complete/.test(document.readyState) && n();\n        }),\n        window == window.top &&\n          (t = setInterval(function () {\n            try {\n              a || document.documentElement.doScroll("left");\n            } catch (t) {\n              return;\n            }\n            n();\n          }, 5)));\n}\n\nbszCaller = {\n  fetch: function (t, e) {\n    var n = "BusuanziCallback_" + Math.floor(1099511627776 * Math.random());\n    t = t.replace("=BusuanziCallback", "=" + n);\n    (scriptTag = document.createElement("SCRIPT")),\n      (scriptTag.type = "text/javascript"),\n      (scriptTag.defer = !0),\n      (scriptTag.src = t),\n      document.getElementsByTagName("HEAD")[0].appendChild(scriptTag);\n    window[n] = this.evalCall(e);\n  },\n  evalCall: function (e) {\n    return function (t) {\n      ready(function () {\n        try {\n          e(t),\n            scriptTag &&\n              scriptTag.parentElement &&\n              scriptTag.parentElement.removeChild &&\n              scriptTag.parentElement.removeChild(scriptTag);\n        } catch (t) {\n          console.log(t), bszTag.hides();\n        }\n      });\n    };\n  },\n};\n\nexport function fetch() {\n  bszTag && bszTag.hides();\n  bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", function (t) {\n    bszTag.texts(t), bszTag.shows();\n  })\n};\n\nbszTag = {\n  bszs: ["site_pv", "page_pv", "site_uv"],\n  texts: function (n) {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_value_" + t);\n      e && (e.innerHTML = n[t]);\n    });\n  },\n  hides: function () {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_container_" + t);\n      e && (e.style.display = "none");\n    });\n  },\n  shows: function () {\n    this.bszs.map(function (t) {\n      var e = document.getElementById("busuanzi_container_" + t);\n      e && (e.style.display = "inline");\n    });\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n\n\n\n# Vue组件创建\n\n需要两个 Vue 组件，分别是首页的站点信息模块和文章页信息模块。\n\n在 vdoing/components 目录下创建 WebInfo.vue 文件，添加如下内容：\n\n<template>\n  \x3c!-- Young Kbt --\x3e\n  <div class="web-info card-box">\n    <div class="webinfo-title">\n      <i\n        class="iconfont icon-award"\n        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"\n      ></i>\n      <span>站点信息</span>\n    </div>\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">文章数目：</div>\n      <div class="webinfo-content">{{ mdFileCount }} 篇</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">已运行时间：</div>\n      <div class="webinfo-content">\n        {{ createToNowDay != 0 ? createToNowDay + " 天" : "不到一天" }}\n      </div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">本站总字数：</div>\n      <div class="webinfo-content">{{ totalWords }} 字</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">最后活动时间：</div>\n      <div class="webinfo-content">\n        {{ lastActiveDate == "刚刚" ? "刚刚" : lastActiveDate + "前" }}\n      </div>\n    </div>\n\n    <div v-if="indexView" class="webinfo-item">\n      <div class="webinfo-item-title">本站被访问了：</div>\n      <div class="webinfo-content">\n        <span id="busuanzi_value_site_pv" class="web-site-pv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        次\n      </div>\n    </div>\n\n    <div v-if="indexView" class="webinfo-item">\n      <div class="webinfo-item-title">您的访问排名：</div>\n      <div class="webinfo-content busuanzi">\n        <span id="busuanzi_value_site_uv" class="web-site-uv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        名\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { dayDiff, timeDiff, lastUpdatePosts, fetch } from "../util/webSiteInfo";\nexport default {\n  data() {\n    return {\n      // Young Kbt\n      mdFileCount: 0, // markdown 文档总数\n      createToNowDay: 0, // 博客创建时间距今多少天\n      lastActiveDate: "", // 最后活动时间\n      totalWords: 0, // 本站总字数\n      indexView: true, // 开启访问量和排名统计\n    };\n  },\n  computed: {\n    $lastUpdatePosts() {\n      return lastUpdatePosts(this.$filterPosts);\n    },\n  },\n  mounted() {\n    // Young Kbt\n    if (Object.keys(this.$themeConfig.blogInfo).length > 0) {\n      const {\n        blogCreate,\n        mdFileCountType,\n        totalWords,\n        moutedEvent,\n        eachFileWords,\n        indexIteration,\n        indexView,\n      } = this.$themeConfig.blogInfo;\n      this.createToNowDay = dayDiff(blogCreate);\n      if (mdFileCountType != "archives") {\n        this.mdFileCount = mdFileCountType.length;\n      } else {\n        this.mdFileCount = this.$filterPosts.length;\n      }\n      if (totalWords == "archives" && eachFileWords) {\n        let archivesWords = 0;\n        eachFileWords.forEach((itemFile) => {\n          if (itemFile.wordsCount < 1000) {\n            archivesWords += itemFile.wordsCount;\n          } else {\n            let wordsCount = itemFile.wordsCount.slice(\n              0,\n              itemFile.wordsCount.length - 1\n            );\n            archivesWords += wordsCount * 1000;\n          }\n        });\n        this.totalWords = Math.round(archivesWords / 100) / 10 + "k";\n      } else if (totalWords == "archives") {\n        this.totalWords = 0;\n        console.log(\n          "如果 totalWords = \'archives\'，必须传入 eachFileWords，显然您并没有传入！"\n        );\n      } else {\n        this.totalWords = totalWords;\n      }\n      // 最后一次活动时间\n      this.lastActiveDate = timeDiff(this.$lastUpdatePosts[0].lastUpdated);\n      this.mountedWebInfo(moutedEvent);\n      // 获取访问量和排名\n      this.indexView = indexView == undefined ? true : indexView;\n      if (this.indexView) {\n        this.getIndexViewCouter(indexIteration);\n      }\n    }\n  },\n  methods: {\n    /**\n     * 挂载站点信息模块\n     */\n    mountedWebInfo(moutedEvent = ".tags-wrapper") {\n      let interval = setInterval(() => {\n        const tagsWrapper = document.querySelector(moutedEvent);\n        const webInfo = document.querySelector(".web-info");\n        if (tagsWrapper && webInfo) {\n          if (!this.isSiblilngNode(tagsWrapper, webInfo)) {\n            tagsWrapper.parentNode.insertBefore(\n              webInfo,\n              tagsWrapper.nextSibling\n            );\n            clearInterval(interval);\n          }\n        }\n      }, 200);\n    },\n    /**\n     * 挂载在兄弟元素后面，说明当前组件是 siblingNode 变量\n     */\n    isSiblilngNode(element, siblingNode) {\n      if (element.siblingNode == siblingNode) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    /**\n     * 首页的统计量\n     */\n    getIndexViewCouter(iterationTime = 3000) {\n      fetch();\n      var i = 0;\n      var defaultCouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 setTimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 setTimeout 的时间（需求调节），setTimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      setTimeout(() => {\n        let indexUv = document.querySelector(".web-site-pv");\n        let indexPv = document.querySelector(".web-site-uv");\n        if (\n          indexPv &&\n          indexUv &&\n          indexPv.innerText == "" &&\n          indexUv.innerText == ""\n        ) {\n          let interval = setInterval(() => {\n            // 再次判断原因：防止进入 setInterval 的瞬间，访问量获取成功\n            if (\n              indexPv &&\n              indexUv &&\n              indexPv.innerText == "" &&\n              indexUv.innerText == ""\n            ) {\n              i += iterationTime;\n              if (i > iterationTime * 5) {\n                indexPv.innerText = defaultCouter;\n                indexUv.innerText = defaultCouter;\n                clearInterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (indexPv.innerText == "" && indexUv.innerText == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearInterval(interval);\n              }\n            } else {\n              clearInterval(interval);\n            }\n          }, iterationTime);\n          // 绑定 beforeDestroy 生命钩子，清除定时器\n          this.$once("hook:beforeDestroy", () => {\n            clearInterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationTime);\n    },\n   \n  },\n};\n<\/script>\n\n<style scoped>\n.web-info {\n  font-size: 0.875rem;\n  padding: 0.95rem;\n}\n.webinfo-title {\n  text-align: center;\n  color: #888;\n  font-weight: bold;\n  padding: 0 0 10px 0;\n}\n.webinfo-item {\n  padding: 8px 0 0;\n  margin: 0;\n}\n.webinfo-item-title {\n  display: inline-block;\n}\n.webinfo-content {\n  display: inline-block;\n  float: right;\n}\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n\n\n继续在 vdoing/components 目录下创建 PageInfo.vue 文件，添加如下内容：\n\n<template>\n  <div class="page-view">\n    \x3c!-- 文章字数 --\x3e\n    <div title="文章字数" class="book-words iconfont icon-book">\n      <a href="javascript:;" style="margin-left: 3px; color: #888">{{\n        wordsCount\n      }}</a>\n    </div>\n\n    \x3c!-- 预阅读时长 --\x3e\n    <div\n      v-if="readingTime"\n      title="预阅读时长"\n      class="reading-time iconfont icon-shijian"\n    >\n      <a href="javascript:;" style="margin-left: 3px; color: #888">{{\n        readingTime\n      }}</a>\n    </div>\n    \x3c!-- 浏览量 --\x3e\n    <div v-if="pageView" title="浏览量" class="page-view iconfont icon-view">\n      <a\n        style="color: #888; margin-left: 3px"\n        href="javascript:;"\n        id="busuanzi_value_page_pv"\n        class="view-data"\n        ><i title="正在获取..." class="loading iconfont icon-loading"></i\n      ></a>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { fetch } from "../util/webSiteInfo";\nexport default {\n  data() {\n    return {\n      // Young Kbt\n      wordsCount: 0,\n      readingTime: 0,\n      pageView: true,\n      pageIteration: 3000,\n    };\n  },\n  mounted() {\n    this.initPageInfo();\n  },\n  watch: {\n    $route(to, from) {\n      if (\n        to.path !== "/" &&\n        to.path != from.path &&\n        this.$themeConfig.blogInfo\n      ) {\n        this.initPageInfo();\n      }\n    },\n  },\n  methods: {\n    /**\n     * 初始化页面信息\n     */\n    initPageInfo() {\n      this.$filterPosts.forEach((itemPage) => {\n        if (itemPage.path == this.$route.path) {\n          const { eachFileWords, pageView, pageIteration, readingTime } =\n            this.$themeConfig.blogInfo;\n          this.pageIteration = pageIteration;\n          if (eachFileWords) {\n            eachFileWords.forEach((itemFile) => {\n              if (itemFile.permalink == itemPage.frontmatter.permalink) {\n                this.wordsCount = itemFile.wordsCount;\n                if (readingTime || readingTime == undefined) {\n                  this.readingTime = itemFile.readingTime;\n                } else {\n                  this.readingTime = false;\n                }\n              }\n            });\n          }\n          this.pageView = pageView == undefined ? true : pageView;\n          if (this.pageView) {\n            this.getPageViewCouter(this.pageIteration);\n          }\n          return;\n        }\n      });\n    },\n    /**\n     * 文章页的访问量\n     */\n    getPageViewCouter(iterationTime = 3000) {\n      fetch();\n      let i = 0;\n      var defaultCouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 setTimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 setTimeout 的时间（需求调节），setTimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      setTimeout(() => {\n        let pageView = document.querySelector(".view-data");\n        if (pageView && pageView.innerText == "") {\n          let interval = setInterval(() => {\n            // 再次判断原因：防止进入 setInterval 的瞬间，访问量获取成功\n            if (pageView && pageView.innerText == "") {\n              i += iterationTime;\n              if (i > iterationTime * 5) {\n                pageView.innerText = defaultCouter;\n                clearInterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (pageView.innerText == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearInterval(interval);\n              }\n            } else {\n              clearInterval(interval);\n            }\n          }, iterationTime);\n          // 绑定 beforeDestroy 生命钩子，清除定时器\n          this.$once("hook:beforeDestroy", () => {\n            clearInterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationTime);\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.page-view > div {\n  float: left;\n  margin-left: 20px;\n  font-size: 0.8rem;\n}\n\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n\n\n\n# Vue组件引用\n\n写好两个组件，那么我们需要使用它们。\n\n> 引入 WebInfo.vue 组件\n\n打开 vdoing/components/Home.vue 文件。\n\n大概在 174 行处引入 WebInfo.vue 组件：\n\nimport WebInfo from \'./WebInfo.vue\';\n\n\n1\n\n\n大概在 242 行处找到 components 注册该组件：\n\ncomponents: { ......, WebInfo },\n\n\n1\n\n\n大概在 153 行处（div 的 class 为 custom-html-box 的上方），添加如下内容：\n\n<webInfo />\n\n\n1\n\n\n三个效果图：\n\n\n\n\n\n\n\n> 引入 PageInfo.vue 组件\n\n打开 vdoing/components/ArticleInfo.vue 文件。\n\n大概在 67 行处引入 PagesView.vue 组件：\n\nimport PageInfo from \'./PageInfo.vue\';\n\n\n1\n\n\n大概在 69 行处添加 components 注册该组件（data() 上方）：\n\ncomponents: { PageInfo },\n\n\n1\n\n\n大概在 61 行处，添加如下内容：\n\n<PageInfo style="margin-left: 0" />\n\n\n1\n\n\n效果图：\n\n\n\n\n# 核心配置文件\n\n在 docs/.vuepress 目录下创建 webSiteInfo 文件夹，并在文件夹里创建 readFile.js 文件。\n\n添加如下内容：\n\nconst fs = require(\'fs\'); // 文件模块\nconst path = require(\'path\'); // 路径模块\nconst matter = require(\'gray-matter\'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst chalk = require(\'chalk\') // 命令行打印美化\nconst log = console.log\nconst docsRoot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readFileList(excludeFiles = [\'\'], dir = docsRoot, filesList = []) {\n  const files = fs.readdirSync(dir);\n  files.forEach((item, index) => {\n    let filePath = path.join(dir, item);\n    const stat = fs.statSync(filePath);\n    if (!(excludeFiles instanceof Array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludeFiles.forEach((excludeFile) => {\n      if (stat.isDirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludeFile) {\n        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const fileNameArr = path.basename(filePath).split(\'.\')\n          let name = null, type = null;\n          if (fileNameArr.length === 2) { // 没有序号的文件\n            name = fileNameArr[0]\n            type = fileNameArr[1]\n          } else if (fileNameArr.length === 3) { // 有序号的文件\n            name = fileNameArr[1]\n            type = fileNameArr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            filesList.push({\n              name,\n              filePath\n            });\n          }\n        }\n      }\n    });\n  });\n  return filesList;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readTotalFileWords(excludeFiles = [\'\']) {\n  const filesList = readFileList(excludeFiles);\n  var wordCount = 0;\n  filesList.forEach((item) => {\n    const content = getContent(item.filePath);\n    var len = counter(content);\n    wordCount += len[0] + len[1];\n  });\n  if (wordCount < 1000) {\n    return wordCount;\n  }\n  return Math.round(wordCount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readEachFileWords(excludeFiles = [\'\'], cn, en) {\n  const filesListWords = [];\n  const filesList = readFileList(excludeFiles);\n  filesList.forEach((item) => {\n    const content = getContent(item.filePath);\n    var len = counter(content);\n    // 计算预计的阅读时间\n    var readingTime = readTime(len, cn, en);\n    var wordsCount = 0;\n    wordsCount = len[0] + len[1];\n    if (wordsCount >= 1000) {\n      wordsCount = Math.round(wordsCount / 100) / 10 + \'k\';\n    }\n    // fileMatterObj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const fileMatterObj = matter(content, {});\n    const matterData = fileMatterObj.data;\n    filesListWords.push({ ...item, wordsCount, readingTime, ...matterData });\n  });\n  return filesListWords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readTime(len, cn = 300, en = 160) {\n  var readingTime = len[0] / cn + len[1] / en;\n  if (readingTime > 60 && readingTime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = parseInt(readingTime / 60);\n    let minute = parseInt((readingTime - hour * 60));\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingTime > 60 * 24) {      // 大于一天\n    let day = parseInt(readingTime / (60 * 24));\n    let hour = parseInt((readingTime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingTime < 1 ? \'1\' : parseInt((readingTime * 10)) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getContent(filePath) {\n  return fs.readFileSync(filePath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content) {\n  const cn = (content.match(/[\\u4E00-\\u9FA5]/g) || []).length;\n  const en = (content.replace(/[\\u4E00-\\u9FA5]/g, \'\').match(/[a-zA-Z0-9_\\u0392-\\u03c9\\u0400-\\u04FF]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|[\\u00E4\\u00C4\\u00E5\\u00C5\\u00F6\\u00D6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nmodule.exports = {\n  readFileList,\n  readTotalFileWords,\n  readEachFileWords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\nimport fs from \'fs\'; // 文件模块\nimport path from \'path\'; // 路径模块\nimport matter from \'gray-matter\'; // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nimport chalk from \'chalk\' // 命令行打印美化\nconst log = console.log\nconst docsRoot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readFileList(excludeFiles: Array<string> = [\'\'], dir: string = docsRoot, filesList: Array<Object> = []) {\n  const files = fs.readdirSync(dir);\n  files.forEach((item, index) => {\n    let filePath = path.join(dir, item);\n    const stat = fs.statSync(filePath);\n    if (!(excludeFiles instanceof Array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludeFiles.forEach((excludeFile) => {\n      if (stat.isDirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludeFile) {\n        readFileList(excludeFiles, path.join(dir, item), filesList);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const fileNameArr = path.basename(filePath).split(\'.\')\n          let name = null, type = null;\n          if (fileNameArr.length === 2) { // 没有序号的文件\n            name = fileNameArr[0]\n            type = fileNameArr[1]\n          } else if (fileNameArr.length === 3) { // 有序号的文件\n            name = fileNameArr[1]\n            type = fileNameArr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filePath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            filesList.push({\n              name,\n              filePath\n            });\n          }\n        }\n      }\n    });\n  });\n  return filesList;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readTotalFileWords(excludeFiles = [\'\']) {\n  const filesList = readFileList(excludeFiles);\n  let wordCount = 0;\n  filesList.forEach((item: any) => {\n    const content = getContent(item.filePath);\n    let len = counter(content);\n    wordCount += len[0] + len[1];\n  });\n  if (wordCount < 1000) {\n    return wordCount;\n  }\n  return Math.round(wordCount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readEachFileWords(excludeFiles: Array<string> = [\'\'], cn: number, en: number) {\n  const filesListWords = [];\n  const filesList = readFileList(excludeFiles);\n  filesList.forEach((item: any) => {\n    const content = getContent(item.filePath);\n    let len = counter(content);\n    // 计算预计的阅读时间\n    let readingTime = readTime(len, cn, en);\n    let wordsCount: any = 0;\n    wordsCount = len[0] + len[1];\n    if (wordsCount >= 1000) {\n      wordsCount = Math.round(wordsCount / 100) / 10 + \'k\';\n    }\n    // fileMatterObj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const fileMatterObj = matter(content, {});\n    const matterData = fileMatterObj.data;\n    filesListWords.push({ ...item, wordsCount, readingTime, ...matterData });\n  });\n  return filesListWords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readTime(len: Array<number>, cn: number = 300, en: number = 160) {\n  let readingTime = len[0] / cn + len[1] / en;\n  if (readingTime > 60 && readingTime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = Math.trunc(readingTime / 60);\n    let minute = Math.trunc(readingTime - hour * 60);\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingTime > 60 * 24) {      // 大于一天\n    let day = Math.trunc(readingTime / (60 * 24));\n    let hour = Math.trunc((readingTime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingTime < 1 ? \'1\' : Math.trunc(readingTime * 10) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getContent(filePath: string) {\n  return fs.readFileSync(filePath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content: string) {\n  const cn = (content.match(/[\\u4E00-\\u9FA5]/g) || []).length;\n  const en = (content.replace(/[\\u4E00-\\u9FA5]/g, \'\').match(/[a-zA-Z0-9_\\u0392-\\u03c9\\u0400-\\u04FF]+|[\\u4E00-\\u9FFF\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04FF]+|[\\u00E4\\u00C4\\u00E5\\u00C5\\u00F6\\u00D6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nexport {\n  readFileList,\n  readTotalFileWords,\n  readEachFileWords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n\n# 配置站点信息\n\n最后一步，在 docs/.vuepress/config.js（新版为 config.ts）文件，引入写好的 readFile.js 文件（路径要准确，这里仅仅是模板）\n\nconst { readFileList, readTotalFileWords, readEachFileWords } = require(\'./webSiteInfo/readFile\');\n\n\n1\n\n\nimport { readFileList, readTotalFileWords, readEachFileWords } from \'./webSiteInfo/readFile\';\n\n\n1\n\n\n如图（演示 JS 代码块）：\n\n\n\n在 themeConfig 中添加如下内容：\n\n// 站点配置（首页 & 文章页）\nblogInfo: {\n  blogCreate: \'2021-10-19\', // 博客创建时间\n  indexView: true,  // 开启首页的访问量和排名统计，默认 true（开启）\n  pageView: true,  // 开启文章页的浏览量统计，默认 true（开启）\n  readingTime: true,  // 开启文章页的预计阅读时间，条件：开启 eachFileWords，默认 true（开启）。可在 eachFileWords 的 readEachFileWords 的第二个和第三个参数自定义，默认 1 分钟 300 中文、160 英文\n  eachFileWords: readEachFileWords([\'\'], 300, 160),  // 开启每个文章页的字数。readEachFileWords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数。无默认值。readEachFileWords() 方法默认排除了 article 为 false 的文章\n  mdFileCountType: \'archives\',  // 开启文档数。1. archives 获取归档的文档数（默认）。2. 数组 readFileList([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文档数。提示：readFileList() 获取 docs 下所有的 md 文档（除了 `.vuepress` 和 `@pages` 目录下的文档）\n  totalWords: \'archives\',  // 开启本站文档总字数。1. archives 获取归档的文档数（使用 archives 条件：传入 eachFileWords，否则报错）。2. readTotalFileWords([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数。无默认值\n  moutedEvent: \'.tags-wrapper\',   // 首页的站点模块挂载在某个元素后面（支持多种选择器），指的是挂载在哪个兄弟元素的后面，默认是热门标签 \'.tags-wrapper\' 下面，提示：\'.categories-wrapper\' 会挂载在文章分类下面。\'.blogger-wrapper\' 会挂载在博客头像模块下面\n  // 下面两个选项：第一次获取访问量失败后的迭代时间\n  indexIteration: 2500,   // 如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  pageIteration: 2500,    // 如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  // 说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如图（图片内容不一定是最新）：\n\n\n\n属性配置的具体介绍请看 属性配置。\n\n\n# 属性配置\n\nblogCreate\n\n * 类型：string\n * 默认值：当前时间（new Date()）\n * 格式：yyyy-mm-dd\n\n博客创建时间。如果不添加时间，页面上显示 0 天。\n\nmdFileCountType\n\n * 类型：string | readFileList()\n * 参数：数组\n * 默认值：archives\n\n文章数目。如果不添加内容，页面上显示归档的文章数目。\n\nreadFileList 是一个 js 文件，需要引入，参数是 目录的全名，最终效果会 排除该目录里的文章数，可多选，逗号隔开。也可不传参数。\n\n温馨提示：readFileList() 不传参数会获取 docs 下所有的 md 文档（除了 .vuepress 和 @pages 目录下的文档）。\n\ntotalWords\n\n * 类型：string | readFileWords()\n * 参数：数组\n * 默认值：null\n\n本站文档总字数。如果不添加内容，页面上显示 0 字。\n\nstring 仅支持 archives，并且使用该类型有条件：必须使用 eachFileWords，否则报错。\n\nreadFileWords 是一个 js 文件，需要引入，参数是目录的全名，最终效果会 排除该目录里的文章字数，可多选，逗号隔开。也可不传参数。\n\nmoutedEvent\n\n * 类型：string\n * 默认值：.tags-wrapper\n\n选择挂载的元素属性，支持多种选择器（id、class ......），该模块会挂载到该元素后面，形成兄弟元素。（仅支持首页的元素）。\n\n温馨提示：.categories-wrapper 会挂载在文章分类下面；.blogger-wrapper 会挂载在头像模块下面；.icons 会挂载在头像下方、图标上方。\n\n默认是热门标签 .tags-wrapper 下面。\n\nindexView\n\n * 类型：boolean\n * 默认值：true\n\n开启首页的访问量和排名统计，默认 true(开启)。\n\npageView\n\n * 类型 boolean\n * 默认值：true\n\n开启文章页的浏览量统计，默认 true（开启）。\n\neachFileWords\n\n * 类型：readEachFileWords()\n * 参数：数组\n * 默认值：null\n\n开启每个文章页的字数。如果不添加内容，则不开启。\n\nreadEachFileWords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长。\n\nreadEachFileWords() 第一个参数是数组，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数，配合 readingTime 使用。\n\nreadEachFileWords() 方法默认排除了 article 为 false 的文章。\n\nreadingTime\n\n * 类型：boolean\n\n * 默认值：true\n\n * 条件：使用 eachFileWords\n\n开启文章页的预计阅读时间。默认阅读中文 1 分钟 300 个字，英文 1 分钟 160 个字。如果想自定义阅读文字时长，请在 eachFileWords 的 readEachFileWords() 传入后面两个参数。分别为 1 分钟阅读的中文和英文个数。\n\nindexIteration\n\n * 类型：number\n * 默认值：3000\n\n如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。\n\n注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n\npageIteration\n\n * 类型：number\n * 默认值：3000\n\n如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。\n\n注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n\n说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n本内容介绍如何搭建本站首页的站点信息，以及每篇文章的浏览量统计。\n\n2021-12-30 @du wu\n\n\n\n * 前言\n * 添加meta\n * 添加在线图标\n * vue模板\n * 主题选择\n * 在线主题\n   * 网站信息工具代码\n   * 站点信息代码\n   * 站点信息配置\n * 本地主题\n   * 工具类\n   * vue组件创建\n   * vue组件引用\n   * 核心配置文件\n   * 配置站点信息\n * 属性配置\n * 结束语\n\n\n\n\n# 前言\n\n本内容将在首页和每篇的文章页加入了一些元素，目前适用版本是 vdoing v1.x。\n\n> 如果你想集成到其他 vuepress 主题，那么要添加卡片样式，修改挂载元素即可（建议先按照步骤完成一次再考虑集成）。\n> \n>  * 为什么添加卡片样式？本模块的站点信息是基于 vdoing 自带的卡片样式，模块并没有添加任何卡片样式，所以想集成到其他主题，则需要参考 vdoing 卡片样式进行添加，或者按照自己喜欢的样式进行添加\n>  * 为什么修改挂载元素？本模块的挂载元素是基于 vdoing 标签提供的 class 或 id，而其他主题的标签不一样，所以自行进行调试\n> \n> 本模块的所有 功能 支持大部分 vuepress 主题，但是如何将所有功能展示到其他主题页面合适的地方，以及展示的样式等 dom 技术，需要自己适配。\n\n效果如下：\n\n\n\n\n\n本站的访问量和文章的浏览量使用了 不蒜子，本地启动的 localhost 有很多人访问过，但无需担心实际部署后的访问量。\n\n不蒜子官网地址\n\n不蒜子文档地址\n\n注意\n\n问题：本模块目前有一个功能依赖于 git 的 lastupdated 功能，该功能已经内置 vuepress，所以无需担心，唯一值得注意的是：在本地添加了新的文件，最后活动时间的数据可能为 nan（无法获取的意思）。\n\n解决：只需要在博客项目部署的过程中执行 git commit 命令，因为该命令将会获取一个准确的时间代替 nan，给本模块使用。\n\n2022-01-17 @du wu\n\n\n# 添加meta\n\n为什么添加 meta 头信息呢，因为在 chrome 85 版本中，为了保护用户的隐私，默认的 referrer policy 则变成了 strict-origin-when-cross-origin。\n\n所以必须添加 meta，否则文章统计访问量的数据则不正确。\n\n在 docs/.vuepress/config.js 下的 head 中添加如下内容：\n\n[\'meta\', { name: \'referrer\', content: \'no-referrer-when-downgrade\' }],\n\n\n1\n\n\n如图：\n\n\n\n\n# 添加在线图标\n\n这里使用的是阿里矢量库。\n\n地址：https://www.iconfont.cn/\n\n添加了五个图标\n\n\n\n如果你不想使用自己的矢量库项目（不害怕我删图标跑路🤣），那么可以使用我的图标项目网址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n在 config.js 下的 head 中文件添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'https://at.alicdn.com/t/font_3077305_pt8umhrn4k9.css\' }]\n\n\n1\n\n\n如图：（图片的内容不一定是最新的，以上方代码块为准）\n\n\n\n\n# vue模板\n\n这里先提供一个在 vue 里常用的模板代码，即通用代码（了解即可）：\n\n<template>\n  <div class="busuanzi">\n    <span id="busuanzi_container_site_pv" style="display:none">\n      本站总访问量\n      <span id="busuanzi_value_site_pv"></span>次\n      <span class="post-meta-divider">|</span>\n    </span>\n    <span id="busuanzi_container_site_uv" style="display:none">\n      本站访客数\n      <span id="busuanzi_value_site_uv"></span>人\n    </span>\n  </div>\n</template>\n \n<script>\nlet script;\nexport default {\n  mounted() {\n    script = require("busuanzi.pure.js");\n  },\n  // 监听，当路由发生变化的时候执行\n  watch: {\n    $route(to, from) {\n      if (to.path != from.path) {\n        script.fetch();\n      }\n    }\n  }\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 主题选择\n\n下面有两种配置方式可以选，分别为：\n\n * 在线主题：npm 主题，采用监听路由、插入式的代码\n * 本地主题：站点信息模块与页面一起渲染出来，没有延迟\n\n本地主题不好的一点就是版本升级后曾修改的内容被重置，所以需要记好修改位置、备份，比较麻烦。好处是根据自己的需求在基础上拓展。\n\n在线主题具有通用性，即在任意环境（如本地主题）都有效果。\n\n\n# 在线主题\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n不管使不使用本地主题，都可以配置在线主题的站点模块。\n\n\n# 网站信息工具代码\n\n添加网站信息需要的计算代码、获取字数代码等工具类。\n\n首先进入 docs/.vuepress 目录，创建 websiteinfo 文件夹\n\n\n\n然后在 websiteinfo 目录下创建 busuanzi.js 文件，这个文件用于 获取访问量。\n\nvar bszcaller, bsztag, scripttag, ready;\n\nvar t,\n  e,\n  n,\n  a = !1,\n  c = [];\n\n// 修复node同构代码的问题\nif (typeof document !== "undefined") {\n  (ready = function (t) {\n    return (\n      a ||\n      "interactive" === document.readystate ||\n      "complete" === document.readystate\n        ? t.call(document)\n        : c.push(function () {\n            return t.call(this);\n          }),\n      this\n    );\n  }),\n    (e = function () {\n      for (var t = 0, e = c.length; t < e; t++) c[t].apply(document);\n      c = [];\n    }),\n    (n = function () {\n      a ||\n        ((a = !0),\n        e.call(window),\n        document.removeeventlistener\n          ? document.removeeventlistener("domcontentloaded", n, !1)\n          : document.attachevent &&\n            (document.detachevent("onreadystatechange", n),\n            window == window.top && (clearinterval(t), (t = null))));\n    }),\n    document.addeventlistener\n      ? document.addeventlistener("domcontentloaded", n, !1)\n      : document.attachevent &&\n        (document.attachevent("onreadystatechange", function () {\n          /loaded|complete/.test(document.readystate) && n();\n        }),\n        window == window.top &&\n          (t = setinterval(function () {\n            try {\n              a || document.documentelement.doscroll("left");\n            } catch (t) {\n              return;\n            }\n            n();\n          }, 5)));\n}\n\nbszcaller = {\n  fetch: function (t, e) {\n    var n = "busuanzicallback_" + math.floor(1099511627776 * math.random());\n    t = t.replace("=busuanzicallback", "=" + n);\n    (scripttag = document.createelement("script")),\n      (scripttag.type = "text/javascript"),\n      (scripttag.defer = !0),\n      (scripttag.src = t),\n      document.getelementsbytagname("head")[0].appendchild(scripttag);\n    window[n] = this.evalcall(e);\n  },\n  evalcall: function (e) {\n    return function (t) {\n      ready(function () {\n        try {\n          e(t),\n            scripttag &&\n              scripttag.parentelement &&\n              scripttag.parentelement.removechild &&\n              scripttag.parentelement.removechild(scripttag);\n        } catch (t) {\n          console.log(t), bsztag.hides();\n        }\n      });\n    };\n  },\n};\n\nbsztag = {\n  bszs: ["site_pv", "page_pv", "site_uv"],\n  texts: function (n) {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_value_" + t);\n      e && (e.innerhtml = n[t]);\n    });\n  },\n  hides: function () {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_container_" + t);\n      e && (e.style.display = "none");\n    });\n  },\n  shows: function () {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_container_" + t);\n      e && (e.style.display = "inline");\n    });\n  },\n};\n\nexport default () => {\n  bsztag && bsztag.hides();\n  bszcaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpcallback=busuanzicallback", function (t) {\n    bsztag.texts(t), bsztag.shows();\n  })\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n\n\n然后创建 readfile.js 或者 readfile.ts 文件，这个文件用于 统计文章数目 和 网站总字数 等。\n\n添加如下内容：\n\nconst fs = require(\'fs\'); // 文件模块\nconst path = require(\'path\'); // 路径模块\nconst matter = require(\'gray-matter\'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst chalk = require(\'chalk\') // 命令行打印美化\nconst log = console.log\nconst docsroot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readfilelist(excludefiles = [\'\'], dir = docsroot, fileslist = []) {\n  const files = fs.readdirsync(dir);\n  files.foreach((item, index) => {\n    let filepath = path.join(dir, item);\n    const stat = fs.statsync(filepath);\n    if (!(excludefiles instanceof array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludefiles.foreach((excludefile) => {\n      if (stat.isdirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludefile) {\n        readfilelist(excludefiles, path.join(dir, item), fileslist);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const filenamearr = path.basename(filepath).split(\'.\')\n          let name = null, type = null;\n          if (filenamearr.length === 2) { // 没有序号的文件\n            name = filenamearr[0]\n            type = filenamearr[1]\n          } else if (filenamearr.length === 3) { // 有序号的文件\n            name = filenamearr[1]\n            type = filenamearr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filepath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            fileslist.push({\n              name,\n              filepath\n            });\n          }\n        }\n      }\n    });\n  });\n  return fileslist;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readtotalfilewords(excludefiles = [\'\']) {\n  const fileslist = readfilelist(excludefiles);\n  var wordcount = 0;\n  fileslist.foreach((item) => {\n    const content = getcontent(item.filepath);\n    var len = counter(content);\n    wordcount += len[0] + len[1];\n  });\n  if (wordcount < 1000) {\n    return wordcount;\n  }\n  return math.round(wordcount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readeachfilewords(excludefiles = [\'\'], cn, en) {\n  const fileslistwords = [];\n  const fileslist = readfilelist(excludefiles);\n  fileslist.foreach((item) => {\n    const content = getcontent(item.filepath);\n    var len = counter(content);\n    // 计算预计的阅读时间\n    var readingtime = readtime(len, cn, en);\n    var wordscount = 0;\n    wordscount = len[0] + len[1];\n    if (wordscount >= 1000) {\n      wordscount = math.round(wordscount / 100) / 10 + \'k\';\n    }\n    // filematterobj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const filematterobj = matter(content, {});\n    const matterdata = filematterobj.data;\n    fileslistwords.push({ ...item, wordscount, readingtime, ...matterdata });\n  });\n  return fileslistwords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readtime(len, cn = 300, en = 160) {\n  var readingtime = len[0] / cn + len[1] / en;\n  if (readingtime > 60 && readingtime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = parseint(readingtime / 60);\n    let minute = parseint((readingtime - hour * 60));\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingtime > 60 * 24) {      // 大于一天\n    let day = parseint(readingtime / (60 * 24));\n    let hour = parseint((readingtime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingtime < 1 ? \'1\' : parseint((readingtime * 10)) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getcontent(filepath) {\n  return fs.readfilesync(filepath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content) {\n  const cn = (content.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n  const en = (content.replace(/[\\u4e00-\\u9fa5]/g, \'\').match(/[a-za-z0-9_\\u0392-\\u03c9\\u0400-\\u04ff]+|[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04ff]+|[\\u00e4\\u00c4\\u00e5\\u00c5\\u00f6\\u00d6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nmodule.exports = {\n  readfilelist,\n  readtotalfilewords,\n  readeachfilewords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\nimport fs from \'fs\'; // 文件模块\nimport path from \'path\'; // 路径模块\nimport matter from \'gray-matter\'; // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nimport chalk from \'chalk\' // 命令行打印美化\nconst log = console.log\nconst docsroot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readfilelist(excludefiles: array<string> = [\'\'], dir: string = docsroot, fileslist: array<object> = []) {\n  const files = fs.readdirsync(dir);\n  files.foreach((item, index) => {\n    let filepath = path.join(dir, item);\n    const stat = fs.statsync(filepath);\n    if (!(excludefiles instanceof array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludefiles.foreach((excludefile) => {\n      if (stat.isdirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludefile) {\n        readfilelist(excludefiles, path.join(dir, item), fileslist);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const filenamearr = path.basename(filepath).split(\'.\')\n          let name = null, type = null;\n          if (filenamearr.length === 2) { // 没有序号的文件\n            name = filenamearr[0]\n            type = filenamearr[1]\n          } else if (filenamearr.length === 3) { // 有序号的文件\n            name = filenamearr[1]\n            type = filenamearr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filepath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            fileslist.push({\n              name,\n              filepath\n            });\n          }\n        }\n      }\n    });\n  });\n  return fileslist;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readtotalfilewords(excludefiles = [\'\']) {\n  const fileslist = readfilelist(excludefiles);\n  let wordcount = 0;\n  fileslist.foreach((item: any) => {\n    const content = getcontent(item.filepath);\n    let len = counter(content);\n    wordcount += len[0] + len[1];\n  });\n  if (wordcount < 1000) {\n    return wordcount;\n  }\n  return math.round(wordcount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readeachfilewords(excludefiles: array<string> = [\'\'], cn: number, en: number) {\n  const fileslistwords = [];\n  const fileslist = readfilelist(excludefiles);\n  fileslist.foreach((item: any) => {\n    const content = getcontent(item.filepath);\n    let len = counter(content);\n    // 计算预计的阅读时间\n    let readingtime = readtime(len, cn, en);\n    let wordscount: any = 0;\n    wordscount = len[0] + len[1];\n    if (wordscount >= 1000) {\n      wordscount = math.round(wordscount / 100) / 10 + \'k\';\n    }\n    // filematterobj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const filematterobj = matter(content, {});\n    const matterdata = filematterobj.data;\n    fileslistwords.push({ ...item, wordscount, readingtime, ...matterdata });\n  });\n  return fileslistwords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readtime(len: array<number>, cn: number = 300, en: number = 160) {\n  let readingtime = len[0] / cn + len[1] / en;\n  if (readingtime > 60 && readingtime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = math.trunc(readingtime / 60);\n    let minute = math.trunc(readingtime - hour * 60);\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingtime > 60 * 24) {      // 大于一天\n    let day = math.trunc(readingtime / (60 * 24));\n    let hour = math.trunc((readingtime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingtime < 1 ? \'1\' : math.trunc(readingtime * 10) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getcontent(filepath: string) {\n  return fs.readfilesync(filepath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content: string) {\n  const cn = (content.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n  const en = (content.replace(/[\\u4e00-\\u9fa5]/g, \'\').match(/[a-za-z0-9_\\u0392-\\u03c9\\u0400-\\u04ff]+|[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04ff]+|[\\u00e4\\u00c4\\u00e5\\u00c5\\u00f6\\u00d6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nexport {\n  readfilelist,\n  readtotalfilewords,\n  readeachfilewords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n接着继续在该目录下创建第三个文件 utils.js，该文件用于计算 已运行时间 和 最后活动时间。\n\n添加如下内容：\n\n// 日期格式化(只获取年月日)\nexport function dateformat(date) {\n  if (!(date instanceof date)) {\n    date = new date(date);\n  }\n  return `${date.getutcfullyear()}-${zero(date.getutcmonth() + 1)}-${zero(date.getutcdate())}`;\n}\n\n// 小于10补0\nexport function zero(d) {\n  return d.tostring().padstart(2, \'0\');\n}\n\n/**\n * 计算最后活动时间\n */\nexport function lastupdateposts(posts) {\n  posts.sort((prev, next) => {\n    return comparedate(prev, next);\n  });\n  return posts;\n}\n\n// 获取时间的时间戳\nexport function gettimenum(post) {\n  let datestr = post.lastupdated || post.frontmatter.date;\n  let date = new date(datestr);\n  if (date == "invalid date" && datestr) { // 修复new date()在safari下出现invalid date的问题\n    date = new date(datestr.replace(/-/g, \'/\'));\n  }\n  return date.gettime();\n}\n\n// 比对时间\nexport function comparedate(a, b) {\n  return gettimenum(b) - gettimenum(a);\n}\n\n/**\n * 获取两个日期相差多少天\n */\nexport function daydiff(startdate, enddate) {\n  if (!enddate) {\n    enddate = startdate;\n    startdate = new date();\n  }\n  startdate = dateformat(startdate);\n  enddate = dateformat(enddate);\n  let day = parseint(math.abs(new date(startdate) - new date(enddate)) / (1000 * 60 * 60 * 24));\n  return day;\n}\n\n/**\n * 计算相差多少年/月/日/时/分/秒\n */\nexport function timediff(startdate, enddate) {\n  if (!enddate) {\n    enddate = startdate;\n    startdate = new date();\n  }\n  if (!(startdate instanceof date)) {\n    startdate = new date(startdate);\n  }\n  if (!(enddate instanceof date)) {\n    enddate = new date(enddate);\n  }\n  // 计算时间戳的差\n  const diffvalue = parseint((math.abs(enddate - startdate) / 1000));\n  if (diffvalue == 0) {\n    return \'刚刚\';\n  } else if (diffvalue < 60) {\n    return diffvalue + \' 秒\';\n  } else if (parseint(diffvalue / 60) < 60) {\n    return parseint(diffvalue / 60) + \' 分\';\n  } else if (parseint(diffvalue / (60 * 60)) < 24) {\n    return parseint(diffvalue / (60 * 60)) + \' 时\';\n  } else if (parseint(diffvalue / (60 * 60 * 24)) < getdays(startdate.getmonth, startdate.getfullyear)) {\n    return parseint(diffvalue / (60 * 60 * 24)) + \' 天\';\n  } else if (parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear))) < 12) {\n    return parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear))) + \' 月\';\n  } else {\n    return parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear) * 12)) + \' 年\';\n  }\n}\n\n/**\n * 判断当前月的天数（28、29、30、31）\n */\nexport function getdays(mouth, year) {\n  let days = 30;\n  if (mouth === 2) {\n    days = year % 4 === 0 ? 29 : 28;\n  } else if (mouth === 1 || mouth === 3 || mouth === 5 || mouth === 7 || mouth === 8 || mouth === 10 || mouth === 12) {\n    // 月份为：1,3,5,7,8,10,12 时，为大月.则天数为 31；\n    days = 31;\n  }\n  return days;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n目前就三个文件，最终效果如图：\n\n\n\n\n# 站点信息代码\n\n这一步的文件目录不能随便移动，因为该目录是 vuepress 规定的。\n\n首先进入 docs/.vuepress 目录，创建 components 文件夹\n\n\n\n创建一个 vue 文件：webinfo.vue，这就是首页的站点信息模块。\n\n并添加如下内容：\n\n<template>\n  \x3c!-- young kbt --\x3e\n  <div class="web-info card-box">\n    <div class="webinfo-title">\n      <i\n        class="iconfont icon-award"\n        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"\n      ></i>\n      <span>站点信息</span>\n    </div>\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">文章数目：</div>\n      <div class="webinfo-content">{{ mdfilecount }} 篇</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">已运行时间：</div>\n      <div class="webinfo-content">\n        {{ createtonowday != 0 ? createtonowday + " 天" : "不到一天" }}\n      </div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">本站总字数：</div>\n      <div class="webinfo-content">{{ totalwords }} 字</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">最后活动时间：</div>\n      <div class="webinfo-content">\n        {{ lastactivedate == "刚刚" ? "刚刚" : lastactivedate + "前" }}\n      </div>\n    </div>\n\n    <div v-if="indexview" class="webinfo-item">\n      <div class="webinfo-item-title">本站被访问了：</div>\n      <div class="webinfo-content">\n        <span id="busuanzi_value_site_pv" class="web-site-pv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        次\n      </div>\n    </div>\n\n    <div v-if="indexview" class="webinfo-item">\n      <div class="webinfo-item-title">您的访问排名：</div>\n      <div class="webinfo-content busuanzi">\n        <span id="busuanzi_value_site_uv" class="web-site-uv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        名\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { daydiff, timediff, lastupdateposts } from "../websiteinfo/utils";\nimport fetch from "../websiteinfo/busuanzi"; // 统计量\nexport default {\n  data() {\n    return {\n      // young kbt\n      mdfilecount: 0, // markdown 文档总数\n      createtonowday: 0, // 博客创建时间距今多少天\n      lastactivedate: "", // 最后活动时间\n      totalwords: 0, // 本站总字数\n      indexview: true, // 开启访问量和排名统计\n    };\n  },\n  computed: {\n    $lastupdateposts() {\n      return lastupdateposts(this.$filterposts);\n    },\n  },\n  mounted() {\n    // young kbt\n    if (object.keys(this.$themeconfig.bloginfo).length > 0) {\n      const {\n        blogcreate,\n        mdfilecounttype,\n        totalwords,\n        moutedevent,\n        eachfilewords,\n        indexiteration,\n        indexview,\n      } = this.$themeconfig.bloginfo;\n      this.createtonowday = daydiff(blogcreate);\n      if (mdfilecounttype != "archives") {\n        this.mdfilecount = mdfilecounttype.length;\n      } else {\n        this.mdfilecount = this.$filterposts.length;\n      }\n      if (totalwords == "archives" && eachfilewords) {\n        let archiveswords = 0;\n        eachfilewords.foreach((itemfile) => {\n          if (itemfile.wordscount < 1000) {\n            archiveswords += itemfile.wordscount;\n          } else {\n            let wordscount = itemfile.wordscount.slice(\n              0,\n              itemfile.wordscount.length - 1\n            );\n            archiveswords += wordscount * 1000;\n          }\n        });\n        this.totalwords = math.round(archiveswords / 100) / 10 + "k";\n      } else if (totalwords == "archives") {\n        this.totalwords = 0;\n        console.log(\n          "如果 totalwords = \'archives\'，必须传入 eachfilewords，显然您并没有传入！"\n        );\n      } else {\n        this.totalwords = totalwords;\n      }\n      // 最后一次活动时间\n      this.lastactivedate = timediff(this.$lastupdateposts[0].lastupdated);\n      this.mountedwebinfo(moutedevent);\n      // 获取访问量和排名\n      this.indexview = indexview == undefined ? true : indexview;\n      if (this.indexview) {\n        this.getindexviewcouter(indexiteration);\n      }\n    }\n  },\n  methods: {\n    /**\n     * 挂载站点信息模块\n     */\n    mountedwebinfo(moutedevent = ".tags-wrapper") {\n      let interval = setinterval(() => {\n        const tagswrapper = document.queryselector(moutedevent);\n        const webinfo = document.queryselector(".web-info");\n        if (tagswrapper && webinfo) {\n          if (!this.issiblilngnode(tagswrapper, webinfo)) {\n            tagswrapper.parentnode.insertbefore(\n              webinfo,\n              tagswrapper.nextsibling\n            );\n            clearinterval(interval);\n          }\n        }\n      }, 200);\n    },\n    /**\n     * 挂载在兄弟元素后面，说明当前组件是 siblingnode 变量\n     */\n    issiblilngnode(element, siblingnode) {\n      if (element.siblingnode == siblingnode) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    /**\n     * 首页的统计量\n     */\n    getindexviewcouter(iterationtime = 3000) {\n      fetch();\n      var i = 0;\n      var defaultcouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 settimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 settimeout 的时间（需求调节），settimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      settimeout(() => {\n        let indexuv = document.queryselector(".web-site-pv");\n        let indexpv = document.queryselector(".web-site-uv");\n        if (\n          indexpv &&\n          indexuv &&\n          indexpv.innertext == "" &&\n          indexuv.innertext == ""\n        ) {\n          let interval = setinterval(() => {\n            // 再次判断原因：防止进入 setinterval 的瞬间，访问量获取成功\n            if (\n              indexpv &&\n              indexuv &&\n              indexpv.innertext == "" &&\n              indexuv.innertext == ""\n            ) {\n              i += iterationtime;\n              if (i > iterationtime * 5) {\n                indexpv.innertext = defaultcouter;\n                indexuv.innertext = defaultcouter;\n                clearinterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (indexpv.innertext == "" && indexuv.innertext == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearinterval(interval);\n              }\n            } else {\n              clearinterval(interval);\n            }\n          }, iterationtime);\n          // 绑定 beforedestroy 生命钩子，清除定时器\n          this.$once("hook:beforedestroy", () => {\n            clearinterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationtime);\n    },\n    beforemount() {\n      let webinfo = document.queryselector(".web-info");\n      webinfo && webinfo.parentnode.removechild(webinfo);\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.web-info {\n  font-size: 0.875rem;\n  padding: 0.95rem;\n}\n.webinfo-title {\n  text-align: center;\n  color: #888;\n  font-weight: bold;\n  padding: 0 0 10px 0;\n}\n.webinfo-item {\n  padding: 8px 0 0;\n  margin: 0;\n}\n.webinfo-item-title {\n  display: inline-block;\n}\n.webinfo-content {\n  display: inline-block;\n  float: right;\n}\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n\n\n继续创建一个 vue 文件：pageinfo.vue，这就是文章页的信息模块：文章浏览量、字数代码、预阅读时间。\n\n<template></template>\n\n<script>\nimport fetch from "../websiteinfo/busuanzi";\nexport default {\n  mounted() {\n    // 首页不初始页面信息\n    if (this.$route.path != "/") {\n      this.initpageinfo();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 如果页面是非首页，# 号也会触发路由变化，这里要排除掉\n      if (\n        to.path !== "/" &&\n        to.path !== from.path &&\n        this.$themeconfig.bloginfo\n      ) {\n        this.initpageinfo();\n      }\n    },\n  },\n  methods: {\n    /**\n     * 初始化页面信息\n     */\n    initpageinfo() {\n      if (this.$frontmatter.article == undefined || this.$frontmatter.article) {\n        // 排除掉 article 为 false 的文章\n        const { eachfilewords, pageview, pageiteration, readingtime } =\n          this.$themeconfig.bloginfo;\n        // 下面两个 if 可以调换位置，从而让文章的浏览量和字数交换位置\n        if (eachfilewords) {\n          try {\n            eachfilewords.foreach((itemfile) => {\n              if (itemfile.permalink == this.$frontmatter.permalink) {\n                // this.addpagewordscount 和 if 可以调换位置，从而让文章的字数和预阅读时间交换位置\n                this.addpagewordscount(itemfile.wordscount);\n                if (readingtime || readingtime == undefined) {\n                  this.addreadtimecount(itemfile.readingtime);\n                }\n                throw new error();\n              }\n            });\n          } catch (error) {}\n        }\n        if (pageview || pageview == undefined) {\n          this.addpageview();\n          this.getpageviewcouter(pageiteration);\n        }\n        return;\n      }\n    },\n    /**\n     * 文章页的访问量\n     */\n    getpageviewcouter(iterationtime = 3000) {\n      fetch();\n      let i = 0;\n      var defaultcouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 settimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 settimeout 的时间（需求调节），settimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      settimeout(() => {\n        let pageview = document.queryselector(".view-data");\n        if (pageview && pageview.innertext == "") {\n          let interval = setinterval(() => {\n            // 再次判断原因：防止进入 setinterval 的瞬间，访问量获取成功\n            if (pageview && pageview.innertext == "") {\n              i += iterationtime;\n              if (i > iterationtime * 5) {\n                pageview.innertext = defaultcouter;\n                clearinterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (pageview.innertext == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearinterval(interval);\n              }\n            } else {\n              clearinterval(interval);\n            }\n          }, iterationtime);\n          // 绑定 beforedestroy 生命钩子，清除定时器\n          this.$once("hook:beforedestroy", () => {\n            clearinterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationtime);\n    },\n    /**\n     * 添加浏览量元素\n     */\n    addpageview() {\n      let pageview = document.queryselector(".page-view");\n      if (pageview) {\n        pageview.innerhtml =\n          \'<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>\';\n      } else {\n        // 创建访问量的元素\n        let template = document.createelement("div");\n        template.title = "浏览量";\n        template.classname = "page-view iconfont icon-view";\n        template.style.float = "left";\n        template.style.marginleft = "20px";\n        template.style.fontsize = "0.8rem";\n        template.innerhtml =\n          \'<a style="color: #888; margin-left: 3px" href="javascript:;" id="busuanzi_value_page_pv" class="view-data"><i title="正在获取..." class="loading iconfont icon-loading"></i></a>\';\n        // 添加 loading 效果\n        let style = document.createelement("style");\n        style.innerhtml = `@keyframes turn {\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n      }\n      .loading {\n        display: inline-block;\n        animation: turn 1s linear infinite;\n        -webkit-animation: turn 1s linear infinite;\n      }`;\n        document.head.appendchild(style);\n        this.mountedview(template);\n      }\n    },\n    /**\n     * 添加当前文章页的字数元素\n     */\n    addpagewordscount(wordscount = 0) {\n      let words = document.queryselector(".book-words");\n      if (words) {\n        words.innerhtml = `<a href="javascript:;" style="margin-left: 3px; color: #888">${wordscount}</a>`;\n      } else {\n        let template = document.createelement("div");\n        template.title = "文章字数";\n        template.classname = "book-words iconfont icon-book";\n        template.style.float = "left";\n        template.style.marginleft = "20px";\n        template.style.fontsize = "0.8rem";\n\n        template.innerhtml = `<a href="javascript:;" style="margin-left: 3px; color: #888">${wordscount}</a>`;\n        this.mountedview(template);\n      }\n    },\n    /**\n     * 添加预计的阅读时间\n     */\n    addreadtimecount(readtimecount = 0) {\n      let reading = document.queryselector(".reading-time");\n      if (reading) {\n        reading.innerhtml = `<a href="javascript:;" style="margin-left: 3px; color: #888">${readtimecount}</a>`;\n      } else {\n        let template = document.createelement("div");\n        template.title = "预阅读时长";\n        template.classname = "reading-time iconfont icon-shijian";\n        template.style.float = "left";\n        template.style.marginleft = "20px";\n        template.style.fontsize = "0.8rem";\n        template.innerhtml = `<a href="javascript:;" style="margin-left: 3px; color: #888">${readtimecount}</a>`;\n        this.mountedview(template);\n      }\n    },\n    /**\n     * 挂载目标到页面上\n     */\n    mountedview(\n      template,\n      mountedintervaltime = 100,\n      moutedparentevent = ".articleinfo-wrap > .articleinfo > .info"\n    ) {\n      let i = 0;\n      let parentelement = document.queryselector(moutedparentevent);\n      if (parentelement) {\n        if (!this.ismountedview(template, parentelement)) {\n          parentelement.appendchild(template);\n        }\n      } else {\n        let interval = setinterval(() => {\n          parentelement = document.queryselector(moutedparentevent);\n          if (parentelement) {\n            if (!this.ismountedview(template, parentelement)) {\n              parentelement.appendchild(template);\n              clearinterval(interval);\n            }\n          } else if (i > 1 * 10) {\n            // 10 秒后清除\n            clearinterval(interval);\n          }\n        }, mountedintervaltime);\n        // 绑定 beforedestroy 生命钩子，清除定时器\n        this.$once("hook:beforedestroy", () => {\n          clearinterval(interval);\n          interval = null;\n        });\n      }\n    },\n    /**\n     * 如果元素存在，则删除\n     */\n    removeelement(selector) {\n      var element = document.queryselector(selector);\n      element && element.parentnode.removechild(element);\n    },\n    /**\n     * 目标是否已经挂载在页面上\n     */\n    ismountedview(element, parentelement) {\n      if (element.parentnode == parentelement) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n  },\n  // 防止重写编译时，导致页面信息重复出现问题\n  beforemount() {\n    clearinterval(this.interval);\n    this.removeelement(".page-view");\n    this.removeelement(".book-words");\n    this.removeelement(".reading-time");\n  },\n};\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n\n\n最终效果如图：\n\n\n\n创建好了两个 vue 组件，我们需要使用它们。\n\n> 使用 webinfo.vue 组件\n\n打开 docs/index.md\n\n\n\n移到最下方，添加如下内容：\n\n<clientonly>\n  <webinfo/>\n</clientonly>\n\n\n1\n2\n3\n\n\n> 使用 pageinfo.vue 组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加配置。\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globaluicomponents: ["pageinfo"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n        }\n    ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from \'vuepress/config\'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobaluicomponents: ["pageinfo"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 站点信息配置\n\n上面都按照步骤写好代码、使用组件了，那么就可以走最后一步配置我们的站点信息。\n\n进入到 docs/.vuepress/config.js（新版为 config.ts）文件。\n\n引入之前写好的工具代码文件：（路径要准确，这里仅仅是模板）\n\nconst { readfilelist, readtotalfilewords, readeachfilewords } = require(\'./websiteinfo/readfile\');\n\n\n1\n\n\nimport { readfilelist, readtotalfilewords, readeachfilewords } from \'./websiteinfo/readfile\';\n\n\n1\n\n\n如图（演示 js 代码块）：\n\n\n\n在 themeconfig 中添加如下内容：\n\n// 站点配置（首页 & 文章页）\nbloginfo: {\n  blogcreate: \'2021-10-19\', // 博客创建时间\n  indexview: true,  // 开启首页的访问量和排名统计，默认 true（开启）\n  pageview: true,  // 开启文章页的浏览量统计，默认 true（开启）\n  readingtime: true,  // 开启文章页的预计阅读时间，条件：开启 eachfilewords，默认 true（开启）。可在 eachfilewords 的 readeachfilewords 的第二个和第三个参数自定义，默认 1 分钟 300 中文、160 英文\n  eachfilewords: readeachfilewords([\'\'], 300, 160),  // 开启每个文章页的字数。readeachfilewords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数。无默认值。readeachfilewords() 方法默认排除了 article 为 false 的文章\n  mdfilecounttype: \'archives\',  // 开启文档数。1. archives 获取归档的文档数（默认）。2. 数组 readfilelist([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文档数。提示：readfilelist() 获取 docs 下所有的 md 文档（除了 `.vuepress` 和 `@pages` 目录下的文档）\n  totalwords: \'archives\',  // 开启本站文档总字数。1. archives 获取归档的文档数（使用 archives 条件：传入 eachfilewords，否则报错）。2. readtotalfilewords([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数。无默认值\n  moutedevent: \'.tags-wrapper\',   // 首页的站点模块挂载在某个元素后面（支持多种选择器），指的是挂载在哪个兄弟元素的后面，默认是热门标签 \'.tags-wrapper\' 下面，提示：\'.categories-wrapper\' 会挂载在文章分类下面。\'.blogger-wrapper\' 会挂载在博客头像模块下面\n  // 下面两个选项：第一次获取访问量失败后的迭代时间\n  indexiteration: 2500,   // 如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  pageiteration: 2500,    // 如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  // 说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如图（图片内容不一定是最新，最新的是代码块内容）：\n\n\n\n属性配置的具体介绍请看 属性配置。\n\n\n# 本地主题\n\n如果已经看完了在线主题的内容，其实本内容的大小不变，只是位置变换、一些代码重组。\n\n配置了在线主题，就不需要配置本地主题，反之亦然。\n\n\n# 工具类\n\n在 vdoing/util 目录下创建 websiteinfo.js，添加如下内容：\n\n// 日期格式化(只获取年月日)\nexport function dateformat(date) {\n  if (!(date instanceof date)) {\n    date = new date(date);\n  }\n  return `${date.getutcfullyear()}-${zero(date.getutcmonth() + 1)}-${zero(date.getutcdate())}`;\n}\n\n// 小于10补0\nexport function zero(d) {\n  return d.tostring().padstart(2, \'0\');\n}\n\n/**\n * 计算最后活动时间\n */\nexport function lastupdateposts(posts) {\n  posts.sort((prev, next) => {\n    return comparedate(prev, next);\n  });\n  return posts;\n}\n\n// 获取时间的时间戳\nexport function gettimenum(post) {\n  let datestr = post.lastupdated || post.frontmatter.date;\n  let date = new date(datestr);\n  if (date == "invalid date" && datestr) { // 修复new date()在safari下出现invalid date的问题\n    date = new date(datestr.replace(/-/g, \'/\'));\n  }\n  return date.gettime();\n}\n\n// 比对时间\nexport function comparedate(a, b) {\n  return gettimenum(b) - gettimenum(a);\n}\n\n/**\n * 获取两个日期相差多少天\n */\nexport function daydiff(startdate, enddate) {\n  if (!enddate) {\n    enddate = startdate;\n    startdate = new date();\n  }\n  startdate = dateformat(startdate);\n  enddate = dateformat(enddate);\n  let day = parseint(math.abs(new date(startdate) - new date(enddate)) / (1000 * 60 * 60 * 24));\n  return day;\n}\n\n/**\n * 计算相差多少年/月/日/时/分/秒\n */\nexport function timediff(startdate, enddate) {\n  if (!enddate) {\n    enddate = startdate;\n    startdate = new date();\n  }\n  if (!(startdate instanceof date)) {\n    startdate = new date(startdate);\n  }\n  if (!(enddate instanceof date)) {\n    enddate = new date(enddate);\n  }\n  // 计算时间戳的差\n  const diffvalue = parseint((math.abs(enddate - startdate) / 1000));\n  if (diffvalue == 0) {\n    return \'刚刚\';\n  } else if (diffvalue < 60) {\n    return diffvalue + \' 秒\';\n  } else if (parseint(diffvalue / 60) < 60) {\n    return parseint(diffvalue / 60) + \' 分\';\n  } else if (parseint(diffvalue / (60 * 60)) < 24) {\n    return parseint(diffvalue / (60 * 60)) + \' 时\';\n  } else if (parseint(diffvalue / (60 * 60 * 24)) < getdays(startdate.getmonth, startdate.getfullyear)) {\n    return parseint(diffvalue / (60 * 60 * 24)) + \' 天\';\n  } else if (parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear))) < 12) {\n    return parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear))) + \' 月\';\n  } else {\n    return parseint(diffvalue / (60 * 60 * 24 * getdays(startdate.getmonth, startdate.getfullyear) * 12)) + \' 年\';\n  }\n}\n\n/**\n * 判断当前月的天数（28、29、30、31）\n */\nexport function getdays(mouth, year) {\n  let days = 30;\n  if (mouth === 2) {\n    days = year % 4 === 0 ? 29 : 28;\n  } else if (mouth === 1 || mouth === 3 || mouth === 5 || mouth === 7 || mouth === 8 || mouth === 10 || mouth === 12) {\n    // 月份为：1,3,5,7,8,10,12 时，为大月.则天数为 31；\n    days = 31;\n  }\n  return days;\n}\n\n/**\n * 已运行时间低于一天显示时分秒\n * 目前该函数没有使用，低于一天直接显示不到一天\n */\nexport function gettime(startdate, enddate) {\n  if (day < 0) {\n    let hour = parseint(math.abs(new date(startdate) - new date(enddate)) / (1000 * 60 * 60));\n    if (hour > 0) {\n      let minute = parseint(math.abs(new date(startdate) - new date(enddate) - hour * 60 * 60 * 1000) / (1000 * 60));\n      if (minute > 0) {\n        let second = parseint(math.abs(new date(startdate) - new date(enddate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));\n        if (second != 0) {\n          return hour + \' 小时 \' + minute + \' 分钟 \' + second + \' 秒\';\n        } else {\n          return hour + \' 小时 \' + minute + \' 分钟 \';\n        }\n      } else {\n        return hour + \' 小时 \';\n      }\n    } else {\n      let minute = parseint(math.abs(new date(startdate) - new date(enddate) - hour * 60 * 60 * 1000) / (1000 * 60));\n      if (minute > 0) {\n        let second = parseint(math.abs(new date(startdate) - new date(enddate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000));\n        if (second != 0) {\n          return + minute + \' 分钟 \' + second + \' 秒\';\n        } else {\n          return minute + \' 分钟 \';\n        }\n      } else {\n        return parseint(math.abs(new date(startdate) - new date(enddate) - hour * 60 * 60 * 1000 - minute * 60 * 1000) / (1000)) + \' 秒 \';\n      }\n    }\n  }\n}\n\nvar bszcaller, bsztag, scripttag, ready;\n\nvar t,\n  e,\n  n,\n  a = !1,\n  c = [];\n\n// 修复node同构代码的问题\nif (typeof document !== "undefined") {\n  (ready = function (t) {\n    return (\n      a ||\n      "interactive" === document.readystate ||\n      "complete" === document.readystate\n        ? t.call(document)\n        : c.push(function () {\n            return t.call(this);\n          }),\n      this\n    );\n  }),\n    (e = function () {\n      for (var t = 0, e = c.length; t < e; t++) c[t].apply(document);\n      c = [];\n    }),\n    (n = function () {\n      a ||\n        ((a = !0),\n        e.call(window),\n        document.removeeventlistener\n          ? document.removeeventlistener("domcontentloaded", n, !1)\n          : document.attachevent &&\n            (document.detachevent("onreadystatechange", n),\n            window == window.top && (clearinterval(t), (t = null))));\n    }),\n    document.addeventlistener\n      ? document.addeventlistener("domcontentloaded", n, !1)\n      : document.attachevent &&\n        (document.attachevent("onreadystatechange", function () {\n          /loaded|complete/.test(document.readystate) && n();\n        }),\n        window == window.top &&\n          (t = setinterval(function () {\n            try {\n              a || document.documentelement.doscroll("left");\n            } catch (t) {\n              return;\n            }\n            n();\n          }, 5)));\n}\n\nbszcaller = {\n  fetch: function (t, e) {\n    var n = "busuanzicallback_" + math.floor(1099511627776 * math.random());\n    t = t.replace("=busuanzicallback", "=" + n);\n    (scripttag = document.createelement("script")),\n      (scripttag.type = "text/javascript"),\n      (scripttag.defer = !0),\n      (scripttag.src = t),\n      document.getelementsbytagname("head")[0].appendchild(scripttag);\n    window[n] = this.evalcall(e);\n  },\n  evalcall: function (e) {\n    return function (t) {\n      ready(function () {\n        try {\n          e(t),\n            scripttag &&\n              scripttag.parentelement &&\n              scripttag.parentelement.removechild &&\n              scripttag.parentelement.removechild(scripttag);\n        } catch (t) {\n          console.log(t), bsztag.hides();\n        }\n      });\n    };\n  },\n};\n\nexport function fetch() {\n  bsztag && bsztag.hides();\n  bszcaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpcallback=busuanzicallback", function (t) {\n    bsztag.texts(t), bsztag.shows();\n  })\n};\n\nbsztag = {\n  bszs: ["site_pv", "page_pv", "site_uv"],\n  texts: function (n) {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_value_" + t);\n      e && (e.innerhtml = n[t]);\n    });\n  },\n  hides: function () {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_container_" + t);\n      e && (e.style.display = "none");\n    });\n  },\n  shows: function () {\n    this.bszs.map(function (t) {\n      var e = document.getelementbyid("busuanzi_container_" + t);\n      e && (e.style.display = "inline");\n    });\n  },\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n\n\n\n# vue组件创建\n\n需要两个 vue 组件，分别是首页的站点信息模块和文章页信息模块。\n\n在 vdoing/components 目录下创建 webinfo.vue 文件，添加如下内容：\n\n<template>\n  \x3c!-- young kbt --\x3e\n  <div class="web-info card-box">\n    <div class="webinfo-title">\n      <i\n        class="iconfont icon-award"\n        style="font-size: 0.875rem; font-weight: 900; width: 1.25em"\n      ></i>\n      <span>站点信息</span>\n    </div>\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">文章数目：</div>\n      <div class="webinfo-content">{{ mdfilecount }} 篇</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">已运行时间：</div>\n      <div class="webinfo-content">\n        {{ createtonowday != 0 ? createtonowday + " 天" : "不到一天" }}\n      </div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">本站总字数：</div>\n      <div class="webinfo-content">{{ totalwords }} 字</div>\n    </div>\n\n    <div class="webinfo-item">\n      <div class="webinfo-item-title">最后活动时间：</div>\n      <div class="webinfo-content">\n        {{ lastactivedate == "刚刚" ? "刚刚" : lastactivedate + "前" }}\n      </div>\n    </div>\n\n    <div v-if="indexview" class="webinfo-item">\n      <div class="webinfo-item-title">本站被访问了：</div>\n      <div class="webinfo-content">\n        <span id="busuanzi_value_site_pv" class="web-site-pv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        次\n      </div>\n    </div>\n\n    <div v-if="indexview" class="webinfo-item">\n      <div class="webinfo-item-title">您的访问排名：</div>\n      <div class="webinfo-content busuanzi">\n        <span id="busuanzi_value_site_uv" class="web-site-uv"\n          ><i title="正在获取..." class="loading iconfont icon-loading"></i>\n        </span>\n        名\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { daydiff, timediff, lastupdateposts, fetch } from "../util/websiteinfo";\nexport default {\n  data() {\n    return {\n      // young kbt\n      mdfilecount: 0, // markdown 文档总数\n      createtonowday: 0, // 博客创建时间距今多少天\n      lastactivedate: "", // 最后活动时间\n      totalwords: 0, // 本站总字数\n      indexview: true, // 开启访问量和排名统计\n    };\n  },\n  computed: {\n    $lastupdateposts() {\n      return lastupdateposts(this.$filterposts);\n    },\n  },\n  mounted() {\n    // young kbt\n    if (object.keys(this.$themeconfig.bloginfo).length > 0) {\n      const {\n        blogcreate,\n        mdfilecounttype,\n        totalwords,\n        moutedevent,\n        eachfilewords,\n        indexiteration,\n        indexview,\n      } = this.$themeconfig.bloginfo;\n      this.createtonowday = daydiff(blogcreate);\n      if (mdfilecounttype != "archives") {\n        this.mdfilecount = mdfilecounttype.length;\n      } else {\n        this.mdfilecount = this.$filterposts.length;\n      }\n      if (totalwords == "archives" && eachfilewords) {\n        let archiveswords = 0;\n        eachfilewords.foreach((itemfile) => {\n          if (itemfile.wordscount < 1000) {\n            archiveswords += itemfile.wordscount;\n          } else {\n            let wordscount = itemfile.wordscount.slice(\n              0,\n              itemfile.wordscount.length - 1\n            );\n            archiveswords += wordscount * 1000;\n          }\n        });\n        this.totalwords = math.round(archiveswords / 100) / 10 + "k";\n      } else if (totalwords == "archives") {\n        this.totalwords = 0;\n        console.log(\n          "如果 totalwords = \'archives\'，必须传入 eachfilewords，显然您并没有传入！"\n        );\n      } else {\n        this.totalwords = totalwords;\n      }\n      // 最后一次活动时间\n      this.lastactivedate = timediff(this.$lastupdateposts[0].lastupdated);\n      this.mountedwebinfo(moutedevent);\n      // 获取访问量和排名\n      this.indexview = indexview == undefined ? true : indexview;\n      if (this.indexview) {\n        this.getindexviewcouter(indexiteration);\n      }\n    }\n  },\n  methods: {\n    /**\n     * 挂载站点信息模块\n     */\n    mountedwebinfo(moutedevent = ".tags-wrapper") {\n      let interval = setinterval(() => {\n        const tagswrapper = document.queryselector(moutedevent);\n        const webinfo = document.queryselector(".web-info");\n        if (tagswrapper && webinfo) {\n          if (!this.issiblilngnode(tagswrapper, webinfo)) {\n            tagswrapper.parentnode.insertbefore(\n              webinfo,\n              tagswrapper.nextsibling\n            );\n            clearinterval(interval);\n          }\n        }\n      }, 200);\n    },\n    /**\n     * 挂载在兄弟元素后面，说明当前组件是 siblingnode 变量\n     */\n    issiblilngnode(element, siblingnode) {\n      if (element.siblingnode == siblingnode) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n    /**\n     * 首页的统计量\n     */\n    getindexviewcouter(iterationtime = 3000) {\n      fetch();\n      var i = 0;\n      var defaultcouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 settimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 settimeout 的时间（需求调节），settimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      settimeout(() => {\n        let indexuv = document.queryselector(".web-site-pv");\n        let indexpv = document.queryselector(".web-site-uv");\n        if (\n          indexpv &&\n          indexuv &&\n          indexpv.innertext == "" &&\n          indexuv.innertext == ""\n        ) {\n          let interval = setinterval(() => {\n            // 再次判断原因：防止进入 setinterval 的瞬间，访问量获取成功\n            if (\n              indexpv &&\n              indexuv &&\n              indexpv.innertext == "" &&\n              indexuv.innertext == ""\n            ) {\n              i += iterationtime;\n              if (i > iterationtime * 5) {\n                indexpv.innertext = defaultcouter;\n                indexuv.innertext = defaultcouter;\n                clearinterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (indexpv.innertext == "" && indexuv.innertext == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearinterval(interval);\n              }\n            } else {\n              clearinterval(interval);\n            }\n          }, iterationtime);\n          // 绑定 beforedestroy 生命钩子，清除定时器\n          this.$once("hook:beforedestroy", () => {\n            clearinterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationtime);\n    },\n   \n  },\n};\n<\/script>\n\n<style scoped>\n.web-info {\n  font-size: 0.875rem;\n  padding: 0.95rem;\n}\n.webinfo-title {\n  text-align: center;\n  color: #888;\n  font-weight: bold;\n  padding: 0 0 10px 0;\n}\n.webinfo-item {\n  padding: 8px 0 0;\n  margin: 0;\n}\n.webinfo-item-title {\n  display: inline-block;\n}\n.webinfo-content {\n  display: inline-block;\n  float: right;\n}\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n\n\n继续在 vdoing/components 目录下创建 pageinfo.vue 文件，添加如下内容：\n\n<template>\n  <div class="page-view">\n    \x3c!-- 文章字数 --\x3e\n    <div title="文章字数" class="book-words iconfont icon-book">\n      <a href="javascript:;" style="margin-left: 3px; color: #888">{{\n        wordscount\n      }}</a>\n    </div>\n\n    \x3c!-- 预阅读时长 --\x3e\n    <div\n      v-if="readingtime"\n      title="预阅读时长"\n      class="reading-time iconfont icon-shijian"\n    >\n      <a href="javascript:;" style="margin-left: 3px; color: #888">{{\n        readingtime\n      }}</a>\n    </div>\n    \x3c!-- 浏览量 --\x3e\n    <div v-if="pageview" title="浏览量" class="page-view iconfont icon-view">\n      <a\n        style="color: #888; margin-left: 3px"\n        href="javascript:;"\n        id="busuanzi_value_page_pv"\n        class="view-data"\n        ><i title="正在获取..." class="loading iconfont icon-loading"></i\n      ></a>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { fetch } from "../util/websiteinfo";\nexport default {\n  data() {\n    return {\n      // young kbt\n      wordscount: 0,\n      readingtime: 0,\n      pageview: true,\n      pageiteration: 3000,\n    };\n  },\n  mounted() {\n    this.initpageinfo();\n  },\n  watch: {\n    $route(to, from) {\n      if (\n        to.path !== "/" &&\n        to.path != from.path &&\n        this.$themeconfig.bloginfo\n      ) {\n        this.initpageinfo();\n      }\n    },\n  },\n  methods: {\n    /**\n     * 初始化页面信息\n     */\n    initpageinfo() {\n      this.$filterposts.foreach((itempage) => {\n        if (itempage.path == this.$route.path) {\n          const { eachfilewords, pageview, pageiteration, readingtime } =\n            this.$themeconfig.bloginfo;\n          this.pageiteration = pageiteration;\n          if (eachfilewords) {\n            eachfilewords.foreach((itemfile) => {\n              if (itemfile.permalink == itempage.frontmatter.permalink) {\n                this.wordscount = itemfile.wordscount;\n                if (readingtime || readingtime == undefined) {\n                  this.readingtime = itemfile.readingtime;\n                } else {\n                  this.readingtime = false;\n                }\n              }\n            });\n          }\n          this.pageview = pageview == undefined ? true : pageview;\n          if (this.pageview) {\n            this.getpageviewcouter(this.pageiteration);\n          }\n          return;\n        }\n      });\n    },\n    /**\n     * 文章页的访问量\n     */\n    getpageviewcouter(iterationtime = 3000) {\n      fetch();\n      let i = 0;\n      var defaultcouter = "9999";\n      // 如果只需要第一次获取数据（可能获取失败），可注释掉 settimeout 内容，此内容是第一次获取失败后，重新获取访问量\n      // 可能会导致访问量再次 + 1 原因：取决于 settimeout 的时间（需求调节），settimeout 太快导致第一个获取的数据没返回，就第二次获取，导致结果返回 + 2 的数据\n      settimeout(() => {\n        let pageview = document.queryselector(".view-data");\n        if (pageview && pageview.innertext == "") {\n          let interval = setinterval(() => {\n            // 再次判断原因：防止进入 setinterval 的瞬间，访问量获取成功\n            if (pageview && pageview.innertext == "") {\n              i += iterationtime;\n              if (i > iterationtime * 5) {\n                pageview.innertext = defaultcouter;\n                clearinterval(interval); // 5 次后无法获取，则取消获取\n              }\n              if (pageview.innertext == "") {\n                // 手动获取访问量\n                fetch();\n              } else {\n                clearinterval(interval);\n              }\n            } else {\n              clearinterval(interval);\n            }\n          }, iterationtime);\n          // 绑定 beforedestroy 生命钩子，清除定时器\n          this.$once("hook:beforedestroy", () => {\n            clearinterval(interval);\n            interval = null;\n          });\n        }\n      }, iterationtime);\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.page-view > div {\n  float: left;\n  margin-left: 20px;\n  font-size: 0.8rem;\n}\n\n@keyframes turn {\n  0% {\n    transform: rotate(0deg);\n  }\n\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n.loading {\n  display: inline-block;\n  animation: turn 1s linear infinite;\n  -webkit-animation: turn 1s linear infinite;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n\n\n\n# vue组件引用\n\n写好两个组件，那么我们需要使用它们。\n\n> 引入 webinfo.vue 组件\n\n打开 vdoing/components/home.vue 文件。\n\n大概在 174 行处引入 webinfo.vue 组件：\n\nimport webinfo from \'./webinfo.vue\';\n\n\n1\n\n\n大概在 242 行处找到 components 注册该组件：\n\ncomponents: { ......, webinfo },\n\n\n1\n\n\n大概在 153 行处（div 的 class 为 custom-html-box 的上方），添加如下内容：\n\n<webinfo />\n\n\n1\n\n\n三个效果图：\n\n\n\n\n\n\n\n> 引入 pageinfo.vue 组件\n\n打开 vdoing/components/articleinfo.vue 文件。\n\n大概在 67 行处引入 pagesview.vue 组件：\n\nimport pageinfo from \'./pageinfo.vue\';\n\n\n1\n\n\n大概在 69 行处添加 components 注册该组件（data() 上方）：\n\ncomponents: { pageinfo },\n\n\n1\n\n\n大概在 61 行处，添加如下内容：\n\n<pageinfo style="margin-left: 0" />\n\n\n1\n\n\n效果图：\n\n\n\n\n# 核心配置文件\n\n在 docs/.vuepress 目录下创建 websiteinfo 文件夹，并在文件夹里创建 readfile.js 文件。\n\n添加如下内容：\n\nconst fs = require(\'fs\'); // 文件模块\nconst path = require(\'path\'); // 路径模块\nconst matter = require(\'gray-matter\'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst chalk = require(\'chalk\') // 命令行打印美化\nconst log = console.log\nconst docsroot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readfilelist(excludefiles = [\'\'], dir = docsroot, fileslist = []) {\n  const files = fs.readdirsync(dir);\n  files.foreach((item, index) => {\n    let filepath = path.join(dir, item);\n    const stat = fs.statsync(filepath);\n    if (!(excludefiles instanceof array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludefiles.foreach((excludefile) => {\n      if (stat.isdirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludefile) {\n        readfilelist(excludefiles, path.join(dir, item), fileslist);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const filenamearr = path.basename(filepath).split(\'.\')\n          let name = null, type = null;\n          if (filenamearr.length === 2) { // 没有序号的文件\n            name = filenamearr[0]\n            type = filenamearr[1]\n          } else if (filenamearr.length === 3) { // 有序号的文件\n            name = filenamearr[1]\n            type = filenamearr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filepath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            fileslist.push({\n              name,\n              filepath\n            });\n          }\n        }\n      }\n    });\n  });\n  return fileslist;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readtotalfilewords(excludefiles = [\'\']) {\n  const fileslist = readfilelist(excludefiles);\n  var wordcount = 0;\n  fileslist.foreach((item) => {\n    const content = getcontent(item.filepath);\n    var len = counter(content);\n    wordcount += len[0] + len[1];\n  });\n  if (wordcount < 1000) {\n    return wordcount;\n  }\n  return math.round(wordcount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readeachfilewords(excludefiles = [\'\'], cn, en) {\n  const fileslistwords = [];\n  const fileslist = readfilelist(excludefiles);\n  fileslist.foreach((item) => {\n    const content = getcontent(item.filepath);\n    var len = counter(content);\n    // 计算预计的阅读时间\n    var readingtime = readtime(len, cn, en);\n    var wordscount = 0;\n    wordscount = len[0] + len[1];\n    if (wordscount >= 1000) {\n      wordscount = math.round(wordscount / 100) / 10 + \'k\';\n    }\n    // filematterobj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const filematterobj = matter(content, {});\n    const matterdata = filematterobj.data;\n    fileslistwords.push({ ...item, wordscount, readingtime, ...matterdata });\n  });\n  return fileslistwords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readtime(len, cn = 300, en = 160) {\n  var readingtime = len[0] / cn + len[1] / en;\n  if (readingtime > 60 && readingtime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = parseint(readingtime / 60);\n    let minute = parseint((readingtime - hour * 60));\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingtime > 60 * 24) {      // 大于一天\n    let day = parseint(readingtime / (60 * 24));\n    let hour = parseint((readingtime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingtime < 1 ? \'1\' : parseint((readingtime * 10)) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getcontent(filepath) {\n  return fs.readfilesync(filepath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content) {\n  const cn = (content.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n  const en = (content.replace(/[\\u4e00-\\u9fa5]/g, \'\').match(/[a-za-z0-9_\\u0392-\\u03c9\\u0400-\\u04ff]+|[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04ff]+|[\\u00e4\\u00c4\\u00e5\\u00c5\\u00f6\\u00d6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nmodule.exports = {\n  readfilelist,\n  readtotalfilewords,\n  readeachfilewords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\nimport fs from \'fs\'; // 文件模块\nimport path from \'path\'; // 路径模块\nimport matter from \'gray-matter\'; // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nimport chalk from \'chalk\' // 命令行打印美化\nconst log = console.log\nconst docsroot = path.join(__dirname, \'..\', \'..\', \'..\', \'docs\'); // docs文件路径\n\n/**\n * 获取本站的文章数据\n * 获取所有的 md 文档，可以排除指定目录下的文档\n */\nfunction readfilelist(excludefiles: array<string> = [\'\'], dir: string = docsroot, fileslist: array<object> = []) {\n  const files = fs.readdirsync(dir);\n  files.foreach((item, index) => {\n    let filepath = path.join(dir, item);\n    const stat = fs.statsync(filepath);\n    if (!(excludefiles instanceof array)) {\n      log(chalk.yellow(`error: 传入的参数不是一个数组。`))\n    }\n    excludefiles.foreach((excludefile) => {\n      if (stat.isdirectory() && item !== \'.vuepress\' && item !== \'@pages\' && item !== excludefile) {\n        readfilelist(excludefiles, path.join(dir, item), fileslist);  //递归读取文件\n      } else {\n        if (path.basename(dir) !== \'docs\') { // 过滤 docs目录级下的文件\n\n          const filenamearr = path.basename(filepath).split(\'.\')\n          let name = null, type = null;\n          if (filenamearr.length === 2) { // 没有序号的文件\n            name = filenamearr[0]\n            type = filenamearr[1]\n          } else if (filenamearr.length === 3) { // 有序号的文件\n            name = filenamearr[1]\n            type = filenamearr[2]\n          } else { // 超过两个‘.’的\n            log(chalk.yellow(`warning: 该文件 "${filepath}" 没有按照约定命名，将忽略生成相应数据。`))\n            return\n          }\n          if (type === \'md\') { // 过滤非 md 文件\n            fileslist.push({\n              name,\n              filepath\n            });\n          }\n        }\n      }\n    });\n  });\n  return fileslist;\n}\n/**\n * 获取本站的文章总字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readtotalfilewords(excludefiles = [\'\']) {\n  const fileslist = readfilelist(excludefiles);\n  let wordcount = 0;\n  fileslist.foreach((item: any) => {\n    const content = getcontent(item.filepath);\n    let len = counter(content);\n    wordcount += len[0] + len[1];\n  });\n  if (wordcount < 1000) {\n    return wordcount;\n  }\n  return math.round(wordcount / 100) / 10 + \'k\';\n}\n/**\n * 获取每一个文章的字数\n * 可以排除某个目录下的 md 文档字数\n */\nfunction readeachfilewords(excludefiles: array<string> = [\'\'], cn: number, en: number) {\n  const fileslistwords = [];\n  const fileslist = readfilelist(excludefiles);\n  fileslist.foreach((item: any) => {\n    const content = getcontent(item.filepath);\n    let len = counter(content);\n    // 计算预计的阅读时间\n    let readingtime = readtime(len, cn, en);\n    let wordscount: any = 0;\n    wordscount = len[0] + len[1];\n    if (wordscount >= 1000) {\n      wordscount = math.round(wordscount / 100) / 10 + \'k\';\n    }\n    // filematterobj => {content:\'剔除frontmatter后的文件内容字符串\', data:{<frontmatter对象>}, ...}\n    const filematterobj = matter(content, {});\n    const matterdata = filematterobj.data;\n    fileslistwords.push({ ...item, wordscount, readingtime, ...matterdata });\n  });\n  return fileslistwords;\n}\n\n/**\n * 计算预计的阅读时间\n */\nfunction readtime(len: array<number>, cn: number = 300, en: number = 160) {\n  let readingtime = len[0] / cn + len[1] / en;\n  if (readingtime > 60 && readingtime < 60 * 24) {   // 大于一个小时，小于一天\n    let hour = math.trunc(readingtime / 60);\n    let minute = math.trunc(readingtime - hour * 60);\n    if (minute === 0) {\n      return hour + \'h\';\n    }\n    return hour + \'h\' + minute + \'m\';\n  } else if (readingtime > 60 * 24) {      // 大于一天\n    let day = math.trunc(readingtime / (60 * 24));\n    let hour = math.trunc((readingtime - day * 24 * 60) / 60);\n    if (hour === 0) {\n      return day + \'d\';\n    }\n    return day + \'d\' + hour + \'h\';\n  }\n  return readingtime < 1 ? \'1\' : math.trunc(readingtime * 10) / 10 + \'m\';   // 取一位小数\n}\n\n/**\n * 读取文件内容\n */\nfunction getcontent(filepath: string) {\n  return fs.readfilesync(filepath, \'utf8\');\n}\n/**\n * 获取文件内容的字数\n * cn：中文\n * en：一整句英文（没有空格隔开的英文为 1 个）\n */\nfunction counter(content: string) {\n  const cn = (content.match(/[\\u4e00-\\u9fa5]/g) || []).length;\n  const en = (content.replace(/[\\u4e00-\\u9fa5]/g, \'\').match(/[a-za-z0-9_\\u0392-\\u03c9\\u0400-\\u04ff]+|[\\u4e00-\\u9fff\\u3400-\\u4dbf\\uf900-\\ufaff\\u3040-\\u309f\\uac00-\\ud7af\\u0400-\\u04ff]+|[\\u00e4\\u00c4\\u00e5\\u00c5\\u00f6\\u00d6]+|\\w+/g) || []).length;\n  return [cn, en];\n}\n\nexport {\n  readfilelist,\n  readtotalfilewords,\n  readeachfilewords,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n\n\n\n# 配置站点信息\n\n最后一步，在 docs/.vuepress/config.js（新版为 config.ts）文件，引入写好的 readfile.js 文件（路径要准确，这里仅仅是模板）\n\nconst { readfilelist, readtotalfilewords, readeachfilewords } = require(\'./websiteinfo/readfile\');\n\n\n1\n\n\nimport { readfilelist, readtotalfilewords, readeachfilewords } from \'./websiteinfo/readfile\';\n\n\n1\n\n\n如图（演示 js 代码块）：\n\n\n\n在 themeconfig 中添加如下内容：\n\n// 站点配置（首页 & 文章页）\nbloginfo: {\n  blogcreate: \'2021-10-19\', // 博客创建时间\n  indexview: true,  // 开启首页的访问量和排名统计，默认 true（开启）\n  pageview: true,  // 开启文章页的浏览量统计，默认 true（开启）\n  readingtime: true,  // 开启文章页的预计阅读时间，条件：开启 eachfilewords，默认 true（开启）。可在 eachfilewords 的 readeachfilewords 的第二个和第三个参数自定义，默认 1 分钟 300 中文、160 英文\n  eachfilewords: readeachfilewords([\'\'], 300, 160),  // 开启每个文章页的字数。readeachfilewords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数。无默认值。readeachfilewords() 方法默认排除了 article 为 false 的文章\n  mdfilecounttype: \'archives\',  // 开启文档数。1. archives 获取归档的文档数（默认）。2. 数组 readfilelist([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文档数。提示：readfilelist() 获取 docs 下所有的 md 文档（除了 `.vuepress` 和 `@pages` 目录下的文档）\n  totalwords: \'archives\',  // 开启本站文档总字数。1. archives 获取归档的文档数（使用 archives 条件：传入 eachfilewords，否则报错）。2. readtotalfilewords([\'xx\']) 排除 xx 目录（可多个，可不传参数），获取其他目录的文章字数。无默认值\n  moutedevent: \'.tags-wrapper\',   // 首页的站点模块挂载在某个元素后面（支持多种选择器），指的是挂载在哪个兄弟元素的后面，默认是热门标签 \'.tags-wrapper\' 下面，提示：\'.categories-wrapper\' 会挂载在文章分类下面。\'.blogger-wrapper\' 会挂载在博客头像模块下面\n  // 下面两个选项：第一次获取访问量失败后的迭代时间\n  indexiteration: 2500,   // 如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  pageiteration: 2500,    // 如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n  // 说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如图（图片内容不一定是最新）：\n\n\n\n属性配置的具体介绍请看 属性配置。\n\n\n# 属性配置\n\nblogcreate\n\n * 类型：string\n * 默认值：当前时间（new date()）\n * 格式：yyyy-mm-dd\n\n博客创建时间。如果不添加时间，页面上显示 0 天。\n\nmdfilecounttype\n\n * 类型：string | readfilelist()\n * 参数：数组\n * 默认值：archives\n\n文章数目。如果不添加内容，页面上显示归档的文章数目。\n\nreadfilelist 是一个 js 文件，需要引入，参数是 目录的全名，最终效果会 排除该目录里的文章数，可多选，逗号隔开。也可不传参数。\n\n温馨提示：readfilelist() 不传参数会获取 docs 下所有的 md 文档（除了 .vuepress 和 @pages 目录下的文档）。\n\ntotalwords\n\n * 类型：string | readfilewords()\n * 参数：数组\n * 默认值：null\n\n本站文档总字数。如果不添加内容，页面上显示 0 字。\n\nstring 仅支持 archives，并且使用该类型有条件：必须使用 eachfilewords，否则报错。\n\nreadfilewords 是一个 js 文件，需要引入，参数是目录的全名，最终效果会 排除该目录里的文章字数，可多选，逗号隔开。也可不传参数。\n\nmoutedevent\n\n * 类型：string\n * 默认值：.tags-wrapper\n\n选择挂载的元素属性，支持多种选择器（id、class ......），该模块会挂载到该元素后面，形成兄弟元素。（仅支持首页的元素）。\n\n温馨提示：.categories-wrapper 会挂载在文章分类下面；.blogger-wrapper 会挂载在头像模块下面；.icons 会挂载在头像下方、图标上方。\n\n默认是热门标签 .tags-wrapper 下面。\n\nindexview\n\n * 类型：boolean\n * 默认值：true\n\n开启首页的访问量和排名统计，默认 true(开启)。\n\npageview\n\n * 类型 boolean\n * 默认值：true\n\n开启文章页的浏览量统计，默认 true（开启）。\n\neachfilewords\n\n * 类型：readeachfilewords()\n * 参数：数组\n * 默认值：null\n\n开启每个文章页的字数。如果不添加内容，则不开启。\n\nreadeachfilewords([\'xx\']) 关闭 xx 目录（可多个，可不传参数）下的文章页字数和阅读时长。\n\nreadeachfilewords() 第一个参数是数组，后面两个参数分别是 1 分钟里能阅读的中文字数和英文字数，配合 readingtime 使用。\n\nreadeachfilewords() 方法默认排除了 article 为 false 的文章。\n\nreadingtime\n\n * 类型：boolean\n\n * 默认值：true\n\n * 条件：使用 eachfilewords\n\n开启文章页的预计阅读时间。默认阅读中文 1 分钟 300 个字，英文 1 分钟 160 个字。如果想自定义阅读文字时长，请在 eachfilewords 的 readeachfilewords() 传入后面两个参数。分别为 1 分钟阅读的中文和英文个数。\n\nindexiteration\n\n * 类型：number\n * 默认值：3000\n\n如果首页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。\n\n注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n\npageiteration\n\n * 类型：number\n * 默认值：3000\n\n如果文章页获取访问量失败，则每隔多少时间后获取一次访问量，直到获取成功或获取 10 次后。默认 3 秒。\n\n注意：设置时间太低，可能导致访问量 + 2、+ 3 ......\n\n说明：成功获取一次访问量，访问量 + 1，所以第一次获取失败后，设置的每个隔段重新获取时间，将会影响访问量的次数。如 100 可能每次获取访问量 + 3。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 私密文章模块",frontmatter:{title:"本站 - 私密文章模块",date:"2022-01-07T17:05:56.000Z",permalink:"/about/website/private/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/22.%E6%9C%AC%E7%AB%99%20-%20%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/22.本站 - 私密文章模块.md",key:"v-798ab013",path:"/about/website/private/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:75},{level:2,title:"组件添加",slug:"组件添加",normalizedTitle:"组件添加",charIndex:81},{level:2,title:"组件引用",slug:"组件引用",normalizedTitle:"组件引用",charIndex:89},{level:2,title:"路由监听",slug:"路由监听",normalizedTitle:"路由监听",charIndex:97},{level:2,title:"安全检测代码",slug:"安全检测代码",normalizedTitle:"安全检测代码",charIndex:105},{level:2,title:"配置添加",slug:"配置添加",normalizedTitle:"配置添加",charIndex:115},{level:2,title:"配置介绍",slug:"配置介绍",normalizedTitle:"配置介绍",charIndex:123},{level:2,title:"key介绍",slug:"key介绍",normalizedTitle:"key介绍",charIndex:131},{level:2,title:"开启私密文章",slug:"开启私密文章",normalizedTitle:"开启私密文章",charIndex:140},{level:2,title:"进入网站验证",slug:"进入网站验证",normalizedTitle:"进入网站验证",charIndex:150},{level:2,title:"管理员验证",slug:"管理员验证",normalizedTitle:"管理员验证",charIndex:160},{level:2,title:"全局私密验证",slug:"全局私密验证",normalizedTitle:"全局私密验证",charIndex:169},{level:2,title:"单私密文章验证",slug:"单私密文章验证",normalizedTitle:"单私密文章验证",charIndex:179},{level:2,title:"举例",slug:"举例",normalizedTitle:"举例",charIndex:190},{level:3,title:"例1",slug:"例1",normalizedTitle:"例1",charIndex:198},{level:3,title:"例2",slug:"例2",normalizedTitle:"例2",charIndex:206},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:212}],headersStr:"前言 组件添加 组件引用 路由监听 安全检测代码 配置添加 配置介绍 key介绍 开启私密文章 进入网站验证 管理员验证 全局私密验证 单私密文章验证 举例 例1 例2 结束语",content:'笔记\n\n本站实现了私密文章功能，当大家想要「云端备份」到博客时，又不希望别人看到，该功能能满足你。\n\n2022-01-07 @Du Wu\n\n\n\n * 前言\n * 组件添加\n * 组件引用\n * 路由监听\n * 安全检测代码\n * 配置添加\n * 配置介绍\n * key介绍\n * 开启私密文章\n * 进入网站验证\n * 管理员验证\n * 全局私密验证\n * 单私密文章验证\n * 举例\n   * 例1\n   * 例2\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n本功能不是插件，好处在于你可以自定义喜欢的页面。\n\n如果你想先体验私密文章的效果，请访问：\n\n * 全局私密文章测试\n\n * 单个私密文章测试\n\n本模块分为四步：\n\n * 创建 Login.vue 组件\n * 创建一个 markdown 文档，引用 Login.vue 组件\n * 监听路由，跳转前判断是否为私有文章，是否登录过，或是否登录状态过期\n * 在 themeConfig 里添加一些配置信息\n\n本模块功能：\n\n * 网站验证功能：用于封锁整个网站，当第一次访问网站，需要进行验证登录，支持多组用户名和密码\n * 私密文章验证功能：访问一篇文章时要进行验证登录，支持一篇私密文章多组用户名和密码\n * 管理员验证功能：以管理员进行验证成功，网站和所有私密文章无需验证，直接访问\n * 有效时间功能：验证成功后，在有效时间内的访问都不需要验证，支持天和小时为单位\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n首先在 .vuepress/config.js 的 head 模块添加在线图标。图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n[\'link\', { rel: \'stylesheet\', href: \'https://at.alicdn.com/t/font_3129839_xft6cqs5gc.css\' }], // 阿里在线图标\n\n\n1\n\n\n\n\n在 doc/.vuepress 目录下，创建 components 文件夹，如果有，则不需要创建。\n\n接着在 components 文件夹下创建 Login.vue 组件，该组件是登录的表单，可以根据需求自行修改。\n\n一定是 components 文件夹且路径要对，因为 Vuepress 会自动全局注册该文件夹下的所有 .vue 组件。\n\n在 Login.vue 添加如下内容：\n\n<template>\n  <div class="login-form">\n    <div class="form-header">用户名</div>\n    <div>\n      <input\n        type="text"\n        class="form-control"\n        placeholder="请输入用户名 ..."\n        v-model="username"\n      />\n    </div>\n    <div class="form-header">密码</div>\n    <div>\n      <input\n        type="password"\n        class="form-control"\n        placeholder="请输入密码 ..."\n        v-model="password"\n      />\n    </div>\n\n    <div class="btn-row">\n      <button class="btn" @click="login">登录</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      username: "",\n      password: "",\n      privateInfo: {\n        username: "",\n        password: "",\n        loginKey: "",\n        expire: "",\n        loginInfo: "",\n        allLoginKey: "kbt",\n      },\n    };\n  },\n  mounted() {\n    // Enter 键也能触发登录按钮\n    document.onkeyup = (e) => {\n      let key = window.event.keyCode;\n      if (key == 13) {\n        this.login();\n      }\n    };\n  },\n  methods: {\n    /**\n     * 登录验证\n     */\n    login() {\n      let { privateInfo } = this;\n      // 获取全局配置\n      let { username, password, loginKey, expire, firstLoginKey, loginInfo } =\n        this.$themeConfig.privatePage;\n      !loginKey && (loginKey = "vdoing_manager"); // 默认为 vdoing_manager\n      // 计算正确的过期时间\n      expire = this.getExpire(expire);\n      !expire && (expire = 86400000);\n      if (this.username && this.password) {\n        // 进入网站前进行验证\n        if (this.$route.query.verifyMode == "first") {\n          privateInfo.expire = expire;\n          !firstLoginKey && (firstLoginKey = "vdoing_first_login"); // 默认为 vdoing_first_login\n          // 检查 loginInfo 是否验证成功\n          let check = false;\n          if (loginInfo && loginInfo.hasOwnProperty(firstLoginKey)) {\n            check = this.checkLoginInfoAndJump(\n              loginInfo[firstLoginKey],\n              firstLoginKey\n            );\n          }\n          // 如果第一次进入网站以管理员登录，则网站的所有私密文章不再需要验证\n          if (\n            !check &&\n            this.username == username &&\n            this.password == password\n          ) {\n            // 如果管理员登录，直接 key = vdoing_manager，不需要再次 key = vdoing_first_login\n            // this.storageLocalAndJump(firstLoginKey, false);\n            this.storageLocalAndJump(loginKey, true);\n          } else if (!check) {\n            this.password = ""; // 清空密码\n            addTip(\n              "用户名或者密码错误！请联系博主获取用户名和密码！",\n              "danger"\n            );\n          }\n        } else {\n          // 如果是单个文章验证\n          if (this.$route.query.verifyMode == "single") {\n            try {\n              this.$filterPosts.forEach((item) => {\n                if (item.path == this.$route.query.toPath) {\n                  privateInfo.username = item.frontmatter.username;\n                  privateInfo.password = item.frontmatter.password;\n                  privateInfo.loginKey = item.frontmatter.permalink;\n                  privateInfo.expire =\n                    this.getExpire(item.frontmatter.expire) || expire;\n                  privateInfo.loginInfo = item.frontmatter.loginInfo;\n                  // 利用异常机制跳出 forEach 循环，break、return、continue 不会起作用\n                  throw new Error();\n                }\n              });\n            } catch (e) {}\n          }\n          // checkLoginInfo：判断是否进行了 loginInfo 验证\n          let checkLoginInfo = false;\n          // 如果没有配置单私密文章用户信息，则使用全局配置\n          if (\n            !privateInfo.username &&\n            !privateInfo.password &&\n            !privateInfo.loginInfo\n          ) {\n            privateInfo.loginKey = this.$route.query.toPath;\n            privateInfo.loginInfo = loginInfo;\n            privateInfo.expire ? "" : (privateInfo.expire = expire);\n          }\n          // 先进行 loginInfo 验证\n          if (privateInfo.loginInfo) {\n            // 如果是数组：即单个文章设置的 loginInfo\n            if (Array.isArray(privateInfo.loginInfo)) {\n              checkLoginInfo = this.checkLoginInfoAndJump(\n                privateInfo.loginInfo\n              );\n            } else if (\n              privateInfo.loginInfo.hasOwnProperty(this.$route.query.toPath)\n            ) {\n              // 如果是对象，即全局设置的 loginInfo\n              checkLoginInfo = this.checkLoginInfoAndJump(\n                privateInfo.loginInfo[this.$route.query.toPath]\n              );\n            }\n          }\n          // 如果没有触发 loginInfo 验证或者 loginInfo 验证失败，则进行单个用户名密码验证\n          if (!checkLoginInfo) {\n            // 如果使用文章配置的用户名密码\n            if (\n              this.username == privateInfo.username &&\n              this.password == privateInfo.password\n            ) {\n              this.storageLocalAndJump(this.privateInfo.loginKey, true);\n            } else if (\n              // 如果使用全局配置的用户名密码\n              this.username == username &&\n              this.password == password\n            ) {\n              this.storageLocalAndJump(loginKey, true);\n            } else {\n              this.password = ""; // 清空密码\n              addTip(\n                "用户名或者密码错误！请联系博主获取用户名和密码！",\n                "danger"\n              );\n            }\n          }\n        }\n      } else if (this.username == "" && this.password != "") {\n        addTip("用户名不能为空！", "warning");\n      } else if (this.username != "" && this.password == "") {\n        addTip("密码不能为空！", "warning");\n      } else {\n        addTip("您访问的文章是私密文章，请先输入用户名和密码！", "info");\n      }\n    },\n    /**\n     * 检查 loginInfo 里的用户名和密码\n     * 匹配成功返回 true，失败返回 false\n     */\n    checkLoginInfoAndJump(\n      loginInfo = this.privateInfo.loginInfo,\n      loginKey = this.privateInfo.loginKey\n    ) {\n      try {\n        loginInfo.forEach((item) => {\n          if (\n            this.username == item.username &&\n            this.password == item.password\n          ) {\n            this.storageLocalAndJump(loginKey, true);\n            // 利用异常机制跳出 forEach 循环，break、return、continue 不会起作用\n            throw new Error();\n          }\n        });\n      } catch (error) {\n        return true;\n      }\n      return false;\n    },\n    /**\n     * 添加登录信息到本地存储区，并跳转到私密文章\n     * loginKey：存储到本地的 key，方便自动验证\n     * jump：是否跳转到私密文章，默认存储到本地后跳转\n     */\n    storageLocalAndJump(loginKey = this.privateInfo.loginKey, jump = true) {\n      const data = JSON.stringify({\n        username: this.username,\n        password: this.password,\n        time: new Date().getTime(),\n        expire: this.privateInfo.expire,\n      });\n      window.localStorage.setItem(loginKey, data);\n      if (jump) {\n        addTip("登录成功，正在跳转 ...", "success");\n        if (this.$route.query.toPath) {\n          this.$router.push({\n            path: this.$route.query.toPath,\n          });\n        } else {\n          this.$router.push({\n            path: "/",\n          });\n        }\n      }\n    },\n    /**\n     * 计算过期时间\n     */\n    getExpire(expire) {\n      if (expire) {\n        if (expire.indexOf("d") !== -1) {\n          expire = parseInt(expire.replace("d", "")) * 24 * 60 * 60 * 1000; // 天\n        } else if (expire.indexOf("h") !== -1) {\n          expire = parseInt(expire.replace("h", "")) * 60 * 60 * 1000; // 小时\n        } else {\n          expire = parseInt(expire) * 1000; // 不加单位为秒\n        }\n      }\n      return expire;\n    },\n  },\n};\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startHeight：第一个弹窗的高度，默认 50\n * dieTime：弹窗消失时间（毫秒），默认 3000 毫秒\n */\nfunction addTip(content, type, startHeight = 50, dieTime = 3000) {\n  var tip = document.querySelectorAll(".global-tip");\n  var time = new Date().getTime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getAttribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lastTop =\n    parseInt(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetHeight + 17 : startHeight);\n\n  let div = document.createElement("div");\n  div.className = `global-tip tip-${type} ${time}`;\n  div.style.top = parseInt(top) + "px";\n  div.setAttribute("data-top", lastTop);\n  if (type == "info" || type == 1) {\n    div.innerHTML = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerHTML = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerHTML = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerHTML = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendChild(div);\n\n  let timeTip = document.getElementsByClassName(time)[0];\n  setTimeout(() => {\n    timeTip.style.top = parseInt(lastTop) + "px";\n    timeTip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dieTime 秒后隐藏并被删除\n  setTimeout(() => {\n    timeTip.style.top = "0px";\n    timeTip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var allTipElement = nextAllTipElement(timeTip);\n    for (let i = 0; i < allTipElement.length; i++) {\n      var next = allTipElement[i];\n      var top =\n        parseInt(next.getAttribute("data-top")) - next.offsetHeight - 17;\n      next.setAttribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    setTimeout(() => {\n      timeTip.remove();\n    }, 500);\n  }, dieTime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextAllTipElement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextSibling) {\n    if (n.nodeType === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style lang="stylus">\n.login-form {\n  padding: 1rem;\n  box-sizing: border-box;\n\n  .btn-row {\n    margin-top: 1rem;\n    text-align: center;\n  }\n\n  .btn {\n    padding: 0.6rem 2rem;\n    outline: none;\n    background-color: #60C084;\n    color: white;\n    border: 0;\n    cursor: pointer;\n  }\n\n  .form-header {\n    color: #13b9e2;\n    margin-bottom: 0.5rem;\n  }\n\n  .form-control {\n    padding: 0.6rem;\n    border: 2px solid #ddd;\n    width: 100%;\n    margin-bottom: 0.5rem;\n    box-sizing: border-box;\n    outline: none;\n    transition: border 0.2s ease;\n\n    &:focus {\n      border: 2px solid #aaa;\n    }\n  }\n}\n\ndiv.v-dialog-overlay {\n  opacity: 1 !important;\n}\n\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translateX(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n\n\n\n# 组件引用\n\nLogin.vue 文件写好后需要引用，在 docs 目录下 的任意位置创建一个 markdown 文档，如我就在 docs 的根目录下创建 99.Vdoing私密文章登录.md 文件。\n\n添加如下内容：(需要修改 frontmatter 为自己的内容)\n\n---\ntitle: Vdoing私密文章登录   # 可修改\ndate: 2022-01-07 14:26:04 # 你的创建时间，可修改\npermalink: /vdoing/login/  # 可修改，建议按步骤使用，后面用到这个 permalink，否则要改一起改\nsidebar: false\narticle: false\ncomment: false\neditLink: false\n---\n\n您当前访问的是博主的私密文章，请输入有效的用户名和密码。如果没有，请在评论区或者其他途径向博主获取。\n\n<ClientOnly>\n  <Login/>\n</ClientOnly>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n记住你的 permalink，后面的 配置添加 需要用到。\n\n<ClientOnly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n\n# 路由监听\n\n打开 docs/enhanceApp.js 文件，添加如下内容：\n\nexport default ({\n    Vue, // VuePress 正在使用的 Vue 构造函数\n    options, // 附加到根实例的一些选项\n    router, // 当前应用的路由实例\n    siteData, // 站点元数据\n    isServer // 当前应用配置是处于 服务端渲染 或 客户端\n}) => {\n  /**\n   * 私密文章验证\n   */\n  if (!isServer) {\n    // 如果开启了私密文章验证\n    if (\n      siteData.themeConfig.privatePage &&\n      siteData.themeConfig.privatePage.openPrivate\n    ) {\n      router.beforeEach((to, from, next) => {\n        try {\n          let {\n            username,\n            password,\n            loginPath,\n            loginKey,\n            loginSession,\n            loginInfo,\n            firstLogin,\n            firstLoginKey,\n          } = siteData.themeConfig.privatePage;\n          !loginKey && (loginKey = "vdoing_manager"); // 默认为 vdoing_manager\n          !firstLoginKey && (firstLoginKey = "vdoing_first_login"); // 默认为 vdoing_first_login\n          // 网站关闭或者刷新后，清除登录状态\n          if (loginSession) {\n            window.addEventListener("unload", function () {\n              localStorage.removeItem(loginKey);\n              localStorage.removeItem(firstLoginKey);\n            });\n          }\n          // 如果是登录页面，不需要验证\n          if (loginPath == to.path || !loginPath) {\n            throw new Error("无需验证");\n          }\n          // 尝试获取管理员曾经登录的用户信息\n          let globalInfo = JSON.parse(localStorage.getItem(loginKey));\n          // 管理员用户名密码验证\n          if (\n            globalInfo &&\n            globalInfo.username == username &&\n            globalInfo.password == password\n          ) {\n            // 存在曾经登录信息，如果登录状态过期\n            if (new Date() - globalInfo.time > globalInfo.expire) {\n              localStorage.removeItem(loginKey);\n            } else {\n              throw new Error("管理员验证成功！");\n            }\n          }\n          // 整个网站进入前需要验证\n          let isAgainLogin = true;\n          if (parseInt(firstLogin) == 1 || parseInt(firstLogin) == 2) {\n            parseInt(firstLogin) == 2 && (isAgainLogin = false);\n            // 尝试获取第一次访问网站曾经登录的用户信息\n            let firstLoginInfo = JSON.parse(\n              localStorage.getItem(firstLoginKey)\n            );\n            !firstLoginInfo && jumpToLogin(loginPath, to.path, "first");\n            if (firstLoginInfo) {\n              // 先判断 loginInfo 是否存在，然后判断 loginInfo 是否对象，最后判断 loginInfo 是否有 firstLoginKey\n              if (loginInfo && loginInfo.hasOwnProperty(firstLoginKey)) {\n                // 进行 loginInfo 验证\n                checkLoginInfo(loginInfo[firstLoginKey], firstLoginInfo) &&\n                  jumpToLogin(loginPath, to.path, "first");\n              } else {\n                jumpToLogin(loginPath, to.path, "first");\n              }\n            }\n          }\n          if (to.path == "/") {\n            throw new Error("首页不需要验证！");\n          }\n          // 如果 firstLogin 不等于 2\n          if (isAgainLogin) {\n            siteData.pages.forEach((item) => {\n              // 找出带有 private 的文章\n              if (item.path == to.path) {\n                if (\n                  item.frontmatter.private &&\n                  item.frontmatter.private == true\n                ) {\n                  // 网站关闭或者刷新后，清除登录状态\n                  if (loginSession) {\n                    window.addEventListener("unload", function () {\n                      localStorage.removeItem(item.frontmatter.permalink);\n                    });\n                  }\n                  // 尝试获取该私密文章曾经登录的用户信息\n                  let singleInfo = JSON.parse(\n                    localStorage.getItem(item.frontmatter.permalink)\n                  );\n                  // 都不存在登录信息\n                  !singleInfo &&\n                    jumpToLogin(\n                      loginPath,\n                      to.path,\n                      item.frontmatter.loginInfo ||\n                        item.frontmatter.username ||\n                        item.frontmatter.password ||\n                        item.frontmatter.expire\n                        ? "single"\n                        : "all"\n                    );\n\n                  // 单个文章私密验证\n                  if (\n                    (item.frontmatter.username && item.frontmatter.password) ||\n                    item.frontmatter.loginInfo\n                  ) {\n                    // 不存在登录信息，则跳转到登录页面\n                    !singleInfo && jumpToLogin(loginPath, to.path, "single");\n                    // 存在曾经登录信息，如果登录状态过期\n                    if (new Date() - singleInfo.time > singleInfo.expire) {\n                      localStorage.removeItem(item.frontmatter.permalink);\n                      jumpToLogin(loginPath, to.path, "single");\n                    }\n                    // 是否需要登录\n                    let isLogin = true;\n                    // 对 loginInfo 进行验证\n                    if (Array.isArray(item.frontmatter.loginInfo)) {\n                      isLogin = checkLoginInfo(\n                        item.frontmatter.loginInfo,\n                        singleInfo\n                      );\n                    }\n                    // 如果 loginInfo 不存在，则进行单文章的用户名密码验证\n                    if (\n                      isLogin &&\n                      singleInfo.username !== item.frontmatter.username &&\n                      singleInfo.password !== item.frontmatter.password\n                    ) {\n                      jumpToLogin(loginPath, to.path, "single");\n                    }\n                  } else {\n                    // 全局私密验证\n                    let isLogin = true;\n                    // 先判断 loginInfo 是否存在，然后判断 loginInfo 是否对象，最后判断 loginInfo 是否有该文章的 permalink\n                    if (loginInfo && loginInfo.hasOwnProperty(to.path)) {\n                      isLogin = checkLoginInfo(loginInfo[to.path], singleInfo);\n                    }\n                    // 如果 loginInfo 验证失败\n                    isLogin && jumpToLogin(loginPath, to.path, "all");\n                  }\n                }\n              }\n            });\n          }\n        } catch (e) {}\n        next();\n      });\n    }\n  }\n  /**\n   * 检查 loginInfo 里的用户名和密码，userInfo 为曾经登录的信息\n   * 匹配成功返回 false，失败返回 true\n   */\n  function checkLoginInfo(loginInfo, userInfo) {\n    try {\n      loginInfo.forEach((info) => {\n        if (\n          userInfo.username == info.username &&\n          userInfo.password == info.password\n        ) {\n          // 利用异常机制跳出 forEach 循环，break、return、continue 不会起作用\n          throw new Error();\n        }\n      });\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * 跳转到登录页面\n   * loginPath：登录页面的 permalink\n   * toPath：当前页面的 permalink，verifyMode：验证方式\n   */\n  function jumpToLogin(loginPath, toPath, verifyMode) {\n    router.push({\n      path: loginPath,\n      query: {\n        toPath: toPath,\n        verifyMode: verifyMode, // 单个文章验证（single）或全局验证（all）或网站验证（first）\n      },\n    });\n    throw new Error("请先登录！");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n\n\n\n# 安全检测代码\n\n因为 Vuepress 是静态页面，所以我们无法往后端获取登录信息，那么也就有一个问题，如果用户禁用 JavaScript，那么私有文章将不会进行验证，也就是禁用了 JavaScript，可以毫无阻塞的浏览私有文章内容，那么如何处理这个问题呢？\n\n打开 .vuepress/config.js（新版是 config.ts）文件，给 head 模块添加如下信息：\n\n[\'noscript\', {}, \'<meta http-equiv="refresh" content="0; url=https://www.youngkbt.cn/noscript/"><style>.theme-vdoing-content { display:none }\']\n\n\n1\n\n\n值得注意的是，url 不要填写自己博客的任意地址，而是填写博客以外的地址，因为博客的页面总会触发这段代码，导致反复跳转该页面。\n\n如果你不介意的话，可以用我提供的 url，使用前你可以访问看看，只是一个简单的 html，点击跳转。\n\n\n# 配置添加\n\n打开 .vuepress/config.js（新版为 config.ts） 文件，在 themeConfig 模块里添加如下内容：\n\n// 私密文章配置\nprivatePage: {\n  openPrivate: true, // 开启私密文章验证，默认开启（true），如果不开启（false），则下面配置都失效\n  username: "youngkbt", // 管理员用户名\n  password: "123456", // 管理员密码\n  expire: "1d", // 登录过期时间：1d 代表 1 天，1h 代表 1 小时，仅支持这两个单位，不加单位代表秒。过期后访问私密文章重新输入用户名和密码。默认一天\n  loginPath: "/vdoing/login/", // 引用登录组件的 md 文章的 permalink（必须），无默认值\n  loginKey: "vdoing_manager", // 存储用户名信息的 key，默认是 vdoing_manager。系统通过该 key 验证是否登录、是否过期\n  loginSession: false, // 开启是否在网页关闭或刷新后，清除登录状态，这样再次访问网页，需要重新登录，默认为 false（不开启）\n  firstLogin: 0, // 第一次进入网站需要验证。用于封锁整个网站，默认为 0（不开启），1 和 2 都代表开启，区别：1 代表虽然进入网站成功，但是网站内的私密文章仍需要单独验证，2 代表进入网站成功，网站内的私密文章不需要单独验证，也就是网站内的私密文章和普通文章一样可以访问\n  firstLoginKey: "vdoing_first_login", // 存储用户名信息的 key，firstLogin 开启后该配置生效，默认为 vdoing_first_login，系统通过该 key 验证是否登录、是否过期\n  // 私密文章多组用户名密码\n  // loginInfo: {\n  //   "/private/test1/": [\n  //     { username: "vdoing", password: "123456" },\n  //   ],\n  //   "vdoing_first_login" :[  // 对应 firstLoginKey 的值\n  //     { username: "vdoing", password: "123456" },\n  //   ]\n  // }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n注释的内容是配置多组用户名密码，往下看。\n\n如果您想封锁整个网站，进入网站前进行验证登录，请看 firstLogin 的配置介绍，它的功能也许对你有帮助。\n\n\n# 配置介绍\n\n> openPrivate\n\n * 类型：boolean\n * 默认值：true\n\n开启私密文章验证，默认开启（true），如果不开启（false），则所有私密文章的配置都失效。\n\n为什么设计这个配置呢？如果你暂时不使用私密文章模块，但是又希望网站拥有私密文章模块，担心日后找不到本文章的地址，则可以先配置，然后改为 false 失效就行。\n\n> username\n\n * 类型：string\n * 默认值：undefined\n\n管理员用户名。\n\n> password\n\n * 类型：string\n * 默认值：undefined\n\n管理员密码。\n\n> expire\n\n * 类型：number\n * 默认值：1d\n\n登录过期时间：1d 代表 1 天，1h 代表 1 小时，仅支持这两个单位，不加单位代表秒。过期后访问私密文章重新输入用户名和密码。默认一天。\n\n如果您想适配更多的单位，请自行修改 Login.vue 源码的 getExpire 方法（大约 225 - 236 处）。\n\n> loginPath\n\n * 类型：string\n * 默认值：undefined\n\n引用 Login.vue 组件的 markdown 文章中 frontmatter 的 permalink。\n\n> loginKey\n\n * 类型：string\n * 默认值：vdoing_manager\n\n存储用户名信息的 key。\n\n请不要与任意文章中 frontmatter 的 permalink 冲突。\n\n> loginSession\n\n * 类型：boolean\n * 默认值：false\n\n是否开启在文章页面关闭或刷新后，清除登录状态。这样再次访问任何私密文章，都需要重新验证登录，默认为 false（不开启）。\n\n> firstLogin\n\n * 类型：number\n * 默认值：0\n\n第一次进入网站需要验证。用于封锁整个网站。\n\n默认为 0（不开启），1 和 2 都代表开启，区别：\n\n * 1：进入网站验证成功，但是网站内的私密文章仍需要单独二次验证\n * 2：进入网站验证成功，网站内的私密文章都不需要单独验证，也就是网站内的私密文章和普通文章一样可以正常访问\n\n如果您不打算设置私密文章，即网站所有文章无需二次验证，只想 单纯封锁整个网站。则 强烈建议设置为 2，因为它能 降低验证性能。源码介绍如下：\n\n * 如果 firstLogin 为 1，则每次进入新的文章都要进行拦截验证，判断是否为私密文章，可能损耗几毫秒到百毫秒（跟文章数有关）\n * 如果 firstLogin 为 2，网站登录成功后，进入任意文章，都不会进行验证，减少了验证性能\n\n> firstLoginKey\n\n * 类型：string\n * 默认值：vdoing_first_login\n\n存储用户名信息的 key，firstLogin 开启后该配置生效，系统通过该 key 验证是否登录、是否过期\n\n> loginInfo\n\n * 类型：Object\n * 默认值：undefined\n\n配置私密文章多组用户名密码，key 为私密文章的 permalink，value 为数组，数组可以有多个用户名和密码。\n\n\n# key介绍\n\n在配置介绍中，有两个 key：loginKey、firstLoginKey，那么他们分别有什么作用呢？\n\n您不希望每次进入网站或者访问私密文章都要进行验证吧，那么就需要一个有效时间，即在有效时间内，您的访问都能直接通过。\n\nloginKey 和 firstLoginKey 就是为这个机制出现的，其实还有一个 key，所以总共有三个 key：\n\n * loginKey 为管理员服务，如果您以管理员的身份登录，那么系统就以 loginKey 存储管理员信息，有效时间内都不会进行验证\n * firstLoginKey 为第一次访问网站服务，如果您登录成功了，那么该 key 就会存储您的登录信息，有效时间内都不会进行验证\n * permalink 为私密文章服务，当您登录某篇私密文章后，那么该 key 就会存储您的登录信息，有效时间内都不会进行验证\n\npermalink 内部能直接获取，所以不需要配置，您要确保的就是 这三个 key 不能都是同一个值。\n\n\n# 开启私密文章\n\n如果你想开启私密文章，请在 markdown 的 frontmatter 中 额外 添加如下内容：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n这是 最基本也是必须的步骤，开启了私密文章，还需要匹配对应的用户名和密码，看下面。\n\n\n# 进入网站验证\n\n如果您希望您的网站不暴露出去，可以使用该 网站验证功能。\n\n那么配置 firstLogin 为 1 或者 2，则进入网站前需要验证，那么如何设置用户名和密码呢？\n\n进入网站前的验证需要用到 firstLoginKey，然后在 loginInfo 里配置 firstLoginKey 的用户名和密码。\n\n假设 firstLoginKey 为 vdoing_first_login，则 loginInfo 里配置 vdoing_first_login 的用户名和密码，如下：\n\nprivatePage: {\n  // 其他配置\n  firstLogin: 1, // 或者 2\n  firstLoginKey: "vdoing_first_login",\n  loginInfo: {\n    "vdoing_first_login" :[  // 对应 firstLoginKey 的值\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" },\n    ]\n   },\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样，就能以 vdoing1、123 或者 vdoing2、123456 进行登录。\n\n> 如果您修改了 firstLoginKey 的值，也请修改 loginInfo 里对应的值。\n\n除了 loginInfo 里配置的用户名和密码登录，还可以进行管理员验证登录。\n\n\n# 管理员验证\n\nprivatePage 里的 username 和 password 是管理员的登录信息。一旦登录管理员的账号，那么进入网站验证、网站的所有私密文章都无需验证，可以直接访问。\n\n> 如何退出管理员的账号？\n\n * 等待 expire 时间到期\n * loginSession 为 true 时，只要关闭页面或者离开页面，就会清除所有登录信息，但是这个是针对所有用户，慎用\n * 手动去浏览器的本地存储空间删除 loginKey 的密钥（这也是 loginSession 的原理）\n\n如果 全局私密验证 或者 单私密文章验证 的用户名密码与管理员的一样，则以全局私密验证 或者 单私密文章验证 的用户名密码为主。\n\n如果您并没有为私密文章配置登录信息（只设置 private: true），则只能以管理员信息进行验证。\n\n\n# 全局私密验证\n\nprivatePage 里的 loginInfo 可以指定私密文章的 permalink，然后配置多个用户名和密码，如下：\n\n// 私密文章配置\nprivatePage: {\n  // 私密文章多组用户名密码\n  loginInfo: {\n    "/private1/": [ // 私密文章的 permalink\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" }\n    ],\n    "/private2/": [\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" }\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这样就能配置 permalink 为 /private1/ 和 /private2/ 私密文章的用户名和密码。\n\n警告\n\n如果打算使用该 loginInfo，则不能开启单私密文章验证，如果单私密文章指定了 username、password 或者 loginInfo，则该 loginInfo 失效。\n\n2022.06.07 @Du Wu\n\n\n# 单私密文章验证\n\n如果你想给某个私密文章设置单独的用户名和密码等配置，请在 frontmatter 中 额外 添加如下内容：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名\npassword: 123456  # 密码\nexpire: 2d  # 登录过期时间，可选（不填则以全局超时时间为准，如果全局也没有设置，则默认是一天）\nloginInfo: [\n  {username: \'1\', password: \'1\'},\n  {username: \'2\', password: \'2\'},\n  {username: \'3\', password: \'3\'},\n]\n-\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到 frontmatter 出现了 username、password，并且 loginInfo 里也出现多个 username、password，怎么区分？\n\n * 在登录方面没有任何区别。无论是以 username、password 登录，还是 loginInfo 里的多个 username、password 都可以\n * 在快速配置方面有区别：如果您只是想给私密文章设置一个用户名和密码，则只配置 username、password 即可，不需要配置复杂的 loginInfo\n\n警告\n\n * 一旦在单私密文章开启 username 或 password 或 loginInfo，那么在全局的 loginInfo 的该文章用户名和密码不起效果，以单私密文章配置为主\n\n * 如果您只想给单私密文章配置 expire 登录过期时间，这是可以的，只要单私密文章不出现 username 或 password 或 loginInfo 任意这三个配置，则都以全局的 loginInfo 为准\n\n2022.06.07 @Du Wu\n\n\n# 举例\n\n\n# 例1\n\n假设一个私密文章的 frontmatter 如下：\n\n---\ntitle: 私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private1/\nprivate: true\nusername: vdoing\npassword: 123456\nexpire: 7h\nloginInfo: [\n  {username: \'1\', password: \'1\'},\n]\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n全局配置如下：\n\nprivatePage: {\n  username: "yougnkbt", // 管理员用户名\n  password: "123", // 管理员密码\n  // ... 其他配置\n  // 私密文章多组用户名密码\n  loginInfo: {\n    "/private1/": [\n      { username: "vdoing1", password: "123" },\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果登录时输入：\n\n * 用户名：vdoing，密码：123456，登录成功\n * 用户名：1，密码：1，登录成功\n * 用户名：youngkbt，密码：123，登录成功，因为这是管理员的账号，对所有私密文章生效\n * 用户名：vdoing1，密码：123，登录失败，因为出现了单私密文章配置，则以单私密文章配置为主\n\n\n# 例2\n\n假设一个私密文章的 frontmatter 如下：\n\n---\ntitle: 私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private1/\nprivate: true\nexpire: 7h\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n全局配置如下：\n\nprivatePage: {\n  // ... 其他配置\n  // 私密文章多组用户名密码\n  loginInfo: {\n    "/private1/": [\n      { username: "vdoing1", password: "123" },\n    ],\n    "/privat2/": [\n      { username: "vdoing2", password: "123456" },\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果登录时输入：\n\n * 用户名：vdoing1，密码：123，登录成功，没单私密文章配置，则以全局私密文章配置为主\n * 用户名：vdoing2，密码：123456，登录失败，/private2/ 并不是该私密文章的 permalink\n\n虽然单私密文章出现了 expire: 7h，但是没有用户登录信息，所以仍然以全局私密信息为主。\n\n\n# 结束语\n\n如果你的 Vdoing 项目使用了本模块，建议不要将项目公开出去，拿 Github 举例，可以去 GitHub 仓库查看你的用户名和密码，进行登录访问。\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n本站实现了私密文章功能，当大家想要「云端备份」到博客时，又不希望别人看到，该功能能满足你。\n\n2022-01-07 @du wu\n\n\n\n * 前言\n * 组件添加\n * 组件引用\n * 路由监听\n * 安全检测代码\n * 配置添加\n * 配置介绍\n * key介绍\n * 开启私密文章\n * 进入网站验证\n * 管理员验证\n * 全局私密验证\n * 单私密文章验证\n * 举例\n   * 例1\n   * 例2\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n本功能不是插件，好处在于你可以自定义喜欢的页面。\n\n如果你想先体验私密文章的效果，请访问：\n\n * 全局私密文章测试\n\n * 单个私密文章测试\n\n本模块分为四步：\n\n * 创建 login.vue 组件\n * 创建一个 markdown 文档，引用 login.vue 组件\n * 监听路由，跳转前判断是否为私有文章，是否登录过，或是否登录状态过期\n * 在 themeconfig 里添加一些配置信息\n\n本模块功能：\n\n * 网站验证功能：用于封锁整个网站，当第一次访问网站，需要进行验证登录，支持多组用户名和密码\n * 私密文章验证功能：访问一篇文章时要进行验证登录，支持一篇私密文章多组用户名和密码\n * 管理员验证功能：以管理员进行验证成功，网站和所有私密文章无需验证，直接访问\n * 有效时间功能：验证成功后，在有效时间内的访问都不需要验证，支持天和小时为单位\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n首先在 .vuepress/config.js 的 head 模块添加在线图标。图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n[\'link\', { rel: \'stylesheet\', href: \'https://at.alicdn.com/t/font_3129839_xft6cqs5gc.css\' }], // 阿里在线图标\n\n\n1\n\n\n\n\n在 doc/.vuepress 目录下，创建 components 文件夹，如果有，则不需要创建。\n\n接着在 components 文件夹下创建 login.vue 组件，该组件是登录的表单，可以根据需求自行修改。\n\n一定是 components 文件夹且路径要对，因为 vuepress 会自动全局注册该文件夹下的所有 .vue 组件。\n\n在 login.vue 添加如下内容：\n\n<template>\n  <div class="login-form">\n    <div class="form-header">用户名</div>\n    <div>\n      <input\n        type="text"\n        class="form-control"\n        placeholder="请输入用户名 ..."\n        v-model="username"\n      />\n    </div>\n    <div class="form-header">密码</div>\n    <div>\n      <input\n        type="password"\n        class="form-control"\n        placeholder="请输入密码 ..."\n        v-model="password"\n      />\n    </div>\n\n    <div class="btn-row">\n      <button class="btn" @click="login">登录</button>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      username: "",\n      password: "",\n      privateinfo: {\n        username: "",\n        password: "",\n        loginkey: "",\n        expire: "",\n        logininfo: "",\n        allloginkey: "kbt",\n      },\n    };\n  },\n  mounted() {\n    // enter 键也能触发登录按钮\n    document.onkeyup = (e) => {\n      let key = window.event.keycode;\n      if (key == 13) {\n        this.login();\n      }\n    };\n  },\n  methods: {\n    /**\n     * 登录验证\n     */\n    login() {\n      let { privateinfo } = this;\n      // 获取全局配置\n      let { username, password, loginkey, expire, firstloginkey, logininfo } =\n        this.$themeconfig.privatepage;\n      !loginkey && (loginkey = "vdoing_manager"); // 默认为 vdoing_manager\n      // 计算正确的过期时间\n      expire = this.getexpire(expire);\n      !expire && (expire = 86400000);\n      if (this.username && this.password) {\n        // 进入网站前进行验证\n        if (this.$route.query.verifymode == "first") {\n          privateinfo.expire = expire;\n          !firstloginkey && (firstloginkey = "vdoing_first_login"); // 默认为 vdoing_first_login\n          // 检查 logininfo 是否验证成功\n          let check = false;\n          if (logininfo && logininfo.hasownproperty(firstloginkey)) {\n            check = this.checklogininfoandjump(\n              logininfo[firstloginkey],\n              firstloginkey\n            );\n          }\n          // 如果第一次进入网站以管理员登录，则网站的所有私密文章不再需要验证\n          if (\n            !check &&\n            this.username == username &&\n            this.password == password\n          ) {\n            // 如果管理员登录，直接 key = vdoing_manager，不需要再次 key = vdoing_first_login\n            // this.storagelocalandjump(firstloginkey, false);\n            this.storagelocalandjump(loginkey, true);\n          } else if (!check) {\n            this.password = ""; // 清空密码\n            addtip(\n              "用户名或者密码错误！请联系博主获取用户名和密码！",\n              "danger"\n            );\n          }\n        } else {\n          // 如果是单个文章验证\n          if (this.$route.query.verifymode == "single") {\n            try {\n              this.$filterposts.foreach((item) => {\n                if (item.path == this.$route.query.topath) {\n                  privateinfo.username = item.frontmatter.username;\n                  privateinfo.password = item.frontmatter.password;\n                  privateinfo.loginkey = item.frontmatter.permalink;\n                  privateinfo.expire =\n                    this.getexpire(item.frontmatter.expire) || expire;\n                  privateinfo.logininfo = item.frontmatter.logininfo;\n                  // 利用异常机制跳出 foreach 循环，break、return、continue 不会起作用\n                  throw new error();\n                }\n              });\n            } catch (e) {}\n          }\n          // checklogininfo：判断是否进行了 logininfo 验证\n          let checklogininfo = false;\n          // 如果没有配置单私密文章用户信息，则使用全局配置\n          if (\n            !privateinfo.username &&\n            !privateinfo.password &&\n            !privateinfo.logininfo\n          ) {\n            privateinfo.loginkey = this.$route.query.topath;\n            privateinfo.logininfo = logininfo;\n            privateinfo.expire ? "" : (privateinfo.expire = expire);\n          }\n          // 先进行 logininfo 验证\n          if (privateinfo.logininfo) {\n            // 如果是数组：即单个文章设置的 logininfo\n            if (array.isarray(privateinfo.logininfo)) {\n              checklogininfo = this.checklogininfoandjump(\n                privateinfo.logininfo\n              );\n            } else if (\n              privateinfo.logininfo.hasownproperty(this.$route.query.topath)\n            ) {\n              // 如果是对象，即全局设置的 logininfo\n              checklogininfo = this.checklogininfoandjump(\n                privateinfo.logininfo[this.$route.query.topath]\n              );\n            }\n          }\n          // 如果没有触发 logininfo 验证或者 logininfo 验证失败，则进行单个用户名密码验证\n          if (!checklogininfo) {\n            // 如果使用文章配置的用户名密码\n            if (\n              this.username == privateinfo.username &&\n              this.password == privateinfo.password\n            ) {\n              this.storagelocalandjump(this.privateinfo.loginkey, true);\n            } else if (\n              // 如果使用全局配置的用户名密码\n              this.username == username &&\n              this.password == password\n            ) {\n              this.storagelocalandjump(loginkey, true);\n            } else {\n              this.password = ""; // 清空密码\n              addtip(\n                "用户名或者密码错误！请联系博主获取用户名和密码！",\n                "danger"\n              );\n            }\n          }\n        }\n      } else if (this.username == "" && this.password != "") {\n        addtip("用户名不能为空！", "warning");\n      } else if (this.username != "" && this.password == "") {\n        addtip("密码不能为空！", "warning");\n      } else {\n        addtip("您访问的文章是私密文章，请先输入用户名和密码！", "info");\n      }\n    },\n    /**\n     * 检查 logininfo 里的用户名和密码\n     * 匹配成功返回 true，失败返回 false\n     */\n    checklogininfoandjump(\n      logininfo = this.privateinfo.logininfo,\n      loginkey = this.privateinfo.loginkey\n    ) {\n      try {\n        logininfo.foreach((item) => {\n          if (\n            this.username == item.username &&\n            this.password == item.password\n          ) {\n            this.storagelocalandjump(loginkey, true);\n            // 利用异常机制跳出 foreach 循环，break、return、continue 不会起作用\n            throw new error();\n          }\n        });\n      } catch (error) {\n        return true;\n      }\n      return false;\n    },\n    /**\n     * 添加登录信息到本地存储区，并跳转到私密文章\n     * loginkey：存储到本地的 key，方便自动验证\n     * jump：是否跳转到私密文章，默认存储到本地后跳转\n     */\n    storagelocalandjump(loginkey = this.privateinfo.loginkey, jump = true) {\n      const data = json.stringify({\n        username: this.username,\n        password: this.password,\n        time: new date().gettime(),\n        expire: this.privateinfo.expire,\n      });\n      window.localstorage.setitem(loginkey, data);\n      if (jump) {\n        addtip("登录成功，正在跳转 ...", "success");\n        if (this.$route.query.topath) {\n          this.$router.push({\n            path: this.$route.query.topath,\n          });\n        } else {\n          this.$router.push({\n            path: "/",\n          });\n        }\n      }\n    },\n    /**\n     * 计算过期时间\n     */\n    getexpire(expire) {\n      if (expire) {\n        if (expire.indexof("d") !== -1) {\n          expire = parseint(expire.replace("d", "")) * 24 * 60 * 60 * 1000; // 天\n        } else if (expire.indexof("h") !== -1) {\n          expire = parseint(expire.replace("h", "")) * 60 * 60 * 1000; // 小时\n        } else {\n          expire = parseint(expire) * 1000; // 不加单位为秒\n        }\n      }\n      return expire;\n    },\n  },\n};\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startheight：第一个弹窗的高度，默认 50\n * dietime：弹窗消失时间（毫秒），默认 3000 毫秒\n */\nfunction addtip(content, type, startheight = 50, dietime = 3000) {\n  var tip = document.queryselectorall(".global-tip");\n  var time = new date().gettime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getattribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lasttop =\n    parseint(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetheight + 17 : startheight);\n\n  let div = document.createelement("div");\n  div.classname = `global-tip tip-${type} ${time}`;\n  div.style.top = parseint(top) + "px";\n  div.setattribute("data-top", lasttop);\n  if (type == "info" || type == 1) {\n    div.innerhtml = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerhtml = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerhtml = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerhtml = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendchild(div);\n\n  let timetip = document.getelementsbyclassname(time)[0];\n  settimeout(() => {\n    timetip.style.top = parseint(lasttop) + "px";\n    timetip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dietime 秒后隐藏并被删除\n  settimeout(() => {\n    timetip.style.top = "0px";\n    timetip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var alltipelement = nextalltipelement(timetip);\n    for (let i = 0; i < alltipelement.length; i++) {\n      var next = alltipelement[i];\n      var top =\n        parseint(next.getattribute("data-top")) - next.offsetheight - 17;\n      next.setattribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    settimeout(() => {\n      timetip.remove();\n    }, 500);\n  }, dietime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextalltipelement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextsibling) {\n    if (n.nodetype === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style lang="stylus">\n.login-form {\n  padding: 1rem;\n  box-sizing: border-box;\n\n  .btn-row {\n    margin-top: 1rem;\n    text-align: center;\n  }\n\n  .btn {\n    padding: 0.6rem 2rem;\n    outline: none;\n    background-color: #60c084;\n    color: white;\n    border: 0;\n    cursor: pointer;\n  }\n\n  .form-header {\n    color: #13b9e2;\n    margin-bottom: 0.5rem;\n  }\n\n  .form-control {\n    padding: 0.6rem;\n    border: 2px solid #ddd;\n    width: 100%;\n    margin-bottom: 0.5rem;\n    box-sizing: border-box;\n    outline: none;\n    transition: border 0.2s ease;\n\n    &:focus {\n      border: 2px solid #aaa;\n    }\n  }\n}\n\ndiv.v-dialog-overlay {\n  opacity: 1 !important;\n}\n\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translatex(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n\n\n\n# 组件引用\n\nlogin.vue 文件写好后需要引用，在 docs 目录下 的任意位置创建一个 markdown 文档，如我就在 docs 的根目录下创建 99.vdoing私密文章登录.md 文件。\n\n添加如下内容：(需要修改 frontmatter 为自己的内容)\n\n---\ntitle: vdoing私密文章登录   # 可修改\ndate: 2022-01-07 14:26:04 # 你的创建时间，可修改\npermalink: /vdoing/login/  # 可修改，建议按步骤使用，后面用到这个 permalink，否则要改一起改\nsidebar: false\narticle: false\ncomment: false\neditlink: false\n---\n\n您当前访问的是博主的私密文章，请输入有效的用户名和密码。如果没有，请在评论区或者其他途径向博主获取。\n\n<clientonly>\n  <login/>\n</clientonly>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n记住你的 permalink，后面的 配置添加 需要用到。\n\n<clientonly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n\n# 路由监听\n\n打开 docs/enhanceapp.js 文件，添加如下内容：\n\nexport default ({\n    vue, // vuepress 正在使用的 vue 构造函数\n    options, // 附加到根实例的一些选项\n    router, // 当前应用的路由实例\n    sitedata, // 站点元数据\n    isserver // 当前应用配置是处于 服务端渲染 或 客户端\n}) => {\n  /**\n   * 私密文章验证\n   */\n  if (!isserver) {\n    // 如果开启了私密文章验证\n    if (\n      sitedata.themeconfig.privatepage &&\n      sitedata.themeconfig.privatepage.openprivate\n    ) {\n      router.beforeeach((to, from, next) => {\n        try {\n          let {\n            username,\n            password,\n            loginpath,\n            loginkey,\n            loginsession,\n            logininfo,\n            firstlogin,\n            firstloginkey,\n          } = sitedata.themeconfig.privatepage;\n          !loginkey && (loginkey = "vdoing_manager"); // 默认为 vdoing_manager\n          !firstloginkey && (firstloginkey = "vdoing_first_login"); // 默认为 vdoing_first_login\n          // 网站关闭或者刷新后，清除登录状态\n          if (loginsession) {\n            window.addeventlistener("unload", function () {\n              localstorage.removeitem(loginkey);\n              localstorage.removeitem(firstloginkey);\n            });\n          }\n          // 如果是登录页面，不需要验证\n          if (loginpath == to.path || !loginpath) {\n            throw new error("无需验证");\n          }\n          // 尝试获取管理员曾经登录的用户信息\n          let globalinfo = json.parse(localstorage.getitem(loginkey));\n          // 管理员用户名密码验证\n          if (\n            globalinfo &&\n            globalinfo.username == username &&\n            globalinfo.password == password\n          ) {\n            // 存在曾经登录信息，如果登录状态过期\n            if (new date() - globalinfo.time > globalinfo.expire) {\n              localstorage.removeitem(loginkey);\n            } else {\n              throw new error("管理员验证成功！");\n            }\n          }\n          // 整个网站进入前需要验证\n          let isagainlogin = true;\n          if (parseint(firstlogin) == 1 || parseint(firstlogin) == 2) {\n            parseint(firstlogin) == 2 && (isagainlogin = false);\n            // 尝试获取第一次访问网站曾经登录的用户信息\n            let firstlogininfo = json.parse(\n              localstorage.getitem(firstloginkey)\n            );\n            !firstlogininfo && jumptologin(loginpath, to.path, "first");\n            if (firstlogininfo) {\n              // 先判断 logininfo 是否存在，然后判断 logininfo 是否对象，最后判断 logininfo 是否有 firstloginkey\n              if (logininfo && logininfo.hasownproperty(firstloginkey)) {\n                // 进行 logininfo 验证\n                checklogininfo(logininfo[firstloginkey], firstlogininfo) &&\n                  jumptologin(loginpath, to.path, "first");\n              } else {\n                jumptologin(loginpath, to.path, "first");\n              }\n            }\n          }\n          if (to.path == "/") {\n            throw new error("首页不需要验证！");\n          }\n          // 如果 firstlogin 不等于 2\n          if (isagainlogin) {\n            sitedata.pages.foreach((item) => {\n              // 找出带有 private 的文章\n              if (item.path == to.path) {\n                if (\n                  item.frontmatter.private &&\n                  item.frontmatter.private == true\n                ) {\n                  // 网站关闭或者刷新后，清除登录状态\n                  if (loginsession) {\n                    window.addeventlistener("unload", function () {\n                      localstorage.removeitem(item.frontmatter.permalink);\n                    });\n                  }\n                  // 尝试获取该私密文章曾经登录的用户信息\n                  let singleinfo = json.parse(\n                    localstorage.getitem(item.frontmatter.permalink)\n                  );\n                  // 都不存在登录信息\n                  !singleinfo &&\n                    jumptologin(\n                      loginpath,\n                      to.path,\n                      item.frontmatter.logininfo ||\n                        item.frontmatter.username ||\n                        item.frontmatter.password ||\n                        item.frontmatter.expire\n                        ? "single"\n                        : "all"\n                    );\n\n                  // 单个文章私密验证\n                  if (\n                    (item.frontmatter.username && item.frontmatter.password) ||\n                    item.frontmatter.logininfo\n                  ) {\n                    // 不存在登录信息，则跳转到登录页面\n                    !singleinfo && jumptologin(loginpath, to.path, "single");\n                    // 存在曾经登录信息，如果登录状态过期\n                    if (new date() - singleinfo.time > singleinfo.expire) {\n                      localstorage.removeitem(item.frontmatter.permalink);\n                      jumptologin(loginpath, to.path, "single");\n                    }\n                    // 是否需要登录\n                    let islogin = true;\n                    // 对 logininfo 进行验证\n                    if (array.isarray(item.frontmatter.logininfo)) {\n                      islogin = checklogininfo(\n                        item.frontmatter.logininfo,\n                        singleinfo\n                      );\n                    }\n                    // 如果 logininfo 不存在，则进行单文章的用户名密码验证\n                    if (\n                      islogin &&\n                      singleinfo.username !== item.frontmatter.username &&\n                      singleinfo.password !== item.frontmatter.password\n                    ) {\n                      jumptologin(loginpath, to.path, "single");\n                    }\n                  } else {\n                    // 全局私密验证\n                    let islogin = true;\n                    // 先判断 logininfo 是否存在，然后判断 logininfo 是否对象，最后判断 logininfo 是否有该文章的 permalink\n                    if (logininfo && logininfo.hasownproperty(to.path)) {\n                      islogin = checklogininfo(logininfo[to.path], singleinfo);\n                    }\n                    // 如果 logininfo 验证失败\n                    islogin && jumptologin(loginpath, to.path, "all");\n                  }\n                }\n              }\n            });\n          }\n        } catch (e) {}\n        next();\n      });\n    }\n  }\n  /**\n   * 检查 logininfo 里的用户名和密码，userinfo 为曾经登录的信息\n   * 匹配成功返回 false，失败返回 true\n   */\n  function checklogininfo(logininfo, userinfo) {\n    try {\n      logininfo.foreach((info) => {\n        if (\n          userinfo.username == info.username &&\n          userinfo.password == info.password\n        ) {\n          // 利用异常机制跳出 foreach 循环，break、return、continue 不会起作用\n          throw new error();\n        }\n      });\n    } catch (error) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * 跳转到登录页面\n   * loginpath：登录页面的 permalink\n   * topath：当前页面的 permalink，verifymode：验证方式\n   */\n  function jumptologin(loginpath, topath, verifymode) {\n    router.push({\n      path: loginpath,\n      query: {\n        topath: topath,\n        verifymode: verifymode, // 单个文章验证（single）或全局验证（all）或网站验证（first）\n      },\n    });\n    throw new error("请先登录！");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n\n\n\n# 安全检测代码\n\n因为 vuepress 是静态页面，所以我们无法往后端获取登录信息，那么也就有一个问题，如果用户禁用 javascript，那么私有文章将不会进行验证，也就是禁用了 javascript，可以毫无阻塞的浏览私有文章内容，那么如何处理这个问题呢？\n\n打开 .vuepress/config.js（新版是 config.ts）文件，给 head 模块添加如下信息：\n\n[\'noscript\', {}, \'<meta http-equiv="refresh" content="0; url=https://www.youngkbt.cn/noscript/"><style>.theme-vdoing-content { display:none }\']\n\n\n1\n\n\n值得注意的是，url 不要填写自己博客的任意地址，而是填写博客以外的地址，因为博客的页面总会触发这段代码，导致反复跳转该页面。\n\n如果你不介意的话，可以用我提供的 url，使用前你可以访问看看，只是一个简单的 html，点击跳转。\n\n\n# 配置添加\n\n打开 .vuepress/config.js（新版为 config.ts） 文件，在 themeconfig 模块里添加如下内容：\n\n// 私密文章配置\nprivatepage: {\n  openprivate: true, // 开启私密文章验证，默认开启（true），如果不开启（false），则下面配置都失效\n  username: "youngkbt", // 管理员用户名\n  password: "123456", // 管理员密码\n  expire: "1d", // 登录过期时间：1d 代表 1 天，1h 代表 1 小时，仅支持这两个单位，不加单位代表秒。过期后访问私密文章重新输入用户名和密码。默认一天\n  loginpath: "/vdoing/login/", // 引用登录组件的 md 文章的 permalink（必须），无默认值\n  loginkey: "vdoing_manager", // 存储用户名信息的 key，默认是 vdoing_manager。系统通过该 key 验证是否登录、是否过期\n  loginsession: false, // 开启是否在网页关闭或刷新后，清除登录状态，这样再次访问网页，需要重新登录，默认为 false（不开启）\n  firstlogin: 0, // 第一次进入网站需要验证。用于封锁整个网站，默认为 0（不开启），1 和 2 都代表开启，区别：1 代表虽然进入网站成功，但是网站内的私密文章仍需要单独验证，2 代表进入网站成功，网站内的私密文章不需要单独验证，也就是网站内的私密文章和普通文章一样可以访问\n  firstloginkey: "vdoing_first_login", // 存储用户名信息的 key，firstlogin 开启后该配置生效，默认为 vdoing_first_login，系统通过该 key 验证是否登录、是否过期\n  // 私密文章多组用户名密码\n  // logininfo: {\n  //   "/private/test1/": [\n  //     { username: "vdoing", password: "123456" },\n  //   ],\n  //   "vdoing_first_login" :[  // 对应 firstloginkey 的值\n  //     { username: "vdoing", password: "123456" },\n  //   ]\n  // }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n注释的内容是配置多组用户名密码，往下看。\n\n如果您想封锁整个网站，进入网站前进行验证登录，请看 firstlogin 的配置介绍，它的功能也许对你有帮助。\n\n\n# 配置介绍\n\n> openprivate\n\n * 类型：boolean\n * 默认值：true\n\n开启私密文章验证，默认开启（true），如果不开启（false），则所有私密文章的配置都失效。\n\n为什么设计这个配置呢？如果你暂时不使用私密文章模块，但是又希望网站拥有私密文章模块，担心日后找不到本文章的地址，则可以先配置，然后改为 false 失效就行。\n\n> username\n\n * 类型：string\n * 默认值：undefined\n\n管理员用户名。\n\n> password\n\n * 类型：string\n * 默认值：undefined\n\n管理员密码。\n\n> expire\n\n * 类型：number\n * 默认值：1d\n\n登录过期时间：1d 代表 1 天，1h 代表 1 小时，仅支持这两个单位，不加单位代表秒。过期后访问私密文章重新输入用户名和密码。默认一天。\n\n如果您想适配更多的单位，请自行修改 login.vue 源码的 getexpire 方法（大约 225 - 236 处）。\n\n> loginpath\n\n * 类型：string\n * 默认值：undefined\n\n引用 login.vue 组件的 markdown 文章中 frontmatter 的 permalink。\n\n> loginkey\n\n * 类型：string\n * 默认值：vdoing_manager\n\n存储用户名信息的 key。\n\n请不要与任意文章中 frontmatter 的 permalink 冲突。\n\n> loginsession\n\n * 类型：boolean\n * 默认值：false\n\n是否开启在文章页面关闭或刷新后，清除登录状态。这样再次访问任何私密文章，都需要重新验证登录，默认为 false（不开启）。\n\n> firstlogin\n\n * 类型：number\n * 默认值：0\n\n第一次进入网站需要验证。用于封锁整个网站。\n\n默认为 0（不开启），1 和 2 都代表开启，区别：\n\n * 1：进入网站验证成功，但是网站内的私密文章仍需要单独二次验证\n * 2：进入网站验证成功，网站内的私密文章都不需要单独验证，也就是网站内的私密文章和普通文章一样可以正常访问\n\n如果您不打算设置私密文章，即网站所有文章无需二次验证，只想 单纯封锁整个网站。则 强烈建议设置为 2，因为它能 降低验证性能。源码介绍如下：\n\n * 如果 firstlogin 为 1，则每次进入新的文章都要进行拦截验证，判断是否为私密文章，可能损耗几毫秒到百毫秒（跟文章数有关）\n * 如果 firstlogin 为 2，网站登录成功后，进入任意文章，都不会进行验证，减少了验证性能\n\n> firstloginkey\n\n * 类型：string\n * 默认值：vdoing_first_login\n\n存储用户名信息的 key，firstlogin 开启后该配置生效，系统通过该 key 验证是否登录、是否过期\n\n> logininfo\n\n * 类型：object\n * 默认值：undefined\n\n配置私密文章多组用户名密码，key 为私密文章的 permalink，value 为数组，数组可以有多个用户名和密码。\n\n\n# key介绍\n\n在配置介绍中，有两个 key：loginkey、firstloginkey，那么他们分别有什么作用呢？\n\n您不希望每次进入网站或者访问私密文章都要进行验证吧，那么就需要一个有效时间，即在有效时间内，您的访问都能直接通过。\n\nloginkey 和 firstloginkey 就是为这个机制出现的，其实还有一个 key，所以总共有三个 key：\n\n * loginkey 为管理员服务，如果您以管理员的身份登录，那么系统就以 loginkey 存储管理员信息，有效时间内都不会进行验证\n * firstloginkey 为第一次访问网站服务，如果您登录成功了，那么该 key 就会存储您的登录信息，有效时间内都不会进行验证\n * permalink 为私密文章服务，当您登录某篇私密文章后，那么该 key 就会存储您的登录信息，有效时间内都不会进行验证\n\npermalink 内部能直接获取，所以不需要配置，您要确保的就是 这三个 key 不能都是同一个值。\n\n\n# 开启私密文章\n\n如果你想开启私密文章，请在 markdown 的 frontmatter 中 额外 添加如下内容：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n这是 最基本也是必须的步骤，开启了私密文章，还需要匹配对应的用户名和密码，看下面。\n\n\n# 进入网站验证\n\n如果您希望您的网站不暴露出去，可以使用该 网站验证功能。\n\n那么配置 firstlogin 为 1 或者 2，则进入网站前需要验证，那么如何设置用户名和密码呢？\n\n进入网站前的验证需要用到 firstloginkey，然后在 logininfo 里配置 firstloginkey 的用户名和密码。\n\n假设 firstloginkey 为 vdoing_first_login，则 logininfo 里配置 vdoing_first_login 的用户名和密码，如下：\n\nprivatepage: {\n  // 其他配置\n  firstlogin: 1, // 或者 2\n  firstloginkey: "vdoing_first_login",\n  logininfo: {\n    "vdoing_first_login" :[  // 对应 firstloginkey 的值\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" },\n    ]\n   },\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样，就能以 vdoing1、123 或者 vdoing2、123456 进行登录。\n\n> 如果您修改了 firstloginkey 的值，也请修改 logininfo 里对应的值。\n\n除了 logininfo 里配置的用户名和密码登录，还可以进行管理员验证登录。\n\n\n# 管理员验证\n\nprivatepage 里的 username 和 password 是管理员的登录信息。一旦登录管理员的账号，那么进入网站验证、网站的所有私密文章都无需验证，可以直接访问。\n\n> 如何退出管理员的账号？\n\n * 等待 expire 时间到期\n * loginsession 为 true 时，只要关闭页面或者离开页面，就会清除所有登录信息，但是这个是针对所有用户，慎用\n * 手动去浏览器的本地存储空间删除 loginkey 的密钥（这也是 loginsession 的原理）\n\n如果 全局私密验证 或者 单私密文章验证 的用户名密码与管理员的一样，则以全局私密验证 或者 单私密文章验证 的用户名密码为主。\n\n如果您并没有为私密文章配置登录信息（只设置 private: true），则只能以管理员信息进行验证。\n\n\n# 全局私密验证\n\nprivatepage 里的 logininfo 可以指定私密文章的 permalink，然后配置多个用户名和密码，如下：\n\n// 私密文章配置\nprivatepage: {\n  // 私密文章多组用户名密码\n  logininfo: {\n    "/private1/": [ // 私密文章的 permalink\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" }\n    ],\n    "/private2/": [\n      { username: "vdoing1", password: "123" },\n      { username: "vdoing2", password: "123456" }\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这样就能配置 permalink 为 /private1/ 和 /private2/ 私密文章的用户名和密码。\n\n警告\n\n如果打算使用该 logininfo，则不能开启单私密文章验证，如果单私密文章指定了 username、password 或者 logininfo，则该 logininfo 失效。\n\n2022.06.07 @du wu\n\n\n# 单私密文章验证\n\n如果你想给某个私密文章设置单独的用户名和密码等配置，请在 frontmatter 中 额外 添加如下内容：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名\npassword: 123456  # 密码\nexpire: 2d  # 登录过期时间，可选（不填则以全局超时时间为准，如果全局也没有设置，则默认是一天）\nlogininfo: [\n  {username: \'1\', password: \'1\'},\n  {username: \'2\', password: \'2\'},\n  {username: \'3\', password: \'3\'},\n]\n-\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看到 frontmatter 出现了 username、password，并且 logininfo 里也出现多个 username、password，怎么区分？\n\n * 在登录方面没有任何区别。无论是以 username、password 登录，还是 logininfo 里的多个 username、password 都可以\n * 在快速配置方面有区别：如果您只是想给私密文章设置一个用户名和密码，则只配置 username、password 即可，不需要配置复杂的 logininfo\n\n警告\n\n * 一旦在单私密文章开启 username 或 password 或 logininfo，那么在全局的 logininfo 的该文章用户名和密码不起效果，以单私密文章配置为主\n\n * 如果您只想给单私密文章配置 expire 登录过期时间，这是可以的，只要单私密文章不出现 username 或 password 或 logininfo 任意这三个配置，则都以全局的 logininfo 为准\n\n2022.06.07 @du wu\n\n\n# 举例\n\n\n# 例1\n\n假设一个私密文章的 frontmatter 如下：\n\n---\ntitle: 私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private1/\nprivate: true\nusername: vdoing\npassword: 123456\nexpire: 7h\nlogininfo: [\n  {username: \'1\', password: \'1\'},\n]\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n全局配置如下：\n\nprivatepage: {\n  username: "yougnkbt", // 管理员用户名\n  password: "123", // 管理员密码\n  // ... 其他配置\n  // 私密文章多组用户名密码\n  logininfo: {\n    "/private1/": [\n      { username: "vdoing1", password: "123" },\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果登录时输入：\n\n * 用户名：vdoing，密码：123456，登录成功\n * 用户名：1，密码：1，登录成功\n * 用户名：youngkbt，密码：123，登录成功，因为这是管理员的账号，对所有私密文章生效\n * 用户名：vdoing1，密码：123，登录失败，因为出现了单私密文章配置，则以单私密文章配置为主\n\n\n# 例2\n\n假设一个私密文章的 frontmatter 如下：\n\n---\ntitle: 私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private1/\nprivate: true\nexpire: 7h\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n全局配置如下：\n\nprivatepage: {\n  // ... 其他配置\n  // 私密文章多组用户名密码\n  logininfo: {\n    "/private1/": [\n      { username: "vdoing1", password: "123" },\n    ],\n    "/privat2/": [\n      { username: "vdoing2", password: "123456" },\n    ],\n  },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如果登录时输入：\n\n * 用户名：vdoing1，密码：123，登录成功，没单私密文章配置，则以全局私密文章配置为主\n * 用户名：vdoing2，密码：123456，登录失败，/private2/ 并不是该私密文章的 permalink\n\n虽然单私密文章出现了 expire: 7h，但是没有用户登录信息，所以仍然以全局私密信息为主。\n\n\n# 结束语\n\n如果你的 vdoing 项目使用了本模块，建议不要将项目公开出去，拿 github 举例，可以去 github 仓库查看你的用户名和密码，进行登录访问。\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 导航站模块",frontmatter:{title:"本站 - 导航站模块",date:"2022-01-11T14:03:46.000Z",permalink:"/about/website/tools/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/24.%E6%9C%AC%E7%AB%99%20-%20%E5%AF%BC%E8%88%AA%E7%AB%99%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/24.本站 - 导航站模块.md",key:"v-11e8e024",path:"/about/website/tools/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:61},{level:2,title:"Vue组件",slug:"vue组件",normalizedTitle:"vue组件",charIndex:67},{level:2,title:"组件使用",slug:"组件使用",normalizedTitle:"组件使用",charIndex:76},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:84},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:90}],headersStr:"前言 Vue组件 组件使用 属性 结束语",content:'笔记\n\n主题自带的卡片列表不适合制作导航卡片，于是我稍微自己实现了它。\n\n2021-01-11 @Du Wu\n\n\n\n * 前言\n * Vue组件\n * 组件使用\n * 属性\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n导航卡片是什么，请先看我的导航站：https://notes.youngkbt.cn/navigation/\n\n因为个人不使用本地主题，所以无法直接获取一个文章的内容来解析，只能一切都在本地代码制作。\n\n\n# Vue组件\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n导航卡片需要一个 Vue 组件，在 docs/.vuepress/components 下创建 Card.vue 组件，如果没有 components 文件夹，请创建。\n\n组件添加如下内容：\n\n<template>\n  <div>\n    <template v-if="cardData[0].title != undefined">\n        <div style="text-align: center; font-weight: 900">{{ cardData[0].title }}</div>\n    </template>\n    <div class="kbt-row">\n    <div\n      class="card-nav-box"\n      :style="\n        cardListSize == 4\n          ? \'width: 25%;\'\n          : cardListSize == 2\n          ? \'width: 50%;\'\n          : \'width: 33.333%;\'\n      "\n      v-for="(item,index) in cardData"\n      :key="index"\n    >\n      <a :href="item.cardSrc" target="_blank">\n        <div class="card-nav-item">\n          <div class="card-nav-title">\n            <img\n              v-if="item.cardImgSrc && item.cardImgSrc != \'\'"\n              :src="item.cardImgSrc"\n              alt="正在加载 ..."\n              class="card-nav-img"\n            />\n            <p class="card-nav-name" :style="\'color:\' + carTitleColor">\n              {{ item.cardName }}\n            </p>\n          </div>\n          <div :title="item.cardContent" class="card-nav-content">\n            {{ item.cardContent }}\n          </div>\n        </div>\n      </a>\n    </div>\n  </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    cardData: {\n      type: Array,\n      default: [],\n    },\n    cardListSize: {\n      type: Number,\n      default: 3,\n    },\n    carTitleColor: {\n      type: String,\n      default: "#000",\n    },\n    carHoverColor: {\n      type: String,\n      default: "#000",\n    },\n  },\n  mounted() {\n    this.cardHoverColor();\n  },\n  methods: {\n    cardHoverColor() {\n      if(!document.querySelector(".card")){\n        const carHoverColor = this.carHoverColor;\n        let style = document.createElement("style");\n        style.className = \'card\';\n        style.innerHTML = `.card-nav-content:hover{color: ${carHoverColor}}`;\n        document.head.appendChild(style);\n      }\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.kbt-row {\n  margin: 0.7rem 0;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-start;\n}\n.card-nav-box {\n  padding: 0 10px 0 10px;\n  box-sizing: border-box;\n}\n.card-nav-box a:hover {\n  text-decoration: none !important;\n}\n.card-nav-item {\n  min-height: 76px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 10px;\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 10px 0 rgb(0 0 0 / 10%);\n  transition: all 0.4s;\n}\n.card-nav-item:hover {\n  box-shadow: 0 10px 20px -10px rgba(0, 0, 0, 0.7);\n  transform: translateY(-3px) scale(1.01, 1.01);\n}\n.card-nav-title {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 15px;\n  margin: 5px 0;\n  height: 40px;\n  line-height: 40px;\n  white-space: nowrap;\n}\n.card-nav-img {\n  height: 38px;\n}\n.card-nav-name {\n  height: 40px;\n  float: right;\n  font-size: 15px;\n  margin: 0 0;\n  line-height: 40px;\n  white-space: nowrap;\n}\n.card-nav-content {\n  margin-top: 10px;\n  font-size: 13px;\n  color: #999;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  height: 37px;\n  margin-bottom: 5px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# 组件使用\n\ndocs 下的任意目录建立一个 md 文档，我在 docs 根目录下建立了 01.导航站.md 文档。\n\n然后在文档里添加一些内容（开头的 frontmatter 需要配置你自己的）：\n\n---\ntitle: 本站 - 导航站模块     # 你自己的标题\ndate: 2022-01-11 14:03:46   # 你自己的时间\npermalink: /about/website/tools/  # 你自己的链接\ncategories:\n  - \ntags: \n  - \n---\n\n## 搜索引擎\n\n<ClientOnly>\n  <Card :cardData="cardData0" :cardListSize=3 carTitlColor="#000" carHoverColor="#000" />\n</ClientOnly>\n\n## 前端开发\n\n<ClientOnly>\n  <Card :cardData="cardData1" :cardListSize=3 carTitlColor="#000" carHoverColor="#000" />\n</ClientOnly>\n\n<script>\nexport default {\n  data() {\n    return {\n      cardData0: [\n        {\n          id: "0",\n          cardSrc: "http://www.baidu.com/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220104224044.png",\n          cardName: "百度",\n          cardContent:\n            "百度——全球最大的中文搜索引擎及最大的中文网站，全球领先的人工智能公司",\n        },\n        {\n          cardSrc: "http://www.google.com/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220104225539.png",\n          cardName: "Google",\n          cardContent: "全球最大的搜索引擎公司",\n        },\n        {\n          cardSrc: "https://www.bing.com/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220104224430.png",\n          cardName: "Bing",\n          cardContent: "微软公司推出的用以取代Live Search的搜索引擎",\n        },\n      ],\n      cardData1: [\n        {\n          id: "1",\n          title: "Vue & UI",\n          cardSrc: "https://cn.vuejs.org/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220105001047.png",\n          cardName: "Vue",\n          cardContent: "渐进式 JavaScript 框架",\n        },\n        {\n          cardSrc: "https://element.eleme.cn/#/zh-CN/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220105001602.png",\n          cardName: "Element-UI",\n          cardContent:\n            "Element，一套为开发者、设计师和产品经理准备的基于 Vue 的桌面端组件库",\n        },\n        {\n          cardSrc: "https://next.antdv.com/docs/vue/introduce-cn/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220105223748.svg",\n          cardName: "Ant Design Vue",\n          cardContent: "Vue UI 之 Ant Design Vue，蚂蚁金服的 Vue 框架",\n        },\n        {\n          cardSrc: "https://www.iviewui.com/",\n          cardImgSrc:\n            "https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/img/tools/20220105001656.png",\n          cardName: "View UI",\n          cardContent: "View UI 是一套基于 Vue.js 的高质量UI 组件库",\n        },\n        {\n          cardSrc: "https://youzan.github.io/vant/#/zh-CN/",\n          cardImgSrc: "https://img01.yzcdn.cn/vant/logo.png",\n          cardName: "Vant",\n          cardContent: "轻量、可靠的移动端 Vue 组件库",\n        },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n如果有多个内容，依次类推。\n\n<ClientOnly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n\n# 属性\n\nVue 组件可以传 4 个属性：\n\ncardData\n\n * 类型：Array\n * 属性：\n   * id：代表当前 cardData 的 id（仅限第一个对象填写）（必填）\n   * title：该 cardData 的标题（仅限第一个对象填写）（可选）\n   * cardSrc：点击卡片跳转的地址\n   * cardImgSrc：卡片的图片\n   * cardName：卡片的名字\n   * cardContent：卡片的内容\n\n卡片的具体数据。\n\ncardListSize\n\n * 类型：number\n * 范围：1 - 4\n * 默认值：3\n\n页面的一行显示多少个卡片。\n\ncarTitlColor\n\n * 类型：string\n * 默认值：#000\n\n卡片的名字颜色。\n\ncarHoverColor\n\n * 类型：string\n * 默认值：#000\n\n卡片的内容鼠标悬停的颜色。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n主题自带的卡片列表不适合制作导航卡片，于是我稍微自己实现了它。\n\n2021-01-11 @du wu\n\n\n\n * 前言\n * vue组件\n * 组件使用\n * 属性\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n导航卡片是什么，请先看我的导航站：https://notes.youngkbt.cn/navigation/\n\n因为个人不使用本地主题，所以无法直接获取一个文章的内容来解析，只能一切都在本地代码制作。\n\n\n# vue组件\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n导航卡片需要一个 vue 组件，在 docs/.vuepress/components 下创建 card.vue 组件，如果没有 components 文件夹，请创建。\n\n组件添加如下内容：\n\n<template>\n  <div>\n    <template v-if="carddata[0].title != undefined">\n        <div style="text-align: center; font-weight: 900">{{ carddata[0].title }}</div>\n    </template>\n    <div class="kbt-row">\n    <div\n      class="card-nav-box"\n      :style="\n        cardlistsize == 4\n          ? \'width: 25%;\'\n          : cardlistsize == 2\n          ? \'width: 50%;\'\n          : \'width: 33.333%;\'\n      "\n      v-for="(item,index) in carddata"\n      :key="index"\n    >\n      <a :href="item.cardsrc" target="_blank">\n        <div class="card-nav-item">\n          <div class="card-nav-title">\n            <img\n              v-if="item.cardimgsrc && item.cardimgsrc != \'\'"\n              :src="item.cardimgsrc"\n              alt="正在加载 ..."\n              class="card-nav-img"\n            />\n            <p class="card-nav-name" :style="\'color:\' + cartitlecolor">\n              {{ item.cardname }}\n            </p>\n          </div>\n          <div :title="item.cardcontent" class="card-nav-content">\n            {{ item.cardcontent }}\n          </div>\n        </div>\n      </a>\n    </div>\n  </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {\n    carddata: {\n      type: array,\n      default: [],\n    },\n    cardlistsize: {\n      type: number,\n      default: 3,\n    },\n    cartitlecolor: {\n      type: string,\n      default: "#000",\n    },\n    carhovercolor: {\n      type: string,\n      default: "#000",\n    },\n  },\n  mounted() {\n    this.cardhovercolor();\n  },\n  methods: {\n    cardhovercolor() {\n      if(!document.queryselector(".card")){\n        const carhovercolor = this.carhovercolor;\n        let style = document.createelement("style");\n        style.classname = \'card\';\n        style.innerhtml = `.card-nav-content:hover{color: ${carhovercolor}}`;\n        document.head.appendchild(style);\n      }\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.kbt-row {\n  margin: 0.7rem 0;\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-start;\n}\n.card-nav-box {\n  padding: 0 10px 0 10px;\n  box-sizing: border-box;\n}\n.card-nav-box a:hover {\n  text-decoration: none !important;\n}\n.card-nav-item {\n  min-height: 76px;\n  margin-top: 10px;\n  margin-bottom: 10px;\n  padding: 10px;\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 2px 10px 0 rgb(0 0 0 / 10%);\n  transition: all 0.4s;\n}\n.card-nav-item:hover {\n  box-shadow: 0 10px 20px -10px rgba(0, 0, 0, 0.7);\n  transform: translatey(-3px) scale(1.01, 1.01);\n}\n.card-nav-title {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-size: 15px;\n  margin: 5px 0;\n  height: 40px;\n  line-height: 40px;\n  white-space: nowrap;\n}\n.card-nav-img {\n  height: 38px;\n}\n.card-nav-name {\n  height: 40px;\n  float: right;\n  font-size: 15px;\n  margin: 0 0;\n  line-height: 40px;\n  white-space: nowrap;\n}\n.card-nav-content {\n  margin-top: 10px;\n  font-size: 13px;\n  color: #999;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n  height: 37px;\n  margin-bottom: 5px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n\n\n\n# 组件使用\n\ndocs 下的任意目录建立一个 md 文档，我在 docs 根目录下建立了 01.导航站.md 文档。\n\n然后在文档里添加一些内容（开头的 frontmatter 需要配置你自己的）：\n\n---\ntitle: 本站 - 导航站模块     # 你自己的标题\ndate: 2022-01-11 14:03:46   # 你自己的时间\npermalink: /about/website/tools/  # 你自己的链接\ncategories:\n  - \ntags: \n  - \n---\n\n## 搜索引擎\n\n<clientonly>\n  <card :carddata="carddata0" :cardlistsize=3 cartitlcolor="#000" carhovercolor="#000" />\n</clientonly>\n\n## 前端开发\n\n<clientonly>\n  <card :carddata="carddata1" :cardlistsize=3 cartitlcolor="#000" carhovercolor="#000" />\n</clientonly>\n\n<script>\nexport default {\n  data() {\n    return {\n      carddata0: [\n        {\n          id: "0",\n          cardsrc: "http://www.baidu.com/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220104224044.png",\n          cardname: "百度",\n          cardcontent:\n            "百度——全球最大的中文搜索引擎及最大的中文网站，全球领先的人工智能公司",\n        },\n        {\n          cardsrc: "http://www.google.com/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220104225539.png",\n          cardname: "google",\n          cardcontent: "全球最大的搜索引擎公司",\n        },\n        {\n          cardsrc: "https://www.bing.com/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220104224430.png",\n          cardname: "bing",\n          cardcontent: "微软公司推出的用以取代live search的搜索引擎",\n        },\n      ],\n      carddata1: [\n        {\n          id: "1",\n          title: "vue & ui",\n          cardsrc: "https://cn.vuejs.org/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220105001047.png",\n          cardname: "vue",\n          cardcontent: "渐进式 javascript 框架",\n        },\n        {\n          cardsrc: "https://element.eleme.cn/#/zh-cn/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220105001602.png",\n          cardname: "element-ui",\n          cardcontent:\n            "element，一套为开发者、设计师和产品经理准备的基于 vue 的桌面端组件库",\n        },\n        {\n          cardsrc: "https://next.antdv.com/docs/vue/introduce-cn/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220105223748.svg",\n          cardname: "ant design vue",\n          cardcontent: "vue ui 之 ant design vue，蚂蚁金服的 vue 框架",\n        },\n        {\n          cardsrc: "https://www.iviewui.com/",\n          cardimgsrc:\n            "https://cdn.staticaly.com/gh/kele-bingtang/static@master/img/tools/20220105001656.png",\n          cardname: "view ui",\n          cardcontent: "view ui 是一套基于 vue.js 的高质量ui 组件库",\n        },\n        {\n          cardsrc: "https://youzan.github.io/vant/#/zh-cn/",\n          cardimgsrc: "https://img01.yzcdn.cn/vant/logo.png",\n          cardname: "vant",\n          cardcontent: "轻量、可靠的移动端 vue 组件库",\n        },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n如果有多个内容，依次类推。\n\n<clientonly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n\n# 属性\n\nvue 组件可以传 4 个属性：\n\ncarddata\n\n * 类型：array\n * 属性：\n   * id：代表当前 carddata 的 id（仅限第一个对象填写）（必填）\n   * title：该 carddata 的标题（仅限第一个对象填写）（可选）\n   * cardsrc：点击卡片跳转的地址\n   * cardimgsrc：卡片的图片\n   * cardname：卡片的名字\n   * cardcontent：卡片的内容\n\n卡片的具体数据。\n\ncardlistsize\n\n * 类型：number\n * 范围：1 - 4\n * 默认值：3\n\n页面的一行显示多少个卡片。\n\ncartitlcolor\n\n * 类型：string\n * 默认值：#000\n\n卡片的名字颜色。\n\ncarhovercolor\n\n * 类型：string\n * 默认值：#000\n\n卡片的内容鼠标悬停的颜色。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 代码块隐藏模块",frontmatter:{title:"本站 - 代码块隐藏模块",date:"2022-02-13T19:18:07.000Z",permalink:"/about/website/code-block-hidden/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/28.%E6%9C%AC%E7%AB%99%20-%20%E4%BB%A3%E7%A0%81%E5%9D%97%E9%9A%90%E8%97%8F%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/28.本站 - 代码块隐藏模块.md",key:"v-27fb31be",path:"/about/website/code-block-hidden/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:68},{level:2,title:"前提 1",slug:"前提-1",normalizedTitle:"前提 1",charIndex:74},{level:2,title:"前提 2",slug:"前提-2",normalizedTitle:"前提 2",charIndex:82},{level:2,title:"添加箭头图标",slug:"添加箭头图标",normalizedTitle:"添加箭头图标",charIndex:90},{level:2,title:"添加Vue组件",slug:"添加vue组件",normalizedTitle:"添加vue组件",charIndex:100},{level:2,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:111},{level:2,title:"注册Vue组件",slug:"注册vue组件",normalizedTitle:"注册vue组件",charIndex:117},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:128}],headersStr:"前言 前提 1 前提 2 添加箭头图标 添加Vue组件 注意 注册Vue组件 结束语",content:'笔记\n\n一个代码块的代码太多，会占据大量的篇幅，如果能选择性隐藏，页面也许更加好看。\n\n2021-01-11 @Du Wu\n\n\n\n * 前言\n * 前提 1\n * 前提 2\n * 添加箭头图标\n * 添加Vue组件\n * 注意\n * 注册Vue组件\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n代码块可以隐藏，也可以展开，这和 ::: details 类似，下面是简单的代码块 Demo：\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println("Hello，World");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n看到代码块右边的箭头了吗，点击即可隐藏代码块，再次点击则会展开代码块。\n\n本内容实现并不难，只需三步：\n\n * 添加箭头图标\n * 编写代码块模块的 Vue 组件\n * 全局注册 Vue 组件\n\n实现内容：\n\n * 代码块的隐藏和显示\n\n * 美化代码块的 UI，趋向于 Mac\n\n * 优化代码块语言的显示，因为默认主题的一些语言如 stylus 是不会显示出来。本内容的优化无论代码块语言是什么（如 abc），都会显示出来，如下\n   \n   我的语言不是 Java、PHP、JS、SH，而是 abdedfg\n   \n   \n   1\n   \n\n\n# 前提 1\n\n本内容重新实现的一键复制功能是基于 vuepress-plugin-one-click-copy 插件（箭头左边），该插件已经内置 vuepress-theme-vdoing 主题，所以无需担心，如果你曾经卸载了该插件，则需要安装回来；如果已经安装，则无需看这一步：\n\nyarn add vuepress-plugin-one-click-copy -D\n\n\n1\n\n\n当然，如果你懂得看下面的源码，则将适配 vuepress-plugin-one-click-copy 插件的代码进行修改，只需要提供其他插件的 class 名进行判断（Vue 组件的 108 - 119 行代码），并自行在 F12 调试，移动到满意的位置。\n\n如果不知道自己是否曾卸载或存在该插件，则前往根目录下的 package.json 文件查看 devDependencies 是否有 vuepress-plugin-one-click-copy 插件。\n\n\n# 前提 2\n\n本功能需要代码块需要开启 行号 功能，该功能已经内置 VuePress，所以只需要开启该配置即可。\n\n在 docs/.vuepress/config.ts 里开启行号：\n\n\n\n\n\n \n \n \n \n\n\n\n\nexport default defineConfig4CustomTheme({\n    theme: "vdoing", // 使用 npm 包主题\n    // ...\n    markdown: {\n        lineNumbers: true, // 显示代码块的行号\n        extractHeaders: ["h2", "h3", "h4"], // 支持 h2、h3、h4 标题\n    },\n    // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 添加箭头图标\n\n图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n当然，建议你使用自己的图标库，比较稳定。就像注册一个购物账户，然后添加到购物车即可。\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 head 模块里添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'//at.alicdn.com/t/font_3114978_qe0b39no76.css\' }]\n\n\n1\n\n\n\n# 添加Vue组件\n\n在 docs/.vuepress/components 目录下创建 Vue 组件：BlockToggle.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template></template>\n\n<script>\nexport default {\n  mounted() {\n    setTimeout(() => {\n      this.addExpand(40);\n    }, 1000);\n  },\n  watch: {\n    $route(to, from) {\n      if (to.path != from.path || this.$route.hash == "") {\n        setTimeout(() => {\n          this.addExpand(40);\n        }, 1000);\n      }\n    },\n  },\n  methods: {\n    // 隐藏代码块后，保留 40 的代码块高度\n    addExpand(hiddenHeight = 40) {\n      let modes = document.getElementsByClassName("line-numbers-mode");\n      // 遍历出每一个代码块\n      Array.from(modes).forEach((item) => {\n        // 首先获取 expand 元素\n        let expand = item.getElementsByClassName("expand")[0];\n        // expand 元素不存在，则进入 if 创建\n        if (!expand) {\n          // 获取代码块原来的高度，进行备份\n          let modeHeight = item.offsetHeight;\n          // display:none 的代码块需要额外处理，图文卡片列表本质是代码块，所以排除掉\n          if (\n            modeHeight == 0 &&\n            item.parentNode.className != "cardImgListContainer"\n          ) {\n            modeHeight = this.getHiddenElementHight(item);\n          }\n          // modeHeight 比主题多 12，所以减掉，并显示赋值，触发动画过渡效果\n          modeHeight -= 12;\n          item.style.height = modeHeight + "px";\n          // 获取代码块的各个元素\n          let pre = item.getElementsByTagName("pre")[0];\n          let wrapper = item.getElementsByClassName("line-numbers-wrapper")[0];\n          // 创建箭头元素\n          const div = document.createElement("div");\n          div.className = "expand icon-xiangxiajiantou iconfont";\n          // 箭头点击事件\n          div.onclick = () => {\n            // 代码块已经被隐藏，则进入 if 循环，如果没有被隐藏，则进入 else 循环\n            if (parseInt(item.style.height) == hiddenHeight) {\n              div.className = "expand icon-xiangxiajiantou iconfont";\n              item.style.height = modeHeight + "px";\n              setTimeout(() => {\n                pre.style.display = "block";\n                wrapper.style.display = "block";\n              }, 80);\n            } else {\n              div.className = "expand icon-xiangxiajiantou iconfont closed";\n              item.style.height = hiddenHeight + "px";\n              setTimeout(() => {\n                pre.style.display = "none";\n                wrapper.style.display = "none";\n              }, 300);\n            }\n          };\n          item.append(div);\n          item.append(this.addCircle());\n        }\n        // 解决某些代码块的语言不显示在页面上\n        this.getLanguage(item);\n        // 移动一键复制图标到正确的位置\n        let flag = false;\n        let interval = setInterval(() => {\n          flag = this.moveCopyBlock(item);\n          if (flag) {\n            clearInterval(interval);\n          }\n        }, 1000);\n      });\n    },\n    getHiddenElementHight(hiddenElement) {\n      let modeHeight;\n      if (\n        hiddenElement.parentNode.style.display == "none" ||\n        hiddenElement.parentNode.className !=\n          "theme-code-block theme-code-block__active"\n      ) {\n        hiddenElement.parentNode.style.display = "block";\n        modeHeight = hiddenElement.offsetHeight;\n        hiddenElement.parentNode.style.display = "none";\n        // 清除 vuepress 自带的 deetails 多选代码块\n        if (\n          hiddenElement.parentNode.className == "theme-code-block" ||\n          hiddenElement.parentNode.className == "cardListContainer"\n        ) {\n          hiddenElement.parentNode.style.display = "";\n        }\n      }\n      return modeHeight;\n    },\n    // 添加三个圆圈\n    addCircle() {\n      let div = document.createElement("div");\n      div.className = "circle";\n      return div;\n    },\n    // 移动一键复制图标\n    moveCopyBlock(element) {\n      let copyElement = element.getElementsByClassName("code-copy")[0];\n      if (copyElement && copyElement.parentNode != element) {\n        copyElement.parentNode.parentNode.insertBefore(\n          copyElement,\n          copyElement.parentNode\n        );\n        return true;\n      } else {\n        return false;\n      }\n    },\n    // 解决某些代码块的语言不显示在页面上\n    getLanguage(element) {\n      // 动态获取 before 的 content 属性\n      let content = getComputedStyle(element, ":before").getPropertyValue(\n        "content"\n      );\n      // "" 的长度是 2，不是 0，"x" 的长度是 3\n      if (content.length == 2 || content == "" || content == "none") {\n        let language = element.className.substring(\n          "language".length + 1,\n          element.className.indexOf(" ")\n        );\n        element.setAttribute("data-language", language);\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n/* 代码块元素 */\n.line-numbers-mode {\n  overflow: hidden;\n  transition: height 0.3s;\n  margin-top: 0.85rem;\n}\n.line-numbers-mode::before {\n  content: attr(data-language);\n}\n/* 箭头元素 */\n.expand {\n  width: 16px;\n  height: 16px;\n  cursor: pointer;\n  position: absolute;\n  z-index: 3;\n  top: 0.8em;\n  right: 0.5em;\n  color: rgba(238, 255, 255, 0.8);\n  font-weight: 900;\n  transition: transform 0.3s;\n}\n\n/* 代码块内容 */\ndiv[class*="language-"].line-numbers-mode pre {\n  margin: 30px 0 0.85rem 0;\n}\n/* 代码块的行数 */\ndiv[class*="language-"].line-numbers-mode .line-numbers-wrapper,\n.highlight-lines {\n  margin-top: 30px;\n}\n/* 箭头关闭后旋转 -90 度 */\n.closed {\n  transform: rotate(90deg) translateY(-3px);\n  transition: all 0.3s;\n}\nli .closed {\n  transform: rotate(90deg) translate(5px, -8px);\n}\n/* 代码块的语言 */\ndiv[class*="language-"]::before {\n  position: absolute;\n  z-index: 3;\n  top: 0.3em;\n  left: 4.7rem;\n  font-size: 1.15em;\n  color: rgba(238, 255, 255, 0.8);\n  text-transform: uppercase;\n  font-weight: bold;\n  width: fit-content;\n}\n/* li 下的代码块的语言和 li 下的箭头 */\nli div[class*="language-"]::before,\nli .expand {\n  margin-top: -4px;\n}\n/* 代码块行数的线条 */\ndiv[class*="language-"].line-numbers-mode::after {\n  margin-top: 35px;\n}\n/* 代码块的三个圆圈颜色 */\n.circle {\n  position: absolute;\n  top: 0.8em;\n  left: 0.9rem;\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  background: #fc625d;\n  -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b;\n  box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b;\n}\n/* 代码块一键复制图标 */\n.code-copy {\n  position: absolute;\n  top: 0.8rem;\n  right: 2rem;\n  fill: rgba(238, 255, 255, 0.8);\n  opacity: 1;\n}\n.code-copy svg {\n  margin: 0;\n}\n\n/* 如果你浅色模式的代码块背景色是浅灰色，则取消下面的注释使代码生效，如果是黑色，则注释下面的三段代码（我注释了，因为是黑色背景） */\n/* .theme-mode-light .expand {\n  color: #666;\n}\n.theme-mode-light div[class*="language-"]::before {\n  color: #666;\n}\n.theme-mode-light .code-copy {\n  fill: #666;\n} */\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n\n\n第 7 行和第 14 行的参数 40 是隐藏代码块后，保留的代码块高度，40 是默认值。\n\n注意\n\n * 如果浅色模式的代码块背景色是浅灰色，则取消 226 - 234 的注释使代码生效（模板已经取消注释）\n * 如果是黑色，则注释 226 - 234 的代码（我自己的注释了，因为我的代码块是黑色背景）\n * 如果不喜欢代码块的语言变成大写，则注释 188 行的 text-transform: uppercase;\n\n如果你想要你的代码块和我一样是 黑色，则打开 docs/.vuepress/styles/palette.styl 文件，替换掉原来的浅色模式：\n\n.theme-mode-light\n  --bodyBg: #f4f4f4\n  --mainBg: rgba(255,255,255,1)\n  --sidebarBg: rgba(255,255,255,.8)\n  --blurBg: rgba(255,255,255,.9)\n  --customBlockBg: rgba(255,255,255,.9)\n  --textColor: #00323c\n  --textLightenColor: #0085AD\n  --borderColor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  //--codeBg: #f6f8fa\n  //--codeColor: #24292e\n  //codeThemeLight()\n  // 行高亮颜色，和代码块浅色主题一起使用，一起注释\n  //div[class*="language-"]\n  //  .highlight-lines\n  //    .highlighted\n  //      background-color rgba(200,200,200,.4)\n  //  &.line-numbers-mode\n  //    .highlight-lines .highlighted\n  //      &:before\n  //        background-color rgba(200,200,200,.4)\n  // 代码块深色主题\n  --codeBg: #282C34\n  --codeColor: #D4D4D4\n  codeThemeDark()\n  // 行高亮颜色，和代码块深色主题一起使用，一起注释\n  div[class*="language-"]\n    .highlight-lines\n      .highlighted\n        background-color rgba(0,0,0,.66)\n    &.line-numbers-mode\n      .highlight-lines .highlighted\n        &:before\n          background-color rgba(0,0,0,.66)\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n如果你喜欢加粗的 绿色、`` 包裹的 英文高亮 abcd、<mark></mark> 包裹的 文字高亮、深色模式的颜色（点击右下角的衣服图标，切换深色模式）等等，那么可以参考我的自定义样式模块，左侧的关于本站目录下就能找到。\n\n\n# 注意\n\n * vuepress-plugin-one-click-copy 插件在移动端（手机端）失效，因为其自带的隐藏效果原因，这并不是本模块引起，而是本身插件的设计问题，所以如果觉得移动端也想要支持一键复制，请更换其他插件，并自行修改源码进行适配\n * 低分辨率的电脑，会导致代码的行数与代码不对应（代码行数溢出），这并非本模块原因，而是 VuePress 代码块本身的原因，可能新版本会修复\n\n\n# 注册Vue组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\n添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globalUIComponents: ["BlockToggle"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from \'vuepress/config\'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobalUIComponents: ["BlockToggle"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 结束语\n\n如果你正在热编译 markdown 的代码块，它不会立马生效，你只需要刷新下就能看到效果，而打包后，效果是会生效，无需担心。\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n一个代码块的代码太多，会占据大量的篇幅，如果能选择性隐藏，页面也许更加好看。\n\n2021-01-11 @du wu\n\n\n\n * 前言\n * 前提 1\n * 前提 2\n * 添加箭头图标\n * 添加vue组件\n * 注意\n * 注册vue组件\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n代码块可以隐藏，也可以展开，这和 ::: details 类似，下面是简单的代码块 demo：\n\npublic class hello {\n    public static void main(string[] args) {\n        system.out.println("hello，world");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n看到代码块右边的箭头了吗，点击即可隐藏代码块，再次点击则会展开代码块。\n\n本内容实现并不难，只需三步：\n\n * 添加箭头图标\n * 编写代码块模块的 vue 组件\n * 全局注册 vue 组件\n\n实现内容：\n\n * 代码块的隐藏和显示\n\n * 美化代码块的 ui，趋向于 mac\n\n * 优化代码块语言的显示，因为默认主题的一些语言如 stylus 是不会显示出来。本内容的优化无论代码块语言是什么（如 abc），都会显示出来，如下\n   \n   我的语言不是 java、php、js、sh，而是 abdedfg\n   \n   \n   1\n   \n\n\n# 前提 1\n\n本内容重新实现的一键复制功能是基于 vuepress-plugin-one-click-copy 插件（箭头左边），该插件已经内置 vuepress-theme-vdoing 主题，所以无需担心，如果你曾经卸载了该插件，则需要安装回来；如果已经安装，则无需看这一步：\n\nyarn add vuepress-plugin-one-click-copy -d\n\n\n1\n\n\n当然，如果你懂得看下面的源码，则将适配 vuepress-plugin-one-click-copy 插件的代码进行修改，只需要提供其他插件的 class 名进行判断（vue 组件的 108 - 119 行代码），并自行在 f12 调试，移动到满意的位置。\n\n如果不知道自己是否曾卸载或存在该插件，则前往根目录下的 package.json 文件查看 devdependencies 是否有 vuepress-plugin-one-click-copy 插件。\n\n\n# 前提 2\n\n本功能需要代码块需要开启 行号 功能，该功能已经内置 vuepress，所以只需要开启该配置即可。\n\n在 docs/.vuepress/config.ts 里开启行号：\n\n\n\n\n\n \n \n \n \n\n\n\n\nexport default defineconfig4customtheme({\n    theme: "vdoing", // 使用 npm 包主题\n    // ...\n    markdown: {\n        linenumbers: true, // 显示代码块的行号\n        extractheaders: ["h2", "h3", "h4"], // 支持 h2、h3、h4 标题\n    },\n    // ...\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 添加箭头图标\n\n图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n当然，建议你使用自己的图标库，比较稳定。就像注册一个购物账户，然后添加到购物车即可。\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 head 模块里添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'//at.alicdn.com/t/font_3114978_qe0b39no76.css\' }]\n\n\n1\n\n\n\n# 添加vue组件\n\n在 docs/.vuepress/components 目录下创建 vue 组件：blocktoggle.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template></template>\n\n<script>\nexport default {\n  mounted() {\n    settimeout(() => {\n      this.addexpand(40);\n    }, 1000);\n  },\n  watch: {\n    $route(to, from) {\n      if (to.path != from.path || this.$route.hash == "") {\n        settimeout(() => {\n          this.addexpand(40);\n        }, 1000);\n      }\n    },\n  },\n  methods: {\n    // 隐藏代码块后，保留 40 的代码块高度\n    addexpand(hiddenheight = 40) {\n      let modes = document.getelementsbyclassname("line-numbers-mode");\n      // 遍历出每一个代码块\n      array.from(modes).foreach((item) => {\n        // 首先获取 expand 元素\n        let expand = item.getelementsbyclassname("expand")[0];\n        // expand 元素不存在，则进入 if 创建\n        if (!expand) {\n          // 获取代码块原来的高度，进行备份\n          let modeheight = item.offsetheight;\n          // display:none 的代码块需要额外处理，图文卡片列表本质是代码块，所以排除掉\n          if (\n            modeheight == 0 &&\n            item.parentnode.classname != "cardimglistcontainer"\n          ) {\n            modeheight = this.gethiddenelementhight(item);\n          }\n          // modeheight 比主题多 12，所以减掉，并显示赋值，触发动画过渡效果\n          modeheight -= 12;\n          item.style.height = modeheight + "px";\n          // 获取代码块的各个元素\n          let pre = item.getelementsbytagname("pre")[0];\n          let wrapper = item.getelementsbyclassname("line-numbers-wrapper")[0];\n          // 创建箭头元素\n          const div = document.createelement("div");\n          div.classname = "expand icon-xiangxiajiantou iconfont";\n          // 箭头点击事件\n          div.onclick = () => {\n            // 代码块已经被隐藏，则进入 if 循环，如果没有被隐藏，则进入 else 循环\n            if (parseint(item.style.height) == hiddenheight) {\n              div.classname = "expand icon-xiangxiajiantou iconfont";\n              item.style.height = modeheight + "px";\n              settimeout(() => {\n                pre.style.display = "block";\n                wrapper.style.display = "block";\n              }, 80);\n            } else {\n              div.classname = "expand icon-xiangxiajiantou iconfont closed";\n              item.style.height = hiddenheight + "px";\n              settimeout(() => {\n                pre.style.display = "none";\n                wrapper.style.display = "none";\n              }, 300);\n            }\n          };\n          item.append(div);\n          item.append(this.addcircle());\n        }\n        // 解决某些代码块的语言不显示在页面上\n        this.getlanguage(item);\n        // 移动一键复制图标到正确的位置\n        let flag = false;\n        let interval = setinterval(() => {\n          flag = this.movecopyblock(item);\n          if (flag) {\n            clearinterval(interval);\n          }\n        }, 1000);\n      });\n    },\n    gethiddenelementhight(hiddenelement) {\n      let modeheight;\n      if (\n        hiddenelement.parentnode.style.display == "none" ||\n        hiddenelement.parentnode.classname !=\n          "theme-code-block theme-code-block__active"\n      ) {\n        hiddenelement.parentnode.style.display = "block";\n        modeheight = hiddenelement.offsetheight;\n        hiddenelement.parentnode.style.display = "none";\n        // 清除 vuepress 自带的 deetails 多选代码块\n        if (\n          hiddenelement.parentnode.classname == "theme-code-block" ||\n          hiddenelement.parentnode.classname == "cardlistcontainer"\n        ) {\n          hiddenelement.parentnode.style.display = "";\n        }\n      }\n      return modeheight;\n    },\n    // 添加三个圆圈\n    addcircle() {\n      let div = document.createelement("div");\n      div.classname = "circle";\n      return div;\n    },\n    // 移动一键复制图标\n    movecopyblock(element) {\n      let copyelement = element.getelementsbyclassname("code-copy")[0];\n      if (copyelement && copyelement.parentnode != element) {\n        copyelement.parentnode.parentnode.insertbefore(\n          copyelement,\n          copyelement.parentnode\n        );\n        return true;\n      } else {\n        return false;\n      }\n    },\n    // 解决某些代码块的语言不显示在页面上\n    getlanguage(element) {\n      // 动态获取 before 的 content 属性\n      let content = getcomputedstyle(element, ":before").getpropertyvalue(\n        "content"\n      );\n      // "" 的长度是 2，不是 0，"x" 的长度是 3\n      if (content.length == 2 || content == "" || content == "none") {\n        let language = element.classname.substring(\n          "language".length + 1,\n          element.classname.indexof(" ")\n        );\n        element.setattribute("data-language", language);\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n/* 代码块元素 */\n.line-numbers-mode {\n  overflow: hidden;\n  transition: height 0.3s;\n  margin-top: 0.85rem;\n}\n.line-numbers-mode::before {\n  content: attr(data-language);\n}\n/* 箭头元素 */\n.expand {\n  width: 16px;\n  height: 16px;\n  cursor: pointer;\n  position: absolute;\n  z-index: 3;\n  top: 0.8em;\n  right: 0.5em;\n  color: rgba(238, 255, 255, 0.8);\n  font-weight: 900;\n  transition: transform 0.3s;\n}\n\n/* 代码块内容 */\ndiv[class*="language-"].line-numbers-mode pre {\n  margin: 30px 0 0.85rem 0;\n}\n/* 代码块的行数 */\ndiv[class*="language-"].line-numbers-mode .line-numbers-wrapper,\n.highlight-lines {\n  margin-top: 30px;\n}\n/* 箭头关闭后旋转 -90 度 */\n.closed {\n  transform: rotate(90deg) translatey(-3px);\n  transition: all 0.3s;\n}\nli .closed {\n  transform: rotate(90deg) translate(5px, -8px);\n}\n/* 代码块的语言 */\ndiv[class*="language-"]::before {\n  position: absolute;\n  z-index: 3;\n  top: 0.3em;\n  left: 4.7rem;\n  font-size: 1.15em;\n  color: rgba(238, 255, 255, 0.8);\n  text-transform: uppercase;\n  font-weight: bold;\n  width: fit-content;\n}\n/* li 下的代码块的语言和 li 下的箭头 */\nli div[class*="language-"]::before,\nli .expand {\n  margin-top: -4px;\n}\n/* 代码块行数的线条 */\ndiv[class*="language-"].line-numbers-mode::after {\n  margin-top: 35px;\n}\n/* 代码块的三个圆圈颜色 */\n.circle {\n  position: absolute;\n  top: 0.8em;\n  left: 0.9rem;\n  width: 12px;\n  height: 12px;\n  border-radius: 50%;\n  background: #fc625d;\n  -webkit-box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b;\n  box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b;\n}\n/* 代码块一键复制图标 */\n.code-copy {\n  position: absolute;\n  top: 0.8rem;\n  right: 2rem;\n  fill: rgba(238, 255, 255, 0.8);\n  opacity: 1;\n}\n.code-copy svg {\n  margin: 0;\n}\n\n/* 如果你浅色模式的代码块背景色是浅灰色，则取消下面的注释使代码生效，如果是黑色，则注释下面的三段代码（我注释了，因为是黑色背景） */\n/* .theme-mode-light .expand {\n  color: #666;\n}\n.theme-mode-light div[class*="language-"]::before {\n  color: #666;\n}\n.theme-mode-light .code-copy {\n  fill: #666;\n} */\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n\n\n第 7 行和第 14 行的参数 40 是隐藏代码块后，保留的代码块高度，40 是默认值。\n\n注意\n\n * 如果浅色模式的代码块背景色是浅灰色，则取消 226 - 234 的注释使代码生效（模板已经取消注释）\n * 如果是黑色，则注释 226 - 234 的代码（我自己的注释了，因为我的代码块是黑色背景）\n * 如果不喜欢代码块的语言变成大写，则注释 188 行的 text-transform: uppercase;\n\n如果你想要你的代码块和我一样是 黑色，则打开 docs/.vuepress/styles/palette.styl 文件，替换掉原来的浅色模式：\n\n.theme-mode-light\n  --bodybg: #f4f4f4\n  --mainbg: rgba(255,255,255,1)\n  --sidebarbg: rgba(255,255,255,.8)\n  --blurbg: rgba(255,255,255,.9)\n  --customblockbg: rgba(255,255,255,.9)\n  --textcolor: #00323c\n  --textlightencolor: #0085ad\n  --bordercolor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  //--codebg: #f6f8fa\n  //--codecolor: #24292e\n  //codethemelight()\n  // 行高亮颜色，和代码块浅色主题一起使用，一起注释\n  //div[class*="language-"]\n  //  .highlight-lines\n  //    .highlighted\n  //      background-color rgba(200,200,200,.4)\n  //  &.line-numbers-mode\n  //    .highlight-lines .highlighted\n  //      &:before\n  //        background-color rgba(200,200,200,.4)\n  // 代码块深色主题\n  --codebg: #282c34\n  --codecolor: #d4d4d4\n  codethemedark()\n  // 行高亮颜色，和代码块深色主题一起使用，一起注释\n  div[class*="language-"]\n    .highlight-lines\n      .highlighted\n        background-color rgba(0,0,0,.66)\n    &.line-numbers-mode\n      .highlight-lines .highlighted\n        &:before\n          background-color rgba(0,0,0,.66)\n  div[class*="language-"].line-numbers-mode::after  // 代码块的行数和内容分割线颜色\n    border-right 1px solid rgba(0, 0, 0, 0.66)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n如果你喜欢加粗的 绿色、`` 包裹的 英文高亮 abcd、<mark></mark> 包裹的 文字高亮、深色模式的颜色（点击右下角的衣服图标，切换深色模式）等等，那么可以参考我的自定义样式模块，左侧的关于本站目录下就能找到。\n\n\n# 注意\n\n * vuepress-plugin-one-click-copy 插件在移动端（手机端）失效，因为其自带的隐藏效果原因，这并不是本模块引起，而是本身插件的设计问题，所以如果觉得移动端也想要支持一键复制，请更换其他插件，并自行修改源码进行适配\n * 低分辨率的电脑，会导致代码的行数与代码不对应（代码行数溢出），这并非本模块原因，而是 vuepress 代码块本身的原因，可能新版本会修复\n\n\n# 注册vue组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\n添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globaluicomponents: ["blocktoggle"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from \'vuepress/config\'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobaluicomponents: ["blocktoggle"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 结束语\n\n如果你正在热编译 markdown 的代码块，它不会立马生效，你只需要刷新下就能看到效果，而打包后，效果是会生效，无需担心。\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 首页大图模块",frontmatter:{title:"本站 - 首页大图模块",date:"2022-01-12T23:35:41.000Z",permalink:"/about/website/index-big-img/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/26.%E6%9C%AC%E7%AB%99%20-%20%E9%A6%96%E9%A1%B5%E5%A4%A7%E5%9B%BE%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/26.本站 - 首页大图模块.md",key:"v-98bdb7cc",path:"/about/website/index-big-img/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:80},{level:2,title:"组件添加",slug:"组件添加",normalizedTitle:"组件添加",charIndex:86},{level:2,title:"组件注册",slug:"组件注册",normalizedTitle:"组件注册",charIndex:94},{level:3,title:"图片添加",slug:"图片添加",normalizedTitle:"图片添加",charIndex:104},{level:3,title:"组件添加",slug:"组件添加-2",normalizedTitle:"组件添加",charIndex:86},{level:2,title:"属性说明",slug:"属性说明",normalizedTitle:"属性说明",charIndex:122},{level:3,title:"导航栏配置",slug:"导航栏配置",normalizedTitle:"导航栏配置",charIndex:132},{level:3,title:"背景图配置",slug:"背景图配置",normalizedTitle:"背景图配置",charIndex:143},{level:3,title:"desc淡入淡出配置",slug:"desc淡入淡出配置",normalizedTitle:"desc淡入淡出配置",charIndex:154},{level:3,title:"气泡配置",slug:"气泡配置",normalizedTitle:"气泡配置",charIndex:170},{level:2,title:"额外动态大图",slug:"额外动态大图",normalizedTitle:"额外动态大图",charIndex:178},{level:3,title:"静态资源获取",slug:"静态资源获取",normalizedTitle:"静态资源获取",charIndex:190},{level:3,title:"组件配置",slug:"组件配置",normalizedTitle:"组件配置",charIndex:202},{level:3,title:"首页配置",slug:"首页配置",normalizedTitle:"首页配置",charIndex:212},{level:3,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:222},{level:3,title:"我的建议",slug:"我的建议",normalizedTitle:"我的建议",charIndex:232},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:240}],headersStr:"前言 组件添加 组件注册 图片添加 组件添加 属性说明 导航栏配置 背景图配置 desc淡入淡出配置 气泡配置 额外动态大图 静态资源获取 组件配置 首页配置 全局配置 我的建议 结束语",content:'笔记\n\n你是否曾进入他人的博客后，占据浏览器大屏的图片映入眼帘，如果你也喜欢这种样式，本内容将介绍如何实现。\n\n2021-01-11 @Du Wu\n\n\n\n * 前言\n * 组件添加\n * 组件注册\n   * 图片添加\n   * 组件添加\n * 属性说明\n   * 导航栏配置\n   * 背景图配置\n   * desc淡入淡出配置\n   * 气泡配置\n * 额外动态大图\n   * 静态资源获取\n   * 组件配置\n   * 首页配置\n   * 全局配置\n   * 我的建议\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n如果你没有了解什么是首页大图模块，可以浏览一番本内容介绍的大图模块，点击跳转 我的首页。(PS：如果不想跳转，也可以参考下方的图片)\n\n\n\n本内容实现了如下功能:\n\n * 客户端的大图片效果\n * 导航栏的颜色效果（可配置选择）\n * 滑出大图片的位置后，切换导航栏颜色效果（可配置选择）\n * 大图片的背景色随一天的不同时间而变化（可配置选择）\n * 首页时间提示效果（可配置选择）\n * 个人描述淡入淡出（打印机）效果（可配置选择）\n * 大图片的气泡效果（可配置选择）\n * 大图片气泡效果的位置选择（可配置选择）\n\n......\n\n本内容分为三步，无脑 Copy 即可：\n\n * 在 docs/.vuepress/components 目录中创建 IndexBigImg.vue 组件\n * 在 docs/index.md 添加 IndexBigImg.vue 组件\n * 在 docs/.vuepress/config.js（新版 config.ts）的 themeConfig 中配置\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 目录中创建 IndexBigImg.vue 组件，如果没有 components 文件夹，则请创建。\n\n在组件添加如下内容：\n\n<template>\n  <div class="index-bigimg" style="display: none"></div>\n</template>\n<script>\n// 两个变量分别是背景元素的 class、生成的箭头 class\nconst banner = "banner";\nconst banner_arrow = "banner-arrow";\nexport default {\n  data() {\n    return {\n      // 下面都是配置的默认值，建议在 themeConfig 进行配置，它们将覆盖这些属性值\n      navColor: 1,\n      switchNavColor: false,\n      bgTimeColor: false,\n      bgTimeColorArray: [\n        "transparent", // 透明\n        "rgba(255, 148, 48, .2)",\n        "rgba(0, 0, 0, .3)",\n        "rgba(0, 0, 0, .5)",\n      ],\n      descFade: false,\n      desc: [],\n      descFadeInTime: 200,\n      descFadeOutTime: 100,\n      descNextTime: 800,\n      descFontSize: "1.4rem",\n      bubble: false,\n      bubblePosition: 0,\n      bubbleNum: 200,\n      fadeInInterval: "", // 淡入定时器\n      fadeOutInterval: "", // 淡出定时器\n    };\n  },\n  mounted() {\n    const arrow = document.getElementById(banner_arrow);\n    arrow && arrow.parentNode.removeChild(arrow);\n    let a = document.createElement("a");\n    a.id = banner_arrow;\n    a.className = banner_arrow;\n    document.getElementsByClassName(banner)[0].append(a);\n    let targetA = document.getElementById(banner_arrow);\n    targetA.addEventListener("click", (e) => {\n      // 添加点击事件\n      this.scrollFn();\n    });\n\n    // 初始化配置\n    this.initConfig();\n\n    // 初始化组件功能\n    if (this.bgTimeColor) {\n      this.bgTimeColorAndTip();\n    }\n    setTimeout(() => {\n      this.noBgBlur();\n    }, 100);\n\n    this.blurText();\n    this.watchScroll();\n\n    if (this.descFade) {\n      this.textFadeInAndOut();\n    }\n    if (this.bubble) {\n      let canvas = document.createElement("canvas");\n      canvas.id = "canvas";\n      canvas.style.top = this.bubblePosition + "%";\n      document.getElementsByClassName(banner)[0].append(canvas);\n      this.canvasBubble();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 点击下一页后，往下滑动，移出大图\n      if (to.path == "/" && Object.keys(this.$route.query).length > 0) {\n        setTimeout(() => {\n          this.clickArrow();\n        }, 200);\n      }\n    },\n  },\n  methods: {\n    // 初始化配置\n    initConfig() {\n      if (\n        this.$themeConfig.indexImg &&\n        Object.keys(this.$themeConfig.indexImg).length > 0\n      ) {\n        this.navColor =\n          this.$themeConfig.indexImg.navColor == undefined\n            ? this.navColor\n            : this.$themeConfig.indexImg.navColor;\n        this.switchNavColor =\n          this.$themeConfig.indexImg.switchNavColor == undefined\n            ? this.switchNavColor\n            : this.$themeConfig.indexImg.switchNavColor;\n        this.bgTimeColor =\n          this.$themeConfig.indexImg.bgTimeColor == undefined\n            ? this.bgTimeColor\n            : this.$themeConfig.indexImg.bgTimeColor;\n        this.bgTimeColorArray =\n          this.$themeConfig.indexImg.bgTimeColorArray == undefined\n            ? this.bgTimeColorArray\n            : this.$themeConfig.indexImg.bgTimeColorArray;\n        this.descFade =\n          this.$themeConfig.indexImg.descFade == undefined\n            ? this.descFade\n            : this.$themeConfig.indexImg.descFade;\n        this.desc =\n          this.$themeConfig.indexImg.desc == undefined\n            ? this.desc\n            : this.$themeConfig.indexImg.desc;\n        this.descFontSize =\n          this.$themeConfig.indexImg.descFontSize == undefined\n            ? this.descFontSize\n            : this.$themeConfig.indexImg.descFontSize;\n        this.descFadeInTime =\n          this.$themeConfig.indexImg.descFadeInTime == undefined\n            ? this.descFadeInTime\n            : this.$themeConfig.indexImg.descFadeInTime;\n        this.descNextTime =\n          this.$themeConfig.indexImg.descNextTime == undefined\n            ? this.descNextTime\n            : this.$themeConfig.indexImg.descNextTime;\n        this.bubble =\n          this.$themeConfig.indexImg.bubble == undefined\n            ? this.bubble\n            : this.$themeConfig.indexImg.bubble;\n        this.bubblePosition =\n          this.$themeConfig.indexImg.bubblePosition == undefined\n            ? this.bubblePosition\n            : this.$themeConfig.indexImg.bubblePosition;\n        this.bubbleNum =\n          this.$themeConfig.indexImg.bubbleNum == undefined\n            ? this.bubbleNum\n            : this.$themeConfig.indexImg.bubbleNum;\n      }\n    },\n    // 点击箭头向下滑动\n    scrollFn() {\n      const windowH = document.getElementsByClassName(banner)[0].clientHeight; // 获取窗口高度\n      window.scrollTo({\n        top: windowH,\n        behavior: "smooth", // 平滑滚动\n      });\n    },\n    // 触发下拉按钮\n    clickArrow() {\n      const arrow = document.getElementById("banner-arrow");\n      arrow.click();\n    },\n    // 监听页面滚动的回调\n    watchScroll() {\n      const windowH = document.getElementsByClassName(banner)[0].clientHeight; // 获取窗口高度\n      window.onscroll = () => {\n        if (document.documentElement.scrollTop < windowH) {\n          this.blurText(this.navColor);\n          this.noBgBlur();\n        } else {\n          if (this.switchNavColor && this.navColor == 1) {\n            this.blurText(2);\n          } else if (this.switchNavColor && this.navColor == 2) {\n            this.blurText(1);\n          }\n          this.bgBlur();\n        }\n      };\n    },\n    // 导航栏恢复原主题样式\n    bgBlur() {\n      let navbar = document.getElementsByClassName("navbar")[0];\n      navbar.className = "navbar blur";\n    },\n    // 导航栏透明\n    noBgBlur() {\n      let navbar = document.getElementsByClassName("navbar")[0];\n      navbar.className = "navbar navbar1 blur";\n    },\n    // 导航栏的字体颜色\n    blurText(navColor = this.navColor) {\n      let title = document.getElementsByClassName("site-name")[0];\n      let search = document.getElementsByClassName("search-box")[0];\n      let nav = document.getElementsByClassName("nav-links")[0];\n      if (navColor == 1) {\n        title.className = "site-name can-hide";\n        nav.className = "nav-links can-hide";\n        search.className = "search-box";\n      } else if (navColor == 2) {\n        title.className = "site-name site-name1 can-hide";\n        nav.className = "nav-links nav-links1 can-hide";\n        search.className = "search-box search-box1";\n      }\n    },\n    // 背景色随时间变化，时间提示框内容随时间变化\n    bgTimeColorAndTip() {\n      var hours = new Date().getHours();\n      var minutes = new Date().getMinutes();\n      var seconds = new Date().getSeconds();\n      hours = hours < 10 ? "0" + hours : hours;\n      minutes = minutes < 10 ? "0" + minutes : minutes;\n      seconds = seconds < 10 ? "0" + seconds : seconds;\n      let div = document.createElement("div");\n      div.className = "banner-color";\n      if (hours >= 6 && hours < 11) {\n        div.style.backgroundColor = this.bgTimeColorArray[0];\n        addTip(\n          `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 12 && hours <= 16) {\n        div.style.backgroundColor = this.bgTimeColorArray[0];\n        addTip(\n          `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 16 && hours <= 19) {\n        div.style.backgroundColor = this.bgTimeColorArray[1];\n        addTip(\n          `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 19 && hours < 24) {\n        div.style.backgroundColor = this.bgTimeColorArray[2];\n        addTip(\n          `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 0 && hours < 6) {\n        div.style.backgroundColor = this.bgTimeColorArray[3];\n        addTip(\n          `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n          "info",\n          50,\n          4000\n        );\n      }\n      document.getElementsByClassName(banner)[0].parentNode.append(div);\n    },\n    // 字体淡入淡出\n    textFadeInAndOut(\n      desc = this.desc, // 文字描述\n      descFontSize = this.descFontSize, // 字体大小\n      descFadeInTime = this.descFadeInTime, // 淡入时间\n      descFadeOutTime = this.descFadeOutTime, // 淡出时间\n      descNextTime = this.descNextTime // 下一个描述出现时间\n    ) {\n      let descElement = document.getElementsByClassName("description")[0];\n\n      if (descElement) {\n        // 非首页不触发\n        descElement.style.fontSize = descFontSize;\n        var span = document.createElement("span"); // 创建 | 的元素\n        span.className = "typed";\n        span.innerHTML = "|";\n        var index = 0; // 为 desc 的长度服务\n        var length = 0; // 为数组服务\n        var description = descElement.innerText; // 先取默认值\n        descElement.innerText = ""; // 清空 desc\n        descElement.appendChild(document.createElement("span")); // 创建 desc 所在的新元素\n        span && descElement.appendChild(span); // 添加 | 的元素\n        // 初始化迭代\n        this.fadeInInterval = setInterval(() => {\n          fadeIn();\n        }, descFadeInTime);\n      } else {\n        let hero = document.getElementsByClassName("hero")[0];\n        descElement = document.createElement("p");\n        descElement && (descElement.className = "description");\n        descElement && hero.appendChild(descElement);\n      }\n      // 淡入回调\n      let fadeIn = () => {\n        if (descElement) {\n          span.style.animation = "none"; // 淡入时，| 光标不允许闪烁\n          if (desc instanceof Array && desc.length > 0) {\n            // 如果是 themeConfig 传来的数组\n            description = desc[length];\n          }\n          descElement.firstChild.innerText = description.substring(0, index++);\n          if (index > description.length) {\n            clearInterval(this.fadeInInterval);\n            span.style.animation = "typedBlink 1s infinite"; // 淡入结束，| 光标允许闪烁\n            setTimeout(() => {\n              this.fadeOutInterval = setInterval(() => {\n                fadeOut();\n              }, descFadeOutTime);\n            }, descNextTime);\n          }\n        }\n      };\n      // 淡出回调\n      let fadeOut = () => {\n        if (index >= 0) {\n          span.style.animation = "none"; // 淡出时，| 光标不允许闪烁\n          descElement.firstChild.innerText = description.substring(0, index--);\n        } else {\n          clearInterval(this.fadeOutInterval);\n          span.style.animation = "typedBlink 1s infinite"; // 淡出结束，| 光标允许闪烁\n          setTimeout(() => {\n            length++;\n            if (length >= desc.length) {\n              length = 0; // desc 展示完，重新开始计数\n            }\n            this.fadeInInterval = setInterval(() => {\n              fadeIn();\n            }, descFadeInTime);\n          }, descNextTime);\n        }\n      };\n    },\n    // 气泡效果\n    canvasBubble(bubbleNum = this.bubbleNum) {\n      var canvas = document.getElementById("canvas");\n      var cxt = canvas.getContext("2d");\n      function Dot() {\n        this.alive = true;\n        this.x = Math.round(Math.random() * canvas.width);\n        this.y = Math.round(Math.random() * canvas.height);\n        this.diameter = Math.random() * 10.8;\n        this.ColorData = {\n          Red: Math.round(Math.random() * 255),\n          Green: Math.round(Math.random() * 255),\n          Blue: Math.round(Math.random() * 255),\n        };\n        this.alpha = 0.5;\n        this.color =\n          "rgba(" +\n          this.ColorData.Red +\n          ", " +\n          this.ColorData.Green +\n          "," +\n          this.ColorData.Blue +\n          "," +\n          this.alpha +\n          ")";\n        this.velocity = {\n          x: Math.round(Math.random() < 0.5 ? -1 : 1) * Math.random() * 0.7,\n          y: Math.round(Math.random() < 0.5 ? -1 : 1) * Math.random() * 0.7,\n        };\n      }\n      Dot.prototype = {\n        Draw: function () {\n          cxt.fillStyle = this.color;\n          cxt.beginPath();\n          cxt.arc(this.x, this.y, this.diameter, 0, Math.PI * 2, false);\n          cxt.fill();\n        },\n        Update: function () {\n          if (this.alpha < 0.8) {\n            this.alpha += 0.01;\n            this.color =\n              "rgba(" +\n              this.ColorData.Red +\n              ", " +\n              this.ColorData.Green +\n              "," +\n              this.ColorData.Blue +\n              "," +\n              this.alpha +\n              ")";\n          }\n          this.x += this.velocity.x;\n          this.y += this.velocity.y;\n          if (\n            this.x > canvas.width + 5 ||\n            this.x < 0 - 5 ||\n            this.y > canvas.height + 5 ||\n            this.y < 0 - 5\n          ) {\n            this.alive = false;\n          }\n        },\n      };\n      var Event = {\n        rArray: [],\n        Init: function () {\n          canvas.width = window.innerWidth;\n          canvas.height = window.innerHeight;\n          for (var x = 0; x < bubbleNum; x++) {\n            this.rArray.push(new Dot());\n          }\n          this.Update();\n        },\n        Draw: function () {\n          cxt.clearRect(0, 0, canvas.width, canvas.height);\n          this.rArray.forEach(function (dot) {\n            dot.Draw();\n          });\n        },\n        Update: function () {\n          if (Event.rArray.length < bubbleNum) {\n            for (var x = Event.rArray.length; x < bubbleNum; x++) {\n              Event.rArray.push(new Dot());\n            }\n          }\n          Event.rArray.forEach(function (dot) {\n            dot.Update();\n          });\n          Event.rArray = Event.rArray.filter(function (dot) {\n            return dot.alive;\n          });\n          Event.Draw();\n          requestAnimationFrame(Event.Update);\n        },\n      };\n      window.onresize = function () {\n        Event.rArray = [];\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n      };\n      Event.Init();\n    },\n  },\n  // 防止重写编译时，导致定时器叠加问题\n  beforeMount() {\n    clearInterval(this.fadeInInterval);\n    clearInterval(this.fadeOutInterval);\n  },\n  beforeDestroy() {\n    clearInterval(this.fadeInInterval);\n    clearInterval(this.fadeOutInterval);\n  },\n};\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startHeight：第一个弹窗的高度，默认 50\n * dieTime：弹窗消失时间（毫秒），默认 3000 毫秒\n *\n * 在 head 里添加图标 link 地址：https://at.alicdn.com/t/font_3114978_qe0b39no76.css\n */\nfunction addTip(content, type, startHeight = 50, dieTime = 3000) {\n  var tip = document.querySelectorAll(".global-tip");\n  var time = new Date().getTime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getAttribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lastTop =\n    parseInt(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetHeight + 17 : startHeight);\n\n  let div = document.createElement("div");\n  div.className = `global-tip tip-${type} ${time}`;\n  div.style.top = parseInt(top) + "px";\n  div.setAttribute("data-top", lastTop);\n  if (type == "info" || type == 1) {\n    div.innerHTML = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerHTML = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerHTML = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerHTML = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendChild(div);\n\n  let timeTip = document.getElementsByClassName(time)[0];\n  setTimeout(() => {\n    timeTip.style.top = parseInt(lastTop) + "px";\n    timeTip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dieTime 秒后隐藏并被删除\n  setTimeout(() => {\n    timeTip.style.top = "0px";\n    timeTip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var allTipElement = nextAllTipElement(timeTip);\n    for (let i = 0; i < allTipElement.length; i++) {\n      var next = allTipElement[i];\n      var top =\n        parseInt(next.getAttribute("data-top")) - next.offsetHeight - 17;\n      next.setAttribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    setTimeout(() => {\n      timeTip.remove();\n    }, 500);\n  }, dieTime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextAllTipElement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextSibling) {\n    if (n.nodeType === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style>\n/* 图片大小 */\n.vdoing-index-class .home-wrapper .banner {\n  margin-top: 0 !important;\n  height: 100vh;\n  background-attachment: fixed !important;\n}\n\n/* 图片中间的签名和标题位置 */\n.banner-conent {\n  margin-top: 23vh !important;\n}\n\n/* 下面是配合 js 用的 class 样式 */\n.vdoing-index-class .navbar1 {\n  background-color: transparent;\n  box-shadow: none;\n  backdrop-filter: none;\n}\n\n.vdoing-index-class .nav-links1>.nav-item>a,\n/* 没有二级导航的一级导航 */\n.vdoing-index-class .nav-links1>a,\n/* GitHub */\n.vdoing-index-class .nav-links1 .dropdown-title a:hover,\n/* 鼠标悬停 */\n.vdoing-index-class .nav-links1 .title,\n/* 不能跳转的一级导航 */\n.vdoing-index-class .nav-links1 .dropdown-title>.link-title,\n/* 能跳转的一级导航 */\n.vdoing-index-class .site-name1\n\n/* 左侧的名字 */ {\n  color: #fff !important;\n}\n\n/* 页脚的颜色 */\n.vdoing-index-class .footer {\n  color: #fff;\n}\n\n.vdoing-index-class .search-box1 input {\n  border-color: #fff;\n  color: #fff;\n}\n\n/* 下面是箭头相关的样式 */\n.banner-arrow {\n  display: block;\n  margin: 12rem auto 0;\n  bottom: 45px;\n  width: 20px;\n  height: 20px;\n  font-size: 34px;\n  text-align: center;\n  animation: bounce-in 5s 3s infinite;\n  position: absolute;\n  left: 50%;\n  bottom: 15%;\n  margin-left: -10px;\n  cursor: pointer;\n  z-index: 999;\n}\n\n@-webkit-keyframes bounce-in {\n  0% {\n    transform: translateY(0);\n  }\n\n  20% {\n    transform: translateY(0);\n  }\n\n  50% {\n    transform: translateY(-20px);\n  }\n\n  80% {\n    transform: translateY(0);\n  }\n\n  to {\n    transform: translateY(0);\n  }\n}\n\n.banner-arrow::before {\n  content: "";\n  width: 20px;\n  height: 20px;\n  display: block;\n  border-right: 3px solid #fff;\n  border-top: 3px solid #fff;\n  transform: rotate(135deg);\n  position: absolute;\n  bottom: 10px;\n}\n\n.banner-arrow::after {\n  content: "";\n  width: 20px;\n  height: 20px;\n  display: block;\n  border-right: 3px solid #fff;\n  border-top: 3px solid #fff;\n  transform: rotate(135deg);\n}\n\n/* 描述淡入淡出元素 */\n.description {\n  display: inline-block;\n}\n\n.typed {\n  opacity: 1;\n}\n\n/* 随时间变化的背景色元素 */\n.vdoing-index-class .banner-color {\n  width: 100%;\n  min-height: 450px;\n  overflow: hidden;\n  margin-top: 0;\n  height: 100vh;\n  position: absolute;\n  top: 0;\n}\n\n/* 气泡效果的画布元素 */\n#canvas {\n  position: absolute;\n  top: 0;\n}\n\n/* 切换第二页，继续打开 banner */\n.hide-banner {\n  display: block !important;\n}\n\n/* 提示框元素 */\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translateX(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n\n@keyframes typedBlink {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n\n\n注释已经有说明，但是有几个配置建议在 themeConfig 中配置（往下看），其他随意。\n\n\n# 组件注册\n\n\n# 图片添加\n\n图片的添加有两种（可二选一，可都选：效果叠加）：\n\n * banner 图片，即仅仅开启首页的大图效果，离开大图后的背景是其他颜色（主题默认灰白色）\n   \n   打开 docs/index.md 文档，首先在 frontmatter 添加一个自定义类和自己的图片路径：\n   \n   ---\n   pageClass: vdoing-index-class\n   bannerBg: /img/index/bg.jpg  # 你的图片路径(必须位于 public 下)，可以是 URL\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 全背景图，即 首页大图 + 全背景图（我的博客使用这种方式）\n   \n   首先在 docs/index.md 中注释掉上方的 bannerBg，但是 pageClass 要保留（这是识别首页的 class），打开 docs/.vuepress/config.js（新版是 config.ts）文件，在 themeConfig 中添加如下代码：\n   \n   bodyBgImg: /img/index/bg.jpg,  // 你的图片路径(必须位于 public 下)，可以是 URL\n   bodyBgImgOpacity: 1, // body 背景图透明度，选值 0 ~ 1.0, 默认0.5\n   \n   \n   1\n   2\n   \n   \n   如果 bodyBgImg 是数组，则每隔 15 秒切换一次图片，具体介绍请看官网，点击直达。\n   \n   注意 bodyBgImg 和 bodyBgImgOpacity 放在 themeConfig 里，否则不生效。\n\n\n# 组件添加\n\n回到 docs/index.md 文档，滑到文档的最下方，添加组件：\n\n<ClientOnly>\n  <IndexBigImg />\n</ClientOnly>\n\n\n1\n2\n3\n\n\n<ClientOnly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n> 确保 pageClass: vdoing-index-class 被添加到 docs/index.md 的 frontmatter 中。\n\n打开 docs/.vuepress/config.js（新版 config.ts）文件，在 themeConfig 模块里添加如下代码（这是我的配置）：\n\nindexImg: {\n  navColor: 2,    // 导航栏左侧名字、中间搜索框、右侧字体的颜色，1 是黑色，2 是白色。默认是 1\n  switchNavColor: true,    // 页面移出大图片的位置后，navColor 是否变换，如由白色变黑色，黑色变白色。默认是 false\n  // 因为本主题的默认背景色偏向白色，如果 navColor 是 2，建议需要开启(true)，否则白背景 + 白字体 = 看不见\n  bgTimeColor: true,     // 是否开启图片的背景色随一天的不同时间而变化，并且开启时间窗口提示，默认是 false。时间分为四种：白天（原图）、黄昏（偏黄）、晚上（偏黑）、深夜（偏深黑）\n  bgTimeColorArray: [\'transparent\', \'rgba(255, 148, 48, .2)\', \'rgba(0, 0, 0, .3)\', \'rgba(0, 0, 0, .5)\'],   // 第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgTimeColor 为 true 生效。提示：如果不想要这个效果，但是又想要时间窗口提示效果，则改为 [\'transparent\', \'transparent\', \'transparent\', \'transparent\']\n  descFade: true,   // 是否开启图片中间描述的淡入效果，默认为 false\n  desc: ["Web前端技术博客，积跬步以至千里，致敬每个爱学习的你 —— 来自 Evan Xu", "故事由我书写，旅程由你见证，传奇由她聆听 —— 来自 Young Kbt", "这一生波澜壮阔或是不惊都没问题 —— 来自 Weibw"],  // 多个描述，如果填写则覆盖 config.js 的 description，不填写默认读取 config.js 的 description，descFade 为 true 生效\n  descFontSize: \'1.4rem\',   // desc 的字体大小，默认 1.4rem。提示：原主题是 1.1rem\n  descFadeInTime: 200,  // 描述的淡入效果持续时间，descFade 为 true 生效，默认 200 毫秒\n  descFadeOutTime: 100,  // 描述的淡出效果持续时间，descFade 为 true 生效，默认 100 毫秒\n  descNextTime: 800,  // 当存在多个 desc 时，一个 desc 展示完后或准备开始时，多少秒后出现下一个 desc，默认 800 毫秒\n  bubble: true,    // 是否开启图片的气泡效果，默认为 false\n  bubblePosition: 0,  // 气泡效果的位置，范围：0-100，不同数值代表不同的起始位置，0是整个图片，50是半张图（一半的下方）。bubble 为 true 生效。默认是 0\n  bubbleNum: 200,   // 气泡的个数，bubble 为 true 生效，默认 200 个\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 属性说明\n\n\n# 导航栏配置\n\nnavColor\n\n * 类型：number\n * 默认值：1\n\n导航栏左侧名字、中间搜索框、右侧字体颜色，1 是黑色，2 是白色，默认是 1。\n\nswitchNavColor\n\n * 类型：boolean\n * 默认值：false\n\n页面移出大图片的位置后，navColor 是否变换，如由白色变黑色，黑色变白色，默认是 false。\n\n提示：因为本主题的默认背景色偏向白色，如果 navColor 是 2，建议需要开启(true)，否则白背景 + 白字体 = 看不见。\n\n\n# 背景图配置\n\nbgTimeColor\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片的背景色随一天的时间而变化，是否开启图片的背景色随一天的不同时间而变化，并且开启时间窗口提示，默认是 false。时间分为四种：白天（原图）、黄昏（偏黄）、晚上（偏黑）、深夜（偏深黑）。\n\n并且开启首次进入首页后的时间提示。\n\nbgTimeColorArray\n\n * 类型：Array\n * 默认值：[\'transparent\', \'rgba(255, 148, 48, .2)\', \'rgba(0, 0, 0, .3)\', \'rgba(0, 0, 0, .5)\']\n\n数组的第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgTimeColor 为 true 生效。\n\n提示：如果不想要图片的背景色随一天的时间而变化效果，但是又想要时间窗口提示效果，则改为 [\'transparent\', \'transparent\', \'transparent\', \'transparent\']\n\n\n# desc淡入淡出配置\n\ndescFade\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片中间描述的淡入效果，默认为 false。\n\ndesc\n\n * 类型：Array\n * 默认值：[]\n\n多条描述，如果填写则覆盖 index.md 的 tagline，不填写则默认读取 index.md 的 tagline，descFade 为 true 生效。\n\ndescFontSize\n\n * 类型：string\n * 默认值：1.4rem\n\ndesc 的字体大小，默认 1.4rem。提示：原主题是 1.1rem。\n\ndescFadeInTime\n\n * 类型：number\n * 默认值：200(ms)\n\n图片中间描述的淡入效果持续时间，descFade 为 true 生效，默认 200 毫秒。\n\ndescFadeOutTime\n\n * 类型：number\n * 默认值：100(ms)\n\n描述的淡出效果持续时间，descFade 为 true 生效，默认 100 毫秒。\n\ndescNextTime\n\n * 类型：number\n * 默认值：800(ms)\n\n当存在多个 desc 时，一个 desc 展示完后或准备开始时，多少时间后出现下一个 desc，默认 800 毫秒。\n\n\n# 气泡配置\n\nbubble\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片的气泡效果，默认为 false。\n\nbubblePosition\n\n * 类型：number\n\n * 默认值：0\n\n * 范围：0 - 100\n\n气泡效果的位置，范围：0 - 100，不同数值代表不同的起始位置，0 是整个图片，50 是半张图（一半的下方）。bubble 为 true 生效，默认是 0。\n\nbubbleNum\n\n * 类型：number\n * 默认值：200\n\n气泡的个数，默认 200 个。\n\n\n# 额外动态大图\n\n上面的所有配置是属于 静态大图效果，如果你喜欢我的 动态 首页背景图：全背景、颜色随时间变化、日历显示当天、时间同步当前、播放音乐有音谱 ...（可能时间久远，我也许换背景图了🤣）\n\n\n\n\n# 静态资源获取\n\n首先需要下载一些需要用到的图片，总共 1.47MB（如果你觉得 1.47MB 太大，可以进行图片压缩）。点击前往下载地址，找到 fantasy.rar 压缩包并下载。\n\n下载后将其解压到 public 目录下，解压后的文件夹叫 fantasy，不是请改名。如图：\n\n\n\n\n# 组件配置\n\n在 docs/.vuepress/components 目录中创建 Fantasy.vue 组件，如果没有 components 文件夹，则请创建。\n\n> 提示：代码块里的图片路径我已经配置好，获取的是 public 根目录下的 fantasy 文件夹下的图片，如果你更改了路径，则下方代码块也要改路径。\n\n添加如下内容：\n\n<template>\n  <div class="fantasy">\n    <canvas id="cvs" class="hidden" width="1980" height="1080"></canvas>\n    <canvas id="screenImage" class="hidden" width="234" height="357"></canvas>\n    <canvas id="rili" class="hidden" width="600" height="600"></canvas>\n    <canvas id="display"></canvas>\n  </div>\n</template>\n\n<script>\nexport default {\n  mounted() {\n    // 只有一个 fantasy 元素，防止重复加载多个图片\n    if (document.getElementsByClassName("fantasy").length == 1) {\n      // 如果使用 IndexBigImg.vue，则去掉该组件提供的时间罩\n      this.clearBannerColor();\n      // 如果是在首页注册该组件，则挂载到正确的位置\n      if (this.$attrs.index) {\n        this.mountedElement();\n      }\n      this.init();\n    }\n  },\n  methods: { \n    init() {\n      var cvs = document.getElementById("cvs");\n      if (!cvs) {\n        return;\n      }\n      var ctx = cvs.getContext("2d");\n\n      var display = document.getElementById("display");\n      var displayCtx = display.getContext("2d");\n\n      var screenImage = document.getElementById("screenImage");\n      var screenImageCtx = screenImage.getContext("2d");\n\n      var rili = document.getElementById("rili");\n      var riliCtx = rili.getContext("2d");\n\n      var songInfo = {};\n      var AllTimeBak = 0;\n      var NowBak = 0;\n      var DrawWarning = false;\n      var EnMonth = false;\n\n      // 出处：https://blog.csdn.net/u012601195/article/details/47860617\n      function drawRili() {\n        riliCtx.clearRect(0, 0, 600, 600);\n        var date = new Date();\n        var year = date.getYear();\n        var mouth = date.getMonth();\n        var today = date.getDate();\n        var week = date.getDay();\n\n        var cardSize = 40;\n\n        var array_three = [4, 6, 9, 11];\n        var array_threeone = [1, 3, 5, 7, 8, 10, 12];\n        var array_week = ["SUN", "MON", "TUES", "WED", "THUR", "FRI", "SAT"];\n\n        var firstDraw; //1号绘制位置\n        var wIdx = (today - 1) % 7;\n\n        if (week >= wIdx) {\n          firstDraw = week - wIdx;\n        } else {\n          firstDraw = week - wIdx + 7;\n        }\n\n        var dayIndex = 1;\n        var countDay = 30;\n\n        if (array_three.indexOf(mouth + 1) > -1) {\n          countDay = 30;\n        } else if (array_threeone.indexOf(mouth + 1) > -1) {\n          countDay = 31;\n        } else {\n          if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            countDay = 29;\n          else countDay = 28;\n        }\n\n        var row = 6;\n        // if (7 - firstDraw + 7 * 4 < countDay) { //确定表格行数，防止日期绘制不全\n        //     row = 7;\n        //}\n\n        function drawTodaybg(i, j) {\n          riliCtx.save();\n\n          riliCtx.beginPath();\n          riliCtx.strokeStyle = "#900";\n          riliCtx.arc(\n            45 + i * cardSize * 1.7 + cardSize / 1.18,\n            50 + j * cardSize + cardSize / 2,\n            cardSize / 2 - 10,\n            -Math.PI,\n            Math.PI * 1\n          );\n          riliCtx.stroke();\n          riliCtx.closePath();\n\n          riliCtx.beginPath();\n          riliCtx.arc(\n            45 + i * cardSize * 1.7 + cardSize / 1.18,\n            50 + j * cardSize + cardSize / 2,\n            cardSize / 2 - 9,\n            -Math.PI,\n            Math.PI * 0.9\n          );\n          riliCtx.stroke();\n          riliCtx.closePath();\n\n          riliCtx.beginPath();\n          riliCtx.arc(\n            45 + i * cardSize * 1.7 + cardSize / 1.18,\n            50 + j * cardSize + cardSize / 2,\n            cardSize / 2 - 8,\n            -Math.PI,\n            Math.PI * 0.8\n          );\n          riliCtx.stroke();\n          riliCtx.closePath();\n\n          riliCtx.beginPath();\n          riliCtx.arc(\n            45 + i * cardSize * 1.7 + cardSize / 1.18,\n            50 + j * cardSize + cardSize / 2,\n            cardSize / 2 - 7,\n            -Math.PI,\n            Math.PI * 0.7\n          );\n          riliCtx.stroke();\n          riliCtx.closePath();\n\n          riliCtx.beginPath();\n          riliCtx.arc(\n            45 + i * cardSize * 1.7 + cardSize / 1.18,\n            50 + j * cardSize + cardSize / 2,\n            cardSize / 2 - 6,\n            -Math.PI,\n            Math.PI * 0.6\n          );\n          riliCtx.stroke();\n          riliCtx.closePath();\n\n          riliCtx.restore();\n        }\n\n        var isNum = /^\\d+(\\d+)?$/;\n\n        function drawDate(txt, i, j) {\n          riliCtx.textAlign = "center";\n          riliCtx.fillStyle = "rgb(69,68,84)";\n          riliCtx.font = cardSize / 1.5 + "px Impact";\n          var yOffest = 3;\n\n          if ((j == 0 || j == 6) && isNum.test(txt)) {\n            riliCtx.fillStyle = "#900";\n          }\n\n          riliCtx.fillText(\n            txt.toString(),\n            45 + j * cardSize * 1.7 + cardSize / 1.18,\n            50 + i * cardSize + (cardSize / 3) * 2 + yOffest\n          );\n\n          if (txt == today) {\n            drawTodaybg(j, i);\n          }\n        }\n\n        riliCtx.fillStyle = "rgb(69,68,84)";\n        riliCtx.font = "900 26pt SimHei";\n        riliCtx.textAlign = "center";\n        var monthCN = [\n          "一",\n          "二",\n          "三",\n          "四",\n          "五",\n          "六",\n          "七",\n          "八",\n          "九",\n          "十",\n          "十一",\n          "十二",\n        ];\n        var monthEN = [\n          " January",\n          "February",\n          "  March",\n          "  April",\n          "   May",\n          "  June",\n          "  July",\n          " August",\n          "September",\n          " October",\n          "November",\n          " December",\n        ];\n\n        if (EnMonth) {\n          riliCtx.scale(1.1, 1);\n          riliCtx.fillText(monthEN[mouth], 245, 32);\n          riliCtx.resetTransform();\n        } else {\n          riliCtx.scale(1.1, 1);\n          riliCtx.fillText(monthCN[mouth] + "月", 260, 32);\n          riliCtx.resetTransform();\n\n          riliCtx.font = "20pt SimHei";\n          riliCtx.textAlign = "end";\n          riliCtx.fillText(today + "日", 520, 38);\n        }\n\n        for (var i = 0; i < row; i++) {\n          for (var j = 0; j < 7; j++) {\n            riliCtx.strokeRect(\n              45 + j * cardSize * 1.7,\n              50 + i * cardSize,\n              cardSize * 1.7,\n              cardSize\n            );\n          }\n        }\n\n        dayIndex = 1;\n\n        for (var i = 0; i < row; i++) {\n          //开始绘制日期数\n          for (var j = 0; j < 7; j++) {\n            if (i == 0) {\n              //表格第一行绘制星期\n              drawDate(array_week[j], i, j);\n              continue;\n            }\n\n            if (i == 1 && j < firstDraw) {\n              //确定1号绘制位置\n              continue;\n            }\n\n            if (dayIndex > countDay) {\n              //只绘制月份的天数\n              break;\n            }\n\n            drawDate(dayIndex++, i, j);\n          }\n        }\n      }\n\n      var riliInterval = setInterval(drawRili, 3600000);\n      drawRili();\n\n      // Canvas奇妙的剪切蒙版实现\n      var screenMask = new Image();\n      screenMask.src = "/fantasy/Screenmask.png";\n\n      var screen = new Image();\n      screen.src = "/fantasy/screen.png";\n\n      var iv = setInterval(() => {\n        if (screen.complete && screenMask.complete) {\n          // 可以切换图片的位置，也可以换成自己的图片\n          screenImageCtx.drawImage(screen, -300, -50, 1280, 720);\n          screenImageCtx.globalCompositeOperation = "destination-atop";\n          screenImageCtx.drawImage(screenMask, 0, 0);\n          screenImageCtx.globalCompositeOperation = "source-over";\n          clearInterval(iv);\n        }\n      }, 14);\n\n      // 奇妙的屏幕大小自适应\n      window.onresize = function () {\n        display.width = window.innerWidth;\n        if (window.innerWidth / window.innerHeight > 1.8333333333333) {\n          display.height = (window.innerWidth / 1980) * 1080;\n          // window.scrollTo(0, (window.innerHeight - 123) / 16);\n        } else {\n          display.height = window.innerHeight;\n        }\n      };\n\n      window.onresize();\n\n      // 加载图片\n      var bg = new Image();\n      bg.src = "/fantasy/bg.png";\n\n      var mask = new Image();\n      mask.src = "/fantasy/mask.png";\n\n      var light = new Image();\n      light.src = "/fantasy/light.png";\n\n      var caidai = new Image();\n      caidai.src = "/fantasy/caidai.png";\n\n      var two = new Image();\n      two.src = "/fantasy/22.png";\n\n      var screenLight = new Image();\n      screenLight.src = "/fantasy/screenLight.png";\n\n      var phoneLight = new Image();\n      phoneLight.src = "/fantasy/phoneLight.png";\n\n      var phoneText = JSON.parse(\n        \'[{"time":0,"text":"凌晨啦!"},{"time":6,"text":"早上好!"},{"time":8,"text":"上午好!"},{"time":11,"text":"你吃了吗"},{"time":13,"text":"下午好鸭!"},{"time":16,"text":"傍晚咯!"},{"time":19,"text":"晚安!"}]\'\n      );\n\n      var noRili = false;\n      var updateSongInfoHandler = -1;\n\n      var data = new Array(128);\n      var animData = new Array(128);\n      var SoundPlaying = false;\n\n      // 奇妙的初始化\n      for (var i = 0; i < 128; i++) {\n        data[i] = animData[i] = 0;\n      }\n\n      // 奇妙的Normalize\n      var peakValue = 1;\n      if (window.wallpaperRegisterAudioListener) {\n        window.wallpaperRegisterAudioListener(function (audioData) {\n          var max = 0;\n\n          for (var i = 0; i < 128; i++) {\n            if (audioData[i] > max) max = audioData[i];\n          }\n\n          peakValue = peakValue * 0.99 + max * 0.01;\n\n          for (i = 0; i < 64; i++) {\n            data[63 - i] = audioData[i] / peakValue;\n          }\n\n          for (i = 0; i < 64; i++) {\n            data[127 - i] = audioData[127 - i];\n          }\n        });\n      } else {\n        var iva;\n        let audio = document.getElementsByClassName("aplayer-button")[0];\n        if (audio) {\n          audio.onclick = () => {\n            let play = document.getElementsByClassName("aplayer-play")[0];\n            if (play) {\n              iva = setInterval(() => {\n                for (i = 0; i < 64; i++) {\n                  peakValue = peakValue * 0.99 + 1 * 0.01;\n                  data[63 - i] =\n                    ((Math.random() * 0.4) / peakValue) * Math.random();\n                }\n                for (i = 0; i < 64; i++) {\n                  data[127 - i] = Math.random() * 0.2 * Math.random();\n                }\n                // for (var i = 0; i < 128; i++) {\n                //     data[i] = Math.random();\n                // }\n              }, 130);\n            } else {\n              clearInterval(iva);\n              for (var i = 0; i < 128; i++) {\n                data[i] = animData[i] = 0;\n              }\n            }\n          };\n        }\n      }\n\n      // ....\n      function min(a, b) {\n        return a > b ? b : a;\n      }\n\n      function max(a, b) {\n        return a > b ? a : b;\n      }\n\n      // 奇妙的颜色变化\n      var targetColor = { r: 80, g: 120, b: 169 };\n      var currentColor = { r: 80, g: 120, b: 169 };\n      var lightColor = { r: 0, g: 34, b: 77, a: 0 };\n\n      function colorToRgb(color) {\n        return (\n          "rgb(" +\n          color.r.toString() +\n          "," +\n          color.g.toString() +\n          "," +\n          color.b.toString() +\n          ")"\n        );\n      }\n\n      function colorToRgba(colorWithA) {\n        return (\n          "rgba(" +\n          colorWithA.r.toString() +\n          "," +\n          colorWithA.g.toString() +\n          "," +\n          colorWithA.b.toString() +\n          "," +\n          colorWithA.a.toString() +\n          ")"\n        );\n      }\n\n      var night = false;\n      var debug = false;\n\n      // Canvas的奇妙冒险!\n      function render() {\n        for (var i = 0; i < 128; i++) {\n          animData[i] += (data[i] - animData[i]) * 0.3;\n          animData[i] = min(animData[i], 1);\n        }\n\n        currentColor.r += (targetColor.r - currentColor.r) * 0.01;\n        currentColor.r = min(currentColor.r, 255);\n        currentColor.r = max(currentColor.r, 0);\n\n        currentColor.g += (targetColor.g - currentColor.g) * 0.01;\n        currentColor.g = min(currentColor.g, 255);\n        currentColor.g = max(currentColor.g, 0);\n\n        currentColor.b += (targetColor.b - currentColor.b) * 0.01;\n        currentColor.b = min(currentColor.b, 255);\n        currentColor.b = max(currentColor.b, 0);\n\n        ctx.clearRect(0, 0, 1980, 1080);\n        ctx.drawImage(bg, 0, 0);\n        ctx.drawImage(mask, 954, 99);\n\n        ctx.fillStyle = "#97adbb"; // 时间的颜色\n        ctx.font = "32pt Impact";\n\n        ctx.transform(1, 2.05 * (Math.PI / 180), 0, 1, 0, 0);\n\n        var time = new Date();\n        ctx.fillText(\n          (time.getHours() < 10 ? "0" : "") +\n            time.getHours().toString() +\n            ":" +\n            (time.getMinutes() < 10 ? "0" : "") +\n            time.getMinutes() +\n            ":" +\n            (time.getSeconds() < 10 ? "0" : "") +\n            time.getSeconds().toString(),\n          725,\n          318\n        );\n        ctx.resetTransform();\n\n        // 日历本\n        ctx.transform(0.9645, 0, 0 * (Math.PI / 180), 0.96, 967, 100);\n        ctx.rotate(6 * (Math.PI / 180));\n\n        if (!noRili) {\n          ctx.drawImage(rili, 0, 0);\n\n          ctx.resetTransform();\n\n          ctx.transform(0.9645, 0, 9 * (Math.PI / 180), 1, 825, 160);\n          ctx.rotate(7 * (Math.PI / 180));\n        }\n\n        targetColor = { r: 80, g: 120, b: 169 };\n\n        if (night) {\n          targetColor = { r: 255, g: 75, b: 80 };\n        }\n\n        if (!noRili) {\n          ctx.fillStyle = "rgba(0,0,0,0.5)";\n          ctx.fillRect(-10, 320, 650, 2);\n        }\n\n        ctx.fillStyle = colorToRgb(currentColor);\n\n        if (!noRili) {\n          for (var i = 32; i < 95; i++)\n            ctx.fillRect(\n              10 * (i - 32),\n              20 + (300 - 300 * animData[i]),\n              4,\n              300 * animData[i]\n            );\n        } else\n          for (var i = 32; i < 95; i++)\n            ctx.fillRect(\n              40 + 7.5 * (i - 32),\n              30 + (300 - 300 * animData[i]),\n              4,\n              300 * animData[i]\n            );\n\n        ctx.resetTransform();\n\n        ctx.globalCompositeOperation = "overlay";\n        ctx.drawImage(light, 971, 197);\n        ctx.globalCompositeOperation = "source-over";\n\n        ctx.drawImage(caidai, 949, 25);\n        ctx.drawImage(two, 1319, 345);\n\n        // 夜间光照\n        if (night && lightColor.a < 0.7) {\n          lightColor.a += 0.005;\n          lightColor.a = min(lightColor.a, 0.7);\n        } else if (!night) {\n          lightColor.a -= 0.005;\n          lightColor.a = max(lightColor.a, 0.0);\n        }\n\n        if (lightColor.a > 0) {\n          ctx.globalCompositeOperation = "hard-light";\n          ctx.fillStyle = colorToRgba(lightColor);\n          ctx.fillRect(0, 0, 1980, 1080);\n          ctx.globalCompositeOperation = "source-over";\n\n          ctx.globalAlpha = lightColor.a / 0.7;\n          ctx.drawImage(phoneLight, 860, 437);\n          ctx.globalAlpha = 1;\n        }\n\n        // 屏幕\n        ctx.drawImage(screenImage, 0, 0);\n        if (lightColor.a > 0) {\n          ctx.globalAlpha = lightColor.a / 0.7;\n          ctx.drawImage(screenLight, 0, 0);\n          ctx.globalAlpha = 1;\n        }\n\n        night = true;\n        var greeting = "凌晨啦!";\n\n        phoneText.forEach((v) => {\n          if (time.getHours() >= v.time) {\n            greeting = v.text;\n          }\n        });\n\n        if (time.getHours() >= 6 && time.getHours() <= 18) {\n          night = false;\n        }\n\n        night = debug ? !night : night;\n\n        // 手机\n        ctx.fillStyle = "#000";\n        ctx.font = "31.02pt SimHei";\n\n        ctx.transform(\n          1.0911,\n          -35 * (Math.PI / 180),\n          0,\n          0.5868,\n          1132.94,\n          564.07\n        );\n        ctx.rotate(56.5 * (Math.PI / 180));\n        ctx.textAlign = "center";\n        ctx.fillStyle = "#fff";\n        ctx.fillText(greeting, 135, 100);\n        ctx.textAlign = "start";\n        ctx.resetTransform();\n\n        displayCtx.drawImage(cvs, 0, 0, display.width, display.height);\n        window.requestAnimationFrame(render);\n      }\n\n      window.requestAnimationFrame(render);\n    },\n    // 针对首页挂载元素\n    mountedElement() {\n      let fantasy = document.getElementsByClassName("fantasy")[0];\n      let banner = document.getElementsByClassName("banner")[0];\n      // 去掉黑色栅格背景\n      banner.style.background = "";\n      fantasy && banner && banner.appendChild(fantasy);\n    },\n    clearBannerColor() {\n      let bannerColor = document.getElementsByClassName("banner-color")[0];\n      if (bannerColor) {\n        bannerColor.parentNode.removeChild(bannerColor);\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n.fantasy {\n  position: fixed;\n  top: 0;\n  height: 100vh;\n  width: 100%;\n  z-index: -9;\n}\n.hidden {\n  display: none;\n}\n#display {\n  margin: auto;\n}\n/* 图片大小 */\n.vdoing-index-class .home-wrapper .banner {\n  margin-top: 0 !important;\n  height: 100vh;\n  background-attachment: fixed !important;\n}\n/* 图片中间的签名和标题位置 */\n.banner-conent {\n  margin-top: 23vh !important;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n\n\n该大图左侧的电脑屏幕展示如下的图片（看页面左边），可以在 269 更换位置来截取自己喜欢的一角，或者换成自己喜欢的图片。\n\n\n\n\n# 首页配置\n\n如果你只想在首页配置该大图，不想在全局的背景使用（全局背景配置请看 全局配置），则打开 docs/index.md 文档，添加如下内容：\n\n<ClientOnly>\n  <Fantasy index="true" />\n</ClientOnly>\n\n\n1\n2\n3\n\n\n此时你是没有导航栏的透明效果、标题下 desc 的淡入淡出（打印机）效果，这些效果我都放在了大图配置模块里，如果你没有配好大图模块，则从头阅读步骤开始，如果已经配好大图模块，则\n\n<ClientOnly>\n  <IndexBigImg />\n  <Fantasy index="true" />\n</ClientOnly>\n\n\n1\n2\n3\n4\n\n\nFantasy 组件的图片会覆盖 IndexBigImg 组件的图片，而 IndexBigImg 组件其他的样式和功能都会保留。\n\n\n# 全局配置\n\n当然你也可以像我一样不仅在首页配置，也在全局背景配置（2022.7.23），那么先把上面 首页配置 的 <Fantasy index="true" /> 注释或者去掉，然后在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\n添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globalUIComponents: ["Fantasy"]\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from \'vuepress/config\'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobalUIComponents: ["Fantasy"]\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后记得重启项目。\n\n> 如果不仅进行首页配置，也进行全局配置，那么以全局配置的为准，即全局配置会覆盖首页配置，所以你完全可以两个都配置，但是不建议这么做，而是建议注释掉其中一个配置以便日后进行切换。\n\n\n# 我的建议\n\n如果使用额外动态大图，则把 bgTimeColorArray 数组的内容都改为 transparent，如下：\n\nindexImg: {\n  // ......\n  bgTimeColorArray: [\'transparent\', \'transparent\', \'transparent\', \'transparent\'],   // 第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgTimeColor 为 true 生效\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n\n\n因为额外动态大图自带该功能，不需要额外添加。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n你是否曾进入他人的博客后，占据浏览器大屏的图片映入眼帘，如果你也喜欢这种样式，本内容将介绍如何实现。\n\n2021-01-11 @du wu\n\n\n\n * 前言\n * 组件添加\n * 组件注册\n   * 图片添加\n   * 组件添加\n * 属性说明\n   * 导航栏配置\n   * 背景图配置\n   * desc淡入淡出配置\n   * 气泡配置\n * 额外动态大图\n   * 静态资源获取\n   * 组件配置\n   * 首页配置\n   * 全局配置\n   * 我的建议\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n如果你没有了解什么是首页大图模块，可以浏览一番本内容介绍的大图模块，点击跳转 我的首页。(ps：如果不想跳转，也可以参考下方的图片)\n\n\n\n本内容实现了如下功能:\n\n * 客户端的大图片效果\n * 导航栏的颜色效果（可配置选择）\n * 滑出大图片的位置后，切换导航栏颜色效果（可配置选择）\n * 大图片的背景色随一天的不同时间而变化（可配置选择）\n * 首页时间提示效果（可配置选择）\n * 个人描述淡入淡出（打印机）效果（可配置选择）\n * 大图片的气泡效果（可配置选择）\n * 大图片气泡效果的位置选择（可配置选择）\n\n......\n\n本内容分为三步，无脑 copy 即可：\n\n * 在 docs/.vuepress/components 目录中创建 indexbigimg.vue 组件\n * 在 docs/index.md 添加 indexbigimg.vue 组件\n * 在 docs/.vuepress/config.js（新版 config.ts）的 themeconfig 中配置\n\n\n# 组件添加\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 目录中创建 indexbigimg.vue 组件，如果没有 components 文件夹，则请创建。\n\n在组件添加如下内容：\n\n<template>\n  <div class="index-bigimg" style="display: none"></div>\n</template>\n<script>\n// 两个变量分别是背景元素的 class、生成的箭头 class\nconst banner = "banner";\nconst banner_arrow = "banner-arrow";\nexport default {\n  data() {\n    return {\n      // 下面都是配置的默认值，建议在 themeconfig 进行配置，它们将覆盖这些属性值\n      navcolor: 1,\n      switchnavcolor: false,\n      bgtimecolor: false,\n      bgtimecolorarray: [\n        "transparent", // 透明\n        "rgba(255, 148, 48, .2)",\n        "rgba(0, 0, 0, .3)",\n        "rgba(0, 0, 0, .5)",\n      ],\n      descfade: false,\n      desc: [],\n      descfadeintime: 200,\n      descfadeouttime: 100,\n      descnexttime: 800,\n      descfontsize: "1.4rem",\n      bubble: false,\n      bubbleposition: 0,\n      bubblenum: 200,\n      fadeininterval: "", // 淡入定时器\n      fadeoutinterval: "", // 淡出定时器\n    };\n  },\n  mounted() {\n    const arrow = document.getelementbyid(banner_arrow);\n    arrow && arrow.parentnode.removechild(arrow);\n    let a = document.createelement("a");\n    a.id = banner_arrow;\n    a.classname = banner_arrow;\n    document.getelementsbyclassname(banner)[0].append(a);\n    let targeta = document.getelementbyid(banner_arrow);\n    targeta.addeventlistener("click", (e) => {\n      // 添加点击事件\n      this.scrollfn();\n    });\n\n    // 初始化配置\n    this.initconfig();\n\n    // 初始化组件功能\n    if (this.bgtimecolor) {\n      this.bgtimecolorandtip();\n    }\n    settimeout(() => {\n      this.nobgblur();\n    }, 100);\n\n    this.blurtext();\n    this.watchscroll();\n\n    if (this.descfade) {\n      this.textfadeinandout();\n    }\n    if (this.bubble) {\n      let canvas = document.createelement("canvas");\n      canvas.id = "canvas";\n      canvas.style.top = this.bubbleposition + "%";\n      document.getelementsbyclassname(banner)[0].append(canvas);\n      this.canvasbubble();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      // 点击下一页后，往下滑动，移出大图\n      if (to.path == "/" && object.keys(this.$route.query).length > 0) {\n        settimeout(() => {\n          this.clickarrow();\n        }, 200);\n      }\n    },\n  },\n  methods: {\n    // 初始化配置\n    initconfig() {\n      if (\n        this.$themeconfig.indeximg &&\n        object.keys(this.$themeconfig.indeximg).length > 0\n      ) {\n        this.navcolor =\n          this.$themeconfig.indeximg.navcolor == undefined\n            ? this.navcolor\n            : this.$themeconfig.indeximg.navcolor;\n        this.switchnavcolor =\n          this.$themeconfig.indeximg.switchnavcolor == undefined\n            ? this.switchnavcolor\n            : this.$themeconfig.indeximg.switchnavcolor;\n        this.bgtimecolor =\n          this.$themeconfig.indeximg.bgtimecolor == undefined\n            ? this.bgtimecolor\n            : this.$themeconfig.indeximg.bgtimecolor;\n        this.bgtimecolorarray =\n          this.$themeconfig.indeximg.bgtimecolorarray == undefined\n            ? this.bgtimecolorarray\n            : this.$themeconfig.indeximg.bgtimecolorarray;\n        this.descfade =\n          this.$themeconfig.indeximg.descfade == undefined\n            ? this.descfade\n            : this.$themeconfig.indeximg.descfade;\n        this.desc =\n          this.$themeconfig.indeximg.desc == undefined\n            ? this.desc\n            : this.$themeconfig.indeximg.desc;\n        this.descfontsize =\n          this.$themeconfig.indeximg.descfontsize == undefined\n            ? this.descfontsize\n            : this.$themeconfig.indeximg.descfontsize;\n        this.descfadeintime =\n          this.$themeconfig.indeximg.descfadeintime == undefined\n            ? this.descfadeintime\n            : this.$themeconfig.indeximg.descfadeintime;\n        this.descnexttime =\n          this.$themeconfig.indeximg.descnexttime == undefined\n            ? this.descnexttime\n            : this.$themeconfig.indeximg.descnexttime;\n        this.bubble =\n          this.$themeconfig.indeximg.bubble == undefined\n            ? this.bubble\n            : this.$themeconfig.indeximg.bubble;\n        this.bubbleposition =\n          this.$themeconfig.indeximg.bubbleposition == undefined\n            ? this.bubbleposition\n            : this.$themeconfig.indeximg.bubbleposition;\n        this.bubblenum =\n          this.$themeconfig.indeximg.bubblenum == undefined\n            ? this.bubblenum\n            : this.$themeconfig.indeximg.bubblenum;\n      }\n    },\n    // 点击箭头向下滑动\n    scrollfn() {\n      const windowh = document.getelementsbyclassname(banner)[0].clientheight; // 获取窗口高度\n      window.scrollto({\n        top: windowh,\n        behavior: "smooth", // 平滑滚动\n      });\n    },\n    // 触发下拉按钮\n    clickarrow() {\n      const arrow = document.getelementbyid("banner-arrow");\n      arrow.click();\n    },\n    // 监听页面滚动的回调\n    watchscroll() {\n      const windowh = document.getelementsbyclassname(banner)[0].clientheight; // 获取窗口高度\n      window.onscroll = () => {\n        if (document.documentelement.scrolltop < windowh) {\n          this.blurtext(this.navcolor);\n          this.nobgblur();\n        } else {\n          if (this.switchnavcolor && this.navcolor == 1) {\n            this.blurtext(2);\n          } else if (this.switchnavcolor && this.navcolor == 2) {\n            this.blurtext(1);\n          }\n          this.bgblur();\n        }\n      };\n    },\n    // 导航栏恢复原主题样式\n    bgblur() {\n      let navbar = document.getelementsbyclassname("navbar")[0];\n      navbar.classname = "navbar blur";\n    },\n    // 导航栏透明\n    nobgblur() {\n      let navbar = document.getelementsbyclassname("navbar")[0];\n      navbar.classname = "navbar navbar1 blur";\n    },\n    // 导航栏的字体颜色\n    blurtext(navcolor = this.navcolor) {\n      let title = document.getelementsbyclassname("site-name")[0];\n      let search = document.getelementsbyclassname("search-box")[0];\n      let nav = document.getelementsbyclassname("nav-links")[0];\n      if (navcolor == 1) {\n        title.classname = "site-name can-hide";\n        nav.classname = "nav-links can-hide";\n        search.classname = "search-box";\n      } else if (navcolor == 2) {\n        title.classname = "site-name site-name1 can-hide";\n        nav.classname = "nav-links nav-links1 can-hide";\n        search.classname = "search-box search-box1";\n      }\n    },\n    // 背景色随时间变化，时间提示框内容随时间变化\n    bgtimecolorandtip() {\n      var hours = new date().gethours();\n      var minutes = new date().getminutes();\n      var seconds = new date().getseconds();\n      hours = hours < 10 ? "0" + hours : hours;\n      minutes = minutes < 10 ? "0" + minutes : minutes;\n      seconds = seconds < 10 ? "0" + seconds : seconds;\n      let div = document.createelement("div");\n      div.classname = "banner-color";\n      if (hours >= 6 && hours < 11) {\n        div.style.backgroundcolor = this.bgtimecolorarray[0];\n        addtip(\n          `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 12 && hours <= 16) {\n        div.style.backgroundcolor = this.bgtimecolorarray[0];\n        addtip(\n          `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 16 && hours <= 19) {\n        div.style.backgroundcolor = this.bgtimecolorarray[1];\n        addtip(\n          `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 19 && hours < 24) {\n        div.style.backgroundcolor = this.bgtimecolorarray[2];\n        addtip(\n          `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 0 && hours < 6) {\n        div.style.backgroundcolor = this.bgtimecolorarray[3];\n        addtip(\n          `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n          "info",\n          50,\n          4000\n        );\n      }\n      document.getelementsbyclassname(banner)[0].parentnode.append(div);\n    },\n    // 字体淡入淡出\n    textfadeinandout(\n      desc = this.desc, // 文字描述\n      descfontsize = this.descfontsize, // 字体大小\n      descfadeintime = this.descfadeintime, // 淡入时间\n      descfadeouttime = this.descfadeouttime, // 淡出时间\n      descnexttime = this.descnexttime // 下一个描述出现时间\n    ) {\n      let descelement = document.getelementsbyclassname("description")[0];\n\n      if (descelement) {\n        // 非首页不触发\n        descelement.style.fontsize = descfontsize;\n        var span = document.createelement("span"); // 创建 | 的元素\n        span.classname = "typed";\n        span.innerhtml = "|";\n        var index = 0; // 为 desc 的长度服务\n        var length = 0; // 为数组服务\n        var description = descelement.innertext; // 先取默认值\n        descelement.innertext = ""; // 清空 desc\n        descelement.appendchild(document.createelement("span")); // 创建 desc 所在的新元素\n        span && descelement.appendchild(span); // 添加 | 的元素\n        // 初始化迭代\n        this.fadeininterval = setinterval(() => {\n          fadein();\n        }, descfadeintime);\n      } else {\n        let hero = document.getelementsbyclassname("hero")[0];\n        descelement = document.createelement("p");\n        descelement && (descelement.classname = "description");\n        descelement && hero.appendchild(descelement);\n      }\n      // 淡入回调\n      let fadein = () => {\n        if (descelement) {\n          span.style.animation = "none"; // 淡入时，| 光标不允许闪烁\n          if (desc instanceof array && desc.length > 0) {\n            // 如果是 themeconfig 传来的数组\n            description = desc[length];\n          }\n          descelement.firstchild.innertext = description.substring(0, index++);\n          if (index > description.length) {\n            clearinterval(this.fadeininterval);\n            span.style.animation = "typedblink 1s infinite"; // 淡入结束，| 光标允许闪烁\n            settimeout(() => {\n              this.fadeoutinterval = setinterval(() => {\n                fadeout();\n              }, descfadeouttime);\n            }, descnexttime);\n          }\n        }\n      };\n      // 淡出回调\n      let fadeout = () => {\n        if (index >= 0) {\n          span.style.animation = "none"; // 淡出时，| 光标不允许闪烁\n          descelement.firstchild.innertext = description.substring(0, index--);\n        } else {\n          clearinterval(this.fadeoutinterval);\n          span.style.animation = "typedblink 1s infinite"; // 淡出结束，| 光标允许闪烁\n          settimeout(() => {\n            length++;\n            if (length >= desc.length) {\n              length = 0; // desc 展示完，重新开始计数\n            }\n            this.fadeininterval = setinterval(() => {\n              fadein();\n            }, descfadeintime);\n          }, descnexttime);\n        }\n      };\n    },\n    // 气泡效果\n    canvasbubble(bubblenum = this.bubblenum) {\n      var canvas = document.getelementbyid("canvas");\n      var cxt = canvas.getcontext("2d");\n      function dot() {\n        this.alive = true;\n        this.x = math.round(math.random() * canvas.width);\n        this.y = math.round(math.random() * canvas.height);\n        this.diameter = math.random() * 10.8;\n        this.colordata = {\n          red: math.round(math.random() * 255),\n          green: math.round(math.random() * 255),\n          blue: math.round(math.random() * 255),\n        };\n        this.alpha = 0.5;\n        this.color =\n          "rgba(" +\n          this.colordata.red +\n          ", " +\n          this.colordata.green +\n          "," +\n          this.colordata.blue +\n          "," +\n          this.alpha +\n          ")";\n        this.velocity = {\n          x: math.round(math.random() < 0.5 ? -1 : 1) * math.random() * 0.7,\n          y: math.round(math.random() < 0.5 ? -1 : 1) * math.random() * 0.7,\n        };\n      }\n      dot.prototype = {\n        draw: function () {\n          cxt.fillstyle = this.color;\n          cxt.beginpath();\n          cxt.arc(this.x, this.y, this.diameter, 0, math.pi * 2, false);\n          cxt.fill();\n        },\n        update: function () {\n          if (this.alpha < 0.8) {\n            this.alpha += 0.01;\n            this.color =\n              "rgba(" +\n              this.colordata.red +\n              ", " +\n              this.colordata.green +\n              "," +\n              this.colordata.blue +\n              "," +\n              this.alpha +\n              ")";\n          }\n          this.x += this.velocity.x;\n          this.y += this.velocity.y;\n          if (\n            this.x > canvas.width + 5 ||\n            this.x < 0 - 5 ||\n            this.y > canvas.height + 5 ||\n            this.y < 0 - 5\n          ) {\n            this.alive = false;\n          }\n        },\n      };\n      var event = {\n        rarray: [],\n        init: function () {\n          canvas.width = window.innerwidth;\n          canvas.height = window.innerheight;\n          for (var x = 0; x < bubblenum; x++) {\n            this.rarray.push(new dot());\n          }\n          this.update();\n        },\n        draw: function () {\n          cxt.clearrect(0, 0, canvas.width, canvas.height);\n          this.rarray.foreach(function (dot) {\n            dot.draw();\n          });\n        },\n        update: function () {\n          if (event.rarray.length < bubblenum) {\n            for (var x = event.rarray.length; x < bubblenum; x++) {\n              event.rarray.push(new dot());\n            }\n          }\n          event.rarray.foreach(function (dot) {\n            dot.update();\n          });\n          event.rarray = event.rarray.filter(function (dot) {\n            return dot.alive;\n          });\n          event.draw();\n          requestanimationframe(event.update);\n        },\n      };\n      window.onresize = function () {\n        event.rarray = [];\n        canvas.width = window.innerwidth;\n        canvas.height = window.innerheight;\n      };\n      event.init();\n    },\n  },\n  // 防止重写编译时，导致定时器叠加问题\n  beforemount() {\n    clearinterval(this.fadeininterval);\n    clearinterval(this.fadeoutinterval);\n  },\n  beforedestroy() {\n    clearinterval(this.fadeininterval);\n    clearinterval(this.fadeoutinterval);\n  },\n};\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startheight：第一个弹窗的高度，默认 50\n * dietime：弹窗消失时间（毫秒），默认 3000 毫秒\n *\n * 在 head 里添加图标 link 地址：https://at.alicdn.com/t/font_3114978_qe0b39no76.css\n */\nfunction addtip(content, type, startheight = 50, dietime = 3000) {\n  var tip = document.queryselectorall(".global-tip");\n  var time = new date().gettime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getattribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lasttop =\n    parseint(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetheight + 17 : startheight);\n\n  let div = document.createelement("div");\n  div.classname = `global-tip tip-${type} ${time}`;\n  div.style.top = parseint(top) + "px";\n  div.setattribute("data-top", lasttop);\n  if (type == "info" || type == 1) {\n    div.innerhtml = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerhtml = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerhtml = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerhtml = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendchild(div);\n\n  let timetip = document.getelementsbyclassname(time)[0];\n  settimeout(() => {\n    timetip.style.top = parseint(lasttop) + "px";\n    timetip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dietime 秒后隐藏并被删除\n  settimeout(() => {\n    timetip.style.top = "0px";\n    timetip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var alltipelement = nextalltipelement(timetip);\n    for (let i = 0; i < alltipelement.length; i++) {\n      var next = alltipelement[i];\n      var top =\n        parseint(next.getattribute("data-top")) - next.offsetheight - 17;\n      next.setattribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    settimeout(() => {\n      timetip.remove();\n    }, 500);\n  }, dietime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextalltipelement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextsibling) {\n    if (n.nodetype === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style>\n/* 图片大小 */\n.vdoing-index-class .home-wrapper .banner {\n  margin-top: 0 !important;\n  height: 100vh;\n  background-attachment: fixed !important;\n}\n\n/* 图片中间的签名和标题位置 */\n.banner-conent {\n  margin-top: 23vh !important;\n}\n\n/* 下面是配合 js 用的 class 样式 */\n.vdoing-index-class .navbar1 {\n  background-color: transparent;\n  box-shadow: none;\n  backdrop-filter: none;\n}\n\n.vdoing-index-class .nav-links1>.nav-item>a,\n/* 没有二级导航的一级导航 */\n.vdoing-index-class .nav-links1>a,\n/* github */\n.vdoing-index-class .nav-links1 .dropdown-title a:hover,\n/* 鼠标悬停 */\n.vdoing-index-class .nav-links1 .title,\n/* 不能跳转的一级导航 */\n.vdoing-index-class .nav-links1 .dropdown-title>.link-title,\n/* 能跳转的一级导航 */\n.vdoing-index-class .site-name1\n\n/* 左侧的名字 */ {\n  color: #fff !important;\n}\n\n/* 页脚的颜色 */\n.vdoing-index-class .footer {\n  color: #fff;\n}\n\n.vdoing-index-class .search-box1 input {\n  border-color: #fff;\n  color: #fff;\n}\n\n/* 下面是箭头相关的样式 */\n.banner-arrow {\n  display: block;\n  margin: 12rem auto 0;\n  bottom: 45px;\n  width: 20px;\n  height: 20px;\n  font-size: 34px;\n  text-align: center;\n  animation: bounce-in 5s 3s infinite;\n  position: absolute;\n  left: 50%;\n  bottom: 15%;\n  margin-left: -10px;\n  cursor: pointer;\n  z-index: 999;\n}\n\n@-webkit-keyframes bounce-in {\n  0% {\n    transform: translatey(0);\n  }\n\n  20% {\n    transform: translatey(0);\n  }\n\n  50% {\n    transform: translatey(-20px);\n  }\n\n  80% {\n    transform: translatey(0);\n  }\n\n  to {\n    transform: translatey(0);\n  }\n}\n\n.banner-arrow::before {\n  content: "";\n  width: 20px;\n  height: 20px;\n  display: block;\n  border-right: 3px solid #fff;\n  border-top: 3px solid #fff;\n  transform: rotate(135deg);\n  position: absolute;\n  bottom: 10px;\n}\n\n.banner-arrow::after {\n  content: "";\n  width: 20px;\n  height: 20px;\n  display: block;\n  border-right: 3px solid #fff;\n  border-top: 3px solid #fff;\n  transform: rotate(135deg);\n}\n\n/* 描述淡入淡出元素 */\n.description {\n  display: inline-block;\n}\n\n.typed {\n  opacity: 1;\n}\n\n/* 随时间变化的背景色元素 */\n.vdoing-index-class .banner-color {\n  width: 100%;\n  min-height: 450px;\n  overflow: hidden;\n  margin-top: 0;\n  height: 100vh;\n  position: absolute;\n  top: 0;\n}\n\n/* 气泡效果的画布元素 */\n#canvas {\n  position: absolute;\n  top: 0;\n}\n\n/* 切换第二页，继续打开 banner */\n.hide-banner {\n  display: block !important;\n}\n\n/* 提示框元素 */\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translatex(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n\n@keyframes typedblink {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n\n\n注释已经有说明，但是有几个配置建议在 themeconfig 中配置（往下看），其他随意。\n\n\n# 组件注册\n\n\n# 图片添加\n\n图片的添加有两种（可二选一，可都选：效果叠加）：\n\n * banner 图片，即仅仅开启首页的大图效果，离开大图后的背景是其他颜色（主题默认灰白色）\n   \n   打开 docs/index.md 文档，首先在 frontmatter 添加一个自定义类和自己的图片路径：\n   \n   ---\n   pageclass: vdoing-index-class\n   bannerbg: /img/index/bg.jpg  # 你的图片路径(必须位于 public 下)，可以是 url\n   ---\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 全背景图，即 首页大图 + 全背景图（我的博客使用这种方式）\n   \n   首先在 docs/index.md 中注释掉上方的 bannerbg，但是 pageclass 要保留（这是识别首页的 class），打开 docs/.vuepress/config.js（新版是 config.ts）文件，在 themeconfig 中添加如下代码：\n   \n   bodybgimg: /img/index/bg.jpg,  // 你的图片路径(必须位于 public 下)，可以是 url\n   bodybgimgopacity: 1, // body 背景图透明度，选值 0 ~ 1.0, 默认0.5\n   \n   \n   1\n   2\n   \n   \n   如果 bodybgimg 是数组，则每隔 15 秒切换一次图片，具体介绍请看官网，点击直达。\n   \n   注意 bodybgimg 和 bodybgimgopacity 放在 themeconfig 里，否则不生效。\n\n\n# 组件添加\n\n回到 docs/index.md 文档，滑到文档的最下方，添加组件：\n\n<clientonly>\n  <indexbigimg />\n</clientonly>\n\n\n1\n2\n3\n\n\n<clientonly> 大部分情况下可加可不加，少部分情况的官方介绍：https://v2.vuepress.vuejs.org/zh/reference/components.html#clientonly。\n\n> 确保 pageclass: vdoing-index-class 被添加到 docs/index.md 的 frontmatter 中。\n\n打开 docs/.vuepress/config.js（新版 config.ts）文件，在 themeconfig 模块里添加如下代码（这是我的配置）：\n\nindeximg: {\n  navcolor: 2,    // 导航栏左侧名字、中间搜索框、右侧字体的颜色，1 是黑色，2 是白色。默认是 1\n  switchnavcolor: true,    // 页面移出大图片的位置后，navcolor 是否变换，如由白色变黑色，黑色变白色。默认是 false\n  // 因为本主题的默认背景色偏向白色，如果 navcolor 是 2，建议需要开启(true)，否则白背景 + 白字体 = 看不见\n  bgtimecolor: true,     // 是否开启图片的背景色随一天的不同时间而变化，并且开启时间窗口提示，默认是 false。时间分为四种：白天（原图）、黄昏（偏黄）、晚上（偏黑）、深夜（偏深黑）\n  bgtimecolorarray: [\'transparent\', \'rgba(255, 148, 48, .2)\', \'rgba(0, 0, 0, .3)\', \'rgba(0, 0, 0, .5)\'],   // 第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgtimecolor 为 true 生效。提示：如果不想要这个效果，但是又想要时间窗口提示效果，则改为 [\'transparent\', \'transparent\', \'transparent\', \'transparent\']\n  descfade: true,   // 是否开启图片中间描述的淡入效果，默认为 false\n  desc: ["web前端技术博客，积跬步以至千里，致敬每个爱学习的你 —— 来自 evan xu", "故事由我书写，旅程由你见证，传奇由她聆听 —— 来自 young kbt", "这一生波澜壮阔或是不惊都没问题 —— 来自 weibw"],  // 多个描述，如果填写则覆盖 config.js 的 description，不填写默认读取 config.js 的 description，descfade 为 true 生效\n  descfontsize: \'1.4rem\',   // desc 的字体大小，默认 1.4rem。提示：原主题是 1.1rem\n  descfadeintime: 200,  // 描述的淡入效果持续时间，descfade 为 true 生效，默认 200 毫秒\n  descfadeouttime: 100,  // 描述的淡出效果持续时间，descfade 为 true 生效，默认 100 毫秒\n  descnexttime: 800,  // 当存在多个 desc 时，一个 desc 展示完后或准备开始时，多少秒后出现下一个 desc，默认 800 毫秒\n  bubble: true,    // 是否开启图片的气泡效果，默认为 false\n  bubbleposition: 0,  // 气泡效果的位置，范围：0-100，不同数值代表不同的起始位置，0是整个图片，50是半张图（一半的下方）。bubble 为 true 生效。默认是 0\n  bubblenum: 200,   // 气泡的个数，bubble 为 true 生效，默认 200 个\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 属性说明\n\n\n# 导航栏配置\n\nnavcolor\n\n * 类型：number\n * 默认值：1\n\n导航栏左侧名字、中间搜索框、右侧字体颜色，1 是黑色，2 是白色，默认是 1。\n\nswitchnavcolor\n\n * 类型：boolean\n * 默认值：false\n\n页面移出大图片的位置后，navcolor 是否变换，如由白色变黑色，黑色变白色，默认是 false。\n\n提示：因为本主题的默认背景色偏向白色，如果 navcolor 是 2，建议需要开启(true)，否则白背景 + 白字体 = 看不见。\n\n\n# 背景图配置\n\nbgtimecolor\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片的背景色随一天的时间而变化，是否开启图片的背景色随一天的不同时间而变化，并且开启时间窗口提示，默认是 false。时间分为四种：白天（原图）、黄昏（偏黄）、晚上（偏黑）、深夜（偏深黑）。\n\n并且开启首次进入首页后的时间提示。\n\nbgtimecolorarray\n\n * 类型：array\n * 默认值：[\'transparent\', \'rgba(255, 148, 48, .2)\', \'rgba(0, 0, 0, .3)\', \'rgba(0, 0, 0, .5)\']\n\n数组的第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgtimecolor 为 true 生效。\n\n提示：如果不想要图片的背景色随一天的时间而变化效果，但是又想要时间窗口提示效果，则改为 [\'transparent\', \'transparent\', \'transparent\', \'transparent\']\n\n\n# desc淡入淡出配置\n\ndescfade\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片中间描述的淡入效果，默认为 false。\n\ndesc\n\n * 类型：array\n * 默认值：[]\n\n多条描述，如果填写则覆盖 index.md 的 tagline，不填写则默认读取 index.md 的 tagline，descfade 为 true 生效。\n\ndescfontsize\n\n * 类型：string\n * 默认值：1.4rem\n\ndesc 的字体大小，默认 1.4rem。提示：原主题是 1.1rem。\n\ndescfadeintime\n\n * 类型：number\n * 默认值：200(ms)\n\n图片中间描述的淡入效果持续时间，descfade 为 true 生效，默认 200 毫秒。\n\ndescfadeouttime\n\n * 类型：number\n * 默认值：100(ms)\n\n描述的淡出效果持续时间，descfade 为 true 生效，默认 100 毫秒。\n\ndescnexttime\n\n * 类型：number\n * 默认值：800(ms)\n\n当存在多个 desc 时，一个 desc 展示完后或准备开始时，多少时间后出现下一个 desc，默认 800 毫秒。\n\n\n# 气泡配置\n\nbubble\n\n * 类型：boolean\n * 默认值：false\n\n是否开启图片的气泡效果，默认为 false。\n\nbubbleposition\n\n * 类型：number\n\n * 默认值：0\n\n * 范围：0 - 100\n\n气泡效果的位置，范围：0 - 100，不同数值代表不同的起始位置，0 是整个图片，50 是半张图（一半的下方）。bubble 为 true 生效，默认是 0。\n\nbubblenum\n\n * 类型：number\n * 默认值：200\n\n气泡的个数，默认 200 个。\n\n\n# 额外动态大图\n\n上面的所有配置是属于 静态大图效果，如果你喜欢我的 动态 首页背景图：全背景、颜色随时间变化、日历显示当天、时间同步当前、播放音乐有音谱 ...（可能时间久远，我也许换背景图了🤣）\n\n\n\n\n# 静态资源获取\n\n首先需要下载一些需要用到的图片，总共 1.47mb（如果你觉得 1.47mb 太大，可以进行图片压缩）。点击前往下载地址，找到 fantasy.rar 压缩包并下载。\n\n下载后将其解压到 public 目录下，解压后的文件夹叫 fantasy，不是请改名。如图：\n\n\n\n\n# 组件配置\n\n在 docs/.vuepress/components 目录中创建 fantasy.vue 组件，如果没有 components 文件夹，则请创建。\n\n> 提示：代码块里的图片路径我已经配置好，获取的是 public 根目录下的 fantasy 文件夹下的图片，如果你更改了路径，则下方代码块也要改路径。\n\n添加如下内容：\n\n<template>\n  <div class="fantasy">\n    <canvas id="cvs" class="hidden" width="1980" height="1080"></canvas>\n    <canvas id="screenimage" class="hidden" width="234" height="357"></canvas>\n    <canvas id="rili" class="hidden" width="600" height="600"></canvas>\n    <canvas id="display"></canvas>\n  </div>\n</template>\n\n<script>\nexport default {\n  mounted() {\n    // 只有一个 fantasy 元素，防止重复加载多个图片\n    if (document.getelementsbyclassname("fantasy").length == 1) {\n      // 如果使用 indexbigimg.vue，则去掉该组件提供的时间罩\n      this.clearbannercolor();\n      // 如果是在首页注册该组件，则挂载到正确的位置\n      if (this.$attrs.index) {\n        this.mountedelement();\n      }\n      this.init();\n    }\n  },\n  methods: { \n    init() {\n      var cvs = document.getelementbyid("cvs");\n      if (!cvs) {\n        return;\n      }\n      var ctx = cvs.getcontext("2d");\n\n      var display = document.getelementbyid("display");\n      var displayctx = display.getcontext("2d");\n\n      var screenimage = document.getelementbyid("screenimage");\n      var screenimagectx = screenimage.getcontext("2d");\n\n      var rili = document.getelementbyid("rili");\n      var rilictx = rili.getcontext("2d");\n\n      var songinfo = {};\n      var alltimebak = 0;\n      var nowbak = 0;\n      var drawwarning = false;\n      var enmonth = false;\n\n      // 出处：https://blog.csdn.net/u012601195/article/details/47860617\n      function drawrili() {\n        rilictx.clearrect(0, 0, 600, 600);\n        var date = new date();\n        var year = date.getyear();\n        var mouth = date.getmonth();\n        var today = date.getdate();\n        var week = date.getday();\n\n        var cardsize = 40;\n\n        var array_three = [4, 6, 9, 11];\n        var array_threeone = [1, 3, 5, 7, 8, 10, 12];\n        var array_week = ["sun", "mon", "tues", "wed", "thur", "fri", "sat"];\n\n        var firstdraw; //1号绘制位置\n        var widx = (today - 1) % 7;\n\n        if (week >= widx) {\n          firstdraw = week - widx;\n        } else {\n          firstdraw = week - widx + 7;\n        }\n\n        var dayindex = 1;\n        var countday = 30;\n\n        if (array_three.indexof(mouth + 1) > -1) {\n          countday = 30;\n        } else if (array_threeone.indexof(mouth + 1) > -1) {\n          countday = 31;\n        } else {\n          if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            countday = 29;\n          else countday = 28;\n        }\n\n        var row = 6;\n        // if (7 - firstdraw + 7 * 4 < countday) { //确定表格行数，防止日期绘制不全\n        //     row = 7;\n        //}\n\n        function drawtodaybg(i, j) {\n          rilictx.save();\n\n          rilictx.beginpath();\n          rilictx.strokestyle = "#900";\n          rilictx.arc(\n            45 + i * cardsize * 1.7 + cardsize / 1.18,\n            50 + j * cardsize + cardsize / 2,\n            cardsize / 2 - 10,\n            -math.pi,\n            math.pi * 1\n          );\n          rilictx.stroke();\n          rilictx.closepath();\n\n          rilictx.beginpath();\n          rilictx.arc(\n            45 + i * cardsize * 1.7 + cardsize / 1.18,\n            50 + j * cardsize + cardsize / 2,\n            cardsize / 2 - 9,\n            -math.pi,\n            math.pi * 0.9\n          );\n          rilictx.stroke();\n          rilictx.closepath();\n\n          rilictx.beginpath();\n          rilictx.arc(\n            45 + i * cardsize * 1.7 + cardsize / 1.18,\n            50 + j * cardsize + cardsize / 2,\n            cardsize / 2 - 8,\n            -math.pi,\n            math.pi * 0.8\n          );\n          rilictx.stroke();\n          rilictx.closepath();\n\n          rilictx.beginpath();\n          rilictx.arc(\n            45 + i * cardsize * 1.7 + cardsize / 1.18,\n            50 + j * cardsize + cardsize / 2,\n            cardsize / 2 - 7,\n            -math.pi,\n            math.pi * 0.7\n          );\n          rilictx.stroke();\n          rilictx.closepath();\n\n          rilictx.beginpath();\n          rilictx.arc(\n            45 + i * cardsize * 1.7 + cardsize / 1.18,\n            50 + j * cardsize + cardsize / 2,\n            cardsize / 2 - 6,\n            -math.pi,\n            math.pi * 0.6\n          );\n          rilictx.stroke();\n          rilictx.closepath();\n\n          rilictx.restore();\n        }\n\n        var isnum = /^\\d+(\\d+)?$/;\n\n        function drawdate(txt, i, j) {\n          rilictx.textalign = "center";\n          rilictx.fillstyle = "rgb(69,68,84)";\n          rilictx.font = cardsize / 1.5 + "px impact";\n          var yoffest = 3;\n\n          if ((j == 0 || j == 6) && isnum.test(txt)) {\n            rilictx.fillstyle = "#900";\n          }\n\n          rilictx.filltext(\n            txt.tostring(),\n            45 + j * cardsize * 1.7 + cardsize / 1.18,\n            50 + i * cardsize + (cardsize / 3) * 2 + yoffest\n          );\n\n          if (txt == today) {\n            drawtodaybg(j, i);\n          }\n        }\n\n        rilictx.fillstyle = "rgb(69,68,84)";\n        rilictx.font = "900 26pt simhei";\n        rilictx.textalign = "center";\n        var monthcn = [\n          "一",\n          "二",\n          "三",\n          "四",\n          "五",\n          "六",\n          "七",\n          "八",\n          "九",\n          "十",\n          "十一",\n          "十二",\n        ];\n        var monthen = [\n          " january",\n          "february",\n          "  march",\n          "  april",\n          "   may",\n          "  june",\n          "  july",\n          " august",\n          "september",\n          " october",\n          "november",\n          " december",\n        ];\n\n        if (enmonth) {\n          rilictx.scale(1.1, 1);\n          rilictx.filltext(monthen[mouth], 245, 32);\n          rilictx.resettransform();\n        } else {\n          rilictx.scale(1.1, 1);\n          rilictx.filltext(monthcn[mouth] + "月", 260, 32);\n          rilictx.resettransform();\n\n          rilictx.font = "20pt simhei";\n          rilictx.textalign = "end";\n          rilictx.filltext(today + "日", 520, 38);\n        }\n\n        for (var i = 0; i < row; i++) {\n          for (var j = 0; j < 7; j++) {\n            rilictx.strokerect(\n              45 + j * cardsize * 1.7,\n              50 + i * cardsize,\n              cardsize * 1.7,\n              cardsize\n            );\n          }\n        }\n\n        dayindex = 1;\n\n        for (var i = 0; i < row; i++) {\n          //开始绘制日期数\n          for (var j = 0; j < 7; j++) {\n            if (i == 0) {\n              //表格第一行绘制星期\n              drawdate(array_week[j], i, j);\n              continue;\n            }\n\n            if (i == 1 && j < firstdraw) {\n              //确定1号绘制位置\n              continue;\n            }\n\n            if (dayindex > countday) {\n              //只绘制月份的天数\n              break;\n            }\n\n            drawdate(dayindex++, i, j);\n          }\n        }\n      }\n\n      var riliinterval = setinterval(drawrili, 3600000);\n      drawrili();\n\n      // canvas奇妙的剪切蒙版实现\n      var screenmask = new image();\n      screenmask.src = "/fantasy/screenmask.png";\n\n      var screen = new image();\n      screen.src = "/fantasy/screen.png";\n\n      var iv = setinterval(() => {\n        if (screen.complete && screenmask.complete) {\n          // 可以切换图片的位置，也可以换成自己的图片\n          screenimagectx.drawimage(screen, -300, -50, 1280, 720);\n          screenimagectx.globalcompositeoperation = "destination-atop";\n          screenimagectx.drawimage(screenmask, 0, 0);\n          screenimagectx.globalcompositeoperation = "source-over";\n          clearinterval(iv);\n        }\n      }, 14);\n\n      // 奇妙的屏幕大小自适应\n      window.onresize = function () {\n        display.width = window.innerwidth;\n        if (window.innerwidth / window.innerheight > 1.8333333333333) {\n          display.height = (window.innerwidth / 1980) * 1080;\n          // window.scrollto(0, (window.innerheight - 123) / 16);\n        } else {\n          display.height = window.innerheight;\n        }\n      };\n\n      window.onresize();\n\n      // 加载图片\n      var bg = new image();\n      bg.src = "/fantasy/bg.png";\n\n      var mask = new image();\n      mask.src = "/fantasy/mask.png";\n\n      var light = new image();\n      light.src = "/fantasy/light.png";\n\n      var caidai = new image();\n      caidai.src = "/fantasy/caidai.png";\n\n      var two = new image();\n      two.src = "/fantasy/22.png";\n\n      var screenlight = new image();\n      screenlight.src = "/fantasy/screenlight.png";\n\n      var phonelight = new image();\n      phonelight.src = "/fantasy/phonelight.png";\n\n      var phonetext = json.parse(\n        \'[{"time":0,"text":"凌晨啦!"},{"time":6,"text":"早上好!"},{"time":8,"text":"上午好!"},{"time":11,"text":"你吃了吗"},{"time":13,"text":"下午好鸭!"},{"time":16,"text":"傍晚咯!"},{"time":19,"text":"晚安!"}]\'\n      );\n\n      var norili = false;\n      var updatesonginfohandler = -1;\n\n      var data = new array(128);\n      var animdata = new array(128);\n      var soundplaying = false;\n\n      // 奇妙的初始化\n      for (var i = 0; i < 128; i++) {\n        data[i] = animdata[i] = 0;\n      }\n\n      // 奇妙的normalize\n      var peakvalue = 1;\n      if (window.wallpaperregisteraudiolistener) {\n        window.wallpaperregisteraudiolistener(function (audiodata) {\n          var max = 0;\n\n          for (var i = 0; i < 128; i++) {\n            if (audiodata[i] > max) max = audiodata[i];\n          }\n\n          peakvalue = peakvalue * 0.99 + max * 0.01;\n\n          for (i = 0; i < 64; i++) {\n            data[63 - i] = audiodata[i] / peakvalue;\n          }\n\n          for (i = 0; i < 64; i++) {\n            data[127 - i] = audiodata[127 - i];\n          }\n        });\n      } else {\n        var iva;\n        let audio = document.getelementsbyclassname("aplayer-button")[0];\n        if (audio) {\n          audio.onclick = () => {\n            let play = document.getelementsbyclassname("aplayer-play")[0];\n            if (play) {\n              iva = setinterval(() => {\n                for (i = 0; i < 64; i++) {\n                  peakvalue = peakvalue * 0.99 + 1 * 0.01;\n                  data[63 - i] =\n                    ((math.random() * 0.4) / peakvalue) * math.random();\n                }\n                for (i = 0; i < 64; i++) {\n                  data[127 - i] = math.random() * 0.2 * math.random();\n                }\n                // for (var i = 0; i < 128; i++) {\n                //     data[i] = math.random();\n                // }\n              }, 130);\n            } else {\n              clearinterval(iva);\n              for (var i = 0; i < 128; i++) {\n                data[i] = animdata[i] = 0;\n              }\n            }\n          };\n        }\n      }\n\n      // ....\n      function min(a, b) {\n        return a > b ? b : a;\n      }\n\n      function max(a, b) {\n        return a > b ? a : b;\n      }\n\n      // 奇妙的颜色变化\n      var targetcolor = { r: 80, g: 120, b: 169 };\n      var currentcolor = { r: 80, g: 120, b: 169 };\n      var lightcolor = { r: 0, g: 34, b: 77, a: 0 };\n\n      function colortorgb(color) {\n        return (\n          "rgb(" +\n          color.r.tostring() +\n          "," +\n          color.g.tostring() +\n          "," +\n          color.b.tostring() +\n          ")"\n        );\n      }\n\n      function colortorgba(colorwitha) {\n        return (\n          "rgba(" +\n          colorwitha.r.tostring() +\n          "," +\n          colorwitha.g.tostring() +\n          "," +\n          colorwitha.b.tostring() +\n          "," +\n          colorwitha.a.tostring() +\n          ")"\n        );\n      }\n\n      var night = false;\n      var debug = false;\n\n      // canvas的奇妙冒险!\n      function render() {\n        for (var i = 0; i < 128; i++) {\n          animdata[i] += (data[i] - animdata[i]) * 0.3;\n          animdata[i] = min(animdata[i], 1);\n        }\n\n        currentcolor.r += (targetcolor.r - currentcolor.r) * 0.01;\n        currentcolor.r = min(currentcolor.r, 255);\n        currentcolor.r = max(currentcolor.r, 0);\n\n        currentcolor.g += (targetcolor.g - currentcolor.g) * 0.01;\n        currentcolor.g = min(currentcolor.g, 255);\n        currentcolor.g = max(currentcolor.g, 0);\n\n        currentcolor.b += (targetcolor.b - currentcolor.b) * 0.01;\n        currentcolor.b = min(currentcolor.b, 255);\n        currentcolor.b = max(currentcolor.b, 0);\n\n        ctx.clearrect(0, 0, 1980, 1080);\n        ctx.drawimage(bg, 0, 0);\n        ctx.drawimage(mask, 954, 99);\n\n        ctx.fillstyle = "#97adbb"; // 时间的颜色\n        ctx.font = "32pt impact";\n\n        ctx.transform(1, 2.05 * (math.pi / 180), 0, 1, 0, 0);\n\n        var time = new date();\n        ctx.filltext(\n          (time.gethours() < 10 ? "0" : "") +\n            time.gethours().tostring() +\n            ":" +\n            (time.getminutes() < 10 ? "0" : "") +\n            time.getminutes() +\n            ":" +\n            (time.getseconds() < 10 ? "0" : "") +\n            time.getseconds().tostring(),\n          725,\n          318\n        );\n        ctx.resettransform();\n\n        // 日历本\n        ctx.transform(0.9645, 0, 0 * (math.pi / 180), 0.96, 967, 100);\n        ctx.rotate(6 * (math.pi / 180));\n\n        if (!norili) {\n          ctx.drawimage(rili, 0, 0);\n\n          ctx.resettransform();\n\n          ctx.transform(0.9645, 0, 9 * (math.pi / 180), 1, 825, 160);\n          ctx.rotate(7 * (math.pi / 180));\n        }\n\n        targetcolor = { r: 80, g: 120, b: 169 };\n\n        if (night) {\n          targetcolor = { r: 255, g: 75, b: 80 };\n        }\n\n        if (!norili) {\n          ctx.fillstyle = "rgba(0,0,0,0.5)";\n          ctx.fillrect(-10, 320, 650, 2);\n        }\n\n        ctx.fillstyle = colortorgb(currentcolor);\n\n        if (!norili) {\n          for (var i = 32; i < 95; i++)\n            ctx.fillrect(\n              10 * (i - 32),\n              20 + (300 - 300 * animdata[i]),\n              4,\n              300 * animdata[i]\n            );\n        } else\n          for (var i = 32; i < 95; i++)\n            ctx.fillrect(\n              40 + 7.5 * (i - 32),\n              30 + (300 - 300 * animdata[i]),\n              4,\n              300 * animdata[i]\n            );\n\n        ctx.resettransform();\n\n        ctx.globalcompositeoperation = "overlay";\n        ctx.drawimage(light, 971, 197);\n        ctx.globalcompositeoperation = "source-over";\n\n        ctx.drawimage(caidai, 949, 25);\n        ctx.drawimage(two, 1319, 345);\n\n        // 夜间光照\n        if (night && lightcolor.a < 0.7) {\n          lightcolor.a += 0.005;\n          lightcolor.a = min(lightcolor.a, 0.7);\n        } else if (!night) {\n          lightcolor.a -= 0.005;\n          lightcolor.a = max(lightcolor.a, 0.0);\n        }\n\n        if (lightcolor.a > 0) {\n          ctx.globalcompositeoperation = "hard-light";\n          ctx.fillstyle = colortorgba(lightcolor);\n          ctx.fillrect(0, 0, 1980, 1080);\n          ctx.globalcompositeoperation = "source-over";\n\n          ctx.globalalpha = lightcolor.a / 0.7;\n          ctx.drawimage(phonelight, 860, 437);\n          ctx.globalalpha = 1;\n        }\n\n        // 屏幕\n        ctx.drawimage(screenimage, 0, 0);\n        if (lightcolor.a > 0) {\n          ctx.globalalpha = lightcolor.a / 0.7;\n          ctx.drawimage(screenlight, 0, 0);\n          ctx.globalalpha = 1;\n        }\n\n        night = true;\n        var greeting = "凌晨啦!";\n\n        phonetext.foreach((v) => {\n          if (time.gethours() >= v.time) {\n            greeting = v.text;\n          }\n        });\n\n        if (time.gethours() >= 6 && time.gethours() <= 18) {\n          night = false;\n        }\n\n        night = debug ? !night : night;\n\n        // 手机\n        ctx.fillstyle = "#000";\n        ctx.font = "31.02pt simhei";\n\n        ctx.transform(\n          1.0911,\n          -35 * (math.pi / 180),\n          0,\n          0.5868,\n          1132.94,\n          564.07\n        );\n        ctx.rotate(56.5 * (math.pi / 180));\n        ctx.textalign = "center";\n        ctx.fillstyle = "#fff";\n        ctx.filltext(greeting, 135, 100);\n        ctx.textalign = "start";\n        ctx.resettransform();\n\n        displayctx.drawimage(cvs, 0, 0, display.width, display.height);\n        window.requestanimationframe(render);\n      }\n\n      window.requestanimationframe(render);\n    },\n    // 针对首页挂载元素\n    mountedelement() {\n      let fantasy = document.getelementsbyclassname("fantasy")[0];\n      let banner = document.getelementsbyclassname("banner")[0];\n      // 去掉黑色栅格背景\n      banner.style.background = "";\n      fantasy && banner && banner.appendchild(fantasy);\n    },\n    clearbannercolor() {\n      let bannercolor = document.getelementsbyclassname("banner-color")[0];\n      if (bannercolor) {\n        bannercolor.parentnode.removechild(bannercolor);\n      }\n    },\n  },\n};\n<\/script>\n\n<style>\n.fantasy {\n  position: fixed;\n  top: 0;\n  height: 100vh;\n  width: 100%;\n  z-index: -9;\n}\n.hidden {\n  display: none;\n}\n#display {\n  margin: auto;\n}\n/* 图片大小 */\n.vdoing-index-class .home-wrapper .banner {\n  margin-top: 0 !important;\n  height: 100vh;\n  background-attachment: fixed !important;\n}\n/* 图片中间的签名和标题位置 */\n.banner-conent {\n  margin-top: 23vh !important;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n\n\n该大图左侧的电脑屏幕展示如下的图片（看页面左边），可以在 269 更换位置来截取自己喜欢的一角，或者换成自己喜欢的图片。\n\n\n\n\n# 首页配置\n\n如果你只想在首页配置该大图，不想在全局的背景使用（全局背景配置请看 全局配置），则打开 docs/index.md 文档，添加如下内容：\n\n<clientonly>\n  <fantasy index="true" />\n</clientonly>\n\n\n1\n2\n3\n\n\n此时你是没有导航栏的透明效果、标题下 desc 的淡入淡出（打印机）效果，这些效果我都放在了大图配置模块里，如果你没有配好大图模块，则从头阅读步骤开始，如果已经配好大图模块，则\n\n<clientonly>\n  <indexbigimg />\n  <fantasy index="true" />\n</clientonly>\n\n\n1\n2\n3\n4\n\n\nfantasy 组件的图片会覆盖 indexbigimg 组件的图片，而 indexbigimg 组件其他的样式和功能都会保留。\n\n\n# 全局配置\n\n当然你也可以像我一样不仅在首页配置，也在全局背景配置（2022.7.23），那么先把上面 首页配置 的 <fantasy index="true" /> 注释或者去掉，然后在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\n添加如下内容：\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globaluicomponents: ["fantasy"]\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from \'vuepress/config\'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobaluicomponents: ["fantasy"]\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后记得重启项目。\n\n> 如果不仅进行首页配置，也进行全局配置，那么以全局配置的为准，即全局配置会覆盖首页配置，所以你完全可以两个都配置，但是不建议这么做，而是建议注释掉其中一个配置以便日后进行切换。\n\n\n# 我的建议\n\n如果使用额外动态大图，则把 bgtimecolorarray 数组的内容都改为 transparent，如下：\n\nindeximg: {\n  // ......\n  bgtimecolorarray: [\'transparent\', \'transparent\', \'transparent\', \'transparent\'],   // 第一个是白天的颜色（默认原图），第二个是黄昏的颜色，第三个是晚上的颜色，第四个是深夜的颜色。bgtimecolor 为 true 生效\n  // ......\n}\n\n\n1\n2\n3\n4\n5\n\n\n因为额外动态大图自带该功能，不需要额外添加。\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"本站 - 全局时间提示模块",frontmatter:{title:"本站 - 全局时间提示模块",date:"2022-02-13T21:26:37.000Z",permalink:"/about/website/global-tip/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/06.%E5%85%B3%E4%BA%8E%20-%20%E6%9C%AC%E7%AB%99/30.%E6%9C%AC%E7%AB%99%20-%20%E5%85%A8%E5%B1%80%E6%97%B6%E9%97%B4%E6%8F%90%E7%A4%BA%E6%A8%A1%E5%9D%97.html",relativePath:"80.关于/06.关于 - 本站/30.本站 - 全局时间提示模块.md",key:"v-50e5c0bc",path:"/about/website/global-tip/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:62},{level:2,title:"添加消息图标",slug:"添加消息图标",normalizedTitle:"添加消息图标",charIndex:68},{level:2,title:"添加Vue组件",slug:"添加vue组件",normalizedTitle:"添加vue组件",charIndex:78},{level:2,title:"注册Vue组件",slug:"注册vue组件",normalizedTitle:"注册vue组件",charIndex:89},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:100}],headersStr:"前言 添加消息图标 添加Vue组件 注册Vue组件 结束语",content:'笔记\n\n这只是一个小功能，无论进入本站的任意网页，都会有温馨的时间提示。\n\n2021-01-11 @Du Wu\n\n\n\n * 前言\n * 添加消息图标\n * 添加Vue组件\n * 注册Vue组件\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 Vdoing v1.x。\n\n当你进入本站任意网页时，都会有不同的时间提示，时间提示分为五种：早上、下午、黄昏、晚上、深夜。\n\n本内容步骤分为三步：\n\n * 添加时间消息提示的图标\n * 编写全局时间提示的 Vue 组件\n * 全局注册 Vue 组件\n\n\n# 添加消息图标\n\n图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n当然，建议你使用自己的图标库，比较稳定。\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 head 模块里添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'//at.alicdn.com/t/font_3114978_qe0b39no76.css\' }],\n\n\n1\n\n\n\n# 添加Vue组件\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 目录下创建 Vue 组件：GlobalTip.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template></template>\n<script>\n// 首页是否开启时间消息提示，默认 false。因为首页大图模块已经内置时间消息提示，所以这里不需要开启，如果您不使用首页大图模块，可以将此值设置为 true。\nconst indexTip = false;\nexport default {\n  mounted() {\n    // 首页不弹出消息提示，因为首页大图模块已经内置首页的消息提示\n    if (indexTip || this.$route.path != "/") {\n      this.bgTimeColor();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      let gloablTip = document.getElementsByClassName("gloablTip");\n      // 如果已经存在一个消息提示，则不会重新弹出，除非消息提示已经消失\n      if(gloablTip.length <= 0){\n        if (indexTip || (this.$route.path != "/" && this.$route.hash == "")) {\n          this.bgTimeColor();\n        }\n      }\n    },\n  },\n  methods: {\n    bgTimeColor() {\n      var hours = new Date().getHours();\n      var minutes = new Date().getMinutes();\n      var seconds = new Date().getSeconds();\n      hours = hours < 10 ? "0" + hours : hours;\n      minutes = minutes < 10 ? "0" + minutes : minutes;\n      seconds = seconds < 10 ? "0" + seconds : seconds;\n      let div = document.createElement("div");\n      div.className = "banner-color";\n      if (hours >= 6 && hours < 11) {\n        addTip(\n          `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 12 && hours <= 16) {\n        addTip(\n          `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 16 && hours <= 19) {\n        addTip(\n          `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 19 && hours < 24) {\n        addTip(\n          `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 0 && hours < 6) {\n        addTip(\n          `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n          "info",\n          50,\n          4000\n        );\n      }\n      document.body.append(div);\n    },\n  },\n};\n\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startHeight：第一个弹窗的高度，默认 50\n * dieTime：弹窗消失时间（毫秒），默认 3000 毫秒\n * \n * 在 head 里添加图标 link 地址：https://at.alicdn.com/t/font_3114978_qe0b39no76.css\n */\nfunction addTip(content, type, startHeight = 50, dieTime = 3000) {\n  var tip = document.querySelectorAll(".global-tip");\n  var time = new Date().getTime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getAttribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lastTop =\n    parseInt(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetHeight + 17 : startHeight);\n\n  let div = document.createElement("div");\n  div.className = `global-tip tip-${type} ${time} gloablTip`;\n  div.style.top = parseInt(top) + "px";\n  div.setAttribute("data-top", lastTop);\n  if (type == "info" || type == 1) {\n    div.innerHTML = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerHTML = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerHTML = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerHTML = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendChild(div);\n\n  let timeTip = document.getElementsByClassName(time)[0];\n  setTimeout(() => {\n    timeTip.style.top = parseInt(lastTop) + "px";\n    timeTip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dieTime 秒后隐藏并被删除\n  setTimeout(() => {\n    timeTip.style.top = "0px";\n    timeTip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var allTipElement = nextAllTipElement(timeTip);\n    for (let i = 0; i < allTipElement.length; i++) {\n      var next = allTipElement[i];\n      var top =\n        parseInt(next.getAttribute("data-top")) - next.offsetHeight - 17;\n      next.setAttribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    setTimeout(() => {\n      timeTip.remove();\n    }, 500);\n  }, dieTime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextAllTipElement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextSibling) {\n    if (n.nodeType === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style>\n/* 提示框元素 */\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translateX(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n\n代码默认不开启首页的时间提示，也就是除了首页，其他网页都会提示。因为我配置了首页大图模块，该模块已经内置时间提示，所以如果你没有配置首页大图模块，则在第 4 行改为 true。\n\n35、42、49、56、63 行是不同时间的时间提示，更加自己的喜好进行修改。\n\n36、43、50、57、64 行默认时间提示的背景色是 info（灰色），还有其他的三种：success（绿色）、warning（黄色）、danger（红色）。\n\n\n# 注册Vue组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globalUIComponents: ["GlobalTip"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { UserPlugins } from \'vuepress/config\'\nplugins: <UserPlugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobalUIComponents: ["GlobalTip"] // 2.x 版本 globalUIComponents 改名为 clientAppRootComponentFiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 GitHub 仓库或者 Gitee 仓库查看源码。\n\n * GitHub\n\n * Gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 Vdoing 主题的 QQ 群：694387113。谢谢！',normalizedContent:'笔记\n\n这只是一个小功能，无论进入本站的任意网页，都会有温馨的时间提示。\n\n2021-01-11 @du wu\n\n\n\n * 前言\n * 添加消息图标\n * 添加vue组件\n * 注册vue组件\n * 结束语\n\n\n\n\n# 前言\n\n目前适用版本是 vdoing v1.x。\n\n当你进入本站任意网页时，都会有不同的时间提示，时间提示分为五种：早上、下午、黄昏、晚上、深夜。\n\n本内容步骤分为三步：\n\n * 添加时间消息提示的图标\n * 编写全局时间提示的 vue 组件\n * 全局注册 vue 组件\n\n\n# 添加消息图标\n\n图标库来自阿里云：https://www.iconfont.cn/。\n\n如果你没有账号，或者觉得添加比较麻烦，就使用我的图标库地址，当你发现图标失效了，就请来这里获取新的地址，如果还没有更新，请在评论区留言。\n\n当然，建议你使用自己的图标库，比较稳定。\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 head 模块里添加如下内容：\n\n[\'link\', { rel: \'stylesheet\', href: \'//at.alicdn.com/t/font_3114978_qe0b39no76.css\' }],\n\n\n1\n\n\n\n# 添加vue组件\n\n> 建议：本内容代码块比较长，可以点击代码块的右侧箭头来折叠，然后点击复制图标进行复制即可。\n\n在 docs/.vuepress/components 目录下创建 vue 组件：globaltip.vue。如果不存在 components 目录，则请创建。\n\n添加如下内容：\n\n<template></template>\n<script>\n// 首页是否开启时间消息提示，默认 false。因为首页大图模块已经内置时间消息提示，所以这里不需要开启，如果您不使用首页大图模块，可以将此值设置为 true。\nconst indextip = false;\nexport default {\n  mounted() {\n    // 首页不弹出消息提示，因为首页大图模块已经内置首页的消息提示\n    if (indextip || this.$route.path != "/") {\n      this.bgtimecolor();\n    }\n  },\n  watch: {\n    $route(to, from) {\n      let gloabltip = document.getelementsbyclassname("gloabltip");\n      // 如果已经存在一个消息提示，则不会重新弹出，除非消息提示已经消失\n      if(gloabltip.length <= 0){\n        if (indextip || (this.$route.path != "/" && this.$route.hash == "")) {\n          this.bgtimecolor();\n        }\n      }\n    },\n  },\n  methods: {\n    bgtimecolor() {\n      var hours = new date().gethours();\n      var minutes = new date().getminutes();\n      var seconds = new date().getseconds();\n      hours = hours < 10 ? "0" + hours : hours;\n      minutes = minutes < 10 ? "0" + minutes : minutes;\n      seconds = seconds < 10 ? "0" + seconds : seconds;\n      let div = document.createelement("div");\n      div.classname = "banner-color";\n      if (hours >= 6 && hours < 11) {\n        addtip(\n          `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 12 && hours <= 16) {\n        addtip(\n          `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 16 && hours <= 19) {\n        addtip(\n          `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 19 && hours < 24) {\n        addtip(\n          `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n          "info",\n          50,\n          4000\n        );\n      } else if (hours >= 0 && hours < 6) {\n        addtip(\n          `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n          "info",\n          50,\n          4000\n        );\n      }\n      document.body.append(div);\n    },\n  },\n};\n\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startheight：第一个弹窗的高度，默认 50\n * dietime：弹窗消失时间（毫秒），默认 3000 毫秒\n * \n * 在 head 里添加图标 link 地址：https://at.alicdn.com/t/font_3114978_qe0b39no76.css\n */\nfunction addtip(content, type, startheight = 50, dietime = 3000) {\n  var tip = document.queryselectorall(".global-tip");\n  var time = new date().gettime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getattribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lasttop =\n    parseint(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetheight + 17 : startheight);\n\n  let div = document.createelement("div");\n  div.classname = `global-tip tip-${type} ${time} gloabltip`;\n  div.style.top = parseint(top) + "px";\n  div.setattribute("data-top", lasttop);\n  if (type == "info" || type == 1) {\n    div.innerhtml = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerhtml = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerhtml = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerhtml = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendchild(div);\n\n  let timetip = document.getelementsbyclassname(time)[0];\n  settimeout(() => {\n    timetip.style.top = parseint(lasttop) + "px";\n    timetip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dietime 秒后隐藏并被删除\n  settimeout(() => {\n    timetip.style.top = "0px";\n    timetip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var alltipelement = nextalltipelement(timetip);\n    for (let i = 0; i < alltipelement.length; i++) {\n      var next = alltipelement[i];\n      var top =\n        parseint(next.getattribute("data-top")) - next.offsetheight - 17;\n      next.setattribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    settimeout(() => {\n      timetip.remove();\n    }, 500);\n  }, dietime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextalltipelement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextsibling) {\n    if (n.nodetype === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n<\/script>\n\n<style>\n/* 提示框元素 */\n.global-tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translatex(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.global-tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n\n\n代码默认不开启首页的时间提示，也就是除了首页，其他网页都会提示。因为我配置了首页大图模块，该模块已经内置时间提示，所以如果你没有配置首页大图模块，则在第 4 行改为 true。\n\n35、42、49、56、63 行是不同时间的时间提示，更加自己的喜好进行修改。\n\n36、43、50、57、64 行默认时间提示的背景色是 info（灰色），还有其他的三种：success（绿色）、warning（黄色）、danger（红色）。\n\n\n# 注册vue组件\n\n在 docs/.vuepress/config.js（新版是 config.ts）的 plugins 中添加插件配置。\n\nmodule.exports = {\n    plugins: [\n        {\n            name: \'custom-plugins\',\n            globaluicomponents: ["globaltip"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n        }\n    ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nimport { userplugins } from \'vuepress/config\'\nplugins: <userplugins>[\n    [\n    \t{\n        \tname: \'custom-plugins\',\n        \tglobaluicomponents: ["globaltip"] // 2.x 版本 globaluicomponents 改名为 clientapprootcomponentfiles\n    \t}\n    ]\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 结束语\n\n如果你还有疑惑，可以去我的 github 仓库或者 gitee 仓库查看源码。\n\n * github\n\n * gitee\n\n如果你有更好的方式，评论区留言告诉我，或者加入 vdoing 主题的 qq 群：694387113。谢谢！',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"首页 - 部署",frontmatter:{title:"首页 - 部署",date:"2021-12-09T21:57:35.000Z",permalink:"/about/index/younngkbt/",titleTag:"原创",categories:["关于 - 首页"],tags:["首页"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/08.%E5%85%B3%E4%BA%8E%20-%20%E9%A6%96%E9%A1%B5/02.%E9%A6%96%E9%A1%B5%20-%20%E9%83%A8%E7%BD%B2.html",relativePath:"80.关于/08.关于 - 首页/02.首页 - 部署.md",key:"v-1bce0795",path:"/about/index/younngkbt/",headers:[{level:2,title:"序言",slug:"序言",normalizedTitle:"序言",charIndex:57},{level:2,title:"首页部署",slug:"首页部署",normalizedTitle:"首页部署",charIndex:63},{level:2,title:"404部署",slug:"_404部署",normalizedTitle:"404部署",charIndex:71},{level:2,title:"博客部署",slug:"博客部署",normalizedTitle:"博客部署",charIndex:80},{level:2,title:"邮箱部署",slug:"邮箱部署",normalizedTitle:"邮箱部署",charIndex:88},{level:3,title:"邮箱源码",slug:"邮箱源码",normalizedTitle:"邮箱源码",charIndex:98},{level:3,title:"官方镜像部署",slug:"官方镜像部署",normalizedTitle:"官方镜像部署",charIndex:108},{level:3,title:"自定义镜像部署",slug:"自定义镜像部署",normalizedTitle:"自定义镜像部署",charIndex:120},{level:2,title:"消息提示效果代码",slug:"消息提示效果代码",normalizedTitle:"消息提示效果代码",charIndex:131}],headersStr:"序言 首页部署 404部署 博客部署 邮箱部署 邮箱源码 官方镜像部署 自定义镜像部署 消息提示效果代码",content:'笔记\n\n这里简单介绍我的首页创建过程，以及邮件功能的设计过程。\n\n2021-12-09 @Du Wu\n\n\n\n * 序言\n * 首页部署\n * 404部署\n * 博客部署\n * 邮箱部署\n   * 邮箱源码\n   * 官方镜像部署\n   * 自定义镜像部署\n * 消息提示效果代码\n\n\n\n\n# 序言\n\n在学习完 Nginx 的知识后，我看着 Nginx 的欢迎页面细想了很久，眼中的世界太过单调，总觉得不够好看，而且无法给我的服务器提供任何信息介绍，而周围的朋友直接是将其代理到其他页面。\n\n当时我就有了一些想法，替换 Nginx 的欢迎页面，将新的页面作为入口页面，介绍网站功能的同时，提供博客、项目导航入口。比如我部署的一个项目，那么在首页就会有提示，如点击跳转，这样就不必记住项目的 URL 地址，只需要记住服务器地址，那么服务器其他的内容，都汇聚于首页。\n\n如果你是从 Github 或者 Gitee 进入到我的博客，那么可以去看看我的服务器首页，希望不会让你失望，点击跳转。\n\n如果你看完了下面的内容，需要我的服务器首页、404页面、邮箱功能、下载站点功能的源码，那么 点击跳转。\n\n\n# 首页部署\n\n首先准备好一个首页，不需要打包之类的，Nginx 的首页只是一个 index.html 加点 CSS 和 JS 文件即可，不需要像一个项目那样完整。\n\n利用工具连接服务器，我是用的是 Xftp，将其上传到 Nginx 的默认路径下。\n\nNginx 的默认路径下如果你不知道，打开 Nginx 的配置文件，看 80 或者 431端口的 location / { ... } 里的 root 指定的路径，那就是 Nginx 的默认路径。\n\n\n\n这就是我的默认路径，所以将首页以及静态文件上传到 Nginx 默认路径下。\n\n在本地，我的首页结构如下：\n\n.\n├── index.html\n│   ├── assets (静态文件目录)\n│   │   ├── css（样式目录）\n│   │   ├── fonts（字体目录）\n│   │   ├── images（图片目录）\n│   │   ├── js（JavaScript 目录）\n│   ├── vendor（JavaScript 库）\n│   │   ├── bootstrap\n|\t│\t├── jquery\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上传到服务器后，因为默认路径下可能有太多文件，所以我对其分类，创建一个 static 文件夹。\n\n根目录\n├── index.html\n|—— static（静态文件目录）\n│   ├── assets\n│   │   ├── css（样式目录）\n│   │   ├── fonts（字体目录）\n│   │   ├── images（图片目录）\n│   │   ├── js（JavaScript 目录）\n│   ├── vendor（JavaScript 库）\n│   │   ├── bootstrap\n|\t│\t├── jquery\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n根目录，就是 /usr/local/openresty/nginx/html 目录。\n\n上传首页后，记得修改 index.html 有关 css 和 js 的引入路径，因为 Nginx 的获取资源规则和本地的不一样。\n\n在本地，我们在 index.html 可以这样写：（部分）\n\n<link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet" />\n<link href="assets/fonts/iconfont.css" rel="stylesheet" />\n<script src="vendor/jquery/jquery.min.js"><\/script>\n\n\n1\n2\n3\n\n\n但是上传到 Nginx 后，我们必须在开头加上 /，代表 Nginx 的根目录，所以我们需要这样写：（部分）\n\n<link href="/static/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet" />\n<link href="/static/assets/fonts/iconfont.css"  rel="stylesheet"  />\n<script src="/static/vendor/jquery/jquery.min.js"><\/script>\n\n\n1\n2\n3\n\n\n然后，访问服务器的域名，即可访问这个首页。当然，如果希望访问域名的后面再加个 /home，如访问 https://www.youngkbt.cn/home ，也能访问首页的话，需要在配置文件进行配置。\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\nserver {\n    listen 80;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name www.youngkbt.cn;\n    # ...... 其他 location\n    \n    location /home {\n        alias  /usr/local/openresty/nginx/html;\n        index  index.html;\n    }\n    \n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里使用的是 alias 指令，因为 root 指令会把 location 后面匹配的请求拼接到目录后，而 alias 指令则会忽略 location 后匹配的请求。\n\nalias 指令不会忽略匹配后面的请求，如访问 /home/aa，则忽略 /home，但是把 /aa 拼接到目录后，但是这不影响我们访问 /home 就能访问到首页，这里只是介绍使用 alias 指令的特点。\n\nJS 文件\n\n在首页，我简单实现了 Element UI 的消息提示效果，也实现了邮箱发送功能，这里提供源码：\n\n$(function () {\n  var storageName = "isSend";\n  \n  // 防止重复发送\n  var isSend = false;\n  $(".button").on("click", function () {\n    if ($("#name").val() == \'\') {\n      addTip("姓名不能为空，请填写", "danger");\n      return;\n    } else if ($("#email").val() == \'\') {\n      addTip("邮箱不能为空，请填写", "danger");\n      return;\n    } else if ($("#subject").val() == \'\') {\n      addTip("标题不能为空，请填写", "danger");\n      return;\n    } else if ($("#message").val() == \'\') {\n      addTip("消息不能为空，请填写", "danger");\n      return;\n    } else {\n      var email = $("#email").val();\n      var reg = /^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]{2,4})$/;\n      if (reg.test(email) && (sessionStorage.getItem(storageName) != "true" || isSend == false)) {\n        if (confirm("确认要发送吗？")) {\n          sendEmail();\n          sessionStorage.setItem(storageName,true);\n          isSend = true;\n        }\n      } else if (sessionStorage.getItem(storageName) == "true" || isSend == true) {\n        addTip("请不要重复发送消息", "warning");\n      } else {\n        addTip("邮箱格式不正确，请填写", "danger");\n      }\n    }\n\n    // 获取表单信息\n    // console.log($("#contact").serialize());  \n  })\n  function sendEmail() {\n    $.post("/sendEmail", $("#contact").serialize(), function (res, error) {\n      if (res == \'OK\') {  \n        addTip("发送消息成功", "success");\n        setTimeout(() => {\n          window.location.reload();\n          sessionStorage.removeItem(storageName);\n          isSend == false;\n        }, 1500);\n      } else {\n        console.log("失败的原因：", error);\n        addTip("发送失败，可能发送超时或消息被拦截，请稍后再重试", "tip");\n      }\n    });\n  }\n\n  // 添加消息提示\n  function addTip(content, type) {\n\n    var time = new Date().getTime();\n    // 获取最后消息提示元素的高度\n    var top = $(".tip:last").attr("data-top") == undefined ? 0 : $(".tip:last").attr("data-top");\n    // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 20\n    var lastTop = parseInt(top) + ($(".tip").length > 0 ? $(".tip:last").outerHeight() + 17 : 20);\n\n    if (type == "success" || type == 1) {\n      $("#page-wraper").append(`<div class="tip tip-success ${time}" style="top: ${parseInt(top)}px" data-top="${lastTop}"><i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p></div>`);\n    } else if (type == "danger" || type == 2) {\n      $("#page-wraper").append(`<div class="tip tip-danger ${time}" style="top: ${parseInt(top)}px" data-top="${lastTop}><i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p></div>`);\n    } else if (type == "info" || type == 3) {\n      $("#page-wraper").append(`<div class="tip tip-info ${time}" style="top: ${parseInt(top)}px" data-top="${lastTop}><i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p></div>`);\n    } else if (type == "warning" || type == 4) {\n      $("#page-wraper").append(`<div class="tip tip-warning ${time}" style="top: ${parseInt(top)}px" data-top="${lastTop}><i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p></div>`);\n    }\n\n    // 动画往下滑动\n    $("." + time).animate({\n      top: parseInt(lastTop) + "px",\n      opacity: "1",\n    })\n\n    // 消息提示 3 秒后隐藏并被删除\n    setTimeout(() => {\n      $("." + time).animate({\n        top: "0px",\n        opacity: "0",\n      });\n\n      setTimeout(() => {\n        $("." + time).remove();\n      }, 500);\n    }, 3000);\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n消息提示效果的 CSS 文件内容：\n\n/* 消息提示样式 */\n.tip{\n  position: fixed;\n  display: flex;\n  height: 48px;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translateX(-50%);\n  transition: opacity .3s linear,top .4s,transform .4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n.tip p{\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n.icon{\n  margin-right: 10px;\n  line-height: 17px;\n}\n.tip-success  {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n.tip-success .tip-success-content{\n  color: #67c23a;\n}\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n.tip-danger .tip-danger-content{\n  color: #f56c6c;\n}\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n.tip-info .tip-info-content{\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n.tip-warning .tip-warning-content{\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n/* 下面是二维码样式 */\n.social-tip{\n  margin-bottom: 170px;\n  display: none;\n} \n.square{\n    width: 0;\n    height: 0;\n    border-bottom: 7px solid rgba(118, 25, 172, 0.3);\n    border-right: 7px solid transparent;\n    border-left: 7px solid transparent;\n    position: relative;\n    left: 36%;\n}\n.social-info{\n  width: 200px;\n  position: absolute;\n  line-height: 48px;\n  left: -95%;\n  margin-left: -40px;\n  background-color: rgba(118, 25, 172, 0.3);\n  color: #fff;\n  padding: 0 15px 15px;\n}\n.social-info img{\n  width: 160px;\n  height: 160px;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n如下效果：\n\n\n\n我设计了四个提示，分别是成功绿色，提示灰色，警告黄色，错误红色。而提示语前面的图标，需要自己去阿里云的矢量库进行获取，并在首页引用，矢量库跳转。\n\n\n# 404部署\n\n你喜欢 Nginx 自带的 404 页面吗？我可能不是特别喜欢，所以我们可以自定义好看的 404 页面，又或者去网上下载别人做好的 404 页面模板。如我的 404 页面如图：\n\n\n\n点击头像还能播放音乐。\n\n利用 xftp 将 404 页面上传到服务器上，我在 Nginx 根目录下创建了一个 404 文件夹，将 404 页面和其 CSS 和 JS 文件放到这个 404 文件夹里。\n\n目录结构：\n\n根目录\n|—— 404（这是个目录）\n│   ├── 404.html（ 404 页面）\n│   ├── css（样式目录）\n│   ├── img（图片目录）\n│   ├── js（JavaScript 目录）\n|\t├── music（音乐目录）\n|\n├── index.html（其他页面）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上传后到 Nginx 后，养成好习惯，打开 404.html，修改 CSS、JS 文件的引入路径，因为 Nginx 的获取资源规则和本地的不一样。\n\n记得开头加 /，改为：（部分）\n\n<link rel="stylesheet" href="/404/css/ghost.css">\n<script type="text/javascript" src="/404/js/jquery.min.js"><\/script>\n\n\n1\n2\n\n\n然后在配置文件修改 404 页面的访问路径\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\n\n\nserver {\n    listen 431;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name youngkbt.cn;\n    # ...... 其他 location\n    \n    error_page   404 500 502 503 504 /404.html;\n    location = /404.html {\n        root    /usr/local/openresty/nginx/html/404;\n        index 404.html;\n    }\n    \n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n此时你随便访问我的服务器地址，如 https://www.youngkbt.cn/aaa 那么就会显示我的 404 页面。在该页面中，点击我的头像后，音乐会伴随头像的旋转而缓缓响起，静静享受 404 带有的静谧时刻。\n\n\n# 博客部署\n\n我的博客已经部署在 Github 和 Gitee 中，如果你看了上一个文章，部署自己的博客到了服务器，那么就请在 Nginx 设置一个 location 模块，进行跳转吧。\n\n我设置了两个 location 模块，当输入 /notes 或者 /note-blog 的时候，都会跳转到我的博客首页\n\nlocation /notes {\n    rewrite ^/notes/(\\w*)$ /notes-blog/$1;\n}\nlocation /notes-blog {\n    root /home/kbt;\n    index index.html;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n实际上，最终都会跳到 /note-blog 的 location 模块里。\n\n我们不仅可以设置博客的 location，也可以设置浏览器的缓存静态文件时间，因为博客的静态文件太多，当用户每次访问都从 Nginx 服务器获取静态文件，那显然不理智，我们可以让用户访问过的静态文件，缓存到用户的浏览器中，这样，用户再次访问博客的时候，直接从浏览器本地获取，打开的速度非常快。\n\n我设置了静态文件缓存 7 天，html 文件缓存 1 天\n\nlocation ~ /note-blog/.*\\.(js|css|png|jpg|jpeg|gif)$ {\n    root /home/kbt;\n    expires 7d;  # 缓存七天\n}\n\nlocation ~ /note-blog/.*\\.(html)$ {\n    root /home/kbt;\n    expires 1d;  # 缓存一天\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n看到 root 了吗，我的博客并没有放在 Nginx 的默认路径下，而是由普通用户 kbt 管理。防止滥用 root 权限，避免被别人恶意访问。\n\n\n# 邮箱部署\n\n建议你看到这里马上停住，然后点击 测试发送邮箱，输入你的邮箱，进行发送，体验之后再来学习，会有更大的收获和兴趣。\n\n邮箱项目我使用了 node 和 express 来搭建简单的服务器，然后利用 nodemailer 进行邮件发送，log4j.js 进行日志信息存储。\n\n这是一个 node 简单项目，安装的依赖只有三个，express、nodemailer、log4js。\n\n\n# 邮箱源码\n\n我的 package.json 文件内容如下：\n\n{\n    "name": "email",\n    "version": "1.0",\n    "private": true,\n    "scripts": {\n        "dev": "node app.js"\n    },\n    "dependencies": {\n        "express": "^4.17.1",\n        "log4js": "^6.3.0",\n        "nodemailer": "^6.7.2"\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n依赖只有三个，如何安装呢，我使用 yarn 进行安装。\n\nyarn add express --save\nyarn add log4js --save\nyarn add nodemailer --save\n\n\n1\n2\n3\n\n\n安装完，我们先编写 log.js 文件，实现日志功能\n\n// 引入插件 log4js  \nvar log4js = require(\'log4js\')\nlog4js.configure({\n    appenders: {\t// 配置日志文件\n        access: {    // 访问日志的 name\n            type: \'file\',     \n            filename: "logs/access.log",\n            layout: {\n                type: \'pattern\',\n                pattern: \'[%d{yyyy-MM-dd hh:mm:ss SSS}] [%p] %c - %m\'\n            },\n        },\n        error: {    // 错误日志的 name\n            type: \'file\',\n            filename: "logs/error.log",\n            layout: {   // 定义日志输出的样式\n                type: \'pattern\',\n                pattern: \'[%d{yyyy MM dd hh:mm:ss SSS}] [%p] %c - %m%n\' // 日志输出时间格式\n            },\n        },\n    },\n\n    categories: {\t// 配置日志级别，以及引用 appenders 配置的日志文件\n        default: { appenders: [\'access\'], level: \'info\' },  // 上方 appenders 的 name\n        error: { appenders: [\'error\'], level: \'error\' }\n    },\n})\n\nexports.logger = function (name) {  // name 取 categories 的 name\n    return log4js.getLogger(name || \'default\')\n};\nexports.use = function (app, logger) {\n    app.use(log4js.connectLogger(logger || log4js.getLogger(\'default\'), { level: \'info\', format: \'请求类型/URI：「 :method:url 」\' })) // 请求类型/URI 格式设置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n文件内容不难理解，我们首先配置要输出的日志文件路径以及名字，然后配置日志输出的信息时间格式，然后配置日志的格式，如 info 或者 error，接着配置请求类型/URI 格式，最后暴露出去。\n\n日志的输出内容如图所示：\n\n\n\n编写 route.js 文件，相信学过 express 的伙伴已经非常熟悉了\n\nconst express = require("express");\nconst router = express.Router();\n// 引入日志\nconst logger = require("./log").logger();\nconst errLogger = require("./log").logger("error");\n// 引入邮件发送功能\nvar nodemailer = require(\'nodemailer\');\n\nrouter.post("/email", (req, res) => {\n    var data = req.body;\n    // 获取发送的模板\n    const myHtml = require("./email/emailHtml").myHtml(data);\n    const otherHtml = require("./email/emailHtml").otherHtml(data);\n    // 创建连接\n    var transporter = nodemailer.createTransport({\n        host: "smtp.163.com",\n        port: 465, // SMTP 端口\n        secureConnection: true, // 使用 SSL 方式（安全方式，防止被窃取信息）\n        auth: {\n            user: \'kele_bingtang@163.com\',\n            // 这里密码不是 qq 密码，是你设置的 smtp 密码\n            pass: \'GJQDWNWVGYEVTSMB\'\n        }\n    });\n\n    // 邮件参数（我的）\n    var myOptions = {\n        from: \'kele_bingtang@163.com\', // 发件地址\n        to: \'kele_bingtang@163.com,2456019588@qq.com\', // 收件列表\n        subject: data.subject, // 标题\n        // text 和 html 同时发送只支持一种\n        html: myHtml,\n\n        //  text: "测试",\n        /*  attachments:[{  // 附件\n       filename: \'\',   // 附件名\n       path: \'\'    // 附件路径\n     }] */\n    };\n\n    // 邮件参数（发件人）\n    var otherOptions = {\n        from: \'kele_bingtang@163.com\', // 发件地址\n        to: `kele_bingtang@163.com,${data.email}`, // 收件列表\n        subject: "Young Kbt 的致谢", // 标题\n        // text 和 html 同时发送只支持一种\n        html: otherHtml,\n    };\n\n    // 发送邮件（给发件人）\n    transporter.sendMail(otherOptions, function (error, info) {\n        if (error) {\n            errLogger.error("发送给「 " + data.name + " 」失败，原因：「 " + error + " 」");\n            res.status(200).send("error：" + error);\n        }else{\n            logger.info("发送给「 " + data.name + " 」成功");\n        }\n        console.log("发送给发件人的响应信息：");\n        console.log(info);\n    });\n\n\n    // 发送邮件（给我）\n    transporter.sendMail(myOptions, function (error, info) {\n        console.log("错误信息：" + error);\n        if (error) {\n            errLogger.error("发送给「 Young Kbt 」失败，原因：「 " + error + " 」");\n            res.status(200).send("error：" + error);\n        }else{\n            res.status(200).send("OK");\n            logger.info("发件邮箱：「 " + info.envelope.from + " 」，收件邮箱：「 " + info.envelope.to + " 」");\n            logger.info("响应结果：「 " + info.response + " 」");\n            console.log("发送给我的响应信息：");\n            console.log(info);\n        }\n    });\n\n    logger.info("发件人：「 " + data.name + " 」，发件人的邮箱：「 " + data.email + " 」，发件主题：「 " + data.subject + " 」，发件消息：「 " + data.message + " 」");\n\n    setTimeout(() => {\n        logger.info("发送一次邮件的日志分割线 ------------------------\\n");\n    }, 4000);\n\n    setTimeout(() => {\n        transporter.close();\n    }, 10000);\n\n})\n\nmodule.exports = router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n第 12 和 13 行引用自定义的邮件页面模板，模板大家根据自己的需求设计邮件页面。\n\n我的邮件页面代码位于根目录下的 email 目录，名字叫 emailHtml，源码为：\n\n// 发送给我\nexports.myHtml = function(data){\n    return `<div style="width: 600px;margin: 0 auto;">\n            <includetail>\n              <table style="text-align: center; font-size: 16px; color: #333333; border-spacing: 0px; border-collapse: collapse; width: 580px; direction: ltr">\n                  <tbody>\n                  <tr>\n                      <td style="font-size: 14px; padding: 0px 0px 7px 0px; text-align: center;color: #0044CC">\n                          ${data.name} 在 Young Kbt 首页发送给您\n                      </td>\n                  </tr>\n                  <tr style="background-color: #2279BD">\n                      <td style="padding: 0px">\n                          <table style="border-spacing: 0px; border-collapse: collapse; width: 100%">\n                              <tbody>\n                              <tr>\n                                  <td style="padding: 0px; text-align: center;">\n                                      <img src="https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211205131212.jpg" alt="请在上方选择信任，以此显示头像">\n                                  </td>\n                              </tr>\n                              <tr>\n                                  <td style="font-size: 38px; color: #FFFFFF; padding: 12px 22px 4px 22px; text-align: center;" colspan="3">\n                                      Young Kbt\n                                  </td>\n                              </tr>\n                              <tr>\n                                  <td style="font-size: 20px; color: #FFFFFF; padding: 0px 22px 18px 22px; text-align: center;" colspan="3">\n                                    人闲车马慢，路遥星亦辞\n                                  </td>\n                              </tr>\n                              </tbody>\n                          </table>\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="background-color: #5BA9DF; border-bottom-style: solid; border-bottom-color: #2279BD; border-bottom-width: 4px;">\n                          <table style="color: #333333; border-spacing: 0px; border-collapse: collapse; width: 100%; color: #fff">\n                              <tbody>\n                                <tr>\n                                  <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                                    <p style="text-align: center">\n                                      <span style="font-weight:bold;">${data.name} </span>\n                                      <span>发送的主题：</span></p>\n                                      <p style="font-size: 16px; letter-spacing: 0.5px; text-indent: 16px; padding:0 20px; line-height: 30px; text-align: left;">\n                                      ${data.subject}\n                                    </p>\n                                  </td>\n                                </tr>\n                                <tr>\n                                  <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                                    <p style="text-align: center; margin-top: 0;">\n                                      <span style="font-weight:bold;">${data.name} </span>\n                                      <span>发送的内容：</span>\n                                    </p>\n                                      <p style="font-size: 16px;letter-spacing: 0.5px; text-indent: 16px; padding:0 20px; line-height: 30px; text-align: left;">\n                                      ${data.message}\n                                    </p>\n                                  </td>\n                                </tr>\t\n                                <tr>\n                                    <td style="font-size: 16px; padding: 30px 20px; text-align: center">\n                                      如果您希望回复他/她，请发送到他/她的邮箱：\n                                      <p style="color: #0044CC; font-weight: bold">${data.email}</p>\n                                    </td>\n                                </tr>\n                              </tbody>\n                          </table>\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="padding: 35px 0px; color: #B2B2B2; font-size: 12px">\n                          From Young Kbt\n                          <br>\n                          This is a WebSite\n                          <br>\n                          ${new Date().getFullYear()}-${new Date().getMonth() + 1 == 13 ? 12 : new Date().getMonth() + 1}-${new Date().getDate() > 10 ? new Date().getDate() : \'0\' + new Date().getDate()}\n                            ${new Date().getHours() > 10 ? new Date().getHours() : \'0\' + new Date().getHours()}:${new Date().getMinutes() > 10 ? new Date().getMinutes() : \'0\' + new Date().getMinutes()}:${new Date().getSeconds() > 10 ? new Date().getSeconds() : \'0\' + new Date().getSeconds()}\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="padding: 0px 0px 10px 0px; color: #B2B2B2; font-size: 12px">\n                          Copyright Young Kbt WebSite             \n                      </td>\n                  </tr>\n                  </tbody>\n              </table>\n            </includetail>\n          </div`;\n}\n\n// 发送给发件人\nexports.otherHtml = function(data){\n    return `<div style="width: 600px;margin: 0 auto;">\n            <includetail>\n              <table\n                style="text-align: center; font-size: 16px; color: #333333; border-spacing: 0px; border-collapse: collapse; width: 580px; direction: ltr">\n                <tbody>\n                  <tr>\n                    <td style="font-size: 14px; padding: 0px 0px 7px 0px; text-align: center;color: #0044CC">\n                      尊敬的 <span style="font-weight: bold;">${data.name}</span>，Young Kbt 感谢您的邮件\n                    </td>\n                  </tr>\n                  <tr style="background-color: #2279BD">\n                    <td style="padding: 0px">\n                      <table style="border-spacing: 0px; border-collapse: collapse; width: 100%">\n                        <tbody>\n                          <tr>\n                            <td style="padding: 0px; text-align: center;">\n                              <img src="https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211205131212.jpg" alt="请在上方选择信任，以此显示头像">\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 38px; color: #FFFFFF; padding: 12px 22px 4px 22px; text-align: center;"\n                              colspan="3">\n                              Young Kbt\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 20px; color: #FFFFFF; padding: 0px 22px 18px 22px; text-align: center;"\n                              colspan="3">\n                              人闲车马慢，路遥星亦辞\n                            </td>\n                          </tr>\n                        </tbody>\n                      </table>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td\n                      style="background-color: #5BA9DF; border-bottom-style: solid; border-bottom-color: #2279BD; border-bottom-width: 4px;">\n                      <table style="color: #333333; border-spacing: 0px; border-collapse: collapse; width: 100%; color: #fff">\n                        <tbody>\n                          <tr>\n                            <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                              <p style="text-align: center">\n                                <span style="font-weight:bold">Young Kbt</span>\n                                <span>提示您：</span>\n                              </p>\n                              <p\n                                style="font-size: 16px; letter-spacing: 0.5px; text-indent: 32px; padding:0 20px; line-height: 30px; text-align: left;">\n                                本邮件由 Young Kbt\'s index 网站发送给您，\n                                <span style="color: #1546a8; font-weight: bold;">如果非本人操作，请忽略即可。</span>\n                              </p>\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                              <p style="text-align: center; margin-top: 0;">\n                                <span style="font-weight:bold">Young Kbt</span>\n                                <span>回复您：</span>\n                              </p>\n                              <p\n                                style="font-size: 16px;letter-spacing: 0.5px; text-indent: 32px; padding:0 20px; line-height: 30px; text-align: left;">\n                                感谢您提供的宝贵消息，我会根据您的内容尽快回复您，如果时间较延迟，请您见谅。\n                              </p>\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 16px; padding: 30px 20px; text-align: center">\n                              如果您对我的网站感兴趣，请访问：\n                              <p style="color: #0044CC; font-weight: bold">\n                               <a href="youngkbt.cn" style="color: #0044CC; text-decoration: none">youngkbt.cn</a>\n                              </p>\n                              <p style="color: #0c3388;font-size: 14px; margin: 15px 0 0 0;">本网站仅是个人使用，并不带有商业用途</p>\n                            </td>\n                          </tr>\n                        </tbody>\n                      </table>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style="padding: 35px 0px; color: #B2B2B2; font-size: 12px">\n                      From Young Kbt\n                      <br>\n                      This is a WebSite\n                      <br>\n                      ${new Date().getFullYear()}-${new Date().getMonth() + 1 == 13 ? 12 : new Date().getMonth() + 1}-${new\n    Date().getDate() > 10 ? new Date().getDate() : \'0\' + new Date().getDate()}\n                      ${new Date().getHours() > 10 ? new Date().getHours() : \'0\' + new Date().getHours()}:${new\n    Date().getMinutes() > 10 ? new Date().getMinutes() : \'0\' + new Date().getMinutes()}:${new\n    Date().getSeconds() > 10 ? new Date().getSeconds() : \'0\' + new Date().getSeconds()}\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style="padding: 0px 0px 10px 0px; color: #B2B2B2; font-size: 12px">\n                      Copyright Young Kbt WebSite\n                    </td>\n                  </tr>\n                </tbody>\n              </table>\n            </includetail>\n          </div>`\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n编写 express 的入口文件 app.js，监听 5678 端口\n\nconst express = require("express");\nconst router = require("./router");\nconst log = require("./log");\nconst app = express();\n\nlog.use(app);\napp.use(express.urlencoded({ extended: false }));\napp.use(express.json());\n\napp.use( ( request , response , next ) => {\n    response.header( \'Access-Control-Allow-Origin\' , \'*\') // 跨域最重要的一步 设置响应头\n    next(); // 执行 next 函数执行后续代码\n})\n\napp.use(\'/\',router);\n\napp.listen(\'5678\',() => {\n    console.log("5678 端口的服务器启动成功");\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n写完邮箱的功能，我们可以进行测试，进入邮箱项目的根目录，使用 node app.js 启动 node 项目。\n\nnode app.js\n\n\n1\n\n\n因为是 POST 请求，所以使用 Postman 等工具进行测试，访问 localhost:5678/email，填写 JSON 格式，包含 name、email、subject、message 四个参数的数据即可。\n\n\n\n\n# 官方镜像部署\n\n在本地编写测试完邮箱的功能后，我们将其上传到服务器，我上传的目录是 docker/node/email 下，然后需要服务器安装 node 环境，我使用的是 docker，所以直接拉取 node。\n\ndocker pull node\n\n\n1\n\n\n下载完 node 镜像后，不要马上启动它，因为 node 项目需要执行打包命令，生成 node_modules 目录，所以使用 Dockerfile 文件来执行打包命令。\n\n在 docker/node/email 目录下，创建并编写 Dockerfile 文件\n\ncd docker/node/email\nvim Dockerfile\n\n\n1\n2\n\n\n添加如下内容：\n\nFROM node\t\t\t\t\t# 基于 node 镜像创建新的镜像\nWORKDIR /home/email\t\t\t# 创建默认工作目录\nCOPY . /home/email\t\t\t# 将当前目录的所有内容拷贝到容器中\nRUN npm i\t\t\t\t\t# 执行打包命令\nEXPOSE 5678\t\t\t\t\t# 暴露 5678 端口\nENTRYPOINT node ./app.js \t# 启动容器时，启动 app.js 文件\n\n\n1\n2\n3\n4\n5\n6\n\n\n不难看出，在生成 docker 镜像的同时，它会将当前目录下的所有内容拷贝到容器中，这些内容就是我们写的邮箱项目。接着它会执行打包命令 npm i，i 代表 install。然后暴露 5678 端口，最后在启动的时候，启动 app.js 文件，也就是执行项目。\n\n写好 Dockerfile 文件，我们执行这个文件，构建基于 node 环境而搭建的「邮箱发送」镜像\n\ndocker build -t email:1.0 .\n\n\n1\n\n\n启动这个名叫 email、版本为 1.0 的容器，当启动这个容器的时候，内部就会执行 node ./app.js 命令，也就是 Dockerfile 文件的 ENTRYPOINT 指令，部署项目。\n\ndocker run -d --name email \\\n-v /docker/node/email/router.js:/home/email/router.js \\\n-v /docker/node/email/app.js:/home/email/app.js \\\n-v /docker/node/email/log.js:/home/email/log.js \\\n-v /docker/node/email/logs:/home/email/logs \\\n-v /docker/node/email/email:/home/email/email \\\n--network web --network-alias email \\\nemail:1.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不要惊讶会有那么多启动命令，这里主要实现挂载功能，只要宿主机的文件发生改变，则容器内的文件也会同步改变，毕竟谁也无法确定自己写的文件以后都不会修改，对吧。\n\n至于第 7 行的 network 网络，因为 Nginx 所处的网络是 web 网络，而想让 Nginx 访问 node 项目，则需要让两者处于同一个网络上。 network-alias 是网络别名，Nginx 会根据这个网络别名找到处于相同网络下的 node 项目，尽量与容器名保持一致。\n\n此时邮箱项目已经部署成功了，但是 Nginx 还无法访问这个邮箱项目，因为我们没有配置 location 模块来访问邮箱项目。\n\nserver {\n    listen       5678;\n    server_name  localhost;\n\n    location /email {\n\t    proxy_pass http://email:5678;    # email 就是网桥别名，Nginx 通过它找到 email 容器\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实际上我并没有直接将上面的 server 模块放在配置文件里，而是将上面的内容放在新创建的 email_5678.conf 文件里，然后在配置文件进行转发。\n\n\n\n因为核心配置文件使用了 include 指令将 conf 目录下的所有 .conf 文件引入，所以我们只需要创建新的配置文件 email_5678.conf 即可。\n\n然后新的配置文件添加如下内容：\n\nserver {\n    listen 431;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name www.youngkbt.cn;\n    # ...... 其他 location\n\n    # 转发给其他的 conf 文件\n    location /email {\n        proxy_pass http://localhost:5678;\n    }\n\n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当访问 /email 的时候，触发 431 端口的的 /email，然后内部就会执行 proxy_pass 指令，将请求转发给本地的 5678 端口，此时 email_5678.conf 文件正好监听这个 5678 端口，所以就会将 /email 请求发给自己的 location ，执行新的 proxy_pass 指令，而这个指令才是将请求发给 node 邮箱项目，触发邮箱的发送。\n\n记得重启 Ngixn，使得配置文件生效。\n\n什么时候外界会访问 /email？\n\n自己写一个 <a> 标签，填写你的服务器的地址加上 /email 即可。\n\n我自己写的不是 <a> 标签，而是一个 js 文件，点击按钮触发 ajax 请求，具体源码请看 首页部署 的 JS 文件。\n\n\n# 自定义镜像部署\n\n我在使用了基于官方镜像的部署几天后，发现这个镜像太大了，有 999MB，如图：\n\n\n\n于是我打算基于 Centos7.9 构建一个 node 环境的镜像，这里提供 Dockerfile 文件内容：\n\n# 这是早期的版本，直接引入 node 镜像，但是该镜像太大了，构建后 999MB，所以我就自己创建一个 nodejs 镜像\n# FROM node  \nFROM centos:7.9\n\n# nodejs 版本\nARG NODE_VERSION="v16.13.1"\n\nWORKDIR /opt/sendEmail\n# 将当前目录的所有文件放入容器的 /opt/sendEmail\nCOPY . /opt/sendEmail\n\n# 因为 COPY 也会将当前的 nodejs 压缩包添加进入，所以可以删除掉\nRUN rm -f /opt/sendEmail/node-${NODE_VERSION}-linux-x64.tar.xz\n\n# ------ 二选一，可注释 ------\n# 如果事先下载的 node 压缩包，则放入 Dockerfile 所在的目录下，利用 ADD 传入并自动解压\nADD node-${NODE_VERSION}-linux-x64.tar.xz /usr/local/\n# ADD 指令自动解压，所以可以删除传入的压缩包\nRUN rm -f /usr/local/node-${NODE_VERSION}-linux-x64.tar.xz\n# ------ ------ ------ ------ ------ ------ ------ ------ ------ ------\n\n# ------ 二选一，可注释 ------\n# 如果想要远程下载 node 压缩包，则取消下面的 RUN 指令注释\n#RUN yum install -y wget tar \\\n#     && cd /usr/local/ \\\n#     && wget https://nodejs.org/dist/${NODE_VERSION}/node-${NODE_VERSION}-linux-x64.tar.xz \\\n#     && tar xvf node-${NODE_VERSION}-linux-x64.tar.xz \\\n#     && rm -f node-${NODE_VERSION}-linux-x64.tar.xz\n# ------ ------ ------ ------ ------ ------ ------ ------ ------ ------\n\n# 将解压的 node 目录重命名\nRUN cd /usr/local/ \\\n     && mv node-${NODE_VERSION}-linux-x64 node\n\n# 将 node 命令添加至全局变量，包括了 node 和 npm\nENV PATH=$PATH:/usr/local/node/bin\n\n# 安装依赖包\nRUN cd /opt/sendEmail \\\n     && npm install\n\n# 暴露 7272 端口\nEXPOSE 7272\n# 启动容器后，自动执行下面的命令来启动项目\nENTRYPOINT node ./app.js\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n我都有注释说明，这里大概总结下：\n\n基于 Centos7.9 系统搭建 node 镜像，首先下载 nodejs，传到与 Dockerfile 同目录下，然后执行 Dockerfile 的时候，将 nodejs 传入镜像里，自动解压，并将 node 和 npm 命令添加至全局变量，然后把邮箱项目的代码传入镜像，接着利用全局变量 npm 进行安装 nodes_modules，最后写 ENTRYPOINT 指令，该指令会在启动容器的时候自动启动项目，这样就不需要我们亲自进入容器里启动项目。\n\n如果不喜欢先下载 nodejs，传入服务器里，那么就在构建容器时使用 wget 下载即可，上面内容的注释就是 wget 相关操作，二选一。\n\n执行如下命令执行 Dockerfile，构建镜像：\n\ndocker build -t email:2.0 .\n\n\n1\n\n\n可以看到构建的新镜像大小已经缩小一半左右，并且功能没有任何缺失，如图：\n\n\n\n2.0 版本的邮箱镜像构建源码我已经放到下载站点里了，如果需要，我在上方提供了下载地址，点击 序言 直达。\n\n\n# 消息提示效果代码\n\n在发送邮箱的过程，如果没有填写一些必要的信息，则会被提示，首页的提示是仿照 Element UI，只有两个函数，使用起来非常简单：\n\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startHeight：第一个弹窗的高度，默认 50\n * dieTime：弹窗消失时间（毫秒），默认 3000 毫秒\n */\nfunction addTip(content, type, startHeight = 50, dieTime = 3000) {\n  var tip = document.querySelectorAll(".tip");\n  var time = new Date().getTime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getAttribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lastTop =\n    parseInt(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetHeight + 17 : startHeight);\n\n  let div = document.createElement("div");\n  div.className = `tip tip-${type} ${time}`;\n  div.style.top = parseInt(top) + "px";\n  div.setAttribute("data-top", lastTop);\n  if (type == "info" || type == 1) {\n    div.innerHTML = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerHTML = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerHTML = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerHTML = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendChild(div);\n\n  let timeTip = document.getElementsByClassName(time)[0];\n  setTimeout(() => {\n    timeTip.style.top = parseInt(lastTop) + "px";\n    timeTip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dieTime 秒后隐藏并被删除\n  setTimeout(() => {\n    timeTip.style.top = "0px";\n    timeTip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var allTipElement = nextAllTipElement(timeTip);\n    for (let i = 0; i < allTipElement.length; i++) {\n      var next = allTipElement[i];\n      var top =\n        parseInt(next.getAttribute("data-top")) - next.offsetHeight - 17;\n      next.setAttribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    setTimeout(() => {\n      timeTip.remove();\n    }, 500);\n  }, dieTime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextAllTipElement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextSibling) {\n    if (n.nodeType === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nCSS 样式：\n\n/* 提示框元素 */\n.tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translateX(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n图片是阿里云的图标库，在线地址：\n\n<link rel="stylesheet" href="//at.alicdn.com/t/font_3114978_qe0b39no76.css">\n\n\n1\n\n\n使用只需要调用 addTip 即可：\n\nfunction test() {\n    var hours = new Date().getHours();\n    var minutes = new Date().getMinutes();\n    var seconds = new Date().getSeconds();\n    hours = hours < 10 ? "0" + hours : hours;\n    minutes = minutes < 10 ? "0" + minutes : minutes;\n    seconds = seconds < 10 ? "0" + seconds : seconds;\n    if (hours >= 6 && hours < 11) {\n        addTip(\n            `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 12 && hours <= 16) {\n        addTip(\n            `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 16 && hours <= 19) {\n        addTip(\n            `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 19 && hours < 24) {\n        addTip(\n            `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 0 && hours < 6) {\n        addTip(\n            `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n            "info",\n            50,\n            4000\n        );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',normalizedContent:'笔记\n\n这里简单介绍我的首页创建过程，以及邮件功能的设计过程。\n\n2021-12-09 @du wu\n\n\n\n * 序言\n * 首页部署\n * 404部署\n * 博客部署\n * 邮箱部署\n   * 邮箱源码\n   * 官方镜像部署\n   * 自定义镜像部署\n * 消息提示效果代码\n\n\n\n\n# 序言\n\n在学习完 nginx 的知识后，我看着 nginx 的欢迎页面细想了很久，眼中的世界太过单调，总觉得不够好看，而且无法给我的服务器提供任何信息介绍，而周围的朋友直接是将其代理到其他页面。\n\n当时我就有了一些想法，替换 nginx 的欢迎页面，将新的页面作为入口页面，介绍网站功能的同时，提供博客、项目导航入口。比如我部署的一个项目，那么在首页就会有提示，如点击跳转，这样就不必记住项目的 url 地址，只需要记住服务器地址，那么服务器其他的内容，都汇聚于首页。\n\n如果你是从 github 或者 gitee 进入到我的博客，那么可以去看看我的服务器首页，希望不会让你失望，点击跳转。\n\n如果你看完了下面的内容，需要我的服务器首页、404页面、邮箱功能、下载站点功能的源码，那么 点击跳转。\n\n\n# 首页部署\n\n首先准备好一个首页，不需要打包之类的，nginx 的首页只是一个 index.html 加点 css 和 js 文件即可，不需要像一个项目那样完整。\n\n利用工具连接服务器，我是用的是 xftp，将其上传到 nginx 的默认路径下。\n\nnginx 的默认路径下如果你不知道，打开 nginx 的配置文件，看 80 或者 431端口的 location / { ... } 里的 root 指定的路径，那就是 nginx 的默认路径。\n\n\n\n这就是我的默认路径，所以将首页以及静态文件上传到 nginx 默认路径下。\n\n在本地，我的首页结构如下：\n\n.\n├── index.html\n│   ├── assets (静态文件目录)\n│   │   ├── css（样式目录）\n│   │   ├── fonts（字体目录）\n│   │   ├── images（图片目录）\n│   │   ├── js（javascript 目录）\n│   ├── vendor（javascript 库）\n│   │   ├── bootstrap\n|\t│\t├── jquery\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上传到服务器后，因为默认路径下可能有太多文件，所以我对其分类，创建一个 static 文件夹。\n\n根目录\n├── index.html\n|—— static（静态文件目录）\n│   ├── assets\n│   │   ├── css（样式目录）\n│   │   ├── fonts（字体目录）\n│   │   ├── images（图片目录）\n│   │   ├── js（javascript 目录）\n│   ├── vendor（javascript 库）\n│   │   ├── bootstrap\n|\t│\t├── jquery\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n根目录，就是 /usr/local/openresty/nginx/html 目录。\n\n上传首页后，记得修改 index.html 有关 css 和 js 的引入路径，因为 nginx 的获取资源规则和本地的不一样。\n\n在本地，我们在 index.html 可以这样写：（部分）\n\n<link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet" />\n<link href="assets/fonts/iconfont.css" rel="stylesheet" />\n<script src="vendor/jquery/jquery.min.js"><\/script>\n\n\n1\n2\n3\n\n\n但是上传到 nginx 后，我们必须在开头加上 /，代表 nginx 的根目录，所以我们需要这样写：（部分）\n\n<link href="/static/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet" />\n<link href="/static/assets/fonts/iconfont.css"  rel="stylesheet"  />\n<script src="/static/vendor/jquery/jquery.min.js"><\/script>\n\n\n1\n2\n3\n\n\n然后，访问服务器的域名，即可访问这个首页。当然，如果希望访问域名的后面再加个 /home，如访问 https://www.youngkbt.cn/home ，也能访问首页的话，需要在配置文件进行配置。\n\n\n\n\n\n\n\n \n \n \n \n\n\n\n\n\nserver {\n    listen 80;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name www.youngkbt.cn;\n    # ...... 其他 location\n    \n    location /home {\n        alias  /usr/local/openresty/nginx/html;\n        index  index.html;\n    }\n    \n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里使用的是 alias 指令，因为 root 指令会把 location 后面匹配的请求拼接到目录后，而 alias 指令则会忽略 location 后匹配的请求。\n\nalias 指令不会忽略匹配后面的请求，如访问 /home/aa，则忽略 /home，但是把 /aa 拼接到目录后，但是这不影响我们访问 /home 就能访问到首页，这里只是介绍使用 alias 指令的特点。\n\njs 文件\n\n在首页，我简单实现了 element ui 的消息提示效果，也实现了邮箱发送功能，这里提供源码：\n\n$(function () {\n  var storagename = "issend";\n  \n  // 防止重复发送\n  var issend = false;\n  $(".button").on("click", function () {\n    if ($("#name").val() == \'\') {\n      addtip("姓名不能为空，请填写", "danger");\n      return;\n    } else if ($("#email").val() == \'\') {\n      addtip("邮箱不能为空，请填写", "danger");\n      return;\n    } else if ($("#subject").val() == \'\') {\n      addtip("标题不能为空，请填写", "danger");\n      return;\n    } else if ($("#message").val() == \'\') {\n      addtip("消息不能为空，请填写", "danger");\n      return;\n    } else {\n      var email = $("#email").val();\n      var reg = /^([a-za-z]|[0-9])(\\w|\\-)+@[a-za-z0-9]+\\.([a-za-z]{2,4})$/;\n      if (reg.test(email) && (sessionstorage.getitem(storagename) != "true" || issend == false)) {\n        if (confirm("确认要发送吗？")) {\n          sendemail();\n          sessionstorage.setitem(storagename,true);\n          issend = true;\n        }\n      } else if (sessionstorage.getitem(storagename) == "true" || issend == true) {\n        addtip("请不要重复发送消息", "warning");\n      } else {\n        addtip("邮箱格式不正确，请填写", "danger");\n      }\n    }\n\n    // 获取表单信息\n    // console.log($("#contact").serialize());  \n  })\n  function sendemail() {\n    $.post("/sendemail", $("#contact").serialize(), function (res, error) {\n      if (res == \'ok\') {  \n        addtip("发送消息成功", "success");\n        settimeout(() => {\n          window.location.reload();\n          sessionstorage.removeitem(storagename);\n          issend == false;\n        }, 1500);\n      } else {\n        console.log("失败的原因：", error);\n        addtip("发送失败，可能发送超时或消息被拦截，请稍后再重试", "tip");\n      }\n    });\n  }\n\n  // 添加消息提示\n  function addtip(content, type) {\n\n    var time = new date().gettime();\n    // 获取最后消息提示元素的高度\n    var top = $(".tip:last").attr("data-top") == undefined ? 0 : $(".tip:last").attr("data-top");\n    // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 20\n    var lasttop = parseint(top) + ($(".tip").length > 0 ? $(".tip:last").outerheight() + 17 : 20);\n\n    if (type == "success" || type == 1) {\n      $("#page-wraper").append(`<div class="tip tip-success ${time}" style="top: ${parseint(top)}px" data-top="${lasttop}"><i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p></div>`);\n    } else if (type == "danger" || type == 2) {\n      $("#page-wraper").append(`<div class="tip tip-danger ${time}" style="top: ${parseint(top)}px" data-top="${lasttop}><i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p></div>`);\n    } else if (type == "info" || type == 3) {\n      $("#page-wraper").append(`<div class="tip tip-info ${time}" style="top: ${parseint(top)}px" data-top="${lasttop}><i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p></div>`);\n    } else if (type == "warning" || type == 4) {\n      $("#page-wraper").append(`<div class="tip tip-warning ${time}" style="top: ${parseint(top)}px" data-top="${lasttop}><i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p></div>`);\n    }\n\n    // 动画往下滑动\n    $("." + time).animate({\n      top: parseint(lasttop) + "px",\n      opacity: "1",\n    })\n\n    // 消息提示 3 秒后隐藏并被删除\n    settimeout(() => {\n      $("." + time).animate({\n        top: "0px",\n        opacity: "0",\n      });\n\n      settimeout(() => {\n        $("." + time).remove();\n      }, 500);\n    }, 3000);\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n消息提示效果的 css 文件内容：\n\n/* 消息提示样式 */\n.tip{\n  position: fixed;\n  display: flex;\n  height: 48px;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translatex(-50%);\n  transition: opacity .3s linear,top .4s,transform .4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n.tip p{\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n.icon{\n  margin-right: 10px;\n  line-height: 17px;\n}\n.tip-success  {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n.tip-success .tip-success-content{\n  color: #67c23a;\n}\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n.tip-danger .tip-danger-content{\n  color: #f56c6c;\n}\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n.tip-info .tip-info-content{\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n.tip-warning .tip-warning-content{\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n/* 下面是二维码样式 */\n.social-tip{\n  margin-bottom: 170px;\n  display: none;\n} \n.square{\n    width: 0;\n    height: 0;\n    border-bottom: 7px solid rgba(118, 25, 172, 0.3);\n    border-right: 7px solid transparent;\n    border-left: 7px solid transparent;\n    position: relative;\n    left: 36%;\n}\n.social-info{\n  width: 200px;\n  position: absolute;\n  line-height: 48px;\n  left: -95%;\n  margin-left: -40px;\n  background-color: rgba(118, 25, 172, 0.3);\n  color: #fff;\n  padding: 0 15px 15px;\n}\n.social-info img{\n  width: 160px;\n  height: 160px;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n如下效果：\n\n\n\n我设计了四个提示，分别是成功绿色，提示灰色，警告黄色，错误红色。而提示语前面的图标，需要自己去阿里云的矢量库进行获取，并在首页引用，矢量库跳转。\n\n\n# 404部署\n\n你喜欢 nginx 自带的 404 页面吗？我可能不是特别喜欢，所以我们可以自定义好看的 404 页面，又或者去网上下载别人做好的 404 页面模板。如我的 404 页面如图：\n\n\n\n点击头像还能播放音乐。\n\n利用 xftp 将 404 页面上传到服务器上，我在 nginx 根目录下创建了一个 404 文件夹，将 404 页面和其 css 和 js 文件放到这个 404 文件夹里。\n\n目录结构：\n\n根目录\n|—— 404（这是个目录）\n│   ├── 404.html（ 404 页面）\n│   ├── css（样式目录）\n│   ├── img（图片目录）\n│   ├── js（javascript 目录）\n|\t├── music（音乐目录）\n|\n├── index.html（其他页面）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上传后到 nginx 后，养成好习惯，打开 404.html，修改 css、js 文件的引入路径，因为 nginx 的获取资源规则和本地的不一样。\n\n记得开头加 /，改为：（部分）\n\n<link rel="stylesheet" href="/404/css/ghost.css">\n<script type="text/javascript" src="/404/js/jquery.min.js"><\/script>\n\n\n1\n2\n\n\n然后在配置文件修改 404 页面的访问路径\n\n\n\n\n\n\n\n \n \n \n \n \n\n\n\n\n\nserver {\n    listen 431;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name youngkbt.cn;\n    # ...... 其他 location\n    \n    error_page   404 500 502 503 504 /404.html;\n    location = /404.html {\n        root    /usr/local/openresty/nginx/html/404;\n        index 404.html;\n    }\n    \n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n此时你随便访问我的服务器地址，如 https://www.youngkbt.cn/aaa 那么就会显示我的 404 页面。在该页面中，点击我的头像后，音乐会伴随头像的旋转而缓缓响起，静静享受 404 带有的静谧时刻。\n\n\n# 博客部署\n\n我的博客已经部署在 github 和 gitee 中，如果你看了上一个文章，部署自己的博客到了服务器，那么就请在 nginx 设置一个 location 模块，进行跳转吧。\n\n我设置了两个 location 模块，当输入 /notes 或者 /note-blog 的时候，都会跳转到我的博客首页\n\nlocation /notes {\n    rewrite ^/notes/(\\w*)$ /notes-blog/$1;\n}\nlocation /notes-blog {\n    root /home/kbt;\n    index index.html;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n实际上，最终都会跳到 /note-blog 的 location 模块里。\n\n我们不仅可以设置博客的 location，也可以设置浏览器的缓存静态文件时间，因为博客的静态文件太多，当用户每次访问都从 nginx 服务器获取静态文件，那显然不理智，我们可以让用户访问过的静态文件，缓存到用户的浏览器中，这样，用户再次访问博客的时候，直接从浏览器本地获取，打开的速度非常快。\n\n我设置了静态文件缓存 7 天，html 文件缓存 1 天\n\nlocation ~ /note-blog/.*\\.(js|css|png|jpg|jpeg|gif)$ {\n    root /home/kbt;\n    expires 7d;  # 缓存七天\n}\n\nlocation ~ /note-blog/.*\\.(html)$ {\n    root /home/kbt;\n    expires 1d;  # 缓存一天\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n看到 root 了吗，我的博客并没有放在 nginx 的默认路径下，而是由普通用户 kbt 管理。防止滥用 root 权限，避免被别人恶意访问。\n\n\n# 邮箱部署\n\n建议你看到这里马上停住，然后点击 测试发送邮箱，输入你的邮箱，进行发送，体验之后再来学习，会有更大的收获和兴趣。\n\n邮箱项目我使用了 node 和 express 来搭建简单的服务器，然后利用 nodemailer 进行邮件发送，log4j.js 进行日志信息存储。\n\n这是一个 node 简单项目，安装的依赖只有三个，express、nodemailer、log4js。\n\n\n# 邮箱源码\n\n我的 package.json 文件内容如下：\n\n{\n    "name": "email",\n    "version": "1.0",\n    "private": true,\n    "scripts": {\n        "dev": "node app.js"\n    },\n    "dependencies": {\n        "express": "^4.17.1",\n        "log4js": "^6.3.0",\n        "nodemailer": "^6.7.2"\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n依赖只有三个，如何安装呢，我使用 yarn 进行安装。\n\nyarn add express --save\nyarn add log4js --save\nyarn add nodemailer --save\n\n\n1\n2\n3\n\n\n安装完，我们先编写 log.js 文件，实现日志功能\n\n// 引入插件 log4js  \nvar log4js = require(\'log4js\')\nlog4js.configure({\n    appenders: {\t// 配置日志文件\n        access: {    // 访问日志的 name\n            type: \'file\',     \n            filename: "logs/access.log",\n            layout: {\n                type: \'pattern\',\n                pattern: \'[%d{yyyy-mm-dd hh:mm:ss sss}] [%p] %c - %m\'\n            },\n        },\n        error: {    // 错误日志的 name\n            type: \'file\',\n            filename: "logs/error.log",\n            layout: {   // 定义日志输出的样式\n                type: \'pattern\',\n                pattern: \'[%d{yyyy mm dd hh:mm:ss sss}] [%p] %c - %m%n\' // 日志输出时间格式\n            },\n        },\n    },\n\n    categories: {\t// 配置日志级别，以及引用 appenders 配置的日志文件\n        default: { appenders: [\'access\'], level: \'info\' },  // 上方 appenders 的 name\n        error: { appenders: [\'error\'], level: \'error\' }\n    },\n})\n\nexports.logger = function (name) {  // name 取 categories 的 name\n    return log4js.getlogger(name || \'default\')\n};\nexports.use = function (app, logger) {\n    app.use(log4js.connectlogger(logger || log4js.getlogger(\'default\'), { level: \'info\', format: \'请求类型/uri：「 :method:url 」\' })) // 请求类型/uri 格式设置\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n文件内容不难理解，我们首先配置要输出的日志文件路径以及名字，然后配置日志输出的信息时间格式，然后配置日志的格式，如 info 或者 error，接着配置请求类型/uri 格式，最后暴露出去。\n\n日志的输出内容如图所示：\n\n\n\n编写 route.js 文件，相信学过 express 的伙伴已经非常熟悉了\n\nconst express = require("express");\nconst router = express.router();\n// 引入日志\nconst logger = require("./log").logger();\nconst errlogger = require("./log").logger("error");\n// 引入邮件发送功能\nvar nodemailer = require(\'nodemailer\');\n\nrouter.post("/email", (req, res) => {\n    var data = req.body;\n    // 获取发送的模板\n    const myhtml = require("./email/emailhtml").myhtml(data);\n    const otherhtml = require("./email/emailhtml").otherhtml(data);\n    // 创建连接\n    var transporter = nodemailer.createtransport({\n        host: "smtp.163.com",\n        port: 465, // smtp 端口\n        secureconnection: true, // 使用 ssl 方式（安全方式，防止被窃取信息）\n        auth: {\n            user: \'kele_bingtang@163.com\',\n            // 这里密码不是 qq 密码，是你设置的 smtp 密码\n            pass: \'gjqdwnwvgyevtsmb\'\n        }\n    });\n\n    // 邮件参数（我的）\n    var myoptions = {\n        from: \'kele_bingtang@163.com\', // 发件地址\n        to: \'kele_bingtang@163.com,2456019588@qq.com\', // 收件列表\n        subject: data.subject, // 标题\n        // text 和 html 同时发送只支持一种\n        html: myhtml,\n\n        //  text: "测试",\n        /*  attachments:[{  // 附件\n       filename: \'\',   // 附件名\n       path: \'\'    // 附件路径\n     }] */\n    };\n\n    // 邮件参数（发件人）\n    var otheroptions = {\n        from: \'kele_bingtang@163.com\', // 发件地址\n        to: `kele_bingtang@163.com,${data.email}`, // 收件列表\n        subject: "young kbt 的致谢", // 标题\n        // text 和 html 同时发送只支持一种\n        html: otherhtml,\n    };\n\n    // 发送邮件（给发件人）\n    transporter.sendmail(otheroptions, function (error, info) {\n        if (error) {\n            errlogger.error("发送给「 " + data.name + " 」失败，原因：「 " + error + " 」");\n            res.status(200).send("error：" + error);\n        }else{\n            logger.info("发送给「 " + data.name + " 」成功");\n        }\n        console.log("发送给发件人的响应信息：");\n        console.log(info);\n    });\n\n\n    // 发送邮件（给我）\n    transporter.sendmail(myoptions, function (error, info) {\n        console.log("错误信息：" + error);\n        if (error) {\n            errlogger.error("发送给「 young kbt 」失败，原因：「 " + error + " 」");\n            res.status(200).send("error：" + error);\n        }else{\n            res.status(200).send("ok");\n            logger.info("发件邮箱：「 " + info.envelope.from + " 」，收件邮箱：「 " + info.envelope.to + " 」");\n            logger.info("响应结果：「 " + info.response + " 」");\n            console.log("发送给我的响应信息：");\n            console.log(info);\n        }\n    });\n\n    logger.info("发件人：「 " + data.name + " 」，发件人的邮箱：「 " + data.email + " 」，发件主题：「 " + data.subject + " 」，发件消息：「 " + data.message + " 」");\n\n    settimeout(() => {\n        logger.info("发送一次邮件的日志分割线 ------------------------\\n");\n    }, 4000);\n\n    settimeout(() => {\n        transporter.close();\n    }, 10000);\n\n})\n\nmodule.exports = router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n\n\n第 12 和 13 行引用自定义的邮件页面模板，模板大家根据自己的需求设计邮件页面。\n\n我的邮件页面代码位于根目录下的 email 目录，名字叫 emailhtml，源码为：\n\n// 发送给我\nexports.myhtml = function(data){\n    return `<div style="width: 600px;margin: 0 auto;">\n            <includetail>\n              <table style="text-align: center; font-size: 16px; color: #333333; border-spacing: 0px; border-collapse: collapse; width: 580px; direction: ltr">\n                  <tbody>\n                  <tr>\n                      <td style="font-size: 14px; padding: 0px 0px 7px 0px; text-align: center;color: #0044cc">\n                          ${data.name} 在 young kbt 首页发送给您\n                      </td>\n                  </tr>\n                  <tr style="background-color: #2279bd">\n                      <td style="padding: 0px">\n                          <table style="border-spacing: 0px; border-collapse: collapse; width: 100%">\n                              <tbody>\n                              <tr>\n                                  <td style="padding: 0px; text-align: center;">\n                                      <img src="https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211205131212.jpg" alt="请在上方选择信任，以此显示头像">\n                                  </td>\n                              </tr>\n                              <tr>\n                                  <td style="font-size: 38px; color: #ffffff; padding: 12px 22px 4px 22px; text-align: center;" colspan="3">\n                                      young kbt\n                                  </td>\n                              </tr>\n                              <tr>\n                                  <td style="font-size: 20px; color: #ffffff; padding: 0px 22px 18px 22px; text-align: center;" colspan="3">\n                                    人闲车马慢，路遥星亦辞\n                                  </td>\n                              </tr>\n                              </tbody>\n                          </table>\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="background-color: #5ba9df; border-bottom-style: solid; border-bottom-color: #2279bd; border-bottom-width: 4px;">\n                          <table style="color: #333333; border-spacing: 0px; border-collapse: collapse; width: 100%; color: #fff">\n                              <tbody>\n                                <tr>\n                                  <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                                    <p style="text-align: center">\n                                      <span style="font-weight:bold;">${data.name} </span>\n                                      <span>发送的主题：</span></p>\n                                      <p style="font-size: 16px; letter-spacing: 0.5px; text-indent: 16px; padding:0 20px; line-height: 30px; text-align: left;">\n                                      ${data.subject}\n                                    </p>\n                                  </td>\n                                </tr>\n                                <tr>\n                                  <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                                    <p style="text-align: center; margin-top: 0;">\n                                      <span style="font-weight:bold;">${data.name} </span>\n                                      <span>发送的内容：</span>\n                                    </p>\n                                      <p style="font-size: 16px;letter-spacing: 0.5px; text-indent: 16px; padding:0 20px; line-height: 30px; text-align: left;">\n                                      ${data.message}\n                                    </p>\n                                  </td>\n                                </tr>\t\n                                <tr>\n                                    <td style="font-size: 16px; padding: 30px 20px; text-align: center">\n                                      如果您希望回复他/她，请发送到他/她的邮箱：\n                                      <p style="color: #0044cc; font-weight: bold">${data.email}</p>\n                                    </td>\n                                </tr>\n                              </tbody>\n                          </table>\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="padding: 35px 0px; color: #b2b2b2; font-size: 12px">\n                          from young kbt\n                          <br>\n                          this is a website\n                          <br>\n                          ${new date().getfullyear()}-${new date().getmonth() + 1 == 13 ? 12 : new date().getmonth() + 1}-${new date().getdate() > 10 ? new date().getdate() : \'0\' + new date().getdate()}\n                            ${new date().gethours() > 10 ? new date().gethours() : \'0\' + new date().gethours()}:${new date().getminutes() > 10 ? new date().getminutes() : \'0\' + new date().getminutes()}:${new date().getseconds() > 10 ? new date().getseconds() : \'0\' + new date().getseconds()}\n                      </td>\n                  </tr>\n                  <tr>\n                      <td style="padding: 0px 0px 10px 0px; color: #b2b2b2; font-size: 12px">\n                          copyright young kbt website             \n                      </td>\n                  </tr>\n                  </tbody>\n              </table>\n            </includetail>\n          </div`;\n}\n\n// 发送给发件人\nexports.otherhtml = function(data){\n    return `<div style="width: 600px;margin: 0 auto;">\n            <includetail>\n              <table\n                style="text-align: center; font-size: 16px; color: #333333; border-spacing: 0px; border-collapse: collapse; width: 580px; direction: ltr">\n                <tbody>\n                  <tr>\n                    <td style="font-size: 14px; padding: 0px 0px 7px 0px; text-align: center;color: #0044cc">\n                      尊敬的 <span style="font-weight: bold;">${data.name}</span>，young kbt 感谢您的邮件\n                    </td>\n                  </tr>\n                  <tr style="background-color: #2279bd">\n                    <td style="padding: 0px">\n                      <table style="border-spacing: 0px; border-collapse: collapse; width: 100%">\n                        <tbody>\n                          <tr>\n                            <td style="padding: 0px; text-align: center;">\n                              <img src="https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211205131212.jpg" alt="请在上方选择信任，以此显示头像">\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 38px; color: #ffffff; padding: 12px 22px 4px 22px; text-align: center;"\n                              colspan="3">\n                              young kbt\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 20px; color: #ffffff; padding: 0px 22px 18px 22px; text-align: center;"\n                              colspan="3">\n                              人闲车马慢，路遥星亦辞\n                            </td>\n                          </tr>\n                        </tbody>\n                      </table>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td\n                      style="background-color: #5ba9df; border-bottom-style: solid; border-bottom-color: #2279bd; border-bottom-width: 4px;">\n                      <table style="color: #333333; border-spacing: 0px; border-collapse: collapse; width: 100%; color: #fff">\n                        <tbody>\n                          <tr>\n                            <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                              <p style="text-align: center">\n                                <span style="font-weight:bold">young kbt</span>\n                                <span>提示您：</span>\n                              </p>\n                              <p\n                                style="font-size: 16px; letter-spacing: 0.5px; text-indent: 32px; padding:0 20px; line-height: 30px; text-align: left;">\n                                本邮件由 young kbt\'s index 网站发送给您，\n                                <span style="color: #1546a8; font-weight: bold;">如果非本人操作，请忽略即可。</span>\n                              </p>\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 18px; padding: 0px 0px 5px 0px;">\n                              <p style="text-align: center; margin-top: 0;">\n                                <span style="font-weight:bold">young kbt</span>\n                                <span>回复您：</span>\n                              </p>\n                              <p\n                                style="font-size: 16px;letter-spacing: 0.5px; text-indent: 32px; padding:0 20px; line-height: 30px; text-align: left;">\n                                感谢您提供的宝贵消息，我会根据您的内容尽快回复您，如果时间较延迟，请您见谅。\n                              </p>\n                            </td>\n                          </tr>\n                          <tr>\n                            <td style="font-size: 16px; padding: 30px 20px; text-align: center">\n                              如果您对我的网站感兴趣，请访问：\n                              <p style="color: #0044cc; font-weight: bold">\n                               <a href="youngkbt.cn" style="color: #0044cc; text-decoration: none">youngkbt.cn</a>\n                              </p>\n                              <p style="color: #0c3388;font-size: 14px; margin: 15px 0 0 0;">本网站仅是个人使用，并不带有商业用途</p>\n                            </td>\n                          </tr>\n                        </tbody>\n                      </table>\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style="padding: 35px 0px; color: #b2b2b2; font-size: 12px">\n                      from young kbt\n                      <br>\n                      this is a website\n                      <br>\n                      ${new date().getfullyear()}-${new date().getmonth() + 1 == 13 ? 12 : new date().getmonth() + 1}-${new\n    date().getdate() > 10 ? new date().getdate() : \'0\' + new date().getdate()}\n                      ${new date().gethours() > 10 ? new date().gethours() : \'0\' + new date().gethours()}:${new\n    date().getminutes() > 10 ? new date().getminutes() : \'0\' + new date().getminutes()}:${new\n    date().getseconds() > 10 ? new date().getseconds() : \'0\' + new date().getseconds()}\n                    </td>\n                  </tr>\n                  <tr>\n                    <td style="padding: 0px 0px 10px 0px; color: #b2b2b2; font-size: 12px">\n                      copyright young kbt website\n                    </td>\n                  </tr>\n                </tbody>\n              </table>\n            </includetail>\n          </div>`\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n\n\n编写 express 的入口文件 app.js，监听 5678 端口\n\nconst express = require("express");\nconst router = require("./router");\nconst log = require("./log");\nconst app = express();\n\nlog.use(app);\napp.use(express.urlencoded({ extended: false }));\napp.use(express.json());\n\napp.use( ( request , response , next ) => {\n    response.header( \'access-control-allow-origin\' , \'*\') // 跨域最重要的一步 设置响应头\n    next(); // 执行 next 函数执行后续代码\n})\n\napp.use(\'/\',router);\n\napp.listen(\'5678\',() => {\n    console.log("5678 端口的服务器启动成功");\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n写完邮箱的功能，我们可以进行测试，进入邮箱项目的根目录，使用 node app.js 启动 node 项目。\n\nnode app.js\n\n\n1\n\n\n因为是 post 请求，所以使用 postman 等工具进行测试，访问 localhost:5678/email，填写 json 格式，包含 name、email、subject、message 四个参数的数据即可。\n\n\n\n\n# 官方镜像部署\n\n在本地编写测试完邮箱的功能后，我们将其上传到服务器，我上传的目录是 docker/node/email 下，然后需要服务器安装 node 环境，我使用的是 docker，所以直接拉取 node。\n\ndocker pull node\n\n\n1\n\n\n下载完 node 镜像后，不要马上启动它，因为 node 项目需要执行打包命令，生成 node_modules 目录，所以使用 dockerfile 文件来执行打包命令。\n\n在 docker/node/email 目录下，创建并编写 dockerfile 文件\n\ncd docker/node/email\nvim dockerfile\n\n\n1\n2\n\n\n添加如下内容：\n\nfrom node\t\t\t\t\t# 基于 node 镜像创建新的镜像\nworkdir /home/email\t\t\t# 创建默认工作目录\ncopy . /home/email\t\t\t# 将当前目录的所有内容拷贝到容器中\nrun npm i\t\t\t\t\t# 执行打包命令\nexpose 5678\t\t\t\t\t# 暴露 5678 端口\nentrypoint node ./app.js \t# 启动容器时，启动 app.js 文件\n\n\n1\n2\n3\n4\n5\n6\n\n\n不难看出，在生成 docker 镜像的同时，它会将当前目录下的所有内容拷贝到容器中，这些内容就是我们写的邮箱项目。接着它会执行打包命令 npm i，i 代表 install。然后暴露 5678 端口，最后在启动的时候，启动 app.js 文件，也就是执行项目。\n\n写好 dockerfile 文件，我们执行这个文件，构建基于 node 环境而搭建的「邮箱发送」镜像\n\ndocker build -t email:1.0 .\n\n\n1\n\n\n启动这个名叫 email、版本为 1.0 的容器，当启动这个容器的时候，内部就会执行 node ./app.js 命令，也就是 dockerfile 文件的 entrypoint 指令，部署项目。\n\ndocker run -d --name email \\\n-v /docker/node/email/router.js:/home/email/router.js \\\n-v /docker/node/email/app.js:/home/email/app.js \\\n-v /docker/node/email/log.js:/home/email/log.js \\\n-v /docker/node/email/logs:/home/email/logs \\\n-v /docker/node/email/email:/home/email/email \\\n--network web --network-alias email \\\nemail:1.0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不要惊讶会有那么多启动命令，这里主要实现挂载功能，只要宿主机的文件发生改变，则容器内的文件也会同步改变，毕竟谁也无法确定自己写的文件以后都不会修改，对吧。\n\n至于第 7 行的 network 网络，因为 nginx 所处的网络是 web 网络，而想让 nginx 访问 node 项目，则需要让两者处于同一个网络上。 network-alias 是网络别名，nginx 会根据这个网络别名找到处于相同网络下的 node 项目，尽量与容器名保持一致。\n\n此时邮箱项目已经部署成功了，但是 nginx 还无法访问这个邮箱项目，因为我们没有配置 location 模块来访问邮箱项目。\n\nserver {\n    listen       5678;\n    server_name  localhost;\n\n    location /email {\n\t    proxy_pass http://email:5678;    # email 就是网桥别名，nginx 通过它找到 email 容器\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实际上我并没有直接将上面的 server 模块放在配置文件里，而是将上面的内容放在新创建的 email_5678.conf 文件里，然后在配置文件进行转发。\n\n\n\n因为核心配置文件使用了 include 指令将 conf 目录下的所有 .conf 文件引入，所以我们只需要创建新的配置文件 email_5678.conf 即可。\n\n然后新的配置文件添加如下内容：\n\nserver {\n    listen 431;\t\t# 431 是 https 的默认端口，80 是 http 的默认端口\n    server_name www.youngkbt.cn;\n    # ...... 其他 location\n\n    # 转发给其他的 conf 文件\n    location /email {\n        proxy_pass http://localhost:5678;\n    }\n\n    # ...... 其他 location\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n当访问 /email 的时候，触发 431 端口的的 /email，然后内部就会执行 proxy_pass 指令，将请求转发给本地的 5678 端口，此时 email_5678.conf 文件正好监听这个 5678 端口，所以就会将 /email 请求发给自己的 location ，执行新的 proxy_pass 指令，而这个指令才是将请求发给 node 邮箱项目，触发邮箱的发送。\n\n记得重启 ngixn，使得配置文件生效。\n\n什么时候外界会访问 /email？\n\n自己写一个 <a> 标签，填写你的服务器的地址加上 /email 即可。\n\n我自己写的不是 <a> 标签，而是一个 js 文件，点击按钮触发 ajax 请求，具体源码请看 首页部署 的 js 文件。\n\n\n# 自定义镜像部署\n\n我在使用了基于官方镜像的部署几天后，发现这个镜像太大了，有 999mb，如图：\n\n\n\n于是我打算基于 centos7.9 构建一个 node 环境的镜像，这里提供 dockerfile 文件内容：\n\n# 这是早期的版本，直接引入 node 镜像，但是该镜像太大了，构建后 999mb，所以我就自己创建一个 nodejs 镜像\n# from node  \nfrom centos:7.9\n\n# nodejs 版本\narg node_version="v16.13.1"\n\nworkdir /opt/sendemail\n# 将当前目录的所有文件放入容器的 /opt/sendemail\ncopy . /opt/sendemail\n\n# 因为 copy 也会将当前的 nodejs 压缩包添加进入，所以可以删除掉\nrun rm -f /opt/sendemail/node-${node_version}-linux-x64.tar.xz\n\n# ------ 二选一，可注释 ------\n# 如果事先下载的 node 压缩包，则放入 dockerfile 所在的目录下，利用 add 传入并自动解压\nadd node-${node_version}-linux-x64.tar.xz /usr/local/\n# add 指令自动解压，所以可以删除传入的压缩包\nrun rm -f /usr/local/node-${node_version}-linux-x64.tar.xz\n# ------ ------ ------ ------ ------ ------ ------ ------ ------ ------\n\n# ------ 二选一，可注释 ------\n# 如果想要远程下载 node 压缩包，则取消下面的 run 指令注释\n#run yum install -y wget tar \\\n#     && cd /usr/local/ \\\n#     && wget https://nodejs.org/dist/${node_version}/node-${node_version}-linux-x64.tar.xz \\\n#     && tar xvf node-${node_version}-linux-x64.tar.xz \\\n#     && rm -f node-${node_version}-linux-x64.tar.xz\n# ------ ------ ------ ------ ------ ------ ------ ------ ------ ------\n\n# 将解压的 node 目录重命名\nrun cd /usr/local/ \\\n     && mv node-${node_version}-linux-x64 node\n\n# 将 node 命令添加至全局变量，包括了 node 和 npm\nenv path=$path:/usr/local/node/bin\n\n# 安装依赖包\nrun cd /opt/sendemail \\\n     && npm install\n\n# 暴露 7272 端口\nexpose 7272\n# 启动容器后，自动执行下面的命令来启动项目\nentrypoint node ./app.js\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n我都有注释说明，这里大概总结下：\n\n基于 centos7.9 系统搭建 node 镜像，首先下载 nodejs，传到与 dockerfile 同目录下，然后执行 dockerfile 的时候，将 nodejs 传入镜像里，自动解压，并将 node 和 npm 命令添加至全局变量，然后把邮箱项目的代码传入镜像，接着利用全局变量 npm 进行安装 nodes_modules，最后写 entrypoint 指令，该指令会在启动容器的时候自动启动项目，这样就不需要我们亲自进入容器里启动项目。\n\n如果不喜欢先下载 nodejs，传入服务器里，那么就在构建容器时使用 wget 下载即可，上面内容的注释就是 wget 相关操作，二选一。\n\n执行如下命令执行 dockerfile，构建镜像：\n\ndocker build -t email:2.0 .\n\n\n1\n\n\n可以看到构建的新镜像大小已经缩小一半左右，并且功能没有任何缺失，如图：\n\n\n\n2.0 版本的邮箱镜像构建源码我已经放到下载站点里了，如果需要，我在上方提供了下载地址，点击 序言 直达。\n\n\n# 消息提示效果代码\n\n在发送邮箱的过程，如果没有填写一些必要的信息，则会被提示，首页的提示是仿照 element ui，只有两个函数，使用起来非常简单：\n\n/**\n * 添加消息提示\n * content：内容\n * type：弹窗类型（tip、success、warning、danger）\n * startheight：第一个弹窗的高度，默认 50\n * dietime：弹窗消失时间（毫秒），默认 3000 毫秒\n */\nfunction addtip(content, type, startheight = 50, dietime = 3000) {\n  var tip = document.queryselectorall(".tip");\n  var time = new date().gettime();\n  // 获取最后消息提示元素的高度\n  var top = tip.length == 0 ? 0 : tip[tip.length - 1].getattribute("data-top");\n  // 如果产生两个以上的消息提示，则出现在上一个提示的下面，即高度添加，否则默认 50\n  var lasttop =\n    parseint(top) +\n    (tip.length != 0 ? tip[tip.length - 1].offsetheight + 17 : startheight);\n\n  let div = document.createelement("div");\n  div.classname = `tip tip-${type} ${time}`;\n  div.style.top = parseint(top) + "px";\n  div.setattribute("data-top", lasttop);\n  if (type == "info" || type == 1) {\n    div.innerhtml = `<i class="iconfont icon-info icon"></i><p class="tip-info-content">${content}</p>`;\n  } else if (type == "success" || type == 2) {\n    div.innerhtml = `<i class="iconfont icon-dagouyouquan icon"></i><p class="tip-success-content">${content}</p>`;\n  } else if (type == "danger" || type == 3) {\n    div.innerhtml = `<i class="iconfont icon-cuowu icon"></i><p class="tip-danger-content">${content}</p>`;\n  } else if (type == "warning" || type == 4) {\n    div.innerhtml = `<i class="iconfont icon-gantanhao icon"></i><p class="tip-warning-content">${content}</p>`;\n  }\n  document.body.appendchild(div);\n\n  let timetip = document.getelementsbyclassname(time)[0];\n  settimeout(() => {\n    timetip.style.top = parseint(lasttop) + "px";\n    timetip.style.opacity = "1";\n  }, 10);\n\n  // 消息提示 dietime 秒后隐藏并被删除\n  settimeout(() => {\n    timetip.style.top = "0px";\n    timetip.style.opacity = "0";\n\n    // 下面的所有元素回到各自曾经的出发点\n    var alltipelement = nextalltipelement(timetip);\n    for (let i = 0; i < alltipelement.length; i++) {\n      var next = alltipelement[i];\n      var top =\n        parseint(next.getattribute("data-top")) - next.offsetheight - 17;\n      next.setattribute("data-top", top);\n      next.style.top = top + "px";\n    }\n    settimeout(() => {\n      timetip.remove();\n    }, 500);\n  }, dietime);\n}\n/**\n * 获取后面的兄弟元素\n */\nfunction nextalltipelement(elem) {\n  var r = [];\n  var n = elem;\n  for (; n; n = n.nextsibling) {\n    if (n.nodetype === 1 && n !== elem) {\n      r.push(n);\n    }\n  }\n  return r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\ncss 样式：\n\n/* 提示框元素 */\n.tip {\n  position: fixed;\n  display: flex;\n  top: -10px;\n  left: 50%;\n  opacity: 0;\n  min-width: 320px;\n  transform: translatex(-50%);\n  transition: opacity 0.3s linear, top 0.4s, transform 0.4s;\n  z-index: 99999;\n  padding: 15px 15px 15px 20px;\n  border: 1px solid #ebeef5;\n  border-radius: 4px;\n  grid-row: 1;\n  line-height: 17px;\n}\n\n.tip p {\n  line-height: 17px;\n  margin: 0;\n  font-size: 14px;\n}\n\n.icon {\n  margin-right: 10px;\n  line-height: 17px;\n}\n\n.tip-success {\n  color: #67c23a;\n  background-color: #f0f9eb;\n  border-color: #e1f3d8;\n}\n\n.tip-success .tip-success-content {\n  color: #67c23a;\n}\n\n.tip-danger {\n  color: #f56c6c;\n  background-color: #fef0f0;\n  border-color: #fde2e2;\n}\n\n.tip-danger .tip-danger-content {\n  color: #f56c6c;\n}\n\n.tip-info {\n  background-color: #edf2fc;\n  border-color: #ebeef5;\n}\n\n.tip-info .tip-info-content {\n  color: #909399;\n}\n\n.tip-warning {\n  color: #e6a23c;\n  background-color: #fdf6ec;\n  border-color: #faecd8;\n}\n\n.tip-warning .tip-warning-content {\n  margin: 0;\n  color: #e6a23c;\n  line-height: 21px;\n  font-size: 14px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n图片是阿里云的图标库，在线地址：\n\n<link rel="stylesheet" href="//at.alicdn.com/t/font_3114978_qe0b39no76.css">\n\n\n1\n\n\n使用只需要调用 addtip 即可：\n\nfunction test() {\n    var hours = new date().gethours();\n    var minutes = new date().getminutes();\n    var seconds = new date().getseconds();\n    hours = hours < 10 ? "0" + hours : hours;\n    minutes = minutes < 10 ? "0" + minutes : minutes;\n    seconds = seconds < 10 ? "0" + seconds : seconds;\n    if (hours >= 6 && hours < 11) {\n        addtip(\n            `早上好呀~~，现在是 ${hours}:${minutes}:${seconds}，吃早餐了吗？😊🤭`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 12 && hours <= 16) {\n        addtip(\n            `下午好呀~~，现在是 ${hours}:${minutes}:${seconds}，繁忙的下午也要适当休息哦🥤🏀~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 16 && hours <= 19) {\n        addtip(\n            `到黄昏了~~，现在是 ${hours}:${minutes}:${seconds}，该准备吃饭啦🥗🍖~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 19 && hours < 24) {\n        addtip(\n            `晚上好呀~~，现在是 ${hours}:${minutes}:${seconds}，该准备洗漱睡觉啦🥱😪~~`,\n            "info",\n            50,\n            4000\n        );\n    } else if (hours >= 0 && hours < 6) {\n        addtip(\n            `别再熬夜了~~，现在是 ${hours}:${minutes}:${seconds}，早点睡吧，让我们一起欣赏早上的太阳~~😇🛏`,\n            "info",\n            50,\n            4000\n        );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"首页 - 下载站点",frontmatter:{title:"首页 - 下载站点",date:"2021-12-14T21:43:11.000Z",permalink:"/about/index/download/",titleTag:"原创",categories:["关于 - 首页"],tags:["首页"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/08.%E5%85%B3%E4%BA%8E%20-%20%E9%A6%96%E9%A1%B5/04.%E9%A6%96%E9%A1%B5%20-%20%E4%B8%8B%E8%BD%BD%E7%AB%99%E7%82%B9.html",relativePath:"80.关于/08.关于 - 首页/04.首页 - 下载站点.md",key:"v-222a195f",path:"/about/index/download/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:60},{level:2,title:"第三方模块",slug:"第三方模块",normalizedTitle:"第三方模块",charIndex:105}],headersStr:"介绍 第三方模块",content:"笔记\n\n首页的下载站点是基于 Nginx 提供的，但是 Nginx 自带的下载站点不是特别好看，比较「拥挤」，所以本内容介绍我的下载站点如何优化。\n\n2021-12-14 @Du Wu\n\n\n\n * 介绍\n * 第三方模块\n\n\n\n\n# 介绍\n\n如果还不懂什么是下载站点，请看我的下载站点：https://www.youngkbt.cn/download/。\n\n看了我的下载站点，你会发现和 Nginx 自带的样式有些不一样，嗯？Nginx 自带的下载站点长啥样？请看 Nginx - 站点与认证。\n\n下载站点，就是能够下载东西的网页。其实设计并没有多难，利用第三方模块，就可以实现上方效果。\n\n本下载站点基于 Nginx 搭建的，没有 Nginx 的支持，本下载站点将会无效。\n\n\n# 第三方模块\n\n首先需要实现 Nginx 自带的下载站点，了解这个后方能利用第三方模块进行美化，如果你不了解什么是模块，就认为这叫做插件。\n\n我使用的是 ngx-fancyindex 模块，这里提供下载地址：\n\n * GitHub 地址：https://github.com/aperezdc/ngx-fancyindex\n\n * 版本选择地址：https://github.com/aperezdc/ngx-fancyindex/releases\n\n * 完整版下载地址：https://github.com/aperezdc/ngx-fancyindex/archive/master.zip\n\n * 我的下载站点下载地址：https://www.youngkbt.cn/download/dark/网站源码/，找到 ngx-fancyindex-0.5.2.tar.xz 进行下载\n\n下载后，放到服务器的某个路径下，然后需要重新编译安装 Nginx，也就是说，你要备份好你之前的配置文件、静态页面目录、日志文件目录。\n\n如果你试过 Nginx 的源码安装，那么一定不陌生 ./configure 来编译，如果不知道如何安装，请看 Nginx - 环境准备。\n\n进入 Nginx 的源码目录，然后执行下方命令：\n\n./configure ...... --add-module=../ngx-fancyindex/\n\nmake && make install\n\n\n1\n2\n3\n\n\n其中 ...... 是其他的模块（插件），../ 代表上一级目录，如果你放的路径没有与 Nginx 的源码处于一个目录，则根据你的路径进行修改。\n\n进入 Nginx 配置文件配置如下内容：\n\nlocation /download{\n    root /usr/local/openresty/nginx/html; # 指定目录所在路径\n    fancyindex on; # 使用fancyindex\n    fancyindex_exact_size off; # 不显示精确大小\n}\n\n\n1\n2\n3\n4\n5\n\n\nroot 指定存放软件的目录，我的是在 /usr/local/openresty/nginx/html 目录里，该目录就是访问我的下载站点看到的根目录\n\n\n\n此时访问 /download，就看看到如下效果\n\n\n\n此时已经实现了这个第三方模块带来的效果。\n\n当然，你会发现这个页面仅仅是我下载站点的红系主题，因为我使用了主题 Nginx-Fancyindex-Theme，这个主题有两种模式，分别为亮系主题和暗系主题，加上红系主题就是三个主题。\n\n下载地址：https://github.com/lanffy/Nginx-Fancyindex-Theme/\n\n不知道如何下载？使用 git clone 指令：\n\ngit clone https://github.com/lanffy/Nginx-Fancyindex-Theme/\n\n\n1\n\n\n下载后，放在 Nginx 的静态页面 html 目录里\n\nmv /opt/Nginx-Fancyindex-Theme /usr/local/nginx/html/\n\n\n1\n\n\n然后在原来的配置文件修改内容：\n\nlocation /download{\n    root /usr/local/openresty/nginx/html; # 指定目录所在路径\n    include /usr/local/nginx/html//Nginx-Fancyindex-Theme/fancyindex.conf; # 主题的配置文件\n}\n\n\n1\n2\n3\n4\n\n\n引用 Nginx-Fancyindex-Theme 里的 fancyindex.conf 配置文件即可实现亮系主题，如果你不喜欢放在 Nginx 的静态页面 html 目录里，那么上方内容也要修改成主题配置文件的路径。\n\n如果想要暗系主题，则修改 fancyindex.conf 的内容，注释掉亮系主题的引入（fancyindex_header 和 fancyindex_footer），加入暗系主题的引用（fancyindex_header 和 fancyindex_footer）。\n\n此时主题已经完全实现，但是你会发现我的下载站点有些不一样，因为我稍微修改了一些内容：\n\n * 三个主题的可切换\n\n * 修改 File Name、File Size、Date\n\n * 修改 Date 的月份英文为中文\n\n * 颜色突出，字体修改\n\n如果你喜欢我的下载站点，这里提供我的源码地址：https://www.youngkbt.cn/download/dark/网站源码/，找到 myNginx-Theme.tar.gz 进行下载。\n\n下载后，解压到静态文件 html 目录下，然后在配置文件填入内容：\n\nlocation /download/light {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header Content-Disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/Nginx-Fancyindex-Theme/light.conf;\n    }\n    \n    location /download/dark {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header Content-Disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/Nginx-Fancyindex-Theme/dark.conf;\n    }\n    \n    location /download/red {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header Content-Disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/Nginx-Fancyindex-Theme/red.conf;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n如果你不喜欢放在 html 目录下，那么上方代码的 include 也要改变成所在路径的配置文件。",normalizedContent:"笔记\n\n首页的下载站点是基于 nginx 提供的，但是 nginx 自带的下载站点不是特别好看，比较「拥挤」，所以本内容介绍我的下载站点如何优化。\n\n2021-12-14 @du wu\n\n\n\n * 介绍\n * 第三方模块\n\n\n\n\n# 介绍\n\n如果还不懂什么是下载站点，请看我的下载站点：https://www.youngkbt.cn/download/。\n\n看了我的下载站点，你会发现和 nginx 自带的样式有些不一样，嗯？nginx 自带的下载站点长啥样？请看 nginx - 站点与认证。\n\n下载站点，就是能够下载东西的网页。其实设计并没有多难，利用第三方模块，就可以实现上方效果。\n\n本下载站点基于 nginx 搭建的，没有 nginx 的支持，本下载站点将会无效。\n\n\n# 第三方模块\n\n首先需要实现 nginx 自带的下载站点，了解这个后方能利用第三方模块进行美化，如果你不了解什么是模块，就认为这叫做插件。\n\n我使用的是 ngx-fancyindex 模块，这里提供下载地址：\n\n * github 地址：https://github.com/aperezdc/ngx-fancyindex\n\n * 版本选择地址：https://github.com/aperezdc/ngx-fancyindex/releases\n\n * 完整版下载地址：https://github.com/aperezdc/ngx-fancyindex/archive/master.zip\n\n * 我的下载站点下载地址：https://www.youngkbt.cn/download/dark/网站源码/，找到 ngx-fancyindex-0.5.2.tar.xz 进行下载\n\n下载后，放到服务器的某个路径下，然后需要重新编译安装 nginx，也就是说，你要备份好你之前的配置文件、静态页面目录、日志文件目录。\n\n如果你试过 nginx 的源码安装，那么一定不陌生 ./configure 来编译，如果不知道如何安装，请看 nginx - 环境准备。\n\n进入 nginx 的源码目录，然后执行下方命令：\n\n./configure ...... --add-module=../ngx-fancyindex/\n\nmake && make install\n\n\n1\n2\n3\n\n\n其中 ...... 是其他的模块（插件），../ 代表上一级目录，如果你放的路径没有与 nginx 的源码处于一个目录，则根据你的路径进行修改。\n\n进入 nginx 配置文件配置如下内容：\n\nlocation /download{\n    root /usr/local/openresty/nginx/html; # 指定目录所在路径\n    fancyindex on; # 使用fancyindex\n    fancyindex_exact_size off; # 不显示精确大小\n}\n\n\n1\n2\n3\n4\n5\n\n\nroot 指定存放软件的目录，我的是在 /usr/local/openresty/nginx/html 目录里，该目录就是访问我的下载站点看到的根目录\n\n\n\n此时访问 /download，就看看到如下效果\n\n\n\n此时已经实现了这个第三方模块带来的效果。\n\n当然，你会发现这个页面仅仅是我下载站点的红系主题，因为我使用了主题 nginx-fancyindex-theme，这个主题有两种模式，分别为亮系主题和暗系主题，加上红系主题就是三个主题。\n\n下载地址：https://github.com/lanffy/nginx-fancyindex-theme/\n\n不知道如何下载？使用 git clone 指令：\n\ngit clone https://github.com/lanffy/nginx-fancyindex-theme/\n\n\n1\n\n\n下载后，放在 nginx 的静态页面 html 目录里\n\nmv /opt/nginx-fancyindex-theme /usr/local/nginx/html/\n\n\n1\n\n\n然后在原来的配置文件修改内容：\n\nlocation /download{\n    root /usr/local/openresty/nginx/html; # 指定目录所在路径\n    include /usr/local/nginx/html//nginx-fancyindex-theme/fancyindex.conf; # 主题的配置文件\n}\n\n\n1\n2\n3\n4\n\n\n引用 nginx-fancyindex-theme 里的 fancyindex.conf 配置文件即可实现亮系主题，如果你不喜欢放在 nginx 的静态页面 html 目录里，那么上方内容也要修改成主题配置文件的路径。\n\n如果想要暗系主题，则修改 fancyindex.conf 的内容，注释掉亮系主题的引入（fancyindex_header 和 fancyindex_footer），加入暗系主题的引用（fancyindex_header 和 fancyindex_footer）。\n\n此时主题已经完全实现，但是你会发现我的下载站点有些不一样，因为我稍微修改了一些内容：\n\n * 三个主题的可切换\n\n * 修改 file name、file size、date\n\n * 修改 date 的月份英文为中文\n\n * 颜色突出，字体修改\n\n如果你喜欢我的下载站点，这里提供我的源码地址：https://www.youngkbt.cn/download/dark/网站源码/，找到 mynginx-theme.tar.gz 进行下载。\n\n下载后，解压到静态文件 html 目录下，然后在配置文件填入内容：\n\nlocation /download/light {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header content-disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/nginx-fancyindex-theme/light.conf;\n    }\n    \n    location /download/dark {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header content-disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/nginx-fancyindex-theme/dark.conf;\n    }\n    \n    location /download/red {\n        alias  /usr/local/openresty/nginx/html/download;\n        # 以这些后缀的文件点击后为下载，注释掉则 txt 等文件是在网页打开并查看内容\n        # if ($request_filename ~* ^.*?\\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx|conf)$){\n        #   add_header content-disposition 'attachment;';\n        # }\n        include /usr/local/openresty/nginx/html/nginx-fancyindex-theme/red.conf;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n如果你不喜欢放在 html 目录下，那么上方代码的 include 也要改变成所在路径的配置文件。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"技巧 - 排版",frontmatter:{title:"技巧 - 排版",date:"2021-11-13T17:19:20.000Z",permalink:"/about/typesetting/",titleTag:"优质",categories:["关于 - 技巧"],tags:["技巧"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/09.%E5%85%B3%E4%BA%8E%20-%20%E6%8A%80%E5%B7%A7/04.%E6%8A%80%E5%B7%A7%20-%20%E6%8E%92%E7%89%88.html",relativePath:"80.关于/09.关于 - 技巧/04.技巧 - 排版.md",key:"v-004ed419",path:"/about/typesetting/",headers:[{level:2,title:"空格",slug:"空格",normalizedTitle:"空格",charIndex:65},{level:3,title:"中英文之间需要增加空格",slug:"中英文之间需要增加空格",normalizedTitle:"中英文之间需要增加空格",charIndex:73},{level:3,title:"中文与数字之间需要增加空格",slug:"中文与数字之间需要增加空格",normalizedTitle:"中文与数字之间需要增加空格",charIndex:90},{level:3,title:"数字与单位之间无需增加空格",slug:"数字与单位之间无需增加空格",normalizedTitle:"数字与单位之间无需增加空格",charIndex:109},{level:3,title:"全角标点与其他字符之间不加空格",slug:"全角标点与其他字符之间不加空格",normalizedTitle:"全角标点与其他字符之间不加空格",charIndex:128},{level:3,title:"-ms-text-autospace to the rescue?",slug:"ms-text-autospace-to-the-rescue",normalizedTitle:"-ms-text-autospace to the rescue?",charIndex:149},{level:2,title:"标点符号",slug:"标点符号",normalizedTitle:"标点符号",charIndex:186},{level:3,title:"不重复使用标点符号",slug:"不重复使用标点符号",normalizedTitle:"不重复使用标点符号",charIndex:196},{level:2,title:"全角和半角",slug:"全角和半角",normalizedTitle:"全角和半角",charIndex:209},{level:3,title:"直角符号",slug:"直角符号",normalizedTitle:"直角符号",charIndex:220},{level:3,title:"使用全角中文标点",slug:"使用全角中文标点",normalizedTitle:"使用全角中文标点",charIndex:230},{level:3,title:"数字使用半角字符",slug:"数字使用半角字符",normalizedTitle:"数字使用半角字符",charIndex:244},{level:3,title:"遇到完整的英文整句、特殊名词，其內容使用半角标点",slug:"遇到完整的英文整句、特殊名词-其內容使用半角标点",normalizedTitle:"遇到完整的英文整句、特殊名词，其內容使用半角标点",charIndex:258},{level:2,title:"名词",slug:"名词",normalizedTitle:"名词",charIndex:270},{level:3,title:"专有名词使用正确的大小写",slug:"专有名词使用正确的大小写",normalizedTitle:"专有名词使用正确的大小写",charIndex:294},{level:3,title:"不要使用不地道的缩写",slug:"不要使用不地道的缩写",normalizedTitle:"不要使用不地道的缩写",charIndex:312},{level:2,title:"争议",slug:"争议",normalizedTitle:"争议",charIndex:326},{level:3,title:"链接之间增加空格",slug:"链接之间增加空格",normalizedTitle:"链接之间增加空格",charIndex:334},{level:3,title:"简体中文使用直角引号",slug:"简体中文使用直角引号",normalizedTitle:"简体中文使用直角引号",charIndex:348},{level:2,title:"自我",slug:"自我",normalizedTitle:"自我",charIndex:362},{level:3,title:"文档命名规范",slug:"文档命名规范",normalizedTitle:"文档命名规范",charIndex:370},{level:3,title:"加粗文字增加空格",slug:"加粗文字增加空格",normalizedTitle:"加粗文字增加空格",charIndex:382},{level:3,title:"加粗文字与标点符号",slug:"加粗文字与标点符号",normalizedTitle:"加粗文字与标点符号",charIndex:396},{level:3,title:"加粗标题使用引号（可选）",slug:"加粗标题使用引号-可选",normalizedTitle:"加粗标题使用引号（可选）",charIndex:411},{level:3,title:"体系化文档开头添加目录",slug:"体系化文档开头添加目录",normalizedTitle:"体系化文档开头添加目录",charIndex:429},{level:3,title:"有序/无序列表末尾不加标点符合",slug:"有序-无序列表末尾不加标点符合",normalizedTitle:"有序/无序列表末尾不加标点符合",charIndex:446},{level:2,title:"格式化工具",slug:"格式化工具",normalizedTitle:"格式化工具",charIndex:465},{level:2,title:"谁在这样做？",slug:"谁在这样做",normalizedTitle:"谁在这样做？",charIndex:474},{level:2,title:"本文转载",slug:"本文转载",normalizedTitle:"本文转载",charIndex:484},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:492}],headersStr:"空格 中英文之间需要增加空格 中文与数字之间需要增加空格 数字与单位之间无需增加空格 全角标点与其他字符之间不加空格 -ms-text-autospace to the rescue? 标点符号 不重复使用标点符号 全角和半角 直角符号 使用全角中文标点 数字使用半角字符 遇到完整的英文整句、特殊名词，其內容使用半角标点 名词 专有名词使用正确的大小写 不要使用不地道的缩写 争议 链接之间增加空格 简体中文使用直角引号 自我 文档命名规范 加粗文字增加空格 加粗文字与标点符号 加粗标题使用引号（可选） 体系化文档开头添加目录 有序/无序列表末尾不加标点符合 格式化工具 谁在这样做？ 本文转载 参考文献",content:'序言\n\n统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质\n\n2021-11-13 @Du Wu\n\n\n\n * 空格\n   * 中英文之间需要增加空格\n   * 中文与数字之间需要增加空格\n   * 数字与单位之间无需增加空格\n   * 全角标点与其他字符之间不加空格\n   * -ms-text-autospace to the rescue?\n * 标点符号\n   * 不重复使用标点符号\n * 全角和半角\n   * 直角符号\n   * 使用全角中文标点\n   * 数字使用半角字符\n   * 遇到完整的英文整句、特殊名词，其內容使用半角标点\n * 名词\n   * 专有名词使用正确的大小写\n   * 不要使用不地道的缩写\n * 争议\n   * 链接之间增加空格\n   * 简体中文使用直角引号\n * 自我\n   * 文档命名规范\n   * 加粗文字增加空格\n   * 加粗文字与标点符号\n   * 加粗标题使用引号（可选）\n   * 体系化文档开头添加目录\n   * 有序/无序列表末尾不加标点符合\n * 格式化工具\n * 谁在这样做？\n * 本文转载\n * 参考文献\n\n\n\n\n# 空格\n\n「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n\n与大家共勉之。\n\n来自—— vinta/paranoid-auto-spacing\n\n\n# 中英文之间需要增加空格\n\n正确：\n\n> 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n\n错误：\n\n> 在LeanCloud上，数据存储是围绕AVObject进行的。\n\n> 在 LeanCloud上，数据存储是围绕AVObject 进行的。\n\n完整的正确用法：\n\n> 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n\n\n# 中文与数字之间需要增加空格\n\n正确：\n\n> 今天出去买菜花了 5000 元。\n\n错误：\n\n> 今天出去买菜花了 5000元。\n\n> 今天出去买菜花了5000元。\n\n\n# 数字与单位之间无需增加空格\n\n正确：\n\n> 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。\n\n错误：\n\n> 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。\n\n另外，度／百分比与数字之间不需要增加空格：\n\n正确：\n\n> 今天是 233° 的高温。\n\n> 新 MacBook Pro 有 15% 的 CPU 性能提升。\n\n错误：\n\n> 今天是 233 ° 的高温。\n\n> 新 MacBook Pro 有 15 % 的 CPU 性能提升。\n\n\n# 全角标点与其他字符之间不加空格\n\n正确：\n\n> 刚刚买了一部 iPhone，好开心！\n\n错误：\n\n> 刚刚买了一部 iPhone ，好开心！\n\n\n# -ms-text-autospace to the rescue?\n\nMicrosoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 OS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n\n\n# 标点符号\n\n\n# 不重复使用标点符号\n\n正确：\n\n> 德国队竟然战胜了巴西队！\n\n> 她竟然对你说「喵」？！\n\n错误：\n\n> 德国队竟然战胜了巴西队！！\n\n> 德国队竟然战胜了巴西队！！！！！！！！\n\n> 她竟然对你说「喵」？？！！\n\n> 她竟然对你说「喵」？！？！？？！！\n\n\n# 全角和半角\n\n不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』或者百度百科词条『全角』和『半角』。\n\n简单介绍：\n\n「全角」指一个字符占用两个标准字符位置的状态，如中文模式下的逗号、句号等：，。？「」\n\n「半角」就是 ASCII 方式的字符，在没有中文输入法起作用的时候输入的字母数字和字符都是半角的，如英文模式下的逗号、句号等: , . ; ? ""\n\n\n# 直角符号\n\n英文单词使用 "" 或者 \'\'；\n\n中文词语使用 「」或者『』，不使用弯角符号 “” 和 ‘’，弯角符号更适用于手写。\n\n其中 "" 对应「」，\'\' 对应『』\n\n\n# 使用全角中文标点\n\n正确：\n\n> 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n\n> 核磁共振成像（NMRI）是什么原理都不知道？JFGI！\n\n错误：\n\n> 嗨! 你知道嘛? 今天前台的小妹跟我说 "喵" 了哎!\n\n> 嗨!你知道嘛?今天前台的小妹跟我说"喵"了哎!\n\n> 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\n\n> 核磁共振成像(NMRI)是什么原理都不知道?JFGI!\n\n\n# 数字使用半角字符\n\n正确：\n\n> 这件蛋糕只卖 1000 元。\n\n错误：\n\n> 这件蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\n\n\n# 遇到完整的英文整句、特殊名词，其內容使用半角标点\n\n正确：\n\n> 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」\n\n> 推荐你阅读《Hackers & Painters: Big Ideas from the Computer Age》，非常的有趣。\n\n错误：\n\n> 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」\n\n> 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。\n\n\n# 名词\n\n\n# 专有名词使用正确的大小写\n\n大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。\n\n正确：\n\n> 使用 GitHub 登录\n\n> 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。\n\n错误：\n\n> 使用 github 登录\n\n> 使用 GITHUB 登录\n\n> 使用 Github 登录\n\n> 使用 gitHub 登录\n\n> 使用 gｲんĤЦ8 登录\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。\n\n> 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。\n\n> 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。\n\n> 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。\n\n\n# 不要使用不地道的缩写\n\n正确：\n\n> 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。\n\n错误：\n\n> 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。\n\n\n# 争议\n\n以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n\n\n# 链接之间增加空格\n\n用法：\n\n> 请 提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n> 请提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请点击这里进行订阅！\n\n\n# 简体中文使用直角引号\n\n用法：\n\n> 「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n> “老师，‘有条不紊’的‘紊’是什么意思？”\n\n\n# 自我\n\n\n# 文档命名规范\n\n正确：\n\n> 关于 - 技巧\n> \n> 笔记 - 技巧\n> \n> 排版 - 技巧\n\n错误：\n\n> 关于技巧\n> \n> 笔记 技巧\n> \n> 排版 ~ 技巧\n\n\n# 加粗文字增加空格\n\n正确：\n\n> 一个好的 排版 彰显好的文档。\n\n错误：\n\n> 一个好的排版彰显好的文档。\n\n\n# 加粗文字与标点符号\n\n加粗的文字如果是最后一行，或者独处一行，那么加粗范围包括标点符号；\n\n加粗的文字如果后面还有文字，则加粗范围不包括标点符号。\n\n正确：\n\n> 欢迎来到我的博客，请慢慢食用。\n\n> 欢迎来到我的博客，请慢慢食用。\n\n错误：\n\n> 欢迎来到我的博客，请慢慢食用。\n> \n> 欢迎来到我的博客， 请慢慢食用。\n\n可能看不太清楚，这里解释一下：\n\n * 错误的例子中，句号在加粗范围外面，逗号在加粗范围里面\n\n * 正确的例子中，句号在加粗范围里面，逗号在加粗范围外面\n\n\n# 加粗标题使用引号（可选）\n\n加粗的字体在手机端显示失效，阅读的效果与普通文字一样，所以加引号既可以在电脑端双重突出，也可以在手机端突出。\n\n这里的引号指的是 Markdown 的引号，即开头添加的 > 符号，特征是左侧有阴影竖条块，如本内容的例子都是通过引号突出。\n\n正确：\n\n> > 什么是 Young\n> \n> Young 代表年轻、朝气、希望、活力 ......\n\n错误：\n\n> 什么是 Young\n> \n> Young 代表年轻、朝气、希望、活力 ......\n\n\n# 体系化文档开头添加目录\n\n生成可以跳转的目录，方便他人阅读和选择。\n\n如 VuePress 可以解析 [[TOC]] 字符串从而生成目录。\n\n\n# 有序/无序列表末尾不加标点符合\n\n因为开头的符号已经代表句号/感叹号/问号了。\n\n正确：\n\n>  * 欢迎来到我的博客\n>  * 希望能入你法眼\n> \n>  1. 酒菜不多，但都是精华。请慢慢食用\n>  2. 文章内容不恰当，可以在评论区留言\n\n错误：\n\n>  * 欢迎来到我的博客。\n>  * 希望能入你法眼。\n> \n>  1. 酒菜不多，但都是精华。请慢慢食用。\n>  2. 文章内容不恰当，可以在评论区留言。\n\n\n# 格式化工具\n\n使用这些工具，可以一次性把需要的文章按照工具的规定进行格式化，类似于杂乱的代码被格式化有序。\n\n仓库                                               语言\nvinta/paranoid-auto-spacing                      JavaScript\nhuei90/pangu.node                                Node.js\nhuacnlee/auto-correct                            Ruby\nsparanoid/space-lover                            PHP (WordPress)\nnauxliu/auto-correct                             PHP\nricoa/copywriting-correct                        PHP\nhotoo/pangu.vim                                  Vim\nsparanoid/grunt-auto-spacing                     Node.js (Grunt)\nhjiang/scripts/add-space-between-latin-and-cjk   Python\n\n\n# 谁在这样做？\n\n网站             文案    UGC\nApple 中国       Yes   N/A\nApple 香港       Yes   N/A\nApple 台湾       Yes   N/A\nMicrosoft 中国   Yes   N/A\nMicrosoft 香港   Yes   N/A\nMicrosoft 台湾   Yes   N/A\nLeanCloud      Yes   N/A\n知乎             Yes   部分用户达成\nV2EX           Yes   Yes\nSegmentFault   Yes   部分用户达成\nApple4us       Yes   N/A\n豌豆荚            Yes   N/A\nRuby China     Yes   标题达成\nPHPHub         Yes   标题达成\n少数派            Yes   N/A\n力扣 LeetCode    Yes   Yes\n\n\n# 本文转载\n\n添加了一些自己的理解\n\n中文文案排版指北\n\n\n# 参考文献\n\n * Guidelines for Using Capital Letters\n * Letter case - Wikipedia\n * Punctuation - Oxford Dictionaries\n * Punctuation - The Purdue OWL\n * How to Use English Punctuation Corrently - wikiHow\n * 格式 - openSUSE\n * 全角和半角 - 维基百科\n * 引号 - 维基百科\n * 疑问惊叹号 - 维基百科\n * 全角 - 百度百科\n * 半角 - 百度百科',normalizedContent:'序言\n\n统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质\n\n2021-11-13 @du wu\n\n\n\n * 空格\n   * 中英文之间需要增加空格\n   * 中文与数字之间需要增加空格\n   * 数字与单位之间无需增加空格\n   * 全角标点与其他字符之间不加空格\n   * -ms-text-autospace to the rescue?\n * 标点符号\n   * 不重复使用标点符号\n * 全角和半角\n   * 直角符号\n   * 使用全角中文标点\n   * 数字使用半角字符\n   * 遇到完整的英文整句、特殊名词，其內容使用半角标点\n * 名词\n   * 专有名词使用正确的大小写\n   * 不要使用不地道的缩写\n * 争议\n   * 链接之间增加空格\n   * 简体中文使用直角引号\n * 自我\n   * 文档命名规范\n   * 加粗文字增加空格\n   * 加粗文字与标点符号\n   * 加粗标题使用引号（可选）\n   * 体系化文档开头添加目录\n   * 有序/无序列表末尾不加标点符合\n * 格式化工具\n * 谁在这样做？\n * 本文转载\n * 参考文献\n\n\n\n\n# 空格\n\n「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n\n与大家共勉之。\n\n来自—— vinta/paranoid-auto-spacing\n\n\n# 中英文之间需要增加空格\n\n正确：\n\n> 在 leancloud 上，数据存储是围绕 avobject 进行的。\n\n错误：\n\n> 在leancloud上，数据存储是围绕avobject进行的。\n\n> 在 leancloud上，数据存储是围绕avobject 进行的。\n\n完整的正确用法：\n\n> 在 leancloud 上，数据存储是围绕 avobject 进行的。每个 avobject 都包含了与 json 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 avobject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣fm」等产品名词，按照官方所定义的格式书写。\n\n\n# 中文与数字之间需要增加空格\n\n正确：\n\n> 今天出去买菜花了 5000 元。\n\n错误：\n\n> 今天出去买菜花了 5000元。\n\n> 今天出去买菜花了5000元。\n\n\n# 数字与单位之间无需增加空格\n\n正确：\n\n> 我家的光纤入户宽带有 10gbps，ssd 一共有 10tb。\n\n错误：\n\n> 我家的光纤入户宽带有 10 gbps，ssd 一共有 20 tb。\n\n另外，度／百分比与数字之间不需要增加空格：\n\n正确：\n\n> 今天是 233° 的高温。\n\n> 新 macbook pro 有 15% 的 cpu 性能提升。\n\n错误：\n\n> 今天是 233 ° 的高温。\n\n> 新 macbook pro 有 15 % 的 cpu 性能提升。\n\n\n# 全角标点与其他字符之间不加空格\n\n正确：\n\n> 刚刚买了一部 iphone，好开心！\n\n错误：\n\n> 刚刚买了一部 iphone ，好开心！\n\n\n# -ms-text-autospace to the rescue?\n\nmicrosoft 有个 -ms-text-autospace 的 css 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 os x、ios 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n\n\n# 标点符号\n\n\n# 不重复使用标点符号\n\n正确：\n\n> 德国队竟然战胜了巴西队！\n\n> 她竟然对你说「喵」？！\n\n错误：\n\n> 德国队竟然战胜了巴西队！！\n\n> 德国队竟然战胜了巴西队！！！！！！！！\n\n> 她竟然对你说「喵」？？！！\n\n> 她竟然对你说「喵」？！？！？？！！\n\n\n# 全角和半角\n\n不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』或者百度百科词条『全角』和『半角』。\n\n简单介绍：\n\n「全角」指一个字符占用两个标准字符位置的状态，如中文模式下的逗号、句号等：，。？「」\n\n「半角」就是 ascii 方式的字符，在没有中文输入法起作用的时候输入的字母数字和字符都是半角的，如英文模式下的逗号、句号等: , . ; ? ""\n\n\n# 直角符号\n\n英文单词使用 "" 或者 \'\'；\n\n中文词语使用 「」或者『』，不使用弯角符号 “” 和 ‘’，弯角符号更适用于手写。\n\n其中 "" 对应「」，\'\' 对应『』\n\n\n# 使用全角中文标点\n\n正确：\n\n> 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n\n> 核磁共振成像（nmri）是什么原理都不知道？jfgi！\n\n错误：\n\n> 嗨! 你知道嘛? 今天前台的小妹跟我说 "喵" 了哎!\n\n> 嗨!你知道嘛?今天前台的小妹跟我说"喵"了哎!\n\n> 核磁共振成像 (nmri) 是什么原理都不知道? jfgi!\n\n> 核磁共振成像(nmri)是什么原理都不知道?jfgi!\n\n\n# 数字使用半角字符\n\n正确：\n\n> 这件蛋糕只卖 1000 元。\n\n错误：\n\n> 这件蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\n\n\n# 遇到完整的英文整句、特殊名词，其內容使用半角标点\n\n正确：\n\n> 乔布斯那句话是怎么说的？「stay hungry, stay foolish.」\n\n> 推荐你阅读《hackers & painters: big ideas from the computer age》，非常的有趣。\n\n错误：\n\n> 乔布斯那句话是怎么说的？「stay hungry，stay foolish。」\n\n> 推荐你阅读《hackers＆painters：big ideas from the computer age》，非常的有趣。\n\n\n# 名词\n\n\n# 专有名词使用正确的大小写\n\n大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。\n\n正确：\n\n> 使用 github 登录\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n错误：\n\n> 使用 github 登录\n\n> 使用 github 登录\n\n> 使用 github 登录\n\n> 使用 github 登录\n\n> 使用 gｲんhц8 登录\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 gｲんhц8、ｷouяƨquﾑгє、๓เςг๏ร๏ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃeв๏๏к, iпᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，html 中请使用标准的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。\n\n\n# 不要使用不地道的缩写\n\n正确：\n\n> 我们需要一位熟悉 javascript、html5，至少理解一种框架（如 backbone.js、angularjs、react 等）的前端开发者。\n\n错误：\n\n> 我们需要一位熟悉 js、h5，至少理解一种框架（如 backbone、angular、rjs 等）的 fed。\n\n\n# 争议\n\n以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n\n\n# 链接之间增加空格\n\n用法：\n\n> 请 提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n> 请提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请点击这里进行订阅！\n\n\n# 简体中文使用直角引号\n\n用法：\n\n> 「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n> “老师，‘有条不紊’的‘紊’是什么意思？”\n\n\n# 自我\n\n\n# 文档命名规范\n\n正确：\n\n> 关于 - 技巧\n> \n> 笔记 - 技巧\n> \n> 排版 - 技巧\n\n错误：\n\n> 关于技巧\n> \n> 笔记 技巧\n> \n> 排版 ~ 技巧\n\n\n# 加粗文字增加空格\n\n正确：\n\n> 一个好的 排版 彰显好的文档。\n\n错误：\n\n> 一个好的排版彰显好的文档。\n\n\n# 加粗文字与标点符号\n\n加粗的文字如果是最后一行，或者独处一行，那么加粗范围包括标点符号；\n\n加粗的文字如果后面还有文字，则加粗范围不包括标点符号。\n\n正确：\n\n> 欢迎来到我的博客，请慢慢食用。\n\n> 欢迎来到我的博客，请慢慢食用。\n\n错误：\n\n> 欢迎来到我的博客，请慢慢食用。\n> \n> 欢迎来到我的博客， 请慢慢食用。\n\n可能看不太清楚，这里解释一下：\n\n * 错误的例子中，句号在加粗范围外面，逗号在加粗范围里面\n\n * 正确的例子中，句号在加粗范围里面，逗号在加粗范围外面\n\n\n# 加粗标题使用引号（可选）\n\n加粗的字体在手机端显示失效，阅读的效果与普通文字一样，所以加引号既可以在电脑端双重突出，也可以在手机端突出。\n\n这里的引号指的是 markdown 的引号，即开头添加的 > 符号，特征是左侧有阴影竖条块，如本内容的例子都是通过引号突出。\n\n正确：\n\n> > 什么是 young\n> \n> young 代表年轻、朝气、希望、活力 ......\n\n错误：\n\n> 什么是 young\n> \n> young 代表年轻、朝气、希望、活力 ......\n\n\n# 体系化文档开头添加目录\n\n生成可以跳转的目录，方便他人阅读和选择。\n\n如 vuepress 可以解析 [[toc]] 字符串从而生成目录。\n\n\n# 有序/无序列表末尾不加标点符合\n\n因为开头的符号已经代表句号/感叹号/问号了。\n\n正确：\n\n>  * 欢迎来到我的博客\n>  * 希望能入你法眼\n> \n>  1. 酒菜不多，但都是精华。请慢慢食用\n>  2. 文章内容不恰当，可以在评论区留言\n\n错误：\n\n>  * 欢迎来到我的博客。\n>  * 希望能入你法眼。\n> \n>  1. 酒菜不多，但都是精华。请慢慢食用。\n>  2. 文章内容不恰当，可以在评论区留言。\n\n\n# 格式化工具\n\n使用这些工具，可以一次性把需要的文章按照工具的规定进行格式化，类似于杂乱的代码被格式化有序。\n\n仓库                                               语言\nvinta/paranoid-auto-spacing                      javascript\nhuei90/pangu.node                                node.js\nhuacnlee/auto-correct                            ruby\nsparanoid/space-lover                            php (wordpress)\nnauxliu/auto-correct                             php\nricoa/copywriting-correct                        php\nhotoo/pangu.vim                                  vim\nsparanoid/grunt-auto-spacing                     node.js (grunt)\nhjiang/scripts/add-space-between-latin-and-cjk   python\n\n\n# 谁在这样做？\n\n网站             文案    ugc\napple 中国       yes   n/a\napple 香港       yes   n/a\napple 台湾       yes   n/a\nmicrosoft 中国   yes   n/a\nmicrosoft 香港   yes   n/a\nmicrosoft 台湾   yes   n/a\nleancloud      yes   n/a\n知乎             yes   部分用户达成\nv2ex           yes   yes\nsegmentfault   yes   部分用户达成\napple4us       yes   n/a\n豌豆荚            yes   n/a\nruby china     yes   标题达成\nphphub         yes   标题达成\n少数派            yes   n/a\n力扣 leetcode    yes   yes\n\n\n# 本文转载\n\n添加了一些自己的理解\n\n中文文案排版指北\n\n\n# 参考文献\n\n * guidelines for using capital letters\n * letter case - wikipedia\n * punctuation - oxford dictionaries\n * punctuation - the purdue owl\n * how to use english punctuation corrently - wikihow\n * 格式 - opensuse\n * 全角和半角 - 维基百科\n * 引号 - 维基百科\n * 疑问惊叹号 - 维基百科\n * 全角 - 百度百科\n * 半角 - 百度百科',charsets:{cyrillic:!0,cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"随笔 - 目录",frontmatter:{title:"随笔 - 目录",date:"2022-01-09T23:35:16.000Z",permalink:"/posts/category/",sidebar:!1,article:!1,comment:!1,editLink:!1,categories:[null],tags:[null],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/12.%E5%85%B3%E4%BA%8E%20-%20%E9%9A%8F%E7%AC%94/01.%E9%9A%8F%E7%AC%94%20-%20%E7%9B%AE%E5%BD%95.html",relativePath:"80.关于/12.关于 - 随笔/01.随笔 - 目录.md",key:"v-c0cdc776",path:"/posts/category/",headersStr:null,content:"随笔目前有两大类：\n\n技术随笔目录\n\n生活随笔目录",normalizedContent:"随笔目前有两大类：\n\n技术随笔目录\n\n生活随笔目录",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"技巧 - 笔记",frontmatter:{title:"技巧 - 笔记",date:"2021-10-28T18:21:33.000Z",permalink:"/about/mdskill/",titleTag:"优质",categories:["关于 - 技巧"],tags:["技巧"],readingShow:"top"},regularPath:"/80.%E5%85%B3%E4%BA%8E/09.%E5%85%B3%E4%BA%8E%20-%20%E6%8A%80%E5%B7%A7/02.%E6%8A%80%E5%B7%A7%20-%20%E7%AC%94%E8%AE%B0.html",relativePath:"80.关于/09.关于 - 技巧/02.技巧 - 笔记.md",key:"v-0843e2a1",path:"/about/mdskill/",headers:[{level:2,title:"使用 emoji 表情",slug:"使用-emoji-表情",normalizedTitle:"使用 emoji 表情",charIndex:85},{level:2,title:"外部链接",slug:"外部链接",normalizedTitle:"外部链接",charIndex:100},{level:2,title:"文本高亮",slug:"文本高亮",normalizedTitle:"文本高亮",charIndex:108},{level:2,title:"代码高亮",slug:"代码高亮",normalizedTitle:"代码高亮",charIndex:116},{level:2,title:"徽章",slug:"徽章",normalizedTitle:"徽章",charIndex:124},{level:3,title:"内置",slug:"内置",normalizedTitle:"内置",charIndex:132},{level:4,title:"《沁园春·雪》",slug:"《沁园春·雪》",normalizedTitle:"《沁园春·雪》",charIndex:1808},{level:3,title:"外置",slug:"外置",normalizedTitle:"外置",charIndex:140},{level:2,title:"信息框容器",slug:"信息框容器",normalizedTitle:"信息框容器",charIndex:146},{level:2,title:"布局容器",slug:"布局容器",normalizedTitle:"布局容器",charIndex:155},{level:3,title:"我是居中的内容",slug:"我是居中的内容",normalizedTitle:"我是居中的内容",charIndex:165},{level:2,title:"代码块选项卡",slug:"代码块选项卡",normalizedTitle:"代码块选项卡",charIndex:176},{level:2,title:"普通卡片列表",slug:"普通卡片列表",normalizedTitle:"普通卡片列表",charIndex:186},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:198},{level:2,title:"图文卡片列表",slug:"图文卡片列表",normalizedTitle:"图文卡片列表",charIndex:204},{level:3,title:"语法",slug:"语法-2",normalizedTitle:"语法",charIndex:198},{level:2,title:"Tabs插件",slug:"tabs插件",normalizedTitle:"tabs插件",charIndex:222},{level:2,title:"Demo插件（因为兼容问题，目前已经不使用）",slug:"demo插件-因为兼容问题-目前已经不使用",normalizedTitle:"demo插件（因为兼容问题，目前已经不使用）",charIndex:232}],excerpt:'<div class="custom-block note"><p class="custom-block-title">笔记</p>\n<p>如果想拥有更多丰富的笔记表现力，让自己阅读时，不处于大片黑白的世界里，本内容会让你的笔记句句深入记忆的深处😸</p>\n<div class="custom-block right">\n<p>2021-10-28 @Du Wu</p>\n</div>\n</div>\n',headersStr:"使用 emoji 表情 外部链接 文本高亮 代码高亮 徽章 内置 《沁园春·雪》 外置 信息框容器 布局容器 我是居中的内容 代码块选项卡 普通卡片列表 语法 图文卡片列表 语法 Tabs插件 Demo插件（因为兼容问题，目前已经不使用）",content:"笔记\n\n如果想拥有更多丰富的笔记表现力，让自己阅读时，不处于大片黑白的世界里，本内容会让你的笔记句句深入记忆的深处😸\n\n2021-10-28 @Du Wu\n\n\n\n * 使用 emoji 表情\n * 外部链接\n * 文本高亮\n * 代码高亮\n * 徽章\n   * 内置\n   * 外置\n * 信息框容器\n * 布局容器\n   * 我是居中的内容\n * 代码块选项卡\n * 普通卡片列表\n   * 语法\n * 图文卡片列表\n   * 语法\n * Tabs插件\n * Demo插件（因为兼容问题，目前已经不使用）\n\n\n\n笔记\n\n本内容来自 VuePress官网 和 vdoing主题官网，有部分是自己总结的。\n\n信息框容器后的内容，基本都是 vdoing主题 带有的。\n\n2021-10-28 @Du Wu\n\n\n# 使用 emoji 表情\n\n阅读大片大片的文字难免产生视觉疲劳，而使用 emoji 表情，不仅缓解精神的渐眠，也会胜过千言。\n\n在 markdown 里，使用 :表情: 输入表情，如\n\n你好:smile:，我喜欢:dog:，我小时候经常拿:100:分哦~~~，欢迎来到我的博客:heart:，一起学习吧:muscle:\n\n\n1\n\n\n效果如下：\n\n> 你好😄，我喜欢🐶，我小时候经常拿💯分哦~~~，欢迎来到我的博客❤️，一起学习吧💪\n\n很多指令肯定是记不了的，我们可以也可以去特定的网站获取表情的格式。也可以 copy 一个表情过来，markdown 自动解析表情。\n\n分享一些 emoji 网站：\n\n * emoji 表情备忘录：有很多表情的格式(:表情:)\n * emoji 表情：有很多表情可以copy\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows 系统下按 Win + . 快速打开表情选择框（不是右侧小键盘的 .）\n\n\n# 外部链接\n\n使用外部链接，文字会变色，并且可以点击跳转，格式如下：\n\n[VuePress官网](https://vuepress.vuejs.org/zh/)\n\n\n1\n\n\n效果：\n\nVuePress官网\n\n\n# 文本高亮\n\n使用 <mark> 标签或者 `` 让文本高亮。\n\n<mark> 标签我经常用于文字的突出，如果是一段字符串，我是用的是 `` 包裹起来。\n\n`Vdoing` 是一款简洁高效的 <mark>知识管理&博客</mark> 主题\n\n\n1\n\n\nVdoing 是一款简洁高效的 知识管理&博客 主题\n\n\n# 代码高亮\n\n突出代码块的某些行，使用 {行数-行数}、{行数,行数} 格式，如\n\n输入：\n\n``` js {2,5-7,13}\nreturn {\n      // 数据\n      options,\n      activeKey,\n      sourceLabels,\n      sourceForm,\n      addForm,\n      addRules,\n      sourceRules,\n      // 函数\n      displayRender,\n      submitProdoce,\n      onAddClose,\n    };\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n输出：\n\n\n\n \n\n\n \n \n \n\n\n\n\n\n \n\n\n\nreturn {\n      // 数据\n      options,\n      activeKey,\n      sourceLabels,\n      sourceForm,\n      addForm,\n      addRules,\n      sourceRules,\n      // 函数\n      displayRender,\n      submitProdoce,\n      onAddClose,\n    };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 行数区间: 例如 {5-8}, {3-10}, {10-17}\n * 多个单行: 例如 {4,7,9}\n * 行数区间与多个单行: 例如 {4,7-13,16,23-27,40}\n\n\n# 徽章\n\n\n# 内置\n\n官方自带。详细使用可前往官网 Badge。\n\n#### 《沁园春·雪》 <Badge text=\"摘\"/>\n北国风光<Badge text=\"注释\" type=\"warning\"/>，千里冰封，万里雪飘。\n\n> <Badge text=\"译文\" type=\"error\" vertical=\"middle\"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n * type 有三个参数：tip、warning、error。默认是 tip\n\n * vertical 有两个参数：top、middle。默认是 top\n\n直接在 markdown 文件使用，效果如下：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\n\n# 外置\n\n如果想用更多的自定义徽章，可使用 Shields来生成\n\n![stars](https://img.shields.io/github/stars/Kele-Bingtang/notes-blog)\n![stars](https://img.shields.io/github/stars/Kele-Bingtang/notes-blog?style=social)\n![kbt](https://img.shields.io/badge/kbt-冰糖-green)\n\n\n1\n2\n3\n\n\n\n\n如果没接触过 Shields，Shields 教程传送门\n\n\n# 信息框容器\n\n以下一些内容是 Vdoing 主题提供，并非官方提供。\n\n输入：\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，主题自带，官方没有\n:::\n\n::: tip 我的自定义标题\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n输出：\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，主题自带，官方没有\n\n我的自定义标题\n\n自定义标题的提示框\n\n如果想要折叠的容器，如下：也可以自定义标题\n\n::: details\n这是一个详情块，在 IE / Edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n\n点击查看\n\n这是一个详情块，在 IE / Edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n\n# 布局容器\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png)\n:::\n\n::: theorem VuePress\nVue 驱动的静态网站生成器\n::: right\n来自 [官网](https://vuepress.vuejs.org/zh/)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\nVuePress\n\nVue 驱动的静态网站生成器\n\n来自 VuePress官网\n\n提示\n\n没有 left 和 top、bottom\n\n\n# 代码块选项卡\n\n在 <code-group> 中嵌套 <code-block> 来配合使用。在 <code-block> 标签添加 title 来指定 tab 标题，active 指定当前 tab：\n\n<code-group>\n  <code-block title=\"YARN\" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -D\n  ```\n  </code-block>\n\n  <code-block title=\"NPM\">\n  ```bash\n  npm install vuepress-theme-vdoing -D\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n效果：\n\nyarn add vuepress-theme-vdoing -D\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -D\n\n\n1\n\n\n注意\n\n请在 <code-group> 标签与 markdown 内容之间使用空行隔开，否则可能会解析不出来。\n\n提示\n\nVdoing 解释该组件仅适用于放置代码块，放其他内容在体验上并不友好。经过测试，我放入文字也是可以的。\n\n而且 <code-block> 放在 <code-group> 里时，首行需要缩进两个空格，经过测试，四个空格出问题。\n\n如果你喜欢 ::: tabs 代替 <code-group>，那么我们可以下载 vuepress-plugin-tabs 插件。点击跳到 Tabs 插件安装。\n\n\n# 普通卡片列表\n\n如果想使用 友链 功能，但是 vdoing 主题并没有直接在首页实现该功能，要么使用 卡片列表，要么自己手动实现html。而 卡片列表 目前只能使用在 markdown 文档里，下方介绍。\n\n普通卡片列表容器，可用于 友情链接、项目推荐、诗词展示 等。\n\n输入：\n\n::: cardList\n```yaml\n- name: George Chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4oKMVI.jpg\n  link: https://cyc0819.top/\n  bgColor: '#FFB6C1' # 可选，默认 var(--bodyBg)。颜色值有 # 号时请添加单引号\n  textColor: '#621529' # 可选，默认 var(--textColor)\n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgColor: '#CBEAFA' \n  textColor: '#6854A1' \n  \n- name: Evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n输出：\n\nGeorge Chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nEvan's blog\n\n前端的小学生\n\n- name: George Chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4oKMVI.jpg\n  link: https://cyc0819.top/\n  bgColor: '#FFB6C1' # 可选，默认 var(--bodyBg)。颜色值有 # 号时请添加单引号\n  textColor: '#621529' # 可选，默认 var(--textColor)\n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgColor: '#CBEAFA' \n  textColor: '#6854A1' \n  \n- name: Evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 语法\n\n::: cardList <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgColor: '#CBEAFA' # 背景色，可选，默认var(--bodyBg)。颜色值有#号时请添加引号\n  textColor: '#6854A1' # 文本色，可选，默认var(--textColor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * <每行显示数量>：一行内显示多少个卡片，值范围 1~4，默认是 3 个，上方的卡片正好是三个，如果再多一个卡片，就会被换到下一行\n\n * 代码块需指定语言为 yaml\n\n * 代码块内是一个 yaml 格式的数组列表\n\n * 数组成员的属性有：\n   \n   * name：名称\n   * desc：描述\n   * avatar：头像，可选\n   * link：链接，可选\n   * bgColor：背景色，可选，默认 var(--bodyBg)。颜色值有 # 号时请添加引号\n   * textColor：文本色，可选，默认 var(--textColor)\n\n不指定颜色，默认为白色，如下演示：\n\n::: cardList 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n  \n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nVdoing\n\n🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  \n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 图文卡片列表\n\n图文卡片列表容器，可用于 项目展示、产品展示 等。\n\n先看效果：\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nYoung Kbt\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nYoung Kbt\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nYoung Kbt\n\n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Young Kbt # 作者，可选\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png # 头像，可选\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Young Kbt\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Young Kbt\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n::: cardImgList\n```yaml\n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Young Kbt # 作者，可选\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png # 头像，可选\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Young Kbt\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Young Kbt\n  avatar: https://cdn.staticaly.com/gh/Kele-Bingtang/static@master/user/avatar2.png\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 语法\n\n::: cardImgList <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围 1~4，默认 3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为 yaml\n * 代码块内是一个 yaml 格式的数组列表\n * 数组成员的属性有：\n   * img：图片地址\n   * link：链接地址\n   * name：标题\n   * desc：描述，可选\n   * author：作者名称，可选\n   * avatar：作者头像，可选\n\n\n# Tabs插件\n\n官网：https://github.com/pskordilakis/vuepress-plugin-tabs\n\n安装插件：\n\nyarn add vuepress-plugin-tabs vue-tabs-component\n\n\n1\n\n\nnpm install vuepress-plugin-tabs vue-tabs-component\n\n\n1\n\n\n在 .vuepress/styles/index.styl 添加如下内容：\n\n@require '~vuepress-plugin-tabs/dist/themes/default.styl'\n\n\n1\n\n\n在 .vuepress/config.js 中添加如下内容：\n\nmodule.exports = {\n  plugins: [ 'tabs' ]\n}\n\n\n1\n2\n3\n\n\n启动项目，下面是使用的 demo。\n\n:::: tabs cache-lifetime=\"5\" :options=\"{ useUrlFragment: false }\"\n::: tab title \n**markdown content**\n:::\n::: tab javascript \n``` javascript\n() => {\n  console.log('Javascript code example')\n}\n```\n:::\n::::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ncache-lifetime 是存活时间，默认 5 分钟，即关闭网页五分钟内回来，当时选中的哪个 tabs，就会显示该内容，5 分钟后默认回到到第一个 tabs。\n\n:options=\"{ useUrlFragment: false }\" 建议写上，不然每次点击任意 tabs，都会刷新一次当前页面，没有必要。\n\n效果：\n\nmarkdown content\n\n() => {\n  console.log('Javascript code example')\n}\n\n\n1\n2\n3\n\n\n\n# Demo插件（因为兼容问题，目前已经不使用）\n\n为了更直观的展示一些代码的效果，博客添加了 demo 模块插件，可查看 demo、源码，以及跳转到 codepen 在线编辑。目前支持 vue、react 或 native js 示例。 demo 目前支持 [vanilla] 、[React]、[Vue]，如果不填写 []，默认是 [vue]。\n\n插件官网：https://github.com/xiguaxigua/vuepress-plugin-demo-block/\n\n演示代码：\n\n\x3c!-- Vue 的 demo --\x3e\n::: demo\n```html\n<template>\n  <div class=\"box-vue\">Vue {{ message }}</div>\n</template>\n<script>\nexport default {\n  data: () => ({ message: 'Hello World' })\n}\n<\/script>\n<style>\n.box-vue { color: red; }\n</style>\n```\n:::\n\n\x3c!-- React 的 demo --\x3e\n::: demo [react]\n```js\nexport default class App extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = { message: 'Hello World' }\n  }\n  render () {\n    return (\n      <div className=\"box-react\">\n        React {this.state.message}\n      </div>\n    )\n  }\n}\nApp.__style__ = `\n  .box-react { color: red; }   \n`\n```\n:::\n\n\x3c!-- vanilla 的 demo --\x3e\n::: demo [vanilla]\n```html\n<html>\n  <div id=\"vanilla-box\"></div>\n</html>\n<script>\n  var box = document.getElementById('vanilla-box')\n  box.innerHTML = 'Hello World! Welcome to EB'\n<\/script>\n<style>\n#vanilla-box {\n  color: #11a8cd;   /* 标题颜色 */\n}\n</style>\n\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n输出结果：\n\n::: demo\n\n<template>\n  <div class=\"box-vue\">Vue {{ message }}</div>\n</template>\n<script>\nexport default {\n  data: () => ({ message: 'Hello World' })\n}\n<\/script>\n<style>\n.box-vue { color: red; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n:::\n\n::: demo [react]\n\nexport default class App extends React.Component {\n  constructor (props) {\n    super(props)\n    this.state = { message: 'Hello World' }\n  }\n  render () {\n    return (\n      <div className=\"box-react\">\n        React {this.state.message}\n      </div>\n    )\n  }\n}\nApp.__style__ = `\n  .box-react { color: #621529; }\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n:::\n\n::: demo [vanilla]\n\n<html>\n  <div id=\"vanilla-box\"></div>\n</html>\n<script>\n  var box = document.getElementById('vanilla-box')\n  box.innerHTML = 'Hello World! Welcome to EB'\n<\/script>\n<style>\n#vanilla-box {\n  color: #11a8cd;   /* 标题颜色 */\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n:::",normalizedContent:"笔记\n\n如果想拥有更多丰富的笔记表现力，让自己阅读时，不处于大片黑白的世界里，本内容会让你的笔记句句深入记忆的深处😸\n\n2021-10-28 @du wu\n\n\n\n * 使用 emoji 表情\n * 外部链接\n * 文本高亮\n * 代码高亮\n * 徽章\n   * 内置\n   * 外置\n * 信息框容器\n * 布局容器\n   * 我是居中的内容\n * 代码块选项卡\n * 普通卡片列表\n   * 语法\n * 图文卡片列表\n   * 语法\n * tabs插件\n * demo插件（因为兼容问题，目前已经不使用）\n\n\n\n笔记\n\n本内容来自 vuepress官网 和 vdoing主题官网，有部分是自己总结的。\n\n信息框容器后的内容，基本都是 vdoing主题 带有的。\n\n2021-10-28 @du wu\n\n\n# 使用 emoji 表情\n\n阅读大片大片的文字难免产生视觉疲劳，而使用 emoji 表情，不仅缓解精神的渐眠，也会胜过千言。\n\n在 markdown 里，使用 :表情: 输入表情，如\n\n你好:smile:，我喜欢:dog:，我小时候经常拿:100:分哦~~~，欢迎来到我的博客:heart:，一起学习吧:muscle:\n\n\n1\n\n\n效果如下：\n\n> 你好😄，我喜欢🐶，我小时候经常拿💯分哦~~~，欢迎来到我的博客❤️，一起学习吧💪\n\n很多指令肯定是记不了的，我们可以也可以去特定的网站获取表情的格式。也可以 copy 一个表情过来，markdown 自动解析表情。\n\n分享一些 emoji 网站：\n\n * emoji 表情备忘录：有很多表情的格式(:表情:)\n * emoji 表情：有很多表情可以copy\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> windows 系统下按 win + . 快速打开表情选择框（不是右侧小键盘的 .）\n\n\n# 外部链接\n\n使用外部链接，文字会变色，并且可以点击跳转，格式如下：\n\n[vuepress官网](https://vuepress.vuejs.org/zh/)\n\n\n1\n\n\n效果：\n\nvuepress官网\n\n\n# 文本高亮\n\n使用 <mark> 标签或者 `` 让文本高亮。\n\n<mark> 标签我经常用于文字的突出，如果是一段字符串，我是用的是 `` 包裹起来。\n\n`vdoing` 是一款简洁高效的 <mark>知识管理&博客</mark> 主题\n\n\n1\n\n\nvdoing 是一款简洁高效的 知识管理&博客 主题\n\n\n# 代码高亮\n\n突出代码块的某些行，使用 {行数-行数}、{行数,行数} 格式，如\n\n输入：\n\n``` js {2,5-7,13}\nreturn {\n      // 数据\n      options,\n      activekey,\n      sourcelabels,\n      sourceform,\n      addform,\n      addrules,\n      sourcerules,\n      // 函数\n      displayrender,\n      submitprodoce,\n      onaddclose,\n    };\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n输出：\n\n\n\n \n\n\n \n \n \n\n\n\n\n\n \n\n\n\nreturn {\n      // 数据\n      options,\n      activekey,\n      sourcelabels,\n      sourceform,\n      addform,\n      addrules,\n      sourcerules,\n      // 函数\n      displayrender,\n      submitprodoce,\n      onaddclose,\n    };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n * 行数区间: 例如 {5-8}, {3-10}, {10-17}\n * 多个单行: 例如 {4,7,9}\n * 行数区间与多个单行: 例如 {4,7-13,16,23-27,40}\n\n\n# 徽章\n\n\n# 内置\n\n官方自带。详细使用可前往官网 badge。\n\n#### 《沁园春·雪》 <badge text=\"摘\"/>\n北国风光<badge text=\"注释\" type=\"warning\"/>，千里冰封，万里雪飘。\n\n> <badge text=\"译文\" type=\"error\" vertical=\"middle\"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n * type 有三个参数：tip、warning、error。默认是 tip\n\n * vertical 有两个参数：top、middle。默认是 top\n\n直接在 markdown 文件使用，效果如下：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\n\n# 外置\n\n如果想用更多的自定义徽章，可使用 shields来生成\n\n![stars](https://img.shields.io/github/stars/kele-bingtang/notes-blog)\n![stars](https://img.shields.io/github/stars/kele-bingtang/notes-blog?style=social)\n![kbt](https://img.shields.io/badge/kbt-冰糖-green)\n\n\n1\n2\n3\n\n\n\n\n如果没接触过 shields，shields 教程传送门\n\n\n# 信息框容器\n\n以下一些内容是 vdoing 主题提供，并非官方提供。\n\n输入：\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，主题自带，官方没有\n:::\n\n::: tip 我的自定义标题\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n输出：\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，主题自带，官方没有\n\n我的自定义标题\n\n自定义标题的提示框\n\n如果想要折叠的容器，如下：也可以自定义标题\n\n::: details\n这是一个详情块，在 ie / edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n\n点击查看\n\n这是一个详情块，在 ie / edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n\n# 布局容器\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png)\n:::\n\n::: theorem vuepress\nvue 驱动的静态网站生成器\n::: right\n来自 [官网](https://vuepress.vuejs.org/zh/)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\nvuepress\n\nvue 驱动的静态网站生成器\n\n来自 vuepress官网\n\n提示\n\n没有 left 和 top、bottom\n\n\n# 代码块选项卡\n\n在 <code-group> 中嵌套 <code-block> 来配合使用。在 <code-block> 标签添加 title 来指定 tab 标题，active 指定当前 tab：\n\n<code-group>\n  <code-block title=\"yarn\" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -d\n  ```\n  </code-block>\n\n  <code-block title=\"npm\">\n  ```bash\n  npm install vuepress-theme-vdoing -d\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n效果：\n\nyarn add vuepress-theme-vdoing -d\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -d\n\n\n1\n\n\n注意\n\n请在 <code-group> 标签与 markdown 内容之间使用空行隔开，否则可能会解析不出来。\n\n提示\n\nvdoing 解释该组件仅适用于放置代码块，放其他内容在体验上并不友好。经过测试，我放入文字也是可以的。\n\n而且 <code-block> 放在 <code-group> 里时，首行需要缩进两个空格，经过测试，四个空格出问题。\n\n如果你喜欢 ::: tabs 代替 <code-group>，那么我们可以下载 vuepress-plugin-tabs 插件。点击跳到 tabs 插件安装。\n\n\n# 普通卡片列表\n\n如果想使用 友链 功能，但是 vdoing 主题并没有直接在首页实现该功能，要么使用 卡片列表，要么自己手动实现html。而 卡片列表 目前只能使用在 markdown 文档里，下方介绍。\n\n普通卡片列表容器，可用于 友情链接、项目推荐、诗词展示 等。\n\n输入：\n\n::: cardlist\n```yaml\n- name: george chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4okmvi.jpg\n  link: https://cyc0819.top/\n  bgcolor: '#ffb6c1' # 可选，默认 var(--bodybg)。颜色值有 # 号时请添加单引号\n  textcolor: '#621529' # 可选，默认 var(--textcolor)\n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgcolor: '#cbeafa' \n  textcolor: '#6854a1' \n  \n- name: evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n输出：\n\ngeorge chan\n\n让我给你讲讲他的传奇故事吧\n\nbutcher2000\n\n即使再小的帆，也能远航\n\nevan's blog\n\n前端的小学生\n\n- name: george chan\n  desc: 让我给你讲讲他的传奇故事吧\n  avatar: https://z3.ax1x.com/2021/09/30/4okmvi.jpg\n  link: https://cyc0819.top/\n  bgcolor: '#ffb6c1' # 可选，默认 var(--bodybg)。颜色值有 # 号时请添加单引号\n  textcolor: '#621529' # 可选，默认 var(--textcolor)\n  \n- name: butcher2000\n  desc: 即使再小的帆，也能远航\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/20211029181901.png\n  link: https://blog.csdn.net/weixin_46827107\n  bgcolor: '#cbeafa' \n  textcolor: '#6854a1' \n  \n- name: evan's blog\n  desc: 前端的小学生\n  avatar: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200103123203.jpg\n  link: https://xugaoyi.com/\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 语法\n\n::: cardlist <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgcolor: '#cbeafa' # 背景色，可选，默认var(--bodybg)。颜色值有#号时请添加引号\n  textcolor: '#6854a1' # 文本色，可选，默认var(--textcolor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * <每行显示数量>：一行内显示多少个卡片，值范围 1~4，默认是 3 个，上方的卡片正好是三个，如果再多一个卡片，就会被换到下一行\n\n * 代码块需指定语言为 yaml\n\n * 代码块内是一个 yaml 格式的数组列表\n\n * 数组成员的属性有：\n   \n   * name：名称\n   * desc：描述\n   * avatar：头像，可选\n   * link：链接，可选\n   * bgcolor：背景色，可选，默认 var(--bodybg)。颜色值有 # 号时请添加引号\n   * textcolor：文本色，可选，默认 var(--textcolor)\n\n不指定颜色，默认为白色，如下演示：\n\n::: cardlist 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n  \n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nvdoing\n\n🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  \n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 图文卡片列表\n\n图文卡片列表容器，可用于 项目展示、产品展示 等。\n\n先看效果：\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nyoung kbt\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nyoung kbt\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nyoung kbt\n\n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: young kbt # 作者，可选\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png # 头像，可选\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: young kbt\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: young kbt\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n::: cardimglist\n```yaml\n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: young kbt # 作者，可选\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png # 头像，可选\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: young kbt\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png\n  \n- img: https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: young kbt\n  avatar: https://cdn.staticaly.com/gh/kele-bingtang/static@master/user/avatar2.png\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 语法\n\n::: cardimglist <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围 1~4，默认 3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为 yaml\n * 代码块内是一个 yaml 格式的数组列表\n * 数组成员的属性有：\n   * img：图片地址\n   * link：链接地址\n   * name：标题\n   * desc：描述，可选\n   * author：作者名称，可选\n   * avatar：作者头像，可选\n\n\n# tabs插件\n\n官网：https://github.com/pskordilakis/vuepress-plugin-tabs\n\n安装插件：\n\nyarn add vuepress-plugin-tabs vue-tabs-component\n\n\n1\n\n\nnpm install vuepress-plugin-tabs vue-tabs-component\n\n\n1\n\n\n在 .vuepress/styles/index.styl 添加如下内容：\n\n@require '~vuepress-plugin-tabs/dist/themes/default.styl'\n\n\n1\n\n\n在 .vuepress/config.js 中添加如下内容：\n\nmodule.exports = {\n  plugins: [ 'tabs' ]\n}\n\n\n1\n2\n3\n\n\n启动项目，下面是使用的 demo。\n\n:::: tabs cache-lifetime=\"5\" :options=\"{ useurlfragment: false }\"\n::: tab title \n**markdown content**\n:::\n::: tab javascript \n``` javascript\n() => {\n  console.log('javascript code example')\n}\n```\n:::\n::::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ncache-lifetime 是存活时间，默认 5 分钟，即关闭网页五分钟内回来，当时选中的哪个 tabs，就会显示该内容，5 分钟后默认回到到第一个 tabs。\n\n:options=\"{ useurlfragment: false }\" 建议写上，不然每次点击任意 tabs，都会刷新一次当前页面，没有必要。\n\n效果：\n\nmarkdown content\n\n() => {\n  console.log('javascript code example')\n}\n\n\n1\n2\n3\n\n\n\n# demo插件（因为兼容问题，目前已经不使用）\n\n为了更直观的展示一些代码的效果，博客添加了 demo 模块插件，可查看 demo、源码，以及跳转到 codepen 在线编辑。目前支持 vue、react 或 native js 示例。 demo 目前支持 [vanilla] 、[react]、[vue]，如果不填写 []，默认是 [vue]。\n\n插件官网：https://github.com/xiguaxigua/vuepress-plugin-demo-block/\n\n演示代码：\n\n\x3c!-- vue 的 demo --\x3e\n::: demo\n```html\n<template>\n  <div class=\"box-vue\">vue {{ message }}</div>\n</template>\n<script>\nexport default {\n  data: () => ({ message: 'hello world' })\n}\n<\/script>\n<style>\n.box-vue { color: red; }\n</style>\n```\n:::\n\n\x3c!-- react 的 demo --\x3e\n::: demo [react]\n```js\nexport default class app extends react.component {\n  constructor (props) {\n    super(props)\n    this.state = { message: 'hello world' }\n  }\n  render () {\n    return (\n      <div classname=\"box-react\">\n        react {this.state.message}\n      </div>\n    )\n  }\n}\napp.__style__ = `\n  .box-react { color: red; }   \n`\n```\n:::\n\n\x3c!-- vanilla 的 demo --\x3e\n::: demo [vanilla]\n```html\n<html>\n  <div id=\"vanilla-box\"></div>\n</html>\n<script>\n  var box = document.getelementbyid('vanilla-box')\n  box.innerhtml = 'hello world! welcome to eb'\n<\/script>\n<style>\n#vanilla-box {\n  color: #11a8cd;   /* 标题颜色 */\n}\n</style>\n\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n输出结果：\n\n::: demo\n\n<template>\n  <div class=\"box-vue\">vue {{ message }}</div>\n</template>\n<script>\nexport default {\n  data: () => ({ message: 'hello world' })\n}\n<\/script>\n<style>\n.box-vue { color: red; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n:::\n\n::: demo [react]\n\nexport default class app extends react.component {\n  constructor (props) {\n    super(props)\n    this.state = { message: 'hello world' }\n  }\n  render () {\n    return (\n      <div classname=\"box-react\">\n        react {this.state.message}\n      </div>\n    )\n  }\n}\napp.__style__ = `\n  .box-react { color: #621529; }\n`\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n:::\n\n::: demo [vanilla]\n\n<html>\n  <div id=\"vanilla-box\"></div>\n</html>\n<script>\n  var box = document.getelementbyid('vanilla-box')\n  box.innerhtml = 'hello world! welcome to eb'\n<\/script>\n<style>\n#vanilla-box {\n  color: #11a8cd;   /* 标题颜色 */\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n:::",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"全局私密文章测试",frontmatter:{title:"全局私密文章测试",date:"2022-01-07T17:00:36.000Z",permalink:"/private/test1/",private:!0,titleTag:"测试",categories:["测试"],tags:[null],readingShow:"top"},regularPath:"/90.%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/01.%E5%85%A8%E5%B1%80%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html",relativePath:"90.私密文章测试/01.全局私密文章测试.md",key:"v-211f711c",path:"/private/test1/",headersStr:null,content:"恭喜您，访问成功！！！\n\n全局的私密文章仅需要在 frontmatter 额外 添加如下信息：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n此时在 themeConfig 里的管理员用户名和密码或者 loginInfo 里的用户名和密码生效。\n\n如果您想单独给一个文章设为私密，则请访问 单个私密文章测试\n\n本文章的全部 frontmatter 内容：\n\n---\ntitle: 全局私密文章测试\ndate: 2022-01-07 17:00:36\npermalink: /private/test1/\nprivate: true\ntitleTag: 测试\ncategories: \n  - 测试\ntags: \n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"恭喜您，访问成功！！！\n\n全局的私密文章仅需要在 frontmatter 额外 添加如下信息：\n\n---\nprivate: true     # 开启文章私密，必须\n---\n\n\n1\n2\n3\n\n\n此时在 themeconfig 里的管理员用户名和密码或者 logininfo 里的用户名和密码生效。\n\n如果您想单独给一个文章设为私密，则请访问 单个私密文章测试\n\n本文章的全部 frontmatter 内容：\n\n---\ntitle: 全局私密文章测试\ndate: 2022-01-07 17:00:36\npermalink: /private/test1/\nprivate: true\ntitletag: 测试\ncategories: \n  - 测试\ntags: \n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"单个私密文章测试",frontmatter:{title:"单个私密文章测试",date:"2022-01-07T17:01:37.000Z",permalink:"/private/test2/",titleTag:"测试",private:!0,username:"vdoing",password:123456,expire:"7h",loginInfo:[{username:"1",password:"1"},{username:"2",password:"2"}],categories:["测试"],tags:[null],readingShow:"top"},regularPath:"/90.%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95/03.%E5%8D%95%E4%B8%AA%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E6%B5%8B%E8%AF%95.html",relativePath:"90.私密文章测试/03.单个私密文章测试.md",key:"v-31fbd7e5",path:"/private/test2/",headersStr:null,content:"恭喜您，访问成功！！！\n\n单独的私密文章，需要在 frontmatter 额外添加如下信息：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名\npassword: 123456  # 密码\nexpire: 7h     # 登录状态超时清除时间，可选（不填则以全局超时时间为准，如果全局没有设置，则默认是一天）\nloginInfo: [   # 多组用户名密码登录\n  {username: '1', password: '1'},\n  {username: '2', password: '2'},\n]\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此时该文章使用 themeConfig 里的 loginInfo 信息登录 不会生效。仅仅该 frontmatter 的用户名和密码或者管理员用户名和密码 生效。\n\n如果您想全局给一个文章设为私密，则请访问 全局私密文章测试\n\n本文章的全部 frontmatter 内容：\n\n---\ntitle: 单个私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private/test2/\ntitleTag: 测试\nprivate: true\nusername: vdoing\npassword: 123456\nexpire: 7h\nloginInfo: [\n  {username: '1', password: '1'},\n  {username: '2', password: '2'},\n]\ncategories: \n  - 测试\ntags: \n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"恭喜您，访问成功！！！\n\n单独的私密文章，需要在 frontmatter 额外添加如下信息：\n\n---\nprivate: true     # 开启文章私密，必须\nusername: vdoing  # 用户名\npassword: 123456  # 密码\nexpire: 7h     # 登录状态超时清除时间，可选（不填则以全局超时时间为准，如果全局没有设置，则默认是一天）\nlogininfo: [   # 多组用户名密码登录\n  {username: '1', password: '1'},\n  {username: '2', password: '2'},\n]\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n此时该文章使用 themeconfig 里的 logininfo 信息登录 不会生效。仅仅该 frontmatter 的用户名和密码或者管理员用户名和密码 生效。\n\n如果您想全局给一个文章设为私密，则请访问 全局私密文章测试\n\n本文章的全部 frontmatter 内容：\n\n---\ntitle: 单个私密文章测试\ndate: 2022-01-07 17:01:37\npermalink: /private/test2/\ntitletag: 测试\nprivate: true\nusername: vdoing\npassword: 123456\nexpire: 7h\nlogininfo: [\n  {username: '1', password: '1'},\n  {username: '2', password: '2'},\n]\ncategories: \n  - 测试\ntags: \n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"本站 - 留言区",frontmatter:{title:"本站 - 留言区",date:"2022-02-15T22:32:38.000Z",permalink:"/message-area/",categories:[null],tags:[null],sidebar:!1,article:!1,editLink:!1,readingShow:"top"},regularPath:"/90.%E6%9C%AC%E7%AB%99%20-%20%E7%95%99%E8%A8%80%E5%8C%BA.html",relativePath:"90.本站 - 留言区.md",key:"v-6ef34192",path:"/message-area/",headersStr:null,content:"如果大家遇到了什么问题，欢迎大家留言讨论。\n\n如果 10s 后评论区还在转圈，可以尝试刷新页面。",normalizedContent:"如果大家遇到了什么问题，欢迎大家留言讨论。\n\n如果 10s 后评论区还在转圈，可以尝试刷新页面。",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"Vdoing私密文章登录",frontmatter:{title:"Vdoing私密文章登录",date:"2022-01-07T14:26:04.000Z",permalink:"/vdoing/login/",sidebar:!1,article:!1,comment:!1,editLink:!1,readingShow:"top"},regularPath:"/99.Vdoing%E7%A7%81%E5%AF%86%E6%96%87%E7%AB%A0%E7%99%BB%E5%BD%95.html",relativePath:"99.Vdoing私密文章登录.md",key:"v-528260fe",path:"/vdoing/login/",headersStr:null,content:"您当前访问的是博主的私密文章，请输入有效的用户名和密码，如果没有，请在评论区或者其他途径向博主获取。\n\n如果你是 全局私密文章测试 或者 单个私密文章测试 进来的，那么登录信息为：\n\n * 全局私密文章测试：用户名为 vdoing，密码为 123456\n * 单个私密文章测试：\n   * 用户名为 vdoing，密码为 123456\n   * 用户名为 1，密码为 1\n   * 用户名为 2，密码为 2\n\n私密文章模块内置五个异步弹窗提示：不输入用户名和密码、只输入两者中的一个、用户名或密码错误、用户名和密码正确。",normalizedContent:"您当前访问的是博主的私密文章，请输入有效的用户名和密码，如果没有，请在评论区或者其他途径向博主获取。\n\n如果你是 全局私密文章测试 或者 单个私密文章测试 进来的，那么登录信息为：\n\n * 全局私密文章测试：用户名为 vdoing，密码为 123456\n * 单个私密文章测试：\n   * 用户名为 vdoing，密码为 123456\n   * 用户名为 1，密码为 1\n   * 用户名为 2，密码为 2\n\n私密文章模块内置五个异步弹窗提示：不输入用户名和密码、只输入两者中的一个、用户名或密码错误、用户名和密码正确。",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"Github - 好看的主页",frontmatter:{title:"Github - 好看的主页",date:"2022-01-09T17:35:33.000Z",permalink:"/github/index/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/Github%20-%20%E5%A5%BD%E7%9C%8B%E7%9A%84%E4%B8%BB%E9%A1%B5.html",relativePath:"_posts/技术随笔/Github - 好看的主页.md",key:"v-1760b555",path:"/github/index/",headers:[{level:2,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:54},{level:2,title:"效果",slug:"效果",normalizedTitle:"效果",charIndex:60},{level:2,title:"如何使用",slug:"如何使用",normalizedTitle:"如何使用",charIndex:66}],headersStr:"图片 效果 如何使用",content:'笔记\n\n介绍我的 GitHub 个人首页的简单卡片设计。\n\n2022-01-09 @Du Wu\n\n\n\n * 图片\n * 效果\n * 如何使用\n\n\n\n\n# 图片\n\n\n# 效果\n\n这是我目前 GitHub 的个人首页，多了一些内容，如卡片统计，仓库的语言统计等。\n\n\n\n你也可以直接去我的主页查看效果：https://github.com/Kele-Bingtang\n\n\n# 如何使用\n\n首先你需要创建一个仓库，而仓库名 必须 是你的用户名，如我的 GitHub 叫做 Kele-Bingtang，则我的仓库名就叫 Kele-Bingtang。\n\n创建仓库的时候，记得公开仓库和创建 README 文件，如图：\n\n\n\n创建好仓库后，不需要克隆仓库到本地，我们直接在仓库里修改 README 文件即可。\n\n这里说明一下：两个卡片内容是第三方提供的，并且第三方提供了很多主题颜色，官方地址：https://github.com/anuraghazra/github-readme-stats。\n\n我的 README 文件内容：\n\n<a href="https://github.com/Kele-Bingtang/">\n  <img align="right" src="https://github-readme-stats.vercel.app/api?username=Kele-Bingtang&theme=algolia&count_private=true&show_icons=true" />\n</a>\n\n<a href="https://github.com/Kele-Bingtang/">\n  <img align="right" src="https://github-readme-stats.vercel.app/api/top-langs/?username=Kele-Bingtang&layout=compact" />\n</a>\n\n## Hello World 👋\n\n- 🔭 I’m currently working on Beijing\n- 💬 You can ask me about java\n- 📫 How to reach me: <https://youngkbt.cn?contact=1>\n- 😄 Pronouns: youngkbt\n- ⚡ Fun fact: 🏀 & 🏃‍ & 💻\n- :meat_on_bone: Meat lover\n\n## My Website\n\n💻：<https://youngkbt.cn>\n  \n## My Blog Websites\n\n- 1️⃣ Main(fast)：<https://notes.youngkbt.cn/>\n- 2️⃣ GitHub Pages(fast)：<https://github.notes.youngkbt.cn/>\n- 3️⃣ Gitee Pages(fast)：<http://gitee.notes.youngkbt.cn/>\n- 4️⃣ My Server(slow)：<https://server.notes.youngkbt.cn/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n其中 a 标签和 img 标签的 src 就是第三方提供的路径，如果你想直接使用我的效果卡片，那么只需要把第 2 行的 https://github-readme-stats.vercel.app/api?username=Kele-Bingtang&theme=algolia&count_private=true&show_icons=true 的 username 改成你自己的 GitHub 用户名，包括第 6 行的 username。其他不变。\n\n当然，a 标签的 src 也改成你想要跳转的地址。\n\n填好 README 文件后，点击保存，然后去首页刷新，就会看到效果。',normalizedContent:'笔记\n\n介绍我的 github 个人首页的简单卡片设计。\n\n2022-01-09 @du wu\n\n\n\n * 图片\n * 效果\n * 如何使用\n\n\n\n\n# 图片\n\n\n# 效果\n\n这是我目前 github 的个人首页，多了一些内容，如卡片统计，仓库的语言统计等。\n\n\n\n你也可以直接去我的主页查看效果：https://github.com/kele-bingtang\n\n\n# 如何使用\n\n首先你需要创建一个仓库，而仓库名 必须 是你的用户名，如我的 github 叫做 kele-bingtang，则我的仓库名就叫 kele-bingtang。\n\n创建仓库的时候，记得公开仓库和创建 readme 文件，如图：\n\n\n\n创建好仓库后，不需要克隆仓库到本地，我们直接在仓库里修改 readme 文件即可。\n\n这里说明一下：两个卡片内容是第三方提供的，并且第三方提供了很多主题颜色，官方地址：https://github.com/anuraghazra/github-readme-stats。\n\n我的 readme 文件内容：\n\n<a href="https://github.com/kele-bingtang/">\n  <img align="right" src="https://github-readme-stats.vercel.app/api?username=kele-bingtang&theme=algolia&count_private=true&show_icons=true" />\n</a>\n\n<a href="https://github.com/kele-bingtang/">\n  <img align="right" src="https://github-readme-stats.vercel.app/api/top-langs/?username=kele-bingtang&layout=compact" />\n</a>\n\n## hello world 👋\n\n- 🔭 i’m currently working on beijing\n- 💬 you can ask me about java\n- 📫 how to reach me: <https://youngkbt.cn?contact=1>\n- 😄 pronouns: youngkbt\n- ⚡ fun fact: 🏀 & 🏃‍ & 💻\n- :meat_on_bone: meat lover\n\n## my website\n\n💻：<https://youngkbt.cn>\n  \n## my blog websites\n\n- 1️⃣ main(fast)：<https://notes.youngkbt.cn/>\n- 2️⃣ github pages(fast)：<https://github.notes.youngkbt.cn/>\n- 3️⃣ gitee pages(fast)：<http://gitee.notes.youngkbt.cn/>\n- 4️⃣ my server(slow)：<https://server.notes.youngkbt.cn/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n其中 a 标签和 img 标签的 src 就是第三方提供的路径，如果你想直接使用我的效果卡片，那么只需要把第 2 行的 https://github-readme-stats.vercel.app/api?username=kele-bingtang&theme=algolia&count_private=true&show_icons=true 的 username 改成你自己的 github 用户名，包括第 6 行的 username。其他不变。\n\n当然，a 标签的 src 也改成你想要跳转的地址。\n\n填好 readme 文件后，点击保存，然后去首页刷新，就会看到效果。',charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1,readingShow:"top"},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-0574d59f",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"技术随笔 - 360天擎关闭",frontmatter:{title:"技术随笔 - 360天擎关闭",date:"2022-02-22T09:09:19.000Z",permalink:"/360/system/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94%20-%20360%E5%A4%A9%E6%93%8E%E5%85%B3%E9%97%AD.html",relativePath:"_posts/技术随笔/技术随笔 - 360天擎关闭.md",key:"v-7f6d28b2",path:"/360/system/",headers:[{level:2,title:"如何退出360天擎/奇安信天擎",slug:"如何退出360天擎-奇安信天擎",normalizedTitle:"如何退出360天擎/奇安信天擎",charIndex:2}],headersStr:"如何退出360天擎/奇安信天擎",content:"# 如何退出360天擎/奇安信天擎\n\n 1. 进入天擎防护中心-设置（在右下角图标右键也能进入设置）-防护中心-自我保护关闭\n\n 2. 进入安装路径 \\360Safe\\EntClient\\conf\\EntBase.dat，右键记事本打开文件\n\n 3. protect 下面两个 pass 改为空\n\n[protect]\n\nuipass=\n\nqtpass=\n\n\n1\n2\n3\n4\n5\n\n 4. 此时可以退出、卸载 360 天擎",normalizedContent:"# 如何退出360天擎/奇安信天擎\n\n 1. 进入天擎防护中心-设置（在右下角图标右键也能进入设置）-防护中心-自我保护关闭\n\n 2. 进入安装路径 \\360safe\\entclient\\conf\\entbase.dat，右键记事本打开文件\n\n 3. protect 下面两个 pass 改为空\n\n[protect]\n\nuipass=\n\nqtpass=\n\n\n1\n2\n3\n4\n5\n\n 4. 此时可以退出、卸载 360 天擎",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"右键打开 IDEA 和 VSCode",frontmatter:{title:"右键打开 IDEA 和 VSCode",date:"2022-07-28T09:31:06.000Z",permalink:"/right-click/idea-vscode/",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/%E5%8F%B3%E9%94%AE%E6%89%93%E5%BC%80%20IDEA%20%E5%92%8C%20VSCode.html",relativePath:"_posts/技术随笔/右键打开 IDEA 和 VSCode.md",key:"v-57a8012f",path:"/right-click/idea-vscode/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:3},{level:2,title:"VSCode 右键打开",slug:"vscode-右键打开",normalizedTitle:"vscode 右键打开",charIndex:9},{level:3,title:"右键 VSCode 打开桌面",slug:"右键-vscode-打开桌面",normalizedTitle:"右键 vscode 打开桌面",charIndex:26},{level:3,title:"右键 VSCode 打开文件夹",slug:"右键-vscode-打开文件夹",normalizedTitle:"右键 vscode 打开文件夹",charIndex:46},{level:3,title:"右键 VSCode 打开文件",slug:"右键-vscode-打开文件",normalizedTitle:"右键 vscode 打开文件",charIndex:46},{level:2,title:"IDEA 右键打开",slug:"idea-右键打开",normalizedTitle:"idea 右键打开",charIndex:85},{level:3,title:"右键 IDEA 打开桌面",slug:"右键-idea-打开桌面",normalizedTitle:"右键 idea 打开桌面",charIndex:100},{level:3,title:"右键 IDEA 打开文件夹",slug:"右键-idea-打开文件夹",normalizedTitle:"右键 idea 打开文件夹",charIndex:118},{level:3,title:"右键 IDEA 打开文件",slug:"右键-idea-打开文件",normalizedTitle:"右键 idea 打开文件",charIndex:118},{level:2,title:"结束语",slug:"结束语",normalizedTitle:"结束语",charIndex:153},{level:2,title:"建议",slug:"建议",normalizedTitle:"建议",charIndex:160}],headersStr:"介绍 VSCode 右键打开 右键 VSCode 打开桌面 右键 VSCode 打开文件夹 右键 VSCode 打开文件 IDEA 右键打开 右键 IDEA 打开桌面 右键 IDEA 打开文件夹 右键 IDEA 打开文件 结束语 建议",content:' * 介绍\n * VSCode 右键打开\n   * 右键 VSCode 打开桌面\n   * 右键 VSCode 打开文件夹\n   * 右键 VSCode 打开文件\n * IDEA 右键打开\n   * 右键 IDEA 打开桌面\n   * 右键 IDEA 打开文件夹\n   * 右键 IDEA 打开文件\n * 结束语\n * 建议\n\n\n\n\n# 介绍\n\n本内容介绍如何快速通过 VSCode、IDEA 打开指定的文件夹或者文件：\n\n\n\n本内容的目录虽然有多个，但是配置就三步：\n\n * 配置显示的文字，如通过 IDEA 打开、通过 Code 打开，可以自定义文字\n * 配置 IDEA 或者 VSCode 软件的图标\n * 配置 IDEA 或者 VSCode 的软件路径，这样点击后才能打开软件\n\n虽然目录有六种，但是只要学会一个目录的右键打开配置，那么其他的右键打开步骤配置就非常相似，只需要换个注册表的路径即可。\n\n\n# VSCode 右键打开\n\n\n# 右键 VSCode 打开桌面\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 的 VSCode 文件夹（项）。\n\n如果之前没有设置过路径，一般需要自己建立此文件夹（项）：\n\n 1. 对 shell 右键 -> 新建 -> 项，然后项的名字叫 VSCode\n\n 2. 单击新建的 VSCode，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 Code 打开，当然你也可以按照自己喜欢的名称填写，到时候右键的适合就会显示这个文本框内容\n    \n    \n\n 3. 接着配置 VSCode 的图标，这样右键的时候，就会显示 VSCode 的图标，方便识别\n    \n    * 对新建的 VSCode 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 VSCode 软件的路径，即 Code.exe\n      \n      如我的 VSCode 软件路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe"\n    \n    \n\n 4. 接着我们需要配置 VSCode 软件的路径，这样右键点击后，就会自动打开 VSCode 软件：\n    \n    * 对新建的 VSCode 右键 -> 新建 -> 项，名字叫做 command\n    \n    * 然后单击 command，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写你的 VSCode 软件的路径 + "%V"，"%V" 代表打开软件\n      \n      如我的图标路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe" "%V"\n    \n    如若 "%V" 失效，则改为 "%1"\n    \n    \n\n\n# 右键 VSCode 打开文件夹\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\Directory\\shell 并新建文件夹（项） VSCode。\n\n> 下面配置和右键 VSCode 打开桌面一样，就不放图片了，包括下面所有的配置都一样，只不过换路径。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 Code 打开\n\n配置 VSCode 的图标，这样右键的时候，就会显示 VSCode 的图标，方便识别\n\n * 新建的 VSCode 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 VSCode 软件的路径，即 Code.exe\n   \n   如我的 VSCode 软件路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe"\n\n接着我们需要配置 VSCode 软件的路径，这样右键点击后，就会自动打开 VSCode 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%V"\n\n * 如我的图标路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe" "%V"\n\n * 如若 "%V" 失效，则改为 "%1"\n\n\n# 右键 VSCode 打开文件\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\*\\shell 并新建文件夹（项） VSCode。\n\n> 和上面一样，配置默认、Icon 和 command 内容。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 Code 打开\n\n配置 VSCode 的图标，这样右键的时候，就会显示 VSCode 的图标，方便识别\n\n * 新建的 VSCode 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 VSCode 软件的路径，即 Code.exe\n   \n   如我的 VSCode 软件路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe"\n\n接着我们需要配置 VSCode 软件的路径，这样右键点击后，就会自动打开 VSCode 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%V"\n * 如我的图标路径为 "D:\\ITArea\\软件区\\VSCode\\Microsoft VS Code\\Code.exe" "%V"\n * 如若 "%V" 失效，则改为 "%1"\n\n\n# IDEA 右键打开\n\nIDEA 右键打开和 VSCode 右键打开的配置一样，只需要更换 IDEA 的路径即可。\n\n\n# 右键 IDEA 打开桌面\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell 的 IDEA 文件夹（项）。\n\n如果之前没有设置过路径，一般需要自己建立此文件夹（项）：\n\n 1. 对 shell 右键 -> 新建 -> 项，然后项的名字叫 IDEA\n\n 2. 单击新建的 IDEA，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 IDEA 打开，当然你也可以按照自己喜欢的名称填写，到时候右键的适合就会显示这个文本框内容\n\n 3. 接着配置 IDEA 的图标，这样右键的时候，就会显示 IDEA 的图标，方便识别\n    \n    * 对新建的 IDEA 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 IDEA 软件的路径，即 idea64.exe\n      \n      如我的 IDEA 软件路径为 "F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe"\n\n 4. 接着我们需要配置 IDEA 软件的路径，这样右键点击后，就会自动打开 IDEA 软件：\n    \n    * 对新建的 IDEA 右键 -> 新建 -> 项，名字叫做 command\n    \n    * 然后单击 command，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写你的 IDEA 软件的路径 + "%V"，其中 "%V" 代表打开软件\n      \n      如我的图标路径为 "F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe" "%V"\n    \n    如若 "%V" 失效，则改为 "%1"\n\n\n# 右键 IDEA 打开文件夹\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\Directory\\shell 并新建文件夹（项）IDEA。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 IDEA 打开\n\n配置 IDEA 的图标，这样右键的时候，就会显示 IDEA 的图标，方便识别\n\n * 新建的 IDEA 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 IDEA 软件的路径，即 idea64.exe\n   \n   如我的 IDEA 软件路径为 "F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe"\n\n接着我们需要配置 IDEA 软件的路径，这样右键点击后，就会自动打开 IDEA 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%V"\n\n * 如我的图标路径为 F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe" "%V"\n\n * 如若 "%V" 失效，则改为 "%1"\n\n\n# 右键 IDEA 打开文件\n\n * 按 WIN + R 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\HKEY_CLASSES_ROOT\\*\\shell 并新建文件夹（项）IDEA。\n\n> 和上面的步骤一样，配置默认、Icon 和 command 内容。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 IDEA 打开\n\n配置 IDEA 的图标，这样右键的时候，就会显示 IDEA 的图标，方便识别\n\n * 新建的 IDEA 右键 -> 新建 -> 字符串值，然后名称为 Icon，接着双击 Icon，数值数据的文本框为你的 IDEA 软件的路径，即 idea64.exe\n   \n   如我的 IDEA 软件路径为 "F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe"\n\n接着我们需要配置 IDEA 软件的路径，这样右键点击后，就会自动打开 IDEA 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%V"\n * 如我的图标路径为 "F:\\软件区\\IDEA\\IntelliJ IDEA 2021.3.3\\bin\\idea64.exe" "%V"\n * 如若 "%V" 失效，则改为 "%1"\n\n\n# 结束语\n\n配置完后，可以在桌面、文件夹、文件夹内、文件进行鼠标右键，看看是否有配置成功。\n\n\n\n\n# 建议\n\n一般不建议 IDEA 配置桌面的右键，因为用 IDEA 打开项目，一般是右键某个文件夹项目，如果配置桌面右键，这样不常用，每次右键总看到右键的菜单很长，就很烦。',normalizedContent:' * 介绍\n * vscode 右键打开\n   * 右键 vscode 打开桌面\n   * 右键 vscode 打开文件夹\n   * 右键 vscode 打开文件\n * idea 右键打开\n   * 右键 idea 打开桌面\n   * 右键 idea 打开文件夹\n   * 右键 idea 打开文件\n * 结束语\n * 建议\n\n\n\n\n# 介绍\n\n本内容介绍如何快速通过 vscode、idea 打开指定的文件夹或者文件：\n\n\n\n本内容的目录虽然有多个，但是配置就三步：\n\n * 配置显示的文字，如通过 idea 打开、通过 code 打开，可以自定义文字\n * 配置 idea 或者 vscode 软件的图标\n * 配置 idea 或者 vscode 的软件路径，这样点击后才能打开软件\n\n虽然目录有六种，但是只要学会一个目录的右键打开配置，那么其他的右键打开步骤配置就非常相似，只需要换个注册表的路径即可。\n\n\n# vscode 右键打开\n\n\n# 右键 vscode 打开桌面\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\directory\\background\\shell 的 vscode 文件夹（项）。\n\n如果之前没有设置过路径，一般需要自己建立此文件夹（项）：\n\n 1. 对 shell 右键 -> 新建 -> 项，然后项的名字叫 vscode\n\n 2. 单击新建的 vscode，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 code 打开，当然你也可以按照自己喜欢的名称填写，到时候右键的适合就会显示这个文本框内容\n    \n    \n\n 3. 接着配置 vscode 的图标，这样右键的时候，就会显示 vscode 的图标，方便识别\n    \n    * 对新建的 vscode 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 vscode 软件的路径，即 code.exe\n      \n      如我的 vscode 软件路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe"\n    \n    \n\n 4. 接着我们需要配置 vscode 软件的路径，这样右键点击后，就会自动打开 vscode 软件：\n    \n    * 对新建的 vscode 右键 -> 新建 -> 项，名字叫做 command\n    \n    * 然后单击 command，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写你的 vscode 软件的路径 + "%v"，"%v" 代表打开软件\n      \n      如我的图标路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe" "%v"\n    \n    如若 "%v" 失效，则改为 "%1"\n    \n    \n\n\n# 右键 vscode 打开文件夹\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\directory\\shell 并新建文件夹（项） vscode。\n\n> 下面配置和右键 vscode 打开桌面一样，就不放图片了，包括下面所有的配置都一样，只不过换路径。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 code 打开\n\n配置 vscode 的图标，这样右键的时候，就会显示 vscode 的图标，方便识别\n\n * 新建的 vscode 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 vscode 软件的路径，即 code.exe\n   \n   如我的 vscode 软件路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe"\n\n接着我们需要配置 vscode 软件的路径，这样右键点击后，就会自动打开 vscode 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%v"\n\n * 如我的图标路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe" "%v"\n\n * 如若 "%v" 失效，则改为 "%1"\n\n\n# 右键 vscode 打开文件\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\*\\shell 并新建文件夹（项） vscode。\n\n> 和上面一样，配置默认、icon 和 command 内容。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 code 打开\n\n配置 vscode 的图标，这样右键的时候，就会显示 vscode 的图标，方便识别\n\n * 新建的 vscode 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 vscode 软件的路径，即 code.exe\n   \n   如我的 vscode 软件路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe"\n\n接着我们需要配置 vscode 软件的路径，这样右键点击后，就会自动打开 vscode 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%v"\n * 如我的图标路径为 "d:\\itarea\\软件区\\vscode\\microsoft vs code\\code.exe" "%v"\n * 如若 "%v" 失效，则改为 "%1"\n\n\n# idea 右键打开\n\nidea 右键打开和 vscode 右键打开的配置一样，只需要更换 idea 的路径即可。\n\n\n# 右键 idea 打开桌面\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\directory\\background\\shell 的 idea 文件夹（项）。\n\n如果之前没有设置过路径，一般需要自己建立此文件夹（项）：\n\n 1. 对 shell 右键 -> 新建 -> 项，然后项的名字叫 idea\n\n 2. 单击新建的 idea，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 idea 打开，当然你也可以按照自己喜欢的名称填写，到时候右键的适合就会显示这个文本框内容\n\n 3. 接着配置 idea 的图标，这样右键的时候，就会显示 idea 的图标，方便识别\n    \n    * 对新建的 idea 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 idea 软件的路径，即 idea64.exe\n      \n      如我的 idea 软件路径为 "f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe"\n\n 4. 接着我们需要配置 idea 软件的路径，这样右键点击后，就会自动打开 idea 软件：\n    \n    * 对新建的 idea 右键 -> 新建 -> 项，名字叫做 command\n    \n    * 然后单击 command，右边出现一个名称叫 (默认) 的字符串值，双击 (默认)，然后在弹出的窗口中，数值数据的文本框写你的 idea 软件的路径 + "%v"，其中 "%v" 代表打开软件\n      \n      如我的图标路径为 "f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe" "%v"\n    \n    如若 "%v" 失效，则改为 "%1"\n\n\n# 右键 idea 打开文件夹\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\directory\\shell 并新建文件夹（项）idea。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 idea 打开\n\n配置 idea 的图标，这样右键的时候，就会显示 idea 的图标，方便识别\n\n * 新建的 idea 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 idea 软件的路径，即 idea64.exe\n   \n   如我的 idea 软件路径为 "f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe"\n\n接着我们需要配置 idea 软件的路径，这样右键点击后，就会自动打开 idea 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%v"\n\n * 如我的图标路径为 f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe" "%v"\n\n * 如若 "%v" 失效，则改为 "%1"\n\n\n# 右键 idea 打开文件\n\n * 按 win + r 组合键运行命令窗口\n * 输入 regedit，然后回车打开注册表编辑器\n\n找到路径 计算机\\hkey_classes_root\\*\\shell 并新建文件夹（项）idea。\n\n> 和上面的步骤一样，配置默认、icon 和 command 内容。\n\n双击 (默认)，然后在弹出的窗口中，数值数据的文本框写 通过 idea 打开\n\n配置 idea 的图标，这样右键的时候，就会显示 idea 的图标，方便识别\n\n * 新建的 idea 右键 -> 新建 -> 字符串值，然后名称为 icon，接着双击 icon，数值数据的文本框为你的 idea 软件的路径，即 idea64.exe\n   \n   如我的 idea 软件路径为 "f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe"\n\n接着我们需要配置 idea 软件的路径，这样右键点击后，就会自动打开 idea 软件：\n\n * 点击所建文件夹（项）鼠标右键新建项，并命名 command\n * 双击右边的 (默认) 设置软件所在路径，并在后面加上 "%v"\n * 如我的图标路径为 "f:\\软件区\\idea\\intellij idea 2021.3.3\\bin\\idea64.exe" "%v"\n * 如若 "%v" 失效，则改为 "%1"\n\n\n# 结束语\n\n配置完后，可以在桌面、文件夹、文件夹内、文件进行鼠标右键，看看是否有配置成功。\n\n\n\n\n# 建议\n\n一般不建议 idea 配置桌面的右键，因为用 idea 打开项目，一般是右键某个文件夹项目，如果配置桌面右键，这样不常用，每次右键总看到右键的菜单很长，就很烦。',charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"技术随笔 - Java启动的-D参数",frontmatter:{title:"技术随笔 - Java启动的-D参数",date:"2022-03-02T09:27:00.000Z",permalink:"/java/d/",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94%20-%20Java%E5%90%AF%E5%8A%A8%E7%9A%84-D%E5%8F%82%E6%95%B0.html",relativePath:"_posts/技术随笔/技术随笔 - Java启动的-D参数.md",key:"v-24efff4c",path:"/java/d/",headersStr:null,content:'Java 程序启动参数 -D 是用来做什么的呢？去查询了一下官方解释：\n\nSet a system property value. If  value  is a string that contains spaces, you must enclose the string in double quotes:\njava -Dfoo="some string" SomeClass\n\n\n1\n2\n\n\n解释说 -D 是用来在启动一个 Java 程序时设置系统属性值的。如果该值是一个字符串且包含空格，那么需要包在一对双引号中。\n\n什么是系统属性值呢？也就是在 System 类中通过 getProperties() 得到的一串系统属性。\n\n测试：\n\npublic class SystemProperty {\n\n    public static void main(String[] args){\n        System.out.print(System.getProperty("java.age"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在运行改程序时加上 JVM 参数 -Djava.age="20" 或者 -Djava.age=20，那么运行之后可以看到控制台输出了 20。\n\n在 CMD 启动命令：\n\njavac SystemProperty.java\njava -Djava.age="20" SystemProperty\n\n\n1\n2\n\n\n如果在 IDEA，则在 VM option 添加 -Djava.age="20" 或者 -Djava.age=20。',normalizedContent:'java 程序启动参数 -d 是用来做什么的呢？去查询了一下官方解释：\n\nset a system property value. if  value  is a string that contains spaces, you must enclose the string in double quotes:\njava -dfoo="some string" someclass\n\n\n1\n2\n\n\n解释说 -d 是用来在启动一个 java 程序时设置系统属性值的。如果该值是一个字符串且包含空格，那么需要包在一对双引号中。\n\n什么是系统属性值呢？也就是在 system 类中通过 getproperties() 得到的一串系统属性。\n\n测试：\n\npublic class systemproperty {\n\n    public static void main(string[] args){\n        system.out.print(system.getproperty("java.age"));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在运行改程序时加上 jvm 参数 -djava.age="20" 或者 -djava.age=20，那么运行之后可以看到控制台输出了 20。\n\n在 cmd 启动命令：\n\njavac systemproperty.java\njava -djava.age="20" systemproperty\n\n\n1\n2\n\n\n如果在 idea，则在 vm option 添加 -djava.age="20" 或者 -djava.age=20。',charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"技术随笔 - 域名解析",frontmatter:{title:"技术随笔 - 域名解析",date:"2021-12-01T23:21:36.000Z",permalink:"/domain/name/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94%20-%20%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90.html",relativePath:"_posts/技术随笔/技术随笔 - 域名解析.md",key:"v-78bd3772",path:"/domain/name/",headers:[{level:2,title:"主机记录",slug:"主机记录",normalizedTitle:"主机记录",charIndex:392},{level:2,title:"记录类型",slug:"记录类型",normalizedTitle:"记录类型",charIndex:373},{level:2,title:"线路",slug:"线路",normalizedTitle:"线路",charIndex:919},{level:2,title:"记录值",slug:"记录值",normalizedTitle:"记录值",charIndex:1070}],headersStr:"主机记录 记录类型 线路 记录值",content:"说一下购买服务器的流程，这里是阿里云服务器：https://www.aliyun.com/\n\n 1. 前往阿里云搜索「服务器 ECS」，按自己的理想配置和经济购买\n 2. 购买域名，选择自己喜欢的英文名和后缀\n 3. 购买域名时，需要填写自己的信息模板，然后等待十多分钟给阿里云审核成功，才能完成域名购买\n 4. 进行域名解析，阿里云里搜索「域名」，点击进入控制台，右侧有解析按钮，点击解析后进入新的界面，点击添加记录\n 5. 添加记录的选项参数就是本内容的介绍重点，在下方\n 6. 添加完记录后，购买 SSL 证书，有免费版，购买后下载证书到服务器进行配置，具体看 SSL 证书生成\n 7. 购买域名后的两三天左右，记得去备案，否则域名就无法访问，被拦截。在阿里云里面搜索「ICP 备案」，安装流程他们自带\n\n域名解析中点击添加记录后，填入各种记录类型，这里进行详细说明。\n\n\n# 主机记录\n\n主机记录就是域名前缀，比如我的域名是 youngkbt.cn，常见用法有：\n\n * www：解析后的域名为 www.youngkbt.cn，此时就需要加 www. 才能访问域名\n * @：直接解析主域名 youngkbt.cn，也就是直接在地址栏输入域名即可\n * ：泛解析，匹配其他所有域名 *.youngkbt.cn\n\n\n# 记录类型\n\n要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」\n\n * A 记录：地址记录，用来指定域名的 IPv4 地址（如：8.8.8.8），如果需要将域名指向一个 IP 地址，就需要添加 A 记录。\n\n * CNAME：如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录。\n\n * NS：域名服务器记录，如果需要把子域名交给其他DNS服务商解析，就需要添加NS记录。\n\n * AAA：用来指定主机名（或域名）对应的 IPv6 地址（例如：ff06:0:0:0:0:0:0:c3）记录。\n\n * MX：如果需要设置邮箱，让邮箱能收到邮件，就需要添加 MX 记录。\n\n如果打算绑定自己的服务器 IP，选择 A 记录即可。\n\n\n# 线路\n\n让指定线路的用户访问这个 IP\n\n常见用法有：\n\n * 默认：必须添加，否则只有单独指定的线路才能访问您的网站。如果双线解析，建议「默认」线路填写「电信 IP」\n\n * 联通：单独为「联通用户」指定服务器 IP，其他用户依然访问「默认」\n\n * 搜索引擎：指定一个服务器 IP 让抓取\n\n\n# 记录值\n\n最常见的是将空间商提供的「IP 地址」填写在这里。\n\n比如我填写的是我的服务器 IP，或者如果你的博客部署在 Github 或者 Gitee，可以填写 GitHub Pages 或者 Gitee Pages 的地址。\n\n各类型的记录值一般是这样的：\n\n * A 记录：填写您服务器 IP，如果您不知道，请咨询您的空间商\n\n * CNAME 记录：填写空间商给您提供的域名，例如：2.com\n\n * MX 记录：填写您邮件服务器的IP地址或企业邮局给您提供的域名，如果您不知道，请咨询您的邮件服务提供商\n\n * AAAA：不常用。解析到 IPv6 的地址。\n\n * NS 记录：不常用。系统默认添加的两个NS记录请不要修改。NS向下授权，填写dns域名，例如：ns3.dnsv3.com\n\n * TTL: 我们默认的 600 秒是最常用的，不用修改\n   \n   即 Time To Live，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到DNSPod获取记录值。\n   \n   600（10分钟）：建议正常情况下使用 600。\n   \n   60（1分钟）：如果您经常修改 IP，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。\n   \n   3600（1小时）：如果您 IP 极少变动（一年几次），建议选择 3600，解析速度快。如果要修改IP，提前一天改为 60，即可快速生效。",normalizedContent:"说一下购买服务器的流程，这里是阿里云服务器：https://www.aliyun.com/\n\n 1. 前往阿里云搜索「服务器 ecs」，按自己的理想配置和经济购买\n 2. 购买域名，选择自己喜欢的英文名和后缀\n 3. 购买域名时，需要填写自己的信息模板，然后等待十多分钟给阿里云审核成功，才能完成域名购买\n 4. 进行域名解析，阿里云里搜索「域名」，点击进入控制台，右侧有解析按钮，点击解析后进入新的界面，点击添加记录\n 5. 添加记录的选项参数就是本内容的介绍重点，在下方\n 6. 添加完记录后，购买 ssl 证书，有免费版，购买后下载证书到服务器进行配置，具体看 ssl 证书生成\n 7. 购买域名后的两三天左右，记得去备案，否则域名就无法访问，被拦截。在阿里云里面搜索「icp 备案」，安装流程他们自带\n\n域名解析中点击添加记录后，填入各种记录类型，这里进行详细说明。\n\n\n# 主机记录\n\n主机记录就是域名前缀，比如我的域名是 youngkbt.cn，常见用法有：\n\n * www：解析后的域名为 www.youngkbt.cn，此时就需要加 www. 才能访问域名\n * @：直接解析主域名 youngkbt.cn，也就是直接在地址栏输入域名即可\n * ：泛解析，匹配其他所有域名 *.youngkbt.cn\n\n\n# 记录类型\n\n要指向空间商提供的 ip 地址，选择「类型 a」，要指向一个域名，选择「类型 cname」\n\n * a 记录：地址记录，用来指定域名的 ipv4 地址（如：8.8.8.8），如果需要将域名指向一个 ip 地址，就需要添加 a 记录。\n\n * cname：如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 cname 记录。\n\n * ns：域名服务器记录，如果需要把子域名交给其他dns服务商解析，就需要添加ns记录。\n\n * aaa：用来指定主机名（或域名）对应的 ipv6 地址（例如：ff06:0:0:0:0:0:0:c3）记录。\n\n * mx：如果需要设置邮箱，让邮箱能收到邮件，就需要添加 mx 记录。\n\n如果打算绑定自己的服务器 ip，选择 a 记录即可。\n\n\n# 线路\n\n让指定线路的用户访问这个 ip\n\n常见用法有：\n\n * 默认：必须添加，否则只有单独指定的线路才能访问您的网站。如果双线解析，建议「默认」线路填写「电信 ip」\n\n * 联通：单独为「联通用户」指定服务器 ip，其他用户依然访问「默认」\n\n * 搜索引擎：指定一个服务器 ip 让抓取\n\n\n# 记录值\n\n最常见的是将空间商提供的「ip 地址」填写在这里。\n\n比如我填写的是我的服务器 ip，或者如果你的博客部署在 github 或者 gitee，可以填写 github pages 或者 gitee pages 的地址。\n\n各类型的记录值一般是这样的：\n\n * a 记录：填写您服务器 ip，如果您不知道，请咨询您的空间商\n\n * cname 记录：填写空间商给您提供的域名，例如：2.com\n\n * mx 记录：填写您邮件服务器的ip地址或企业邮局给您提供的域名，如果您不知道，请咨询您的邮件服务提供商\n\n * aaaa：不常用。解析到 ipv6 的地址。\n\n * ns 记录：不常用。系统默认添加的两个ns记录请不要修改。ns向下授权，填写dns域名，例如：ns3.dnsv3.com\n\n * ttl: 我们默认的 600 秒是最常用的，不用修改\n   \n   即 time to live，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到dnspod获取记录值。\n   \n   600（10分钟）：建议正常情况下使用 600。\n   \n   60（1分钟）：如果您经常修改 ip，修改记录一分钟即可生效。长期使用 60，解析速度会略受影响。\n   \n   3600（1小时）：如果您 ip 极少变动（一年几次），建议选择 3600，解析速度快。如果要修改ip，提前一天改为 60，即可快速生效。",charsets:{cjk:!0},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"生活随笔 - 习惯",frontmatter:{title:"生活随笔 - 习惯",date:"2022-02-19T18:46:39.000Z",permalink:"/live-posts/habit/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%20-%20%E4%B9%A0%E6%83%AF.html",relativePath:"_posts/生活随笔/生活随笔 - 习惯.md",key:"v-7c27afd4",path:"/live-posts/habit/",headers:[{level:2,title:"习惯（正在路上）",slug:"习惯-正在路上",normalizedTitle:"习惯（正在路上）",charIndex:45},{level:2,title:"鸡汤（经历过）",slug:"鸡汤-经历过",normalizedTitle:"鸡汤（经历过）",charIndex:57}],headersStr:"习惯（正在路上） 鸡汤（经历过）",content:"笔记\n\n记录个人收录的一些习惯或鸡汤。\n\n2022-02-19 @Du Wu\n\n\n\n * 习惯（正在路上）\n * 鸡汤（经历过）\n\n\n\n\n# 习惯（正在路上）\n\n1、熬夜或不规律睡眠比纵欲更可怕，凌晨 2 点到 11 点虽然睡眠时间充足，但不规律。\n\n2、裸睡，可以提高睡眠质量，对皮肤也好。我不是夸张乱说，是有科学案例支撑的「美国睡眠医学会研究发现，人们睡觉时体温会自然下降，如果你在睡觉时穿的衣服厚，便会影响到皮肤的散热，甚至流汗把衣服侵湿，睡眠质量自然很差。相反，裸睡不穿衣服，没有了束缚，那么自然而然也会有好的睡眠质量。」\n\n3、不要把最喜欢听的歌设置成闹铃。\n\n4、学会做一手好菜，不仅能养你的胃，也许某一天，还能养她的胃。\n\n5、在备忘录里，将好朋友的生日记录下来，并设置提醒。不用追求送出什么大礼，只要在那一天给他送上祝福，对方就会很开心。因为生日被别人记住是一件很温暖的事情。\n\n6、事成前不声张，话不说太满。这样成功了会让人眼前一亮，失败了也不会啪啪打脸。\n\n7、平时没事、吃饱了撑着就多站到体重秤上，屏幕上的数据压力是你最好的减肥动力。\n\n8、看到好的答案点个赞或评论，这个回答就会出现在你的主页动态里，不用担心下次找不到了。\n\n9、到楼下拿快递、外卖时，跟对方说谢谢，这样外卖小哥心情会变好，下次给你送外卖也会更用心，比如无意识地把外卖保护得更好，不让汤汁洒出来，快递同理。\n\n10、起床就刷牙、要背单词就马上拿起书、再等一下是能吞噬你的拖延黑洞，而且只会让你的事情变得复杂。杀掉拖延症最好的方法：凡事先做三分钟再说。\n\n11、收到回复是成年人的社交第一课。收到信息第一时间先回复，如果在忙或者不想聊，可以先说有事，稍后再聊，这样下一次聊天时才不会尴尬和难堪。\n\n12、感觉人很燥的时候，可以收拾下房间或者桌子，不需要多久，只要一会，你看看整齐的桌面，心情会慢慢变好。\n\n13、药店买东西时，销售推荐的都不要买，因为都是他提成高的，自己选需要的买，就像之前一些医生科普的，3 块钱一瓶的维生素 C 跟 200 元一瓶的没什么区别。\n\n14、出去玩的时候带个充电宝 + 一根苹果和安卓的数据线，关键时刻可以救你命，有时还能收获异性的赞赏。同时，出门随身携带纸巾，时间久了，人们会发现这个男生其实蛮绅士的，女生的话，人们会觉得你很细心 nice。\n\n15、大量阅读、持续阅读，古今中外、文学小说，都可以多读。不是要让你能在朋友圈发一些文艺矫情的句子，而是当你广泛阅读到一定程度的时候，你的谈吐和气质会自然而然让人感到舒服。只知道刷八卦追星看言情打游戏，这些会腐蚀你，让你变得庸俗，让你跟人聊天时，不知道讲什么，只会点头和傻笑。\n\n16、多坦诚，少说谎。有些面具戴久了，就摘不下来了。\n\n17、不要为了省钱降低自己的生活水平，便宜货在你买的瞬间会爽，但往后几年会给你带来许多懊悔和不舒服。而贵的东西也许买的瞬间会心疼，但你用几年就会爽几年。\n\n18、定期体检，在经济条件允许的条件下，做全面一点的，带你的伴侣和父母也一起去，这能大大降低你们的生活风险。\n\n19、不小心让别人受到伤害，永远要诚心诚意去道歉和补偿对方，长期如此人们会发现你知错能改，反而愿意与你交往，一个死不认错的人，是不会有真心朋友的。\n\n20、戒烟戒酒，男人女人都一样。这件事你能办成，那么以后基本没什么事情能难倒你了，别人眼中的难题，对你而言便是：“就这？”\n\n21、通知消息，最好报喜又报忧，比如你买了一套房子，通知朋友，可能他们会被刺激到觉得难受，但你再说一句，贷款买的，欠了几百万，他们就会好受一些。\n\n22、如果懈怠了就这样激励自己：多学一分钟，老公会不同。\n\n23、一个月清理 1 次微信、知乎、B站的收藏夹，如果有几个月忘记清理，就发现这个功能跟废了一样，现在都坚持清理。\n\n24、千万不要把密码记在手机笔记里，手机丢了或者被破解你就麻烦大了！那怕忘记怎么办？我女朋友是这样教我的，用特定字母 + 固定数字去设置密码，比如用 APP 的英文首字母 + 你女朋友的生日去设置密码就很方便，假设你女朋友生日是 960606，那么 QQ 密码就可以设置为 QQ960606，微信密码就可以设置为 WX960606。学废了吗？男女朋友这边排队领。\n\n25、去做客不要两手空空，就算只是给他们买点零食水果，也会大幅度提升对方的好感。\n\n26、吃饱后，坚持散步 20 分钟以上，一年后，你会发现小肚子没了，马甲线若隐若现。\n\n27、如果你真的想不明白自己要什么，运动健身、早睡早起、三餐规律、多读好书，做这些永远不会错。坚持一年，就算你还是没有目标，也能有一个好的身体、博学的脑袋，这些足以让你超越 80% 的同龄人。\n\n28、学会投资理财和强制储蓄，前者能帮你钱生钱，后者能在关键时候救你命。学会打造你的被动赚钱机器，当你的被动赚钱机器超出你的日常支出，这于你而言便是财务自由。挑水重要，但挖井更重要，投资理财完全可以尝试，别守着一份死工资。\n\n29、找到一样爱好坚持下去，他们能给你无穷无尽的力量，伴你走过大段无聊且难熬的人生。\n\n30、三餐规律，多吃蔬菜和水果。喜欢喝奶茶、油炸食物，是非常不好的。明知道不好但就是嘴巴痒，怎么办？找到食物去替代它们，比如说坚果、水果蔬菜等，坚持一个月，你的皮肤会靓很多，身体气质也会慢慢好起来。\n\n31、学会自我解压。有的人读书很厉害，可是一遇考试就失眠，导致成绩失利。能力很重要，会给自己减压，让能力更好地释放更重要。\n\n32、睡前先问下自己：如果时光能倒流到 24 小时前，我会想让今天重新开始吗？不要自我慰藉，这样简单的每日一小问，能让你反思这一天的收获与不足。\n\n33、定期和父母联系。能定期和父母联系是一项很棒的能力，那些关心家人的人值得深交，而那些把最坏一面留给父母的人，要么远离，要么你不惜一切代价用巴掌打醒他。\n\n34、看见生活里的细碎幸福。中 100 万大奖，月入 10 万，住 200㎡ 大房子，只向往这种爆棚感的快乐，会让你忽视生活中的小确幸。你回家的一桌子热菜，一杯难受时的红糖水，一个你期待已久的机械键盘，这些微小幸福的拼凑，其实是大多数人一生的快乐组成。\n\n35、每天坚持收拾好自己的脸、打扮好自己。得体的着装和精致的形象，会让你自信有气质，眼里藏着小星星，生活才能亮晶晶。\n\n36、大方的认同别人，不要在背后议论、抱怨他人，说人坏话。你也不希望自己被别人这样对待。\n\n\n# 鸡汤（经历过）\n\n如果你感到委屈，证明你还有底线。如果你感到迷茫，证明你还有追求。如果你感到痛苦，证明你还有力气。如果你感到绝望，证明你还有希望。从某种意义上，你永远都不会被打倒，因为你还有你。",normalizedContent:"笔记\n\n记录个人收录的一些习惯或鸡汤。\n\n2022-02-19 @du wu\n\n\n\n * 习惯（正在路上）\n * 鸡汤（经历过）\n\n\n\n\n# 习惯（正在路上）\n\n1、熬夜或不规律睡眠比纵欲更可怕，凌晨 2 点到 11 点虽然睡眠时间充足，但不规律。\n\n2、裸睡，可以提高睡眠质量，对皮肤也好。我不是夸张乱说，是有科学案例支撑的「美国睡眠医学会研究发现，人们睡觉时体温会自然下降，如果你在睡觉时穿的衣服厚，便会影响到皮肤的散热，甚至流汗把衣服侵湿，睡眠质量自然很差。相反，裸睡不穿衣服，没有了束缚，那么自然而然也会有好的睡眠质量。」\n\n3、不要把最喜欢听的歌设置成闹铃。\n\n4、学会做一手好菜，不仅能养你的胃，也许某一天，还能养她的胃。\n\n5、在备忘录里，将好朋友的生日记录下来，并设置提醒。不用追求送出什么大礼，只要在那一天给他送上祝福，对方就会很开心。因为生日被别人记住是一件很温暖的事情。\n\n6、事成前不声张，话不说太满。这样成功了会让人眼前一亮，失败了也不会啪啪打脸。\n\n7、平时没事、吃饱了撑着就多站到体重秤上，屏幕上的数据压力是你最好的减肥动力。\n\n8、看到好的答案点个赞或评论，这个回答就会出现在你的主页动态里，不用担心下次找不到了。\n\n9、到楼下拿快递、外卖时，跟对方说谢谢，这样外卖小哥心情会变好，下次给你送外卖也会更用心，比如无意识地把外卖保护得更好，不让汤汁洒出来，快递同理。\n\n10、起床就刷牙、要背单词就马上拿起书、再等一下是能吞噬你的拖延黑洞，而且只会让你的事情变得复杂。杀掉拖延症最好的方法：凡事先做三分钟再说。\n\n11、收到回复是成年人的社交第一课。收到信息第一时间先回复，如果在忙或者不想聊，可以先说有事，稍后再聊，这样下一次聊天时才不会尴尬和难堪。\n\n12、感觉人很燥的时候，可以收拾下房间或者桌子，不需要多久，只要一会，你看看整齐的桌面，心情会慢慢变好。\n\n13、药店买东西时，销售推荐的都不要买，因为都是他提成高的，自己选需要的买，就像之前一些医生科普的，3 块钱一瓶的维生素 c 跟 200 元一瓶的没什么区别。\n\n14、出去玩的时候带个充电宝 + 一根苹果和安卓的数据线，关键时刻可以救你命，有时还能收获异性的赞赏。同时，出门随身携带纸巾，时间久了，人们会发现这个男生其实蛮绅士的，女生的话，人们会觉得你很细心 nice。\n\n15、大量阅读、持续阅读，古今中外、文学小说，都可以多读。不是要让你能在朋友圈发一些文艺矫情的句子，而是当你广泛阅读到一定程度的时候，你的谈吐和气质会自然而然让人感到舒服。只知道刷八卦追星看言情打游戏，这些会腐蚀你，让你变得庸俗，让你跟人聊天时，不知道讲什么，只会点头和傻笑。\n\n16、多坦诚，少说谎。有些面具戴久了，就摘不下来了。\n\n17、不要为了省钱降低自己的生活水平，便宜货在你买的瞬间会爽，但往后几年会给你带来许多懊悔和不舒服。而贵的东西也许买的瞬间会心疼，但你用几年就会爽几年。\n\n18、定期体检，在经济条件允许的条件下，做全面一点的，带你的伴侣和父母也一起去，这能大大降低你们的生活风险。\n\n19、不小心让别人受到伤害，永远要诚心诚意去道歉和补偿对方，长期如此人们会发现你知错能改，反而愿意与你交往，一个死不认错的人，是不会有真心朋友的。\n\n20、戒烟戒酒，男人女人都一样。这件事你能办成，那么以后基本没什么事情能难倒你了，别人眼中的难题，对你而言便是：“就这？”\n\n21、通知消息，最好报喜又报忧，比如你买了一套房子，通知朋友，可能他们会被刺激到觉得难受，但你再说一句，贷款买的，欠了几百万，他们就会好受一些。\n\n22、如果懈怠了就这样激励自己：多学一分钟，老公会不同。\n\n23、一个月清理 1 次微信、知乎、b站的收藏夹，如果有几个月忘记清理，就发现这个功能跟废了一样，现在都坚持清理。\n\n24、千万不要把密码记在手机笔记里，手机丢了或者被破解你就麻烦大了！那怕忘记怎么办？我女朋友是这样教我的，用特定字母 + 固定数字去设置密码，比如用 app 的英文首字母 + 你女朋友的生日去设置密码就很方便，假设你女朋友生日是 960606，那么 qq 密码就可以设置为 qq960606，微信密码就可以设置为 wx960606。学废了吗？男女朋友这边排队领。\n\n25、去做客不要两手空空，就算只是给他们买点零食水果，也会大幅度提升对方的好感。\n\n26、吃饱后，坚持散步 20 分钟以上，一年后，你会发现小肚子没了，马甲线若隐若现。\n\n27、如果你真的想不明白自己要什么，运动健身、早睡早起、三餐规律、多读好书，做这些永远不会错。坚持一年，就算你还是没有目标，也能有一个好的身体、博学的脑袋，这些足以让你超越 80% 的同龄人。\n\n28、学会投资理财和强制储蓄，前者能帮你钱生钱，后者能在关键时候救你命。学会打造你的被动赚钱机器，当你的被动赚钱机器超出你的日常支出，这于你而言便是财务自由。挑水重要，但挖井更重要，投资理财完全可以尝试，别守着一份死工资。\n\n29、找到一样爱好坚持下去，他们能给你无穷无尽的力量，伴你走过大段无聊且难熬的人生。\n\n30、三餐规律，多吃蔬菜和水果。喜欢喝奶茶、油炸食物，是非常不好的。明知道不好但就是嘴巴痒，怎么办？找到食物去替代它们，比如说坚果、水果蔬菜等，坚持一个月，你的皮肤会靓很多，身体气质也会慢慢好起来。\n\n31、学会自我解压。有的人读书很厉害，可是一遇考试就失眠，导致成绩失利。能力很重要，会给自己减压，让能力更好地释放更重要。\n\n32、睡前先问下自己：如果时光能倒流到 24 小时前，我会想让今天重新开始吗？不要自我慰藉，这样简单的每日一小问，能让你反思这一天的收获与不足。\n\n33、定期和父母联系。能定期和父母联系是一项很棒的能力，那些关心家人的人值得深交，而那些把最坏一面留给父母的人，要么远离，要么你不惜一切代价用巴掌打醒他。\n\n34、看见生活里的细碎幸福。中 100 万大奖，月入 10 万，住 200㎡ 大房子，只向往这种爆棚感的快乐，会让你忽视生活中的小确幸。你回家的一桌子热菜，一杯难受时的红糖水，一个你期待已久的机械键盘，这些微小幸福的拼凑，其实是大多数人一生的快乐组成。\n\n35、每天坚持收拾好自己的脸、打扮好自己。得体的着装和精致的形象，会让你自信有气质，眼里藏着小星星，生活才能亮晶晶。\n\n36、大方的认同别人，不要在背后议论、抱怨他人，说人坏话。你也不希望自己被别人这样对待。\n\n\n# 鸡汤（经历过）\n\n如果你感到委屈，证明你还有底线。如果你感到迷茫，证明你还有追求。如果你感到痛苦，证明你还有力气。如果你感到绝望，证明你还有希望。从某种意义上，你永远都不会被打倒，因为你还有你。",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"生活随笔 - 美词",frontmatter:{title:"生活随笔 - 美词",date:"2022-02-19T18:42:09.000Z",permalink:"/live-posts/beautiful-words/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null],readingShow:"top"},regularPath:"/_posts/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%20-%20%E7%BE%8E%E8%AF%8D.html",relativePath:"_posts/生活随笔/生活随笔 - 美词.md",key:"v-5f4699cc",path:"/live-posts/beautiful-words/",headers:[{level:2,title:"巫师三",slug:"巫师三",normalizedTitle:"巫师三",charIndex:42},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:49},{level:2,title:"祝福",slug:"祝福",normalizedTitle:"祝福",charIndex:55}],headersStr:"巫师三 其他 祝福",content:"笔记\n\n记录个人收录的一些词语。\n\n2022-02-19 @Du Wu\n\n\n\n * 巫师三\n * 其他\n * 祝福\n\n\n\n\n# 巫师三\n\n一、从她的漆黑火焰出现在我的瞳仁之间，我便知道，这一生注定沉沦于此。\n\n二、我的情人犹如晨雾氤氲中玫瑰花瓣上的露水，新鲜清冽且随处可撷。\n\n三、我轻轻地念出你的名字，用吻过你的舌尖——你的面容便开始从往日的迷雾浮现，你的名字犹如一句咒语——记忆开始像水仙花一般绽开。\n\n四、踏上前往浮港的船只时，那个熟悉的倩影就站在甲板上，栗红色的头发在海风中飘扬、纤细蜂腰与姣好的面容沉湎在凌晨海面的粼粼波光中，她在静静望着你——一如这双美丽的湛蓝色眼镜经常做的那样。\n\n五、你从血泊中全身而退，转身坐倒时，她在远处陪着你。\n\n六、她转身离开，恍然间就消失在了森林边缘，像一只在薄雾中黯然归家的麋鹿，那样。\n\n七、爱与激情驱使着的身影遮蔽了火光，在漫漫无垠的海上连续闪烁着，根据密码成为了一串字符，被远方船上的船员记录下来。\n\n八、我就坐在门廊的摇椅上，抽着烟斗…听你在屋内调制药剂，瓶身碰撞，叮叮当当。\n\n\n# 其他\n\n * 本能给时间以生命，理性给岁月以文明\n * 人的一生，总是会不停地去你那些已经去过的地方，走曾经走过的路，在记忆里一遍一遍的去临摹当年当时的情景。在这样故地重游的情绪里，获取一种叫做时光倒流的错觉\n * 其实父母一直为我们骄傲，却一直都非常低调的生活着，他们害怕在我们日渐增长的光芒上，投下任何哪怕一点点的微小阴影\n\n\n# 祝福\n\n愿你手捧鲜花，芬芳岁月\n\n愿你脚踏山河，繁华人生\n\n愿你满眼星辰，璀璨无边\n\n愿你以梦为马，不负韶华\n\n愿你平安喜乐，开心幸福\n\n愿你眼里有星辰，身边有微风，心中有暖阳\n\n—— 诸事皆顺",normalizedContent:"笔记\n\n记录个人收录的一些词语。\n\n2022-02-19 @du wu\n\n\n\n * 巫师三\n * 其他\n * 祝福\n\n\n\n\n# 巫师三\n\n一、从她的漆黑火焰出现在我的瞳仁之间，我便知道，这一生注定沉沦于此。\n\n二、我的情人犹如晨雾氤氲中玫瑰花瓣上的露水，新鲜清冽且随处可撷。\n\n三、我轻轻地念出你的名字，用吻过你的舌尖——你的面容便开始从往日的迷雾浮现，你的名字犹如一句咒语——记忆开始像水仙花一般绽开。\n\n四、踏上前往浮港的船只时，那个熟悉的倩影就站在甲板上，栗红色的头发在海风中飘扬、纤细蜂腰与姣好的面容沉湎在凌晨海面的粼粼波光中，她在静静望着你——一如这双美丽的湛蓝色眼镜经常做的那样。\n\n五、你从血泊中全身而退，转身坐倒时，她在远处陪着你。\n\n六、她转身离开，恍然间就消失在了森林边缘，像一只在薄雾中黯然归家的麋鹿，那样。\n\n七、爱与激情驱使着的身影遮蔽了火光，在漫漫无垠的海上连续闪烁着，根据密码成为了一串字符，被远方船上的船员记录下来。\n\n八、我就坐在门廊的摇椅上，抽着烟斗…听你在屋内调制药剂，瓶身碰撞，叮叮当当。\n\n\n# 其他\n\n * 本能给时间以生命，理性给岁月以文明\n * 人的一生，总是会不停地去你那些已经去过的地方，走曾经走过的路，在记忆里一遍一遍的去临摹当年当时的情景。在这样故地重游的情绪里，获取一种叫做时光倒流的错觉\n * 其实父母一直为我们骄傲，却一直都非常低调的生活着，他们害怕在我们日渐增长的光芒上，投下任何哪怕一点点的微小阴影\n\n\n# 祝福\n\n愿你手捧鲜花，芬芳岁月\n\n愿你脚踏山河，繁华人生\n\n愿你满眼星辰，璀璨无边\n\n愿你以梦为马，不负韶华\n\n愿你平安喜乐，开心幸福\n\n愿你眼里有星辰，身边有微风，心中有暖阳\n\n—— 诸事皆顺",charsets:{cjk:!0},lastUpdated:"2023/04/04, 21:10:44",lastUpdatedTimestamp:1680613844e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1,readingShow:"top"},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-1179473f",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1,readingShow:"top"},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-dfe9f282",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/30, 17:54:49",lastUpdatedTimestamp:1680170089e3},{title:"Home",frontmatter:{home:!0,heroText:"Ming's blog",tagline:"故事由我书写，旅程由你见证，传奇由她聆听。",pageClass:"vdoing-index-class",postList:"detailed",readingShow:"top"},regularPath:"/",relativePath:"index.md",key:"v-543ef8d8",path:"/",headers:[{level:2,title:"CI/CD",slug:"ci-cd",normalizedTitle:"ci/cd",charIndex:2},{level:2,title:"目录页的front matter",slug:"目录页的front-matter",normalizedTitle:"目录页的front matter",charIndex:50},{level:2,title:"笔记文档的front matter",slug:"笔记文档的front-matter",normalizedTitle:"笔记文档的front matter",charIndex:512},{level:2,title:"完整的front matter",slug:"完整的front-matter",normalizedTitle:"完整的front matter",charIndex:664}],headersStr:"CI/CD 目录页的front matter 笔记文档的front matter 完整的front matter",content:"# CI/CD\n\nsh deploy.sh  # 部署到GitHub Pages\n\n\n1\n\n\n\n# 目录页的front matter\n\n---\npageComponent: # 使用页面组件\n  name: Catalogue # 组件名：Catalogue => 目录页组件 ，使用目录页时必须设置\n  data: # 组件所需数据\n    path:  01.学习笔记/01.前端 \n    imgUrl: /img/web.png # 目录页内的图片\n    description: JavaScript、ES6、Vue框架等前端技术 # 目录描述（可加入a标签）\ntitle:  # 页面标题\ndate:  # 创建日期\npermalink: /note/javascript # 永久链接\nsidebar: false # 不显示侧边栏\narticle: false # 不是文章页 (不显示面包屑栏、最近更新栏等)\ncomment: false # 不显示评论栏\neditLink: false # 不显示编辑按钮\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 笔记文档的front matter\n\n---\ntitle:     # 页面标题\ndate:     # 创建日期\npermalink:  # 永久链接\ncategories:  # 所在目录\n  - \ntags:    # 所属标签\n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 完整的front matter\n\n---\ntitle: 标题\ndate: 2020-02-21 14:40:19\npermalink: /pages/a1bc87\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\nsidebar: false\narticle: false\ncomment: false\neditLink: false\nauthor:\n name: 作者\n link: https://xxx.com\nsticky: 1  # 置顶，1 最高，数字越大，置顶地位越低下\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",normalizedContent:"# ci/cd\n\nsh deploy.sh  # 部署到github pages\n\n\n1\n\n\n\n# 目录页的front matter\n\n---\npagecomponent: # 使用页面组件\n  name: catalogue # 组件名：catalogue => 目录页组件 ，使用目录页时必须设置\n  data: # 组件所需数据\n    path:  01.学习笔记/01.前端 \n    imgurl: /img/web.png # 目录页内的图片\n    description: javascript、es6、vue框架等前端技术 # 目录描述（可加入a标签）\ntitle:  # 页面标题\ndate:  # 创建日期\npermalink: /note/javascript # 永久链接\nsidebar: false # 不显示侧边栏\narticle: false # 不是文章页 (不显示面包屑栏、最近更新栏等)\ncomment: false # 不显示评论栏\neditlink: false # 不显示编辑按钮\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 笔记文档的front matter\n\n---\ntitle:     # 页面标题\ndate:     # 创建日期\npermalink:  # 永久链接\ncategories:  # 所在目录\n  - \ntags:    # 所属标签\n  - \n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 完整的front matter\n\n---\ntitle: 标题\ndate: 2020-02-21 14:40:19\npermalink: /pages/a1bc87\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\nsidebar: false\narticle: false\ncomment: false\neditlink: false\nauthor:\n name: 作者\n link: https://xxx.com\nsticky: 1  # 置顶，1 最高，数字越大，置顶地位越低下\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n",charsets:{cjk:!0},lastUpdated:"2025/02/09, 02:22:48",lastUpdatedTimestamp:1739038968e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"前端基础",link:"/basics/",items:[{text:"HTML",link:"/basics/HTML/"},{text:"Css",link:"/basics/CSS2/"}]},{text:"JS",link:"/javascript/",items:[{text:"基础",link:"/JSbasics/"},{text:"ES6",link:"/JS-ES6/"}]},{text:"Web Api",link:"/tool/",items:[{text:"Dom",link:"/tool/"},{text:"Bom",link:"/tool/"},{text:"axios",link:"/tool/"},{text:"跨域",link:"/tool/"},{text:"事件",link:"/tool/"},{text:"存储",link:"/tool/"}]},{text:"工具",link:"/tool/",items:[{text:"管理",items:[{text:"Git",link:"/git/"}]},{text:"构建工具",items:[{text:"Webpack",link:"/Webpack/"},{text:"Vite",link:"/Vite/"}]}]},{text:"Demo",items:[{text:"神领物流",link:"http://124.222.141.165:90/"},{text:"尺锤人员管理",link:"http://124.222.141.165:99/"}]},{text:"更多",link:"/more/",items:[{text:"学习",link:"/more/feynmanLearningMethod/"},{text:"进阶",link:"/more/advanced/"},{text:"面试",link:"/more/interview/"},{text:"技术面",link:"/more/interview-vue/"},{text:"友情链接",link:"/friends/"}]},{text:"索引",link:"/archives/",items:[{text:"本站",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"我的",items:[{text:"收藏",link:"/whell/web/"},{text:"关于",link:"/about/website/introduce/"},{text:"Vue2-Admin",link:"https://vue2-admin.youngkbt.cn/"}]}]},{text:"导航站",link:"/navigation/"},{text:"留言区",link:"/message-area/"}],sidebarDepth:2,logo:"/img/index/logo.png",repo:"https://github.com/Ming-D-W",searchMaxSuggestions:10,lastUpdated:"更新时间",docsDir:"docs",editLinks:!1,editLinkText:"编辑此页",categoryText:"随笔",bodyBgImg:"/img/index/bg.jpg",bodyBgImgOpacity:1,sidebar:{"/00.目录页/":[{title:"导航栏 - 目录页",collapsable:!0,children:[["00.导航栏 - 目录页/10.工具 - 知识体系.md","工具 - 知识体系","/tool/"],["00.导航栏 - 目录页/15.前端 - 知识体系.md","前端 - 知识体系","/basics/"],["00.导航栏 - 目录页/17.JS - 知识体系.md","前端 - 知识体系","/javascript/"],["00.导航栏 - 目录页/88.更多 - 知识体系.md","更多 - 知识体系","/more/"]]},{title:"JS - 目录页",collapsable:!0,children:[["03.JS - 目录页/01.基础 - 知识体系.md","JS基础 - 知识体系","/JSbasics/"],["03.JS - 目录页/02.ES6 - 知识体系.md","ES6 - 知识体系","/JS-ES6/"]]},{title:"工具 - 目录页",collapsable:!0,children:[["12.工具 - 目录页/02.Git - 知识体系.md","Git - 知识体系","/git/"],["12.工具 - 目录页/03.Webpack - 知识体系.md","Webpack - 知识体系","/webpack/"]]},{title:"更多 - 目录页",collapsable:!0,children:[["17.更多 - 目录页/03.进阶 - 知识体系.md","Git - 知识体系","/more/advanced/"]]}],catalogue:{"工具 - 知识体系":"/tool/","前端 - 知识体系":"/basics/","JS - 知识体系":"/javascript/","更多 - 知识体系":"/more/","基础 - 知识体系":"/JSbasics/","ES6 - 知识体系":"/JS-ES6/","Git - 知识体系":"/git/","Webpack - 知识体系":"/webpack/","进阶 - 知识体系":"/more/advanced/"},"/01.前端基础/":[{title:"HTML",collapsable:!0,children:[["01.HTML/01.HTML.md","HTML","/basics/HTML/"]]},{title:"CSS",collapsable:!0,children:[["02.CSS/02.CSS基础.md","CSS基础","/basics/CSS2/"],["02.CSS/03.CSS复合选择器、背景盒子透明、三大元素、圆角、阴影.md","CSS复合选择器、背景盒子透明、三大元素、圆角、阴影","/pages/c7b8e9/"],["02.CSS/04.CSS三大特性、盒子模型、边距、过渡动画.md","CSS三大特性、盒子模型、边距、过渡动画","/pages/33f061/"],["02.CSS/05.CSS3选择器、伪元素、光标类型、浮动.md","CSS3选择器、伪元素、光标类型、浮动","/pages/64cb20/"],["02.CSS/06.CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局.md","CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局","/pages/915fc4/"],["02.CSS/20.CSS进阶.md","CSS进阶","/pages/602c76/"]]}],"/20.JS/":[{title:"基础",collapsable:!0,children:[["10.基础/01.JS语法与变量.md","JS语法与变量","/javascript/c8f971/"],["10.基础/02.JS基本数据类型.md","JS基本数据类型","/pages/6f1d80/"],["10.基础/03.JS表达式与操作符.md","JS表达式与操作符","/pages/5c5ad9/"],["10.基础/04.JS流程控制.md","JS流程控制","/pages/4b4e62/"],["10.基础/05.JS数组.md","JS数组","/pages/39d0fd/"],["10.基础/06.JS函数.md","JS函数","/pages/428206/"]]},{title:"ES6",collapsable:!0,children:[["20.ES6/01.ES6基础入门.md","ES6基础入门","/pages/75e0f9/"],["20.ES6/02.ES6语法扩展.md","ES6语法扩展","/pages/067486/"],["20.ES6/03.ES6之Promise与Class类.md","ES6之Promise与Class类","/pages/8bebf7/"],["20.ES6/04.ES6之Module模块.md","ES6之Module模块","/pages/65b11e/"]]}],"/40.工具/":[{title:"开发管理 - Git",collapsable:!0,children:[["20.开发管理 - Git/01.Git - 介绍与安装.md","Git - 介绍与安装","/git/introduce/"],["20.开发管理 - Git/03.Git - 常用命令.md","Git - 常用命令","/git/common-commands"],["20.开发管理 - Git/05.Git - 基本原理.md","Git - 基本原理","/git/basic-principles/"],["20.开发管理 - Git/07.Git - SSH免密登录.md","Git - SSH免密登录","/git/ssh-login/"],["20.开发管理 - Git/09.Git - IDEA集成.md","Git - IDEA集成","/git/idea/"],["20.开发管理 - Git/11.Git - 自建代码托管平台.md","Git - 自建代码托管平台","/git/built-code-platform/"],["20.开发管理 - Git/15.Git - Commit常用表情.md","Git - Commit常用表情","/git/commit-emo/"],["20.开发管理 - Git/16.变更Git作者邮箱信息.md","变更Git作者邮箱信息","/pages/c87550/"]]},{title:"构建工具-webpack",collapsable:!0,children:[["30.构建工具-webpack/01.Babel与webpack.md","Babel与webpack","/pages/c955d9/"]]}],"/55.更多/":[{title:"学习",collapsable:!0,children:[["01.学习/00.费曼学习法.md","费曼学习法","/more/feynmanLearningMethod/"],["01.学习/01.笔记方法.md","笔记方法","/pages/e60c81/"],["01.学习/02.提高学习效率的策略.md","提高学习效率的策略","/pages/a8692ab3bdcb4588"],["01.学习/03.提高记忆的技巧.md","提高记忆的技巧","/pages/996822b2a2ca6e3b"],["01.学习/04.自律小建议.md","自律小建议","/pages/c3f302a03c8daf79"],["01.学习/05.处理问题的思路.md","处理问题的思路","/pages/9ba2b8fb13de1957"],["01.学习/10.搜索引擎使用技巧.md","搜索引擎使用技巧","/pages/ce818a"]]},{title:"进阶",collapsable:!0,children:[["02.进阶/01.JavaScript 的三座大山.md","JavaScript 的三座大山","/advanced/4b2339/"],["02.进阶/07.「硬核JS」垃圾回收机制.md","「硬核JS」垃圾回收机制","/pages/ed7042/"],["02.进阶/10.Javascript 定时器应用技巧讲解.md","Javascript 定时器应用技巧讲解","/advanced/55c2e0/"],["02.进阶/20.FormData 配合 ajax 异步无刷新上传表格数据.md","FormData 配合 ajax 异步无刷新上传表格数据","/advanced/0735ac/"],["02.进阶/30.使用git命令行，删除远程分支上的文件or文件夹.md","使用git命令行，删除远程分支上的文件or文件夹","/advanced/39134a/"],["02.进阶/31.git push到远程指定分支(git拉取指定分支代码).md","git push到远程指定分支(git拉取指定分支代码)","/pages/3190e5/"],["02.进阶/32.如何快速关联及修改Git远程仓库地址.md","如何快速关联及修改Git远程仓库地址","/pages/1130ec/"],["02.进阶/41.后端一次性返回我10万条数据的8种解决方案.md","什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！","/pages/77f5b4/"],["02.进阶/42.虚拟列表，我真的会了！！！.md","虚拟列表，我真的会了！！！","/advanced/6f6d13/"],["02.进阶/43.Vue中实现右键自定义菜单.md","Vue中实现右键自定义菜单","/pages/39df27/"],["02.进阶/44.大文件上传技术实现.md","大文件上传技术实现","/pages/08929e/"],["02.进阶/50.面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见.md","面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见","/advanced/e561b0/"],["02.进阶/60.移动端适配方案.md","移动端适配方案","/pages/4546c7/"],["02.进阶/61.移动端H5-iPhone安全距离适配.md","移动端H5-iPhone安全距离适配","/pages/a7d5db/"],["02.进阶/62.H5页面高德定位打卡功能.md","H5页面高德定位打卡功能","/pages/587043/"]]},{title:"面试",collapsable:!0,children:[["04.面试/01.面试问题集锦.md","面试问题集锦","/more/interview/"]]},{title:"技术面",collapsable:!0,children:[["05.技术面/01.JS.md","JS","/pages/e4dc2c/"],["05.技术面/02.CSS.md","CSS","/pages/26cc37/"],["05.技术面/03.浏览器&http.md","浏览器&http","/pages/d178b0/"],["05.技术面/04.Vue.md","Vue","/more/interview-vue/"],["05.技术面/07.new vue主体流程.md","new Vue的流程","/pages/3d4029/","原创"],["05.技术面/08.Vue2响应式源码.md","Vue2响应式源码","/pages/053424/","原创"],["05.技术面/09.Vue2 Diff 算法.md","Vue2 Diff 算法","/pages/e1d719/"]]},["99.友情连接.md","友情连接","/friends"]],"/75.收藏夹/":[["01.网站轮子.md","网站轮子","/whell/web/"],["02.前端轮子.md","前端轮子","/whell/front"],["03.插件选择.md","插件轮子","/plugins"]],"/80.关于/":[{title:"关于 - 自我",collapsable:!0,children:[["03.关于 - 自我/02.自我 - 介绍.md","自我 - 介绍","/about/me/introduce/","原创"],["03.关于 - 自我/05.自我 - 清单.md","自我 - 清单","/about/list/","原创"],["03.关于 - 自我/07.自我 - 学习线.md","自我 - 学习线","/about/learn-line/","原创"],["03.关于 - 自我/09.自我 - 尊贵公子.md","自我 - 尊贵公子","/about/qin-yu/","原创"],["03.关于 - 自我/11.自我 - 温润少年.md","自我 - 温润少年","/about/liang-shi-bo/","原创"],["03.关于 - 自我/13.自我 - 说明.md","自我 - 说明","/about/me/explain/","原创"]]},{title:"关于 - 本站",collapsable:!0,children:[["06.关于 - 本站/01.本站 - 介绍.md","本站 - 介绍","/about/website/introduce"],["06.关于 - 本站/02.本站 - 规划.md","本站 - 规划","/about/website/plan/","原创"],["06.关于 - 本站/05.本站 - 搭建.md","本站 - 搭建","/about/website/build/","原创"],["06.关于 - 本站/07.本站 - 主题.md","本站 - 主题","/about/website/theme/","原创"],["06.关于 - 本站/10.本站 - 网站部署.md","本站 - 网站部署","/about/website/deploy/","原创"],["06.关于 - 本站/12.本站 - 服务器部署.md","本站 - 服务器部署","/about/website/server/","原创"],["06.关于 - 本站/14.本站 - 评论模块.md","本站 - 评论模块","/about/website/comment/","原创"],["06.关于 - 本站/16.本站 - 站点信息模块.md","本站 - 站点信息模块","/about/website/info/","原创"],["06.关于 - 本站/18.本站 - 自定义样式模块.md","本站 - 自定义样式模块","/about/website/style/","原创"],["06.关于 - 本站/20.本站 - 记录阅读文章模块.md","本站 - 记录曾阅读位置模块","/about/website/lastReading/","原创"],["06.关于 - 本站/22.本站 - 私密文章模块.md","本站 - 私密文章模块","/about/website/private/","原创"],["06.关于 - 本站/24.本站 - 导航站模块.md","本站 - 导航站模块","/about/website/tools/","原创"],["06.关于 - 本站/26.本站 - 首页大图模块.md","本站 - 首页大图模块","/about/website/index-big-img/","原创"],["06.关于 - 本站/28.本站 - 代码块隐藏模块.md","本站 - 代码块隐藏模块","/about/website/code-block-hidden/","原创"],["06.关于 - 本站/30.本站 - 全局时间提示模块.md","本站 - 全局时间提示模块","/about/website/global-tip/","原创"]]},{title:"关于 - 首页",collapsable:!0,children:[["08.关于 - 首页/02.首页 - 部署.md","首页 - 部署","/about/index/younngkbt/","原创"],["08.关于 - 首页/04.首页 - 下载站点.md","首页 - 下载站点","/about/index/download/","原创"]]},{title:"关于 - 技巧",collapsable:!0,children:[["09.关于 - 技巧/02.技巧 - 笔记.md","技巧 - 笔记","/about/mdskill/","优质"],["09.关于 - 技巧/04.技巧 - 排版.md","技巧 - 排版","/about/typesetting/","优质"]]},{title:"关于 - 随笔",collapsable:!0,children:[["12.关于 - 随笔/01.随笔 - 目录.md","随笔 - 目录","/posts/category/"]]}],"/90.私密文章测试/":[["01.全局私密文章测试.md","全局私密文章测试","/private/test1/","测试"],["03.单个私密文章测试.md","单个私密文章测试","/private/test2/","测试"]]},blogInfo:{blogCreate:"2021-10-19",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"工具 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/00.导航栏 - 目录页/10.工具 - 知识体系.md",wordsCount:57,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"40.工具",imgUrl:"/img/catalogue/default.png",description:"编程常用管理工具，包括部署工具等相关知识。"}},title:"工具 - 知识体系",date:"2021-10-21T16:48:47.000Z",permalink:"/tool/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"前端 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/00.导航栏 - 目录页/15.前端 - 知识体系.md",wordsCount:50,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"01.前端基础",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"前端 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/basics/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"JS - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/00.导航栏 - 目录页/17.JS - 知识体系.md",wordsCount:47,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"20.JS",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"前端 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/javascript/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"更多 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/00.导航栏 - 目录页/88.更多 - 知识体系.md",wordsCount:48,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"55.更多",imgUrl:"/img/index/front.png",description:"JavaScript、ES6、Vue 框架等前端技术。"}},title:"更多 - 知识体系",date:"2021-10-21T16:49:31.000Z",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"基础 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/03.JS - 目录页/01.基础 - 知识体系.md",wordsCount:159,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"20.JS/10.基础",imgUrl:"/img/catalogue/default.png",description:"Maven 是最流行的 Java 项目构建系统JavaScript（简称“JS”）是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。"}},title:"JS基础 - 知识体系",date:"2021-11-25T18:49:44.000Z",permalink:"/JSbasics/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"ES6 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/03.JS - 目录页/02.ES6 - 知识体系.md",wordsCount:133,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"20.JS/20.ES6",imgUrl:"/img/catalogue/default.png",description:"ECMAScript 6（简称ES6）是于2015年6月正式发布的JavaScript语言的标准，正式名为ECMAScript 2015（ES2015）。它的目标是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。另外，一些情况下ES6也泛指ES2015及之后的新增特性，虽然之后的版本应当称为ES7、ES8等。"}},title:"ES6 - 知识体系",date:"2021-11-25T18:49:44.000Z",permalink:"/JS-ES6/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"Git - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/12.工具 - 目录页/02.Git - 知识体系.md",wordsCount:114,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"40.工具/20.开发管理 - Git",imgUrl:"/img/catalogue/default.png",description:"Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。"}},title:"Git - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/git/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"Webpack - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/12.工具 - 目录页/03.Webpack - 知识体系.md",wordsCount:132,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"40.工具/30.构建工具-webpack",imgUrl:"/img/catalogue/default.png",description:"webpack 是代码编译工具，有入口、出口、loader 和插件。webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。"}},title:"Webpack - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/webpack/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"进阶 - 知识体系",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/00.目录页/17.更多 - 目录页/03.进阶 - 知识体系.md",wordsCount:112,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"55.更多/02.进阶",imgUrl:"/img/catalogue/default.png",description:"Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。也是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。"}},title:"Git - 知识体系",date:"2021-11-25T18:51:10.000Z",permalink:"/more/advanced/",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"HTML",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/01.HTML/01.HTML.md",wordsCount:"4.5k",readingTime:"17.1m",title:"HTML",date:"2020-04-04T15:15:03.000Z",permalink:"/basics/HTML/",categories:["前端基础","HTML"],tags:[null]},{name:"CSS基础",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/02.CSS基础.md",wordsCount:"4.6k",readingTime:"17.5m",title:"CSS基础",date:"2020-04-05T20:07:40.000Z",permalink:"/basics/CSS2/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"CSS复合选择器、背景盒子透明、三大元素、圆角、阴影",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/03.CSS复合选择器、背景盒子透明、三大元素、圆角、阴影.md",wordsCount:"6k",readingTime:"23.5m",title:"CSS复合选择器、背景盒子透明、三大元素、圆角、阴影",date:"2020-04-06T01:28:54.000Z",permalink:"/pages/c7b8e9/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"CSS三大特性、盒子模型、边距、过渡动画",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/04.CSS三大特性、盒子模型、边距、过渡动画.md",wordsCount:"5.1k",readingTime:"20.9m",title:"CSS三大特性、盒子模型、边距、过渡动画",date:"2020-04-07T23:27:29.000Z",permalink:"/pages/33f061/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"CSS3选择器、伪元素、光标类型、浮动",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/05.CSS3选择器、伪元素、光标类型、浮动.md",wordsCount:"11.1k",readingTime:"47.3m",title:"CSS3选择器、伪元素、光标类型、浮动",date:"2020-04-08T15:05:14.000Z",permalink:"/pages/64cb20/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/06.CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局.md",wordsCount:"4.6k",readingTime:"18.1m",title:"CSS隐藏、对齐属性、精灵图、字体图标、文字溢出、布局",date:"2020-04-09T15:09:00.000Z",permalink:"/pages/915fc4/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"CSS进阶",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/01.前端基础/02.CSS/20.CSS进阶.md",wordsCount:866,readingTime:"3.7m",title:"CSS进阶",date:"2020-10-03T15:46:55.000Z",permalink:"/pages/602c76/",categories:["前端基础","CSS"],tags:["CSS"]},{name:"JS语法与变量",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/01.JS语法与变量.md",wordsCount:"3.2k",readingTime:"12.7m",title:"JS语法与变量",date:"2020-04-30T11:58:31.000Z",permalink:"/javascript/c8f971/",categories:["JS","基础"],tags:["Javascript"]},{name:"JS基本数据类型",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/02.JS基本数据类型.md",wordsCount:"3.7k",readingTime:"15.4m",title:"JS基本数据类型",date:"2020-04-30T12:00:27.000Z",permalink:"/pages/6f1d80/",categories:["JS","基础"],tags:["Javascript"]},{name:"JS表达式与操作符",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/03.JS表达式与操作符.md",wordsCount:"1.9k",readingTime:"7.5m",title:"JS表达式与操作符",date:"2020-04-30T11:11:33.000Z",permalink:"/pages/5c5ad9/",categories:["JS","基础"],tags:["Javascript"]},{name:"JS流程控制",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/04.JS流程控制.md",wordsCount:"1.4k",readingTime:"5.8m",title:"JS流程控制",date:"2020-04-30T11:11:33.000Z",permalink:"/pages/4b4e62/",categories:["JS","基础"],tags:["Javascript"]},{name:"JS数组",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/05.JS数组.md",wordsCount:"5.2k",readingTime:"22.6m",title:"JS数组",date:"2020-04-30T12:02:50.000Z",permalink:"/pages/39d0fd/",categories:["JS","基础"],tags:["Javascript"]},{name:"JS函数",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/10.基础/06.JS函数.md",wordsCount:"4k",readingTime:"16.4m",title:"JS函数",date:"2020-04-30T12:03:52.000Z",permalink:"/pages/428206/",categories:["JS","基础"],tags:["Javascript"]},{name:"ES6基础入门",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/20.ES6/01.ES6基础入门.md",wordsCount:"5.5k",readingTime:"25.2m",title:"ES6基础入门",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/75e0f9/",categories:["JS","ES6"],tags:[null]},{name:"ES6语法扩展",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/20.ES6/02.ES6语法扩展.md",wordsCount:"5.3k",readingTime:"25.3m",title:"ES6语法扩展",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/067486/",categories:["JS","ES6"],tags:[null]},{name:"ES6之Promise与Class类",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/20.ES6/03.ES6之Promise与Class类.md",wordsCount:"8.2k",readingTime:"34.1m",title:"ES6之Promise与Class类",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/8bebf7/",categories:["JS","ES6"],tags:[null]},{name:"ES6之Module模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/20.JS/20.ES6/04.ES6之Module模块.md",wordsCount:"1.7k",readingTime:"7.4m",title:"ES6之Module模块",date:"2020-05-27T14:44:16.000Z",permalink:"/pages/65b11e/",categories:["JS","ES6"],tags:[null]},{name:"Git - 介绍与安装",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/01.Git - 介绍与安装.md",wordsCount:"2k",readingTime:"7.8m",title:"Git - 介绍与安装",date:"2021-02-08T12:52:18.000Z",permalink:"/git/introduce/",categories:["Git"],tags:["Git"]},{name:"Git - 常用命令",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/03.Git - 常用命令.md",wordsCount:"2.6k",readingTime:"10m",title:"Git - 常用命令",date:"2021-02-08T13:22:08.000Z",permalink:"/git/common-commands",categories:["Git"],tags:["Git"]},{name:"Git - 基本原理",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/05.Git - 基本原理.md",wordsCount:672,readingTime:"2.8m",title:"Git - 基本原理",date:"2021-02-08T21:01:48.000Z",permalink:"/git/basic-principles/",categories:["Git"],tags:["Git"]},{name:"Git - SSH免密登录",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/07.Git - SSH免密登录.md",wordsCount:531,readingTime:"2.2m",title:"Git - SSH免密登录",date:"2021-02-08T16:49:21.000Z",permalink:"/git/ssh-login/",categories:["Git"],tags:["Git"]},{name:"Git - IDEA集成",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/09.Git - IDEA集成.md",wordsCount:"2.7k",readingTime:"12.3m",title:"Git - IDEA集成",date:"2021-02-08T18:16:29.000Z",permalink:"/git/idea/",categories:["Git"],tags:["Git"]},{name:"Git - 自建代码托管平台",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/11.Git - 自建代码托管平台.md",wordsCount:"1.2k",readingTime:"5.3m",title:"Git - 自建代码托管平台",date:"2021-02-08T18:52:23.000Z",permalink:"/git/built-code-platform/",categories:["Git"],tags:["Git"]},{name:"Git - Commit常用表情",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/15.Git - Commit常用表情.md",wordsCount:"1.3k",readingTime:"7m",title:"Git - Commit常用表情",date:"2021-02-08T21:15:54.000Z",permalink:"/git/commit-emo/",categories:["Git"],tags:["Git"]},{name:"变更Git作者邮箱信息",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/20.开发管理 - Git/16.变更Git作者邮箱信息.md",wordsCount:452,readingTime:"2.1m",title:"变更Git作者邮箱信息",date:"2025-02-11T03:56:22.000Z",permalink:"/pages/c87550/",categories:["工具","开发管理 - Git"],tags:[null]},{name:"Babel与webpack",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/40.工具/30.构建工具-webpack/01.Babel与webpack.md",wordsCount:"6.3k",readingTime:"29.6m",title:"Babel与webpack",date:"2021-05-25T00:58:24.000Z",permalink:"/pages/c955d9/",categories:["工具","webpack"],tags:[null]},{name:"费曼学习法",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/00.费曼学习法.md",wordsCount:380,readingTime:"1.3m",title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/more/feynmanLearningMethod/",categories:["更多","学习"],tags:["学习方法"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"笔记方法",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/01.笔记方法.md",wordsCount:192,readingTime:"1",title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/pages/e60c81/",categories:["更多","学习"],tags:["笔记方法"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"提高学习效率的策略",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/02.提高学习效率的策略.md",wordsCount:"2.9k",readingTime:"9.6m",title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/pages/a8692ab3bdcb4588",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"提高记忆的技巧",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/03.提高记忆的技巧.md",wordsCount:232,readingTime:"1",title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/pages/996822b2a2ca6e3b",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"自律小建议",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/04.自律小建议.md",wordsCount:522,readingTime:"1.9m",title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/pages/c3f302a03c8daf79",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"处理问题的思路",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/05.处理问题的思路.md",wordsCount:265,readingTime:"1m",title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/pages/9ba2b8fb13de1957",categories:["更多","学习"],tags:[null],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"搜索引擎使用技巧",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/01.学习/10.搜索引擎使用技巧.md",wordsCount:523,readingTime:"1.9m",title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/pages/ce818a",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"JavaScript 的三座大山",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/01.JavaScript 的三座大山.md",wordsCount:"2k",readingTime:"7.9m",title:"JavaScript 的三座大山",date:"2021-10-27T00:58:18.000Z",permalink:"/advanced/4b2339/",categories:["更多","进阶"],tags:["Javascript"]},{name:"「硬核JS」垃圾回收机制",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/07.「硬核JS」垃圾回收机制.md",wordsCount:"8.7k",readingTime:"30.3m",title:"「硬核JS」垃圾回收机制",date:"2021-07-06T22:44:44.000Z",permalink:"/pages/ed7042/",categories:["更多","进阶"],tags:[null]},{name:"Javascript 定时器应用技巧讲解",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/10.Javascript 定时器应用技巧讲解.md",wordsCount:622,readingTime:"2.4m",title:"Javascript 定时器应用技巧讲解",date:"2022-01-24T18:04:49.000Z",permalink:"/advanced/55c2e0/",categories:["更多","进阶"],tags:["Javascript"]},{name:"FormData 配合 ajax 异步无刷新上传表格数据",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/20.FormData 配合 ajax 异步无刷新上传表格数据.md",wordsCount:609,readingTime:"2.3m",title:"FormData 配合 ajax 异步无刷新上传表格数据",date:"2022-05-24T17:56:34.000Z",permalink:"/advanced/0735ac/",categories:["更多","进阶"],tags:["ajax"]},{name:"使用git命令行，删除远程分支上的文件or文件夹",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/30.使用git命令行，删除远程分支上的文件or文件夹.md",wordsCount:290,readingTime:"1m",title:"使用git命令行，删除远程分支上的文件or文件夹",date:"2022-01-25T16:39:04.000Z",permalink:"/advanced/39134a/",categories:["更多","进阶"],tags:["Git"]},{name:"git push到远程指定分支(git拉取指定分支代码)",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/31.git push到远程指定分支(git拉取指定分支代码).md",wordsCount:399,readingTime:"1.4m",title:"git push到远程指定分支(git拉取指定分支代码)",date:"2022-01-30T23:40:00.000Z",permalink:"/pages/3190e5/",categories:["更多","进阶"],tags:[null]},{name:"如何快速关联及修改Git远程仓库地址",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/32.如何快速关联及修改Git远程仓库地址.md",wordsCount:277,readingTime:"1.1m",title:"如何快速关联及修改Git远程仓库地址",date:"2022-02-01T15:39:29.000Z",permalink:"/pages/1130ec/",categories:["更多","进阶"],tags:[null]},{name:"后端一次性返回我10万条数据的8种解决方案",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/41.后端一次性返回我10万条数据的8种解决方案.md",wordsCount:"5.6k",readingTime:"22.3m",title:"什么？后端要一次性返回我10万条数据！且看我这8种方案机智应对！",date:"2022-11-01T15:56:40.000Z",permalink:"/pages/77f5b4/",categories:["更多","进阶"],tags:[null]},{name:"虚拟列表，我真的会了！！！",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/42.虚拟列表，我真的会了！！！.md",wordsCount:"6.3k",readingTime:"23.6m",title:"虚拟列表，我真的会了！！！",date:"2022-02-24T19:29:05.000Z",permalink:"/advanced/6f6d13/",categories:["更多","进阶"],tags:[null]},{name:"Vue中实现右键自定义菜单",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/43.Vue中实现右键自定义菜单.md",wordsCount:799,readingTime:"4.3m",title:"Vue中实现右键自定义菜单",date:"2021-07-13T09:56:28.000Z",permalink:"/pages/39df27/",categories:["更多","进阶"],tags:[null]},{name:"大文件上传技术实现",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/44.大文件上传技术实现.md",wordsCount:"5.2k",readingTime:"21.5m",title:"大文件上传技术实现",date:"2023-05-17T21:39:14.000Z",permalink:"/pages/08929e/",categories:["更多","进阶"],tags:[null]},{name:"面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/50.面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见.md",wordsCount:"1.7k",readingTime:"7.1m",title:"面试官问我按钮级别权限怎么控制，我说v-if，面试官说再见",date:"2022-01-27T01:22:05.000Z",permalink:"/advanced/e561b0/",categories:["更多","进阶"],tags:["Vue"]},{name:"移动端适配方案",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/60.移动端适配方案.md",wordsCount:"1.2k",readingTime:"4.9m",title:"移动端适配方案",date:"2022-02-02T20:11:49.000Z",permalink:"/pages/4546c7/",categories:["更多","进阶"],tags:[null]},{name:"移动端H5-iPhone安全距离适配",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/61.移动端H5-iPhone安全距离适配.md",wordsCount:"1.2k",readingTime:"5.2m",title:"移动端H5-iPhone安全距离适配",date:"2022-02-11T23:48:02.000Z",permalink:"/pages/a7d5db/",categories:["更多","进阶"],tags:["CSS"]},{name:"H5页面高德定位打卡功能",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/02.进阶/62.H5页面高德定位打卡功能.md",wordsCount:"1.7k",readingTime:"8.2m",title:"H5页面高德定位打卡功能",date:"2022-04-10T02:24:48.000Z",permalink:"/pages/587043/",categories:["更多","进阶"],tags:[null]},{name:"面试问题集锦",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/04.面试/01.面试问题集锦.md",wordsCount:"6.8k",readingTime:"22.8m",title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/more/interview/",categories:["更多","面试"],tags:["面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"JS",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/01.JS.md",wordsCount:"8.6k",readingTime:"30.8m",title:"JS",date:"2022-03-03T14:59:21.000Z",permalink:"/pages/e4dc2c/",categories:["更多","技术面"],tags:["Javascript","面试总结"]},{name:"CSS",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/02.CSS.md",wordsCount:"1.6k",readingTime:"6.2m",title:"CSS",date:"2021-10-22T19:17:22.000Z",permalink:"/pages/26cc37/",categories:["更多","技术面"],tags:["CSS","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"浏览器&http",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/03.浏览器&http.md",wordsCount:"6.2k",readingTime:"21.9m",title:"浏览器&http",date:"2022-03-03T15:02:16.000Z",permalink:"/pages/d178b0/",categories:["更多","技术面"],tags:["面试总结"]},{name:"Vue",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/04.Vue.md",wordsCount:"7.1k",readingTime:"26.1m",title:"Vue",date:"2022-03-16T08:37:51.000Z",permalink:"/more/interview-vue/",categories:["更多","技术面"],tags:["Vue","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"new vue主体流程",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/07.new vue主体流程.md",wordsCount:820,readingTime:"3.3m",title:"new Vue的流程",date:"2022-03-20T17:54:52.000Z",permalink:"/pages/3d4029/",titleTag:"原创",sticky:2,categories:["更多","技术面"],tags:["Vue","面试总结"]},{name:"Vue2响应式源码",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/08.Vue2响应式源码.md",wordsCount:"7.3k",readingTime:"27.8m",title:"Vue2响应式源码",date:"2022-03-15T21:54:22.000Z",permalink:"/pages/053424/",titleTag:"原创",sticky:1,categories:["更多","技术面"],tags:["Vue","面试总结"]},{name:"Vue2 Diff 算法",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/05.技术面/09.Vue2 Diff 算法.md",wordsCount:"5.1k",readingTime:"19.9m",title:"Vue2 Diff 算法",date:"2022-01-23T14:48:41.000Z",permalink:"/pages/e1d719/",categories:["更多","技术面"],tags:["Vue","面试总结"],author:{name:"Ming",link:"https://github.com/Ming-D-W"}},{name:"友情连接",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/55.更多/99.友情连接.md",wordsCount:469,readingTime:"2.3m",title:"友情连接",date:"2021-10-28T12:52:20.000Z",permalink:"/friends",article:!1,sidebar:!1,comment:!0},{name:"网站轮子",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/75.收藏夹/01.网站轮子.md",wordsCount:"2.8k",readingTime:"12.4m",title:"网站轮子",permalink:"/whell/web/",date:"2020-04-19T11:33:04.000Z",article:!1},{name:"前端轮子",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/75.收藏夹/02.前端轮子.md",wordsCount:272,readingTime:"1.4m",title:"前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/whell/front",article:!1},{name:"插件选择",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/75.收藏夹/03.插件选择.md",wordsCount:265,readingTime:"1.2m",title:"插件轮子",date:"2021-10-28T16:27:50.000Z",permalink:"/plugins",article:!1},{name:"自我 - 介绍",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/02.自我 - 介绍.md",wordsCount:"1k",readingTime:"5.4m",title:"自我 - 介绍",date:"2021-07-30T22:29:33.000Z",permalink:"/about/me/introduce/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"]},{name:"自我 - 清单",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/05.自我 - 清单.md",wordsCount:"5.8k",readingTime:"28.6m",title:"自我 - 清单",date:"2021-11-13T12:31:23.000Z",permalink:"/about/list/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"]},{name:"自我 - 学习线",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/07.自我 - 学习线.md",wordsCount:"1.8k",readingTime:"8.4m",title:"自我 - 学习线",date:"2021-11-13T15:09:47.000Z",permalink:"/about/learn-line/",titleTag:"原创",categories:["关于 - 自我"],tags:["关于"]},{name:"自我 - 尊贵公子",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/09.自我 - 尊贵公子.md",wordsCount:592,readingTime:"2m",title:"自我 - 尊贵公子",date:"2022-02-19T19:01:31.000Z",permalink:"/about/qin-yu/",private:!0,titleTag:"原创",categories:["关于 - 自我"],tags:["关于"]},{name:"自我 - 温润少年",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/11.自我 - 温润少年.md",wordsCount:711,readingTime:"2.4m",title:"自我 - 温润少年",date:"2022-02-19T19:05:15.000Z",permalink:"/about/liang-shi-bo/",private:!0,titleTag:"原创",categories:["关于 - 自我"],tags:["关于"]},{name:"自我 - 说明",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/03.关于 - 自我/13.自我 - 说明.md",wordsCount:"1.5k",readingTime:"5m",title:"自我 - 说明",date:"2021-11-03T01:24:12.000Z",permalink:"/about/me/explain/",titleTag:"原创",private:!0,categories:["关于 - 自我"],tags:["关于"]},{name:"本站 - 介绍",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/01.本站 - 介绍.md",wordsCount:"2.2k",readingTime:"8.1m",title:"本站 - 介绍",date:"2021-11-01T11:03:34.000Z",permalink:"/about/website/introduce",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 规划",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/02.本站 - 规划.md",wordsCount:366,readingTime:"1.5m",title:"本站 - 规划",date:"2021-11-01T12:02:37.000Z",permalink:"/about/website/plan/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 搭建",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/05.本站 - 搭建.md",wordsCount:"2.8k",readingTime:"11.5m",title:"本站 - 搭建",date:"2021-10-31T14:54:34.000Z",permalink:"/about/website/build/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 主题",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/07.本站 - 主题.md",wordsCount:"3.2k",readingTime:"12.2m",title:"本站 - 主题",date:"2021-11-07T17:32:31.000Z",permalink:"/about/website/theme/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 网站部署",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/10.本站 - 网站部署.md",wordsCount:"7.7k",readingTime:"31.7m",title:"本站 - 网站部署",date:"2021-11-01T15:32:38.000Z",permalink:"/about/website/deploy/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 服务器部署",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/12.本站 - 服务器部署.md",wordsCount:"8.9k",readingTime:"36m",title:"本站 - 服务器部署",date:"2021-12-03T12:23:14.000Z",permalink:"/about/website/server/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 评论模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/14.本站 - 评论模块.md",wordsCount:"4.1k",readingTime:"16.7m",title:"本站 - 评论模块",date:"2021-10-29T16:13:12.000Z",permalink:"/about/website/comment/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 站点信息模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/16.本站 - 站点信息模块.md",wordsCount:"12.1k",readingTime:"58.3m",title:"本站 - 站点信息模块",date:"2021-12-30T21:44:18.000Z",permalink:"/about/website/info/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 自定义样式模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/18.本站 - 自定义样式模块.md",wordsCount:"1.9k",readingTime:"9m",title:"本站 - 自定义样式模块",date:"2022-01-01T20:15:16.000Z",permalink:"/about/website/style/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 记录阅读文章模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/20.本站 - 记录阅读文章模块.md",wordsCount:"1.1k",readingTime:"4.9m",title:"本站 - 记录曾阅读位置模块",date:"2022-01-04T15:44:12.000Z",permalink:"/about/website/lastReading/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 私密文章模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/22.本站 - 私密文章模块.md",wordsCount:"6.4k",readingTime:"26.9m",title:"本站 - 私密文章模块",date:"2022-01-07T17:05:56.000Z",permalink:"/about/website/private/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 导航站模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/24.本站 - 导航站模块.md",wordsCount:"1.3k",readingTime:"6.3m",title:"本站 - 导航站模块",date:"2022-01-11T14:03:46.000Z",permalink:"/about/website/tools/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 首页大图模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/26.本站 - 首页大图模块.md",wordsCount:"7.3k",readingTime:"36m",title:"本站 - 首页大图模块",date:"2022-01-12T23:35:41.000Z",permalink:"/about/website/index-big-img/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 代码块隐藏模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/28.本站 - 代码块隐藏模块.md",wordsCount:"2.5k",readingTime:"10.9m",title:"本站 - 代码块隐藏模块",date:"2022-02-13T19:18:07.000Z",permalink:"/about/website/code-block-hidden/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"本站 - 全局时间提示模块",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/06.关于 - 本站/30.本站 - 全局时间提示模块.md",wordsCount:"1.6k",readingTime:"7.2m",title:"本站 - 全局时间提示模块",date:"2022-02-13T21:26:37.000Z",permalink:"/about/website/global-tip/",titleTag:"原创",categories:["关于 - 本站"],tags:["本站"]},{name:"首页 - 部署",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/08.关于 - 首页/02.首页 - 部署.md",wordsCount:"7.6k",readingTime:"35.2m",title:"首页 - 部署",date:"2021-12-09T21:57:35.000Z",permalink:"/about/index/younngkbt/",titleTag:"原创",categories:["关于 - 首页"],tags:["首页"]},{name:"首页 - 下载站点",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/08.关于 - 首页/04.首页 - 下载站点.md",wordsCount:"1.4k",readingTime:"5.6m",title:"首页 - 下载站点",date:"2021-12-14T21:43:11.000Z",permalink:"/about/index/download/",titleTag:"原创",categories:["关于 - 首页"],tags:["首页"]},{name:"技巧 - 笔记",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/09.关于 - 技巧/02.技巧 - 笔记.md",wordsCount:"3.4k",readingTime:"14.8m",title:"技巧 - 笔记",date:"2021-10-28T18:21:33.000Z",permalink:"/about/mdskill/",titleTag:"优质",categories:["关于 - 技巧"],tags:["技巧"]},{name:"技巧 - 排版",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/09.关于 - 技巧/04.技巧 - 排版.md",wordsCount:"2.8k",readingTime:"11.2m",title:"技巧 - 排版",date:"2021-11-13T17:19:20.000Z",permalink:"/about/typesetting/",titleTag:"优质",categories:["关于 - 技巧"],tags:["技巧"]},{name:"随笔 - 目录",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/80.关于/12.关于 - 随笔/01.随笔 - 目录.md",wordsCount:57,readingTime:"1",title:"随笔 - 目录",date:"2022-01-09T23:35:16.000Z",permalink:"/posts/category/",sidebar:!1,article:!1,comment:!1,editLink:!1,categories:[null],tags:[null]},{name:"全局私密文章测试",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/90.私密文章测试/01.全局私密文章测试.md",wordsCount:163,readingTime:"1",title:"全局私密文章测试",date:"2022-01-07T17:00:36.000Z",permalink:"/private/test1/",private:!0,titleTag:"测试",categories:["测试"],tags:[null]},{name:"单个私密文章测试",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/90.私密文章测试/03.单个私密文章测试.md",wordsCount:272,readingTime:"1.1m",title:"单个私密文章测试",date:"2022-01-07T17:01:37.000Z",permalink:"/private/test2/",titleTag:"测试",private:!0,username:"vdoing",password:123456,expire:"7h",loginInfo:[{username:"1",password:"1"},{username:"2",password:"2"}],categories:["测试"],tags:[null]},{name:"Github - 好看的主页",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/技术随笔/Github - 好看的主页.md",wordsCount:536,readingTime:"2.4m",title:"Github - 好看的主页",date:"2022-01-09T17:35:33.000Z",permalink:"/github/index/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"右键打开 IDEA 和 VSCode",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/技术随笔/右键打开 IDEA 和 VSCode.md",wordsCount:"2.4k",readingTime:"9.4m",title:"右键打开 IDEA 和 VSCode",date:"2022-07-28T09:31:06.000Z",permalink:"/right-click/idea-vscode/",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"技术随笔 - 360天擎关闭",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/技术随笔/技术随笔 - 360天擎关闭.md",wordsCount:123,readingTime:"1",title:"技术随笔 - 360天擎关闭",date:"2022-02-22T09:09:19.000Z",permalink:"/360/system/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"技术随笔 - Java启动的-D参数",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/技术随笔/技术随笔 - Java启动的-D参数.md",wordsCount:249,readingTime:"1.1m",title:"技术随笔 - Java启动的-D参数",date:"2022-03-02T09:27:00.000Z",permalink:"/java/d/",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"技术随笔 - 域名解析",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/技术随笔/技术随笔 - 域名解析.md",wordsCount:"1.1k",readingTime:"4m",title:"技术随笔 - 域名解析",date:"2021-12-01T23:21:36.000Z",permalink:"/domain/name/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"生活随笔 - 习惯",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/生活随笔/生活随笔 - 习惯.md",wordsCount:"2.3k",readingTime:"7.7m",title:"生活随笔 - 习惯",date:"2022-02-19T18:46:39.000Z",permalink:"/live-posts/habit/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},{name:"生活随笔 - 美词",filePath:"/Users/dawu/Desktop/Blog/Ming-D-W.github.io/docs/_posts/生活随笔/生活随笔 - 美词.md",wordsCount:603,readingTime:"2m",title:"生活随笔 - 美词",date:"2022-02-19T18:42:09.000Z",permalink:"/live-posts/beautiful-words/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500},privatePage:{openPrivate:!0,username:"youngkbt",password:"kbt648621",expire:"1d",loginPath:"/vdoing/login/",loginKey:"vdoing_manager",loginSession:!1,firstLogin:0,firstLoginKey:"vdoing_first_login",loginInfo:{"/private/test1/":[{username:"vdoing",password:"123456"}],vdoing_first_login:[{username:"vdoing",password:"123456"}]}},indexImg:{navColor:2,switchNavColor:!0,bgTimeColor:!0,bgTimeColorArray:["transparent","transparent","transparent","transparent"],descFade:!0,desc:["故事由我书写，旅程由你见证，传奇由她聆听 —— 来自 Young Kbt","积跬步以至千里，致敬每个爱学习的你 —— 来自 Evan Xu","这一生波澜壮阔或是不惊都没问题 —— 来自 Weibw"],descFontSize:"1.4rem",descFadeInTime:200,descFadeOutTime:100,descNextTime:800,bubble:!1,bubblePosition:0,bubbleNum:200},author:{name:"Ming",link:"https://github.com/Ming-D-W"},blogger:{avatar:"https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303171033443.png",name:"Da Wu",slogan:"朝圣的使徒，正在走向编程的至高殿堂！"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:wuwanming0405@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Ming-D-W"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/user/home?id=515874856"}]},footer:{createYear:2021,copyrightInfo:'Ming | blog<br><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33019202000592" target="_blank" style="margin-right: 20px; height:20px;line-height:20px;"><img src="https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202304131844613.png" style="height:18px; margin: 0px 5px 0px 0px;"/>浙公网安备 33019202000592号</a> <a href="http://beian.miit.gov.cn/" target="_blank">陇ICP备2023000815号-1</a>'}},locales:{"/":{lang:"zh-CN",title:"Ming's blog",description:"web前端技术博客, VuePress搭建, 使用了 Vdoing 主题,专注web前端学习与总结。学习JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等相关知识, 记录生活和技术路程, 同时分享编程技巧。",path:"/"}}};var dl=t(98),ul=t(99),pl=t(11);var ml={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:i}}=n;return!(e||!1===t||!0===i)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,i=e.frontmatter.sticky;return t&&i?t==i?Object(pl.a)(n,e):t-i:t&&!i?-1:!t&&i?1:Object(pl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(pl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let i=0,a=n.length;i<a;i++){const{frontmatter:{categories:a,tags:o}}=n[i];"array"===Object(pl.n)(a)&&a.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[i]))}),"array"===Object(pl.n)(o)&&o.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[i]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Rt.component(dl.default),Rt.component(ul.default);function hl(n){return n.toString().padStart(2,"0")}t(247);Rt.component("Aplayer",()=>t.e(16).then(t.bind(null,371))),Rt.component("BlockToggle",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,372))),Rt.component("Bubble",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,373))),Rt.component("Card",()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,374))),Rt.component("Fantasy",()=>Promise.all([t.e(0),t.e(8)]).then(t.bind(null,375))),Rt.component("GlobalTip",()=>Promise.all([t.e(0),t.e(9)]).then(t.bind(null,376))),Rt.component("IndexBigImg",()=>Promise.all([t.e(0),t.e(10)]).then(t.bind(null,377))),Rt.component("Login",()=>Promise.all([t.e(0),t.e(11)]).then(t.bind(null,378))),Rt.component("PageInfo",()=>t.e(15).then(t.bind(null,379))),Rt.component("SidebarReverse",()=>t.e(17).then(t.bind(null,380))),Rt.component("Twikoo",()=>Promise.all([t.e(0),t.e(12)]).then(t.bind(null,381))),Rt.component("WebInfo",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,368))),Rt.component("Badge",()=>Promise.all([t.e(0),t.e(13)]).then(t.bind(null,491))),Rt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,98))),Rt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,99)));t(248);var gl=t(96),fl=t.n(gl),vl=t(25);let bl,xl;var yl;"valine"===(yl="gitalk")?t.e(130).then(t.t.bind(null,364,7)).then(n=>xl=n.default):"gitalk"===yl&&Promise.all([t.e(0),t.e(129)]).then(t.t.bind(null,365,7)).then(()=>t.e(128).then(t.t.bind(null,366,7))).then(n=>bl=n.default);function wl(n,e){const t={};return Reflect.ownKeys(n).forEach(i=>{if("string"==typeof n[i])try{t[i]=fl.a.render(n[i],e)}catch(e){console.warn(`Comment config option error at key named "${i}"`),console.warn("More info: "+e.message),t[i]=n[i]}else t[i]=n[i]}),t}console.log(`How to use "gitalk" in ${vl.name}@v${vl.version}:`,vl.homepage);const kl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new bl(wl({clientID:"e88197fb6385926c9d33",clientSecret:"dbb93f54391ab68b4aede08d3b9b373d24014e62",repo:"blog-gitalk-comment",owner:"Ming-D-W",admin:["Ming-D-W"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new xl({...wl({clientID:"e88197fb6385926c9d33",clientSecret:"dbb93f54391ab68b4aede08d3b9b373d24014e62",repo:"blog-gitalk-comment",owner:"Ming-D-W",admin:["Ming-D-W"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},_l="vuepress-plugin-comment";let Tl=null;function Sl(n){return kl.gitalk.clear(_l)}function El(n){return!1!==n.comment&&!1!==n.comments}function jl(n){clearTimeout(Tl);if(document.querySelector("main.page"))return kl.gitalk.render(n,_l);Tl=setTimeout(()=>jl(n),200)}var Il={mounted(){Tl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Sl()&&El(n)&&jl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Sl()&&El(t)&&jl(t)})}},Cl=Object(rl.a)(Il,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,zl={name:"ReadingProgress",data:()=>({readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}),watch:{$readingShow(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:()=>Math.max(document.body.scrollHeight,document.body.offsetHeight,0),getScreenHeight:()=>Math.max(window.innerHeight,document.documentElement.clientHeight,0),getReadingTop:()=>Math.max(window.pageYOffset,document.documentElement.scrollTop,0),getTransform(){const n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find(e=>e in n.style)||void 0},getProgressStyle(){const n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?`${this.transform}: scaleX(${n})`:`width: ${100*n}%`;case"left":case"right":return this.transform?`${this.transform}: scaleY(${n})`:`height: ${100*n}%`;default:return null}}}},Al=(t(253),Object(rl.a)(zl,(function(){var n=this._self._c;return n("ClientOnly",[this.$readingShow?n("div",{staticClass:"reading-progress",class:this.$readingShow},[n("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),Pl={name:"DynamicTitle",data:()=>({originTitle:"",recoverTimeout:null,config:{showIcon:"/favicon.ico",showText:"ヾ(≧▽≦*)o欢迎回来！",hideIcon:"/failure.ico",hideText:"ಥ_ಥ不要走呀！",recoverTime:2e3}}),mounted(){this.originTitle=document.title,""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.addEventListener("visibilitychange",()=>{document.hidden?this.hidden():this.visible()})},methods:{hidden(){""!==this.config.hideIcon&&this.getIconElm().setAttribute("href",this.config.hideIcon),document.title=this.config.hideText,clearTimeout(this.recoverTimeout)},visible(){""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.title=this.config.showText+this.originTitle,this.recoverTimeout=setTimeout(()=>{document.title=this.originTitle},this.config.recoverTime)},getIconElm(){let n=document.querySelector("link[rel=icon]");return null===n&&(n=document.createElement("link"),n.setAttribute("rel","icon"),document.head.appendChild(n)),n}},watch:{$route(n,e){n.path!==e.path&&(this.originTitle=document.title,clearTimeout(this.recoverTimeout))}}},Dl=Object(rl.a)(Pl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,$l=t(97),Bl=t.n($l),Ml=[({Vue:n,options:e,router:t,siteData:i,isServer:a})=>{function o(n,e){try{n.forEach(n=>{if(e.username==n.username&&e.password==n.password)throw new Error})}catch(n){return!1}return!0}function r(n,e,i){throw t.push({path:n,query:{toPath:e,verifyMode:i}}),new Error("请先登录！")}a||i.themeConfig.privatePage&&i.themeConfig.privatePage.openPrivate&&t.beforeEach((n,e,t)=>{try{let{username:e,password:t,loginPath:a,loginKey:s,loginSession:l,loginInfo:c,firstLogin:d,firstLoginKey:u}=i.themeConfig.privatePage;if(!s&&(s="vdoing_manager"),!u&&(u="vdoing_first_login"),l&&window.addEventListener("unload",(function(){localStorage.removeItem(s),localStorage.removeItem(u)})),a==n.path||!a)throw new Error("无需验证");let p=JSON.parse(localStorage.getItem(s));if(p&&p.username==e&&p.password==t){if(!(new Date-p.time>p.expire))throw new Error("管理员验证成功！");localStorage.removeItem(s)}let m=!0;if(1==parseInt(d)||2==parseInt(d)){2==parseInt(d)&&(m=!1);let e=JSON.parse(localStorage.getItem(u));!e&&r(a,n.path,"first"),e&&(c&&c.hasOwnProperty(u)?o(c[u],e)&&r(a,n.path,"first"):r(a,n.path,"first"))}if("/"==n.path)throw new Error("首页不需要验证！");m&&i.pages.forEach(e=>{if(e.path==n.path&&e.frontmatter.private&&1==e.frontmatter.private){l&&window.addEventListener("unload",(function(){localStorage.removeItem(e.frontmatter.permalink)}));let t=JSON.parse(localStorage.getItem(e.frontmatter.permalink));if(!t&&r(a,n.path,e.frontmatter.loginInfo||e.frontmatter.username||e.frontmatter.password||e.frontmatter.expire?"single":"all"),e.frontmatter.username&&e.frontmatter.password||e.frontmatter.loginInfo){!t&&r(a,n.path,"single"),new Date-t.time>t.expire&&(localStorage.removeItem(e.frontmatter.permalink),r(a,n.path,"single"));let i=!0;Array.isArray(e.frontmatter.loginInfo)&&(i=o(e.frontmatter.loginInfo,t)),i&&t.username!==e.frontmatter.username&&t.password!==e.frontmatter.password&&r(a,n.path,"single")}else{let e=!0;c&&c.hasOwnProperty(n.path)&&(e=o(c[n.path],t)),e&&r(a,n.path,"all")}}})}catch(n){}t()})},({Vue:n,options:e,router:t,siteData:i})=>{i.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${hl(n.getUTCMonth()+1)}-${hl(n.getUTCDate())} ${hl(n.getUTCHours())}:${hl(n.getUTCMinutes())}:${hl(n.getUTCSeconds())}`}(e)),t?n.author=t:i.themeConfig.author&&(n.author=i.themeConfig.author)}),n.mixin(ml)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?267c5680c2ffb468ca29c45ffe6801da";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Cl)},({Vue:n})=>{n.component(Al.name,Al),n.mixin({computed:{$readingShow(){return this.$page.frontmatter.readingShow}}})},({Vue:n})=>{n.component("DynamicTitle",Dl)},({Vue:n})=>n.use(Bl.a)],Ll=["PageInfo","BlockToggle","GlobalTip","Fantasy","Comment","ReadingProgress","DynamicTitle"];class Ol extends class{constructor(){this.store=new Rt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Rt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ol.prototype,{getPageAsyncComponent:ss,getLayoutAsyncComponent:ls,getAsyncComponent:cs,getVueComponent:ds});var Nl={install(n){const e=new Ol;n.$vuepress=e,n.prototype.$vuepress=e}};function Fl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Hl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ps("pageKey",e),Rt.component(e)||Rt.component(e,ss(e)),Rt.component(e)?n(e):n("")}},Gl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Vl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},ql=(t(254),t(255),Object(rl.a)(Vl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ul={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Rt.config.productionTip=!1,Rt.use(Ur),Rt.use(Nl),Rt.mixin(function(n,e,t=Rt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},cl)),Rt.component("Content",Hl),Rt.component("ContentSlotsDistributor",Gl),Rt.component("OutboundLink",ql),Rt.component("ClientOnly",Ul),Rt.component("Layout",ls("Layout")),Rt.component("NotFound",ls("NotFound")),Rt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"9d8c24f6"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:cl.routerBase||cl.base,t=new Ur({base:e,mode:"history",fallback:!1,routes:ll,scrollBehavior:(n,e,t)=>t||(n.hash?!Rt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(Fl(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Fl(n,t)?i(t):i()}else i();else{const t=e.path+"/",a=e.path+".html";Fl(n,a)?i(a):Fl(n,t)?i(t):i()}})}(t);const i={};try{await Promise.all(Ml.filter(n=>"function"==typeof n).map(e=>e({Vue:Rt,options:i,router:t,siteData:cl,isServer:n})))}catch(n){console.error(n)}return{app:new Rt(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ll.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);