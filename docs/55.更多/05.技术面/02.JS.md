---
title: JS
date: 2023-03-31 14:59:21
permalink: /pages/e4dc2c/
categories:
  - 更多
  - 技术面
tags:
  - 
---
## 回调函数的概念

> **fs模块** 
>
> fs.writeFile('文件路径'，'编码格式'，function(err,dataStr){})
>
> - fs.writeFile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。**__dirname**为当前目录可以用来拼接文件路径
> - 第二个参数是编码格式，一边采用utf-8 国际码
> - 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。dataStr为读取的文件内容。

JavaScript 语言对异步编程的实现，就是回调函数。**所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。** 它的英语名字 `callback`，直译过来就是"重新调用"。

读取文件进行处理，是这样写的。

```javascript
 fs.readFile('/etc/passwd', function (err, data) {
   if (err) throw err;
   console.log(data);
 });
```

上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。

一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

## 数组的常用方法有哪些?

- join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符

- push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)

- pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）

- shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined

- unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）

- slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变

- splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）

- fill()：使用特定值填充数组中的一个或多个元素(修改原数组)

- filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组

- concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替

- indexOf()：返回当前值在数组中第一次出现位置的索引

- lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。

- every()：判断数组中每一项是否都符合条件

- some()：判断数组中是否存在满足的项

- includes()：判断一个数组是否包含指定的值

- sort(orderfunction):按指定的参数对数组进行排序(修改原数组)

- reverse()：将数组反序(修改原数组)

- forEach()：循环遍历数组每一项（没有返回值）

- map()：循环遍历数组的每一项（有返回值）

- copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）

- find(): 返回第一个匹配的值，并停止查找

- findIndex(): 返回第一个匹配值的索引，并停止查找

- toLocaleString()、toString():将数组转换为字符串

- flat()、flatMap()：扁平化数组

- entries() 、keys() 、values():遍历数组

## 深浅拷贝 递归

**浅拷贝**：对于复杂数据类型浅拷贝拷贝的是地址

**深拷贝**：对于复杂数据类型深拷贝拷贝的是每一项数据(值)

 **浅拷贝方式**：

拷贝对象-Object.assgin()或展开运算符...{obj},

拷贝数组Array.prototype.concat()

**深拷贝方式**：

1.使用lodash库cloneDeep方法 

2.使用JSON.parse(JSON.stringify()) 

3.递归

## 闭包

概念：内层函数有权访问外层函数的作用域的变量就可以形成闭包

**闭包的作用：**

解决变量污染，封闭数据，实现数据私有，外部也可以访问函数内部的变量

**闭包可能引起的问题？**

使函数内部变量存在于内存中，内存消耗大

闭包可能导致内存泄露

**闭包的使用场景**

- setTimeout传参
  - 回调
  - 函数防抖

- 封装私有变量 
  - 实现类和继承

**为什么要使用闭包？**

- 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。

## 作用域链

内部函数访问变量，先在自身作用域找声明，如果没有，往外层找，直到找到全局，如果有，采取就近原则

##  原型链 

**原型继承：**

原型继承: 把父级实例化对象给到子级的原型对象

再把constructor重新指向自己的构造函数

**原型链** : 每一个对象都有自己的原型, 而原型也是对象,也会有自己的原型，此次类推形成链式结构。称之为原型链。(原型链的终点是null) 

**对象访问原型链规则 : ** 就近原则

对象先访问自己的，自己没有就找原型的，原型没有就找原型的原型，一直到原型链终点null.如果还找不到。  属性则获取undefined, 方法则会报错 xxx is not function

## Promise

### Prpmise.all

### async&await

Qingjiu

![iShot_2023-02-19_17.28.38](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303241546652.png)

## 防抖节流

Lodash 的 debounce 和 throttle 的实现

## JS是单线程，为什么能高并发请求