---
title: JS
date: 2022-02-31 14:59:21
permalink: /pages/e4dc2c/
categories:
  - 更多
  - 技术面
tags:
  - Javascript
---

[[TOC]]

## 回调函数的概念

> **fs模块** 
>
> fs.writeFile('文件路径'，'编码格式'，function(err,dataStr){})
>
> - fs.writeFile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。**__dirname**为当前目录可以用来拼接文件路径
> - 第二个参数是编码格式，一边采用utf-8 国际码
> - 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。dataStr为读取的文件内容。

JavaScript 语言对异步编程的实现，就是回调函数。**所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。** 它的英语名字 `callback`，直译过来就是"重新调用"。

读取文件进行处理，是这样写的。

```javascript
 fs.readFile('/etc/passwd', function (err, data) {
   if (err) throw err;
   console.log(data);
 });
```

上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。

一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

## 数组的常用方法有哪些?

- join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符
- push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)
- pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）
- shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined
- unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）
- slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变
- splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）
- fill()：使用特定值填充数组中的一个或多个元素(修改原数组)
- filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组
- concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替
- indexOf()：返回当前值在数组中第一次出现位置的索引
- lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。
- every()：判断数组中每一项是否都符合条件
- some()：判断数组中是否存在满足的项
- includes()：判断一个数组是否包含指定的值
- sort(orderfunction):按指定的参数对数组进行排序(修改原数组)
- reverse()：将数组反序(修改原数组)
- forEach()：循环遍历数组每一项（没有返回值）
- map()：循环遍历数组的每一项（有返回值）
- copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）
- find(): 返回第一个匹配的值，并停止查找
- findIndex(): 返回第一个匹配值的索引，并停止查找
- toLocaleString()、toString():将数组转换为字符串
- flat()、flatMap()：扁平化数组
- entries() 、keys() 、values():遍历数组

## new关键字的执行过程

1. new 构造函数可以在内存中创建一个空的对象

2. this就会指向刚才创建的空对象

3. 执行构造函数里面的代码 给这个空对象添加属性和方法

4. 返回这个对象

## let const(es6)

## Set&Map



## 深浅拷贝 递归

**浅拷贝**：对于复杂数据类型浅拷贝拷贝的是地址

**深拷贝**：对于复杂数据类型深拷贝拷贝的是每一项数据(值)

**浅拷贝方式**：

拷贝对象-Object.assgin()或展开运算符...{obj},

拷贝数组Array.prototype.concat()

**深拷贝方式**：

1. 使用lodash库cloneDeep方法 

2. 使用JSON.parse(JSON.stringify()) 

   **缺点：**

   1. 如果obj里面有时间对象，则JSON。stringify后再JSON。parse的结果，时间将只是字符串的形式。而不是时间对象；
   2. 如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；
   3. 如果obj有函数、undefined，则序列化之后的结果会把函数、undefined丢失。
   4. 如果obj里有NaN、 Infinity和-infinity，则序列化的结果会变成null
   5. JSON.stringify()只能序列化对象的可枚举的自有属性,例如如果obj中的对象是有构造函数生成则使用JSON.parse(JSON.stringify(obj)深拷贝后,会丢弃对象的constructor;
   6. 如果对象中存在循环引用的情况也无法正确实现深拷贝；

3. 递归

## 闭包

概念：内层函数有权访问外层函数的作用域的变量就可以形成闭包

**闭包的作用：**

解决变量污染，封闭数据，实现数据私有，外部也可以访问函数内部的变量

**闭包可能引起的问题？**

使函数内部变量存在于内存中，内存消耗大

闭包可能导致内存泄露

**闭包的使用场景**

- setTimeout传参
  - 回调
  - 函数防抖

- 封装私有变量 
  - 实现类和继承

**为什么要使用闭包？**

- 使用闭包可以延长局部变量的生命周期，不让局部变量使用后立即释放，被删除。

## 作用域链

内部函数访问变量，先在自身作用域找声明，如果没有，往外层找，直到找到全局，如果有，采取就近原则

## this指向



## 事件委托

## 如何理解JS的异步

**JS是一门单线程的语言**，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。

而渲染主线程承担着诸多的工作，渲染页面、执行 JS都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步的方式来避免。 具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。

当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的未尾排队，等待主线程调度执行（这里涉及到JS的事件轮询机制，可以展开讲）。在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

## 事件循环

## 宏任务&微任务

JS中的任务分为宏任务和微任务。

宏任务是指由浏览器或者Node.js环境提供的任务，例如DOM事件、setTimeout、setInterval等等。宏任务的执行顺序由浏览器或者Node.js环境决定，每个宏任务执行完后，会清空微任务队列。

微任务是指在当前宏任务执行完后立即执行的任务，例如Promise.then、MutationObserver等等。微任务的执行时机在宏任务执行完后，会在当前宏任务结束之前执行，也就是说在下一个宏任务之前。微任务执行完后，会清空微任务队列，如果在微任务执行期间产生了新的微任务，那么会在当前微任务队列执行完后继续执行新的微任务队列。

总结一下，宏任务和微任务的执行顺序如下：

1. 执行当前宏任务
2. 执行当前宏任务产生的微任务
3. 执行新的宏任务
4. 重复执行2、3步骤，直到所有任务都执行完毕

需要注意的是，由于微任务的执行时机在宏任务执行完后，所以在同一个宏任务中产生的微任务会在当前宏任务结束之前执行完毕，而不会产生新的宏任务。

##  原型链 

**原型继承：**

原型继承: 把父级实例化对象给到子级的原型对象

再把constructor重新指向自己的构造函数

**原型链** : 每一个对象都有自己的原型, 而原型也是对象,也会有自己的原型，此次类推形成链式结构。称之为原型链。(原型链的终点是null) 

**对象访问原型链规则 : ** 就近原则

对象先访问自己的，自己没有就找原型的，原型没有就找原型的原型，一直到原型链终点null.如果还找不到。  属性则获取undefined, 方法则会报错 xxx is not function

## Promise

### Prpmise.all

### async&await

Qingjiu

![iShot_2023-02-19_17.28.38](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303241546652.png)

## 防抖节流

Lodash 的 debounce 和 throttle 的实现

## JS是单线程，为什么能高并发请求

## 无感知登录

b站小鹿仙
