---
title: Vue
date: 2023-03-16 08:37:51
permalink: /more/interview-vue/
categories:
  - 更多
  - 技术面
tags:
  - 
author: 
  name: Ming
  link: https://github.com/Ming-D-W
---
## 回调函数的概念

> **fs模块** 
>
> fs.writeFile('文件路径'，'编码格式'，function(err,dataStr){})
>
> - fs.writeFile是读取文件的方法，第一个参数是文件路径，可以写绝对路径也可以写相对路径。**__dirname**为当前目录可以用来拼接文件路径
> - 第二个参数是编码格式，一边采用utf-8 国际码
> - 第三个参数是回调函数，err成功时为null，失败时为失败信息。可以用err!==null来判断是否执行成功。dataStr为读取的文件内容。

JavaScript 语言对异步编程的实现，就是回调函数。**所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。** 它的英语名字 `callback`，直译过来就是"重新调用"。

读取文件进行处理，是这样写的。

```javascript
 fs.readFile('/etc/passwd', function (err, data) {
   if (err) throw err;
   console.log(data);
 });
```

上面代码中，readFile 函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了 /etc/passwd 这个文件以后，回调函数才会执行。

一个有趣的问题是，为什么 Node.js 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是 null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。

## 说说new操作符具体干了什么？

## 数组的常用方法有哪些?

- join(separator):将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符

- push()：将参数添加到原数组末尾，并返回数组的长度(修改原数组)

- pop()：删除原数组最后一项，并返回删除元素的值；如果数组为空则返回undefined（修改原数组）

- shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined

- unshift()： 将参数添加到原数组开头，并返回数组的长度（修改原数组）

- slice(start,end):可以截取出数组某部份的元素为一个新的数组，有两个必填的参数，第一个是起始位置，第二个是结束位置( 操作时数字减1 ) 原数组不改变

- splice(start,deleteCount,val1,val2,…):从start位置开始删除deleteCount项，并从该位置起插入。（修改原数组）

- fill()：使用特定值填充数组中的一个或多个元素(修改原数组)

- filter()：过滤,数组中的每一项运行给定函数，返回满足过滤条件组成的数组

- concat()：可以将两个数组合并在一起，如果是使用ES6语法也可以用扩展运算符…来代替

- indexOf()：返回当前值在数组中第一次出现位置的索引

- lastIndexOf()：返回查找的字符串最后出现的位置，如果没有找到匹配字符串则返回 -1。

- every()：判断数组中每一项是否都符合条件

- some()：判断数组中是否存在满足的项

- includes()：判断一个数组是否包含指定的值

- sort(orderfunction):按指定的参数对数组进行排序(修改原数组)

- reverse()：将数组反序(修改原数组)

- forEach()：循环遍历数组每一项（没有返回值）

- map()：循环遍历数组的每一项（有返回值）

- copyWithin(): 从数组的指定位置拷贝元素到数组的另一个指定位置中（修改原数组）

- find(): 返回第一个匹配的值，并停止查找

- findIndex(): 返回第一个匹配值的索引，并停止查找

- toLocaleString()、toString():将数组转换为字符串

- flat()、flatMap()：扁平化数组

- entries() 、keys() 、values():遍历数组

## 深浅拷贝 递归

## 前端如何捕获错误

可以直接用try catch捕获正常代码中的一些错误。但是这只适用于那种同步代码，对于Promise这种类型来说，我们是没有办法try catch直接捕获的。我们对于Promise的异常可以直接在Promise的catch里面去捕获错误，另外，我们可以把Promise放到async和await的函数里面，把它变成类似于同步函数的一个形式，那我们就可以在里面直接使用try catch进行错误捕获。

## Vue

### v-if&v-for

在Vue2中，v-if不能和v-for一起使用的原因是v-for的优先级比v-if高，每创建一个节点都会进行一次判断，造成性能浪费

解决方案有两种，把v-if放在v-for的外层或者写一个计算属性，把数组过滤一遍再拿过来用v-for遍历

### nextTick

如果想要【在修改数据后立刻得到更新后的`DOM`结构/在created钩子函数內获取dom】，可以使用`Vue.nextTick()`

第一个参数为：回调函数（可以获取最近的`DOM`结构）

第二个参数为：执行函数上下文

```js
// 修改数据
vm.message = '修改后的值'
// DOM 还没有更新
console.log(vm.$el.textContent) // 原始的值
Vue.nextTick(function () {
  // DOM 更新了
  console.log(vm.$el.textContent) // 修改后的值
})
```

组件内使用 `vm.$nextTick()` 实例方法只需要通过`this.$nextTick()`，并且回调函数中的 `this` 将自动绑定到当前的 `Vue` 实例上

```js
this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
this.$nextTick(function () {
    console.log(this.$el.textContent) // => '修改后的值'
})
```

`$nextTick()` 会返回一个 `Promise` 对象，可以是用`async/await`完成相同作用的事情

```js
this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
await this.$nextTick()
console.log(this.$el.textContent) // => '修改后的值'
```

[nextTick实现原理（面试官）](https://vue3js.cn/interview/vue/nexttick.html#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)

[nextTick实现原理（源码）](https://juejin.cn/post/7087866362785169416)

[降级方案解读](https://juejin.cn/post/6844903590293684231)



### 组件传值

### keep-alive

### 虚拟dom是什么

Vue的就地复用策略：Vue会尽可能地（同层级），对比虚拟DOM，复用旧DOM的结构，进行差异化更新。

**虚拟DOM**是一个JS对象，是用来描述真实DOM的。真实DOM节点上挂载了太多的属性和方法，对比时性能消耗太大，所以使用虚拟DOM，只保存一些基本的属性。

### diff算法

**diff算法**的策略：

- 当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom上
- 差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程 
- 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较 
- 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的 
- 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。 
- 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。 
- 这样一直递归的遍历下去，直到整棵树完成对比。



diff算法会先比较头部和尾部的节点，头头、尾尾、尾头、头尾，如果没有匹配上就再去依次比较中间的节点，还没有就创新新的dom节点。

在新旧dom比较时，有startIndex和endIndex，匹配到的节点和，会改变index的值。



**没有指定唯一的key时：**

1. 没有key

   此时新旧节点的key都为undefine，所以相同，如果这时tagName也相同就直接复用该节点，同时往下一层级进行比较。

2. key为index

   此时新插入的dom只要位置与原dom位置一致则index相同，即key相同，直接复用并往下层级进行比较。

<span style="color:red;">可以发现当没有key和key为index的时候，diff算法的计算次数是相同的，并没有节省性能。</span>

**指定唯一的key时：**

  找到key和tagName都相同的节点直接复用，不在往下进行比较。

如果在数组中插入一个值，制定了key的就只更新插入的一个dom，未指定key就会更新插入位置开始到最后的dom。



> 因为Vue是双向相应的框架，Data里面的数据只要变化了，它会对应去渲染页面中相关的dom元素，出于渲染效率的考虑，作者在实现的时候实际上把所有页面的dom元素都进行了虚拟化，就是虚拟dom。如果某个数据发生了变化，那么他会考虑性能问题，去比较新的和旧的两个虚拟dom，通过diff算法找到最小的更新路径来更新dom元素，因为JS的运行相比渲染dom的效率是高很多的。



> diff算法他的前提一定是同层级和同类型的的节点,那核心一定是列表循环中的diff算法。说白了，加key之后元素怎么移动、删除和创建。
>
> Vue2.0叫做双端交叉指针，新老Vdom各有两个指针，分别头头、尾尾、尾头、头尾，他会对比4次，如果说4次寻找到元素的key相同，就会去进行复用移动元素的位置。如果说这四种情况都没有匹配，就再去依次比较中间的节点，看老的Vdom里面有没有对应的元素，进行相应的移动删除和创建。
>
> Vue3.0叫做双端快速diff，实际上他也有两个指针，新老Vdom各两个，只对比两种情况，队友和队头，队尾和队尾，如果能匹配上，和vue2.0是一样的。一旦没有匹配上，会触发对新的Vdom去进行最长递增子序列的计算。这套算法说白了是在新的Vdom里寻找依次递增的元素有哪些，找到之后，那这些元素的顺序就是固定的。去寻找不在这些列表里面的元素和老的Vdom进行对比，再进行移动删除和创建。
>
> 不过最长递增子序列这个算法实际上他的时间复杂度是O(n*log(n)),但是在Vue2.0里面他的他的时间复杂度是O(n)。3.0的核心是要减少dom移动，在浏览器中dom的移动它是非常昂贵的，但是JS损失一点也没有关系。所以总体来看损失了JS的性能，但是提升了浏览器dom的渲染效率，总体来讲是利大于弊的。

## 数组转树形结构

方法一：递归函数

```js
function transArrToTree(list,pid) {
  const arr = []
  list.forEach(item => {
    if(item.pid === pid) {
      item.children = transArrToTree(list,item.id)
      arr.push(item)
    }
  })
  return arr
}
```

方法二：map映射

```js
export function transListToTreeUseMap(list) {
  const arr = []
  const map = {}
  list.forEach(item => {
    item.children = []
    map[item.id] = item
  })
  list.forEach(item => {
    if (map[item.pid]) {
      map[item.pid].children.push(item)
    } else {
      arr.push(item)
    }
  })
  return arr
}
```



## 树形扁平化转数组

递归函数

```js
function dataFattening (data) {
  const arr = []
  this.data.forEach(item => {
    if(item.children?.length) {
      arr = [ ...arr, ...dataFattening(item.children) ]
    }esle {
      arr.push(item)
    }
  })
  return arr
}
```

### v-for时候key有什么作用

### 生命周期

### 路由模式

### 路由懒加载

### 跨域

#### 开发环境下解决跨域问题

**webpack反向代理**

跨域是由于浏览器的同源策略，协议、域名、端口号其中任一不同即为跨域，但是服务器和服务器之间不存在跨域。

开发环境下我们启动了本地的localhost服务器，使得浏览器和本地服务器是同源，不存在跨域。

那么我们就让本地服务器转发请求给远程服务器，远程服务器返回数据给本地服务器，本地服务器再转返回给浏览器。

这就是**webpack反向代理**。

![webpack反向代理](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303280925640.png)

#### 生产环境下解决跨域问题

**nginx反向代理**

我们的前端项目部署在一个域名下，接口服务在另一个域名，如果直接请求，由于域名不同，会产生跨域的问题。

## Promise

### Prpmise.all

### async&await

Qingjiu

![iShot_2023-02-19_17.28.38](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303241546652.png)

## Web worker

## 跨页面通信

```js
    const bd = new BroadcastChannel('myChannel');
    var btn = document.querySelector('.btn');
    // 发送参数
    btn.onclick = function () {
        console.log('发送消息')
        bd.postMessage('hello world');
    }
    // 接收参数
    bd.onmessage = function (e) {
        console.log(e.data);
    }
```

项目内以退出登录为例

在utils中新建一个`postMessage.js` 接受参数

```js
import store from '@/store'
import router from '@/router'

const bd = new BroadcastChannel('myChannel')

bd.onmessage = function(e) {
  if (e.data === 'logout') {
    console.log('退出登录')
    // 触发退出登录的action
    store.dispatch('user/logoutAction')
    // 跳转登录界面
    router.push('/login')
  }
}
export default bd
```

触发后发送参数

```js
bd.postMessage('logout')
```

Main.js中引入

```js
import '@/utils/postMessage'
```

## 文件上传

1. 通过element-ui的el-upload进行文件上传

2. 选择文件后触发el-upload组件的change事件，然后通过参数file内部的raw获取到文件对象

3. 将文件对象进行切片

   ●固定数量

   ●固定大小

   比如通过固定大小,切割的文件大小,根据file的size和每块的大小得到切割截取的次数,循环截取逻辑都是通过slice进行文件切片,循环截取.slice方法不是数组的slice方法,文件对象原型上的slice方法,继承自 Blob的slice

4. 断点续传

   ●串行：点击暂停或者上传失败，return终止，这次请求完事后，下一次不在请求了

   ●并行：点击暂停或者上传失败，return终止，取消请求

   ●chunList保存需要传送给后端的chunk，每上传成功一个，将chunkList中对应的chunk删除，下次重新请求从chunkList从头开始上传

5. 全部上传后,发送和并请求,后端会进行合并

6. 文件重新上传考虑文件内容相同文件名不同,上传过的秒传
   spark-MD5根据文件内容生成hash,文件名变化不影响,通过SparckMd5.ArrayBuffer得到一个实例,通过该实例append一个buffer数据流
   通过js api FIleReader 解析文件对象,实例有一个readAsArrayBuffer读取文件对象的流数据,读取是异步的,所以项目利用promise进行封装成功后利用resolve传出
   根据end获取到hash,切两片列表中除了有一个chunk切片数据,还有一个filename: 由hash加索引

## 路由导航守卫

## 登录流程

## 虚拟列表

## 事件总线

## 浏览器&http

### 强缓存&协商缓存

浏览器的缓存主要是为了提高访问效率，什么是**强制缓存** 呢？比如说我们访问一个网站，当我们第一次访问的时候，里面一些静态资源，比如说图片啊CSS，JS这些资源，甚至icon。这些实际上是从服务器上下载的。但是如果说我们刷新网页的话，那这个资源是没有必要在服务器上重新去请求的，因为他没有变动。那像这种资源的话，浏览器会默认是一些强制缓存。那么强制缓存，当你第二次访问的时候，他不会再去服务器上重新下载，同样他会给你返回一个200的状态码，但是这个资源呢，它会从浏览器的本地缓存里去取这种图片，像这种图片第二次去取的缓存的状态，就是一种强制缓存。

**协商缓存** ，就是我们和后台去协商这个资源，要不要对它去进行缓存。如果这个资源是需要协商缓存的，那第一次返回的结果里面的状态码是200，同时会携带一个是否更新Last Modified的一个状态，还会给他返回一个唯一标识etag，可以理解为是一个内容资源的hash。只要说这个资源在服务端没有变化，那么当下次访问的时候，后台会对比这个标签etag，或者说对比这个Last Modified的时间。如果这个资源没有变动，那么他会告诉你返回一个304的状态码，那当浏览器接收到这个304的状态之后，他会认为这个资源没有变化，我只需要从本地把这个缓存的资源拿出来就行了

### http版本

HTTP1.0：

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

服务器完成请求处理后立即断开TCP连接。

简单来讲，每次与服务器交互，都需要新开一个连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，在同一个TCP连接里面，客户端可以同时发送多个请求

- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着

- 新增了一些请求方法，新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式

- 多路复用，只需一个连接即可实现并行

- 使用报头压缩，降低开销

- 服务器推送

HTTP3.0：

- 是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。


### 状态码

**1xx: 请求处理成功状态码**

代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

> 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
>
> 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级

**2xx: 请求处理成功状态码**

代表请求已成功被服务器接收、理解、并接受

> 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
>
> 201（已创建）：请求成功并且服务器创建了新的资源
>
> 202（已创建）：服务器已经接收请求，但尚未处理
>
> 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
>
> 204（无内容）：服务器成功处理请求，但没有返回任何内容
>
> 205（重置内容）：服务器成功处理请求，但没有返回任何内容
>
> 206（部分内容）：服务器成功处理了部分请求

**3xx：请求重定向**

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

> 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
>
> 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
>
> 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
>
> 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
>
> 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
>
> 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

**4xx: 请求失败**

代表了客户端看起来可能发生了错误，妨碍了服务器的处理

> 400（错误请求）： 服务器不理解请求的语法
>
> 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>
> 403（禁止）： 服务器拒绝请求
>
> 404（未找到）： 服务器找不到请求的网页
>
> 405（方法禁用）： 禁用请求中指定的方法
>
> 406（不接受）： 无法使用请求的内容特性响应请求的网页
>
> 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
>
> 408（请求超时）： 服务器等候请求时发生超时

**5xx：服务器问题**

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

> 500（服务器内部错误）：服务器遇到错误，无法完成请求
>
> 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
>
> 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
>
> 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
>
> 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
>
> 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## JSBridge

[前端H5与客户端Native交互原理 - JSBridge双向通信机制的实现](https://juejin.cn/post/7114282473164374029)

## 项目发布上线真实流程到底是什么？

1. 一般情况下发布上线不会由普通开发者直接操作。
2. devlopment
3. Master
   1. 只需要负责把代码提交到git远程仓库里面 【git push】
   2. 代码push上去之后会自动的执行发布上线的流程
   3. 代码push上去之后会自动的执行发布上线的流程
   4. jekins配置的时候，写死一些脚本
   5. jenkins的服务可以实现
   6. 功能分支 /login
   7. 检测特定分支的提交 【dev 二部署到开发环境】【master ＞ 部署到线上环境】

## 布局容器

Layout 布局

Container 布局容器

## 防抖节流

Lodash 的 debounce 和 throttle 的实现
