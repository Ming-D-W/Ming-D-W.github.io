---
title: Vue
date: 2023-03-16 08:37:51
permalink: /more/interview-vue/
categories:
  - 更多
  - 技术面
tags:
  - 
author: 
  name: Ming
  link: https://github.com/Ming-D-W
---


## 说说new操作符具体干了什么？

## 前端如何捕获错误

可以直接用try catch捕获正常代码中的一些错误。但是这只适用于那种同步代码，对于Promise这种类型来说，我们是没有办法try catch直接捕获的。我们对于Promise的异常可以直接在Promise的catch里面去捕获错误，另外，我们可以把Promise放到async和await的函数里面，把它变成类似于同步函数的一个形式，那我们就可以在里面直接使用try catch进行错误捕获。

## Vue

### v-if&v-for

在Vue2中，v-if不能和v-for一起使用的原因是v-for的优先级比v-if高，每创建一个节点都会进行一次判断，造成性能浪费

解决方案有两种，把v-if放在v-for的外层或者写一个计算属性，把数组过滤一遍再拿过来用v-for遍历

### nextTick

如果想要【在修改数据后立刻得到更新后的`DOM`结构/在created钩子函数內获取dom】，可以使用`Vue.nextTick()`

第一个参数为：回调函数（可以获取最近的`DOM`结构）

第二个参数为：执行函数上下文

```js
// 修改数据
vm.message = '修改后的值'
// DOM 还没有更新
console.log(vm.$el.textContent) // 原始的值
Vue.nextTick(function () {
  // DOM 更新了
  console.log(vm.$el.textContent) // 修改后的值
})
```

组件内使用 `vm.$nextTick()` 实例方法只需要通过`this.$nextTick()`，并且回调函数中的 `this` 将自动绑定到当前的 `Vue` 实例上

```js
this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
this.$nextTick(function () {
    console.log(this.$el.textContent) // => '修改后的值'
})
```

`$nextTick()` 会返回一个 `Promise` 对象，可以是用`async/await`完成相同作用的事情

```js
this.message = '修改后的值'
console.log(this.$el.textContent) // => '原始的值'
await this.$nextTick()
console.log(this.$el.textContent) // => '修改后的值'
```

[nextTick实现原理（面试官）](https://vue3js.cn/interview/vue/nexttick.html#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF)

[nextTick实现原理（源码）](https://juejin.cn/post/7087866362785169416)

[降级方案解读](https://juejin.cn/post/6844903590293684231)



### 组件传值

### v-for时候key有什么作用

### 生命周期

### 路由模式

### 路由懒加载

### keep-alive

### 虚拟dom是什么

Vue的就地复用策略：Vue会尽可能地（同层级），对比虚拟DOM，复用旧DOM的结构，进行差异化更新。

**虚拟DOM**是一个JS对象，是用来描述真实DOM的。真实DOM节点上挂载了太多的属性和方法，对比时性能消耗太大，所以使用虚拟DOM，只保存一些基本的属性。

### diff算法

**diff算法**的策略：

- 当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom上
- 差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程 
- 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较 
- 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的 
- 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。 
- 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。 
- 这样一直递归的遍历下去，直到整棵树完成对比。



diff算法会先比较头部和尾部的节点，头头、尾尾、尾头、头尾，如果没有匹配上就再去依次比较中间的节点，还没有就创新新的dom节点。

在新旧dom比较时，有startIndex和endIndex，匹配到的节点和，会改变index的值。



**没有指定唯一的key时：**

1. 没有key

   此时新旧节点的key都为undefine，所以相同，如果这时tagName也相同就直接复用该节点，同时往下一层级进行比较。

2. key为index

   此时新插入的dom只要位置与原dom位置一致则index相同，即key相同，直接复用并往下层级进行比较。

<span style="color:red;">可以发现当没有key和key为index的时候，diff算法的计算次数是相同的，并没有节省性能。</span>

**指定唯一的key时：**

  找到key和tagName都相同的节点直接复用，不在往下进行比较。

如果在数组中插入一个值，制定了key的就只更新插入的一个dom，未指定key就会更新插入位置开始到最后的dom。



> 因为Vue是双向相应的框架，Data里面的数据只要变化了，它会对应去渲染页面中相关的dom元素，出于渲染效率的考虑，作者在实现的时候实际上把所有页面的dom元素都进行了虚拟化，就是虚拟dom。如果某个数据发生了变化，那么他会考虑性能问题，去比较新的和旧的两个虚拟dom，通过diff算法找到最小的更新路径来更新dom元素，因为JS的运行相比渲染dom的效率是高很多的。



> diff算法他的前提一定是同层级和同类型的的节点,那核心一定是列表循环中的diff算法。说白了，加key之后元素怎么移动、删除和创建。
>
> Vue2.0叫做双端交叉指针，新老Vdom各有两个指针，分别头头、尾尾、尾头、头尾，他会对比4次，如果说4次寻找到元素的key相同，就会去进行复用移动元素的位置。如果说这四种情况都没有匹配，就再去依次比较中间的节点，看老的Vdom里面有没有对应的元素，进行相应的移动删除和创建。
>
> Vue3.0叫做双端快速diff，实际上他也有两个指针，新老Vdom各两个，只对比两种情况，队友和队头，队尾和队尾，如果能匹配上，和vue2.0是一样的。一旦没有匹配上，会触发对新的Vdom去进行最长递增子序列的计算。这套算法说白了是在新的Vdom里寻找依次递增的元素有哪些，找到之后，那这些元素的顺序就是固定的。去寻找不在这些列表里面的元素和老的Vdom进行对比，再进行移动删除和创建。
>
> 不过最长递增子序列这个算法实际上他的时间复杂度是O(n*log(n)),但是在Vue2.0里面他的他的时间复杂度是O(n)。3.0的核心是要减少dom移动，在浏览器中dom的移动它是非常昂贵的，但是JS损失一点也没有关系。所以总体来看损失了JS的性能，但是提升了浏览器dom的渲染效率，总体来讲是利大于弊的。

## 数组转树形结构

方法一：递归函数

```js
function transArrToTree(list,pid) {
  const arr = []
  list.forEach(item => {
    if(item.pid === pid) {
      item.children = transArrToTree(list,item.id)
      arr.push(item)
    }
  })
  return arr
}
```

方法二：map映射

```js
export function transListToTreeUseMap(list) {
  const arr = []
  const map = {}
  list.forEach(item => {
    item.children = []
    map[item.id] = item
  })
  list.forEach(item => {
    if (map[item.pid]) {
      map[item.pid].children.push(item)
    } else {
      arr.push(item)
    }
  })
  return arr
}
```



## 树形扁平化转数组

递归函数

```js
function dataFattening (data) {
  const arr = []
  this.data.forEach(item => {
    if(item.children?.length) {
      arr = [ ...arr, ...dataFattening(item.children) ]
    }esle {
      arr.push(item)
    }
  })
  return arr
}
```



## Web worker

## 跨页面通信

```js
    const bd = new BroadcastChannel('myChannel');
    var btn = document.querySelector('.btn');
    // 发送参数
    btn.onclick = function () {
        console.log('发送消息')
        bd.postMessage('hello world');
    }
    // 接收参数
    bd.onmessage = function (e) {
        console.log(e.data);
    }
```

项目内以退出登录为例

在utils中新建一个`postMessage.js` 接受参数

```js
import store from '@/store'
import router from '@/router'

const bd = new BroadcastChannel('myChannel')

bd.onmessage = function(e) {
  if (e.data === 'logout') {
    console.log('退出登录')
    // 触发退出登录的action
    store.dispatch('user/logoutAction')
    // 跳转登录界面
    router.push('/login')
  }
}
export default bd
```

触发后发送参数

```js
bd.postMessage('logout')
```

Main.js中引入

```js
import '@/utils/postMessage'
```

## 文件上传

1. 通过element-ui的el-upload进行文件上传

2. 选择文件后触发el-upload组件的change事件，然后通过参数file内部的raw获取到文件对象

3. 将文件对象进行切片

   ●固定数量

   ●固定大小

   比如通过固定大小,切割的文件大小,根据file的size和每块的大小得到切割截取的次数,循环截取逻辑都是通过slice进行文件切片,循环截取.slice方法不是数组的slice方法,文件对象原型上的slice方法,继承自 Blob的slice

4. 断点续传

   ●串行：点击暂停或者上传失败，return终止，这次请求完事后，下一次不在请求了

   ●并行：点击暂停或者上传失败，return终止，取消请求

   ●chunList保存需要传送给后端的chunk，每上传成功一个，将chunkList中对应的chunk删除，下次重新请求从chunkList从头开始上传

5. 全部上传后,发送和并请求,后端会进行合并

6. 文件重新上传考虑文件内容相同文件名不同,上传过的秒传
   spark-MD5根据文件内容生成hash,文件名变化不影响,通过SparckMd5.ArrayBuffer得到一个实例,通过该实例append一个buffer数据流
   通过js api FIleReader 解析文件对象,实例有一个readAsArrayBuffer读取文件对象的流数据,读取是异步的,所以项目利用promise进行封装成功后利用resolve传出
   根据end获取到hash,切两片列表中除了有一个chunk切片数据,还有一个filename: 由hash加索引

## 路由导航守卫

## 登录流程

## 虚拟列表

## 事件总线

## JSBridge

[前端H5与客户端Native交互原理 - JSBridge双向通信机制的实现](https://juejin.cn/post/7114282473164374029)

## 项目发布上线真实流程到底是什么？

1. 一般情况下发布上线不会由普通开发者直接操作。
2. devlopment
3. Master
   1. 只需要负责把代码提交到git远程仓库里面 【git push】
   2. 代码push上去之后会自动的执行发布上线的流程
   3. 代码push上去之后会自动的执行发布上线的流程
   4. jekins配置的时候，写死一些脚本
   5. jenkins的服务可以实现
   6. 功能分支 /login
   7. 检测特定分支的提交 【dev 二部署到开发环境】【master ＞ 部署到线上环境】

## 布局容器

Layout 布局

Container 布局容器

1. 
