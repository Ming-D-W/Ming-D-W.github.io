---
title: 浏览器&http
date: 2022-02-31 15:02:16
permalink: /pages/d178b0/
categories:
  - 更多
  - 技术面
tags:
  - 
---


## 强缓存&协商缓存

浏览器的缓存主要是为了提高访问效率，什么是**强制缓存** 呢？比如说我们访问一个网站，当我们第一次访问的时候，里面一些静态资源，比如说图片啊CSS，JS这些资源，甚至icon。这些实际上是从服务器上下载的。但是如果说我们刷新网页的话，那这个资源是没有必要在服务器上重新去请求的，因为他没有变动。那像这种资源的话，浏览器会默认是一些强制缓存。那么强制缓存，当你第二次访问的时候，他不会再去服务器上重新下载，同样他会给你返回一个200的状态码，但是这个资源呢，它会从浏览器的本地缓存里去取这种图片，像这种图片第二次去取的缓存的状态，就是一种强制缓存。

**协商缓存** ，就是我们和后台去协商这个资源，要不要对它去进行缓存。如果这个资源是需要协商缓存的，那第一次返回的结果里面的状态码是200，同时会携带一个是否更新Last Modified的一个状态，还会给他返回一个唯一标识etag，可以理解为是一个内容资源的hash。只要说这个资源在服务端没有变化，那么当下次访问的时候，后台会对比这个标签etag，或者说对比这个Last Modified的时间。如果这个资源没有变动，那么他会告诉你返回一个304的状态码，那当浏览器接收到这个304的状态之后，他会认为这个资源没有变化，我只需要从本地把这个缓存的资源拿出来就行了

## 在浏览器里输入url会经历哪些流程？

1. DNS解析：将域名转化为IP地址
2. 浏览器根据IP地址向服务器发起http请求
3. 服务器处理http请求，并将数据给返回浏览器
4. 浏览器根据html代码生成DOM Tree，根据 CSS代码生成CSSOM(CSS Object Model_**CSS对象模型**)
5. 将DOM Tree和CSSOM整合成Render Tree(渲染树)
6. 根据Render Tree渲染页面
7. 遇到`<script>`则暂停渲染，优先加载执行js代码
8. 执行完毕继续渲染，直到全部渲染完成

### 问1： 为什么把CSS加载放在head里？

如果我们把css加载放在最后，这时候页面已经渲染完成了，然后发现css改变了，还有重新一个个去查找渲染一遍，这样就拖慢了页面渲染的速度

### 问2：为什么要把js加载放着body最后？

因为遇到`<script>`会暂停渲染，如果把js加载放在前面，这时页面还没渲染完，暂停住了，就加长了整个页面渲染的时间。

## 性能优化

### 1. 浏览器加载资源优化

- 减少资源体积：压缩代码

- webpack打包会压缩代码

- 减少访问次数：合并代码，ssr（服务端渲染），缓存

- 合并代码

```js
//三次网络请求
<script src="a. js"></script> 
<script src="b. is"></script> 
<script src="c. js"></script>

//合并成一次网络请求,网络请求减少了 
<script src="abc.js"></script>
```

- 缓存(强缓存&协商缓存)

- SSR：服务端渲染

- SSR(前后端不分离）：将网页和数据一起加载

- 非SSR（前后端分离）：先加载网页，再加载数据，再渲染数据

- 早先的jsp，asp都属于ssr。

- 使用更快的网络：CDN

### 2. 浏览器渲染优化

- CSS放着head，JS放在body最下面

- 尽早开始执行JS，页面渲染完之后马上开始执行js，不要在图片资源加载完后才去执行JS

- 图片懒加载

  用户看到第一屏的图片先加载，在屏幕之外的图片先加载一张本地预览图片，等用户滑动到的时候再加载，如果用户快速滑动，会先显示一张预览图片的占个位，等到网络请求完成了，预览图就变成了真正的网络请求下来的图片。

- 对DOM查询操作进行缓存

- 频繁的DOM操作，合并到一起插入DOM结构(减少回流)

- 节流**throttle**

  拖拽一个元素时，要随时拿到该元素的被拖拽的位置，直接使用原生事件会频繁触发，很容易造成卡顿。无论拖拽多快，我们可以每隔500ms触发一次

- 防抖**debounce**

  例如，我们在输入框中快速的输入文字的时候，不能实时进行网络请求，可以每次输入后的500ms后进行一次网络请求，这样可以大大减少网络请求的次数。

## 跨域

JSONP Cors

### 开发环境下解决跨域问题

**webpack反向代理**

跨域是由于浏览器的同源策略，协议、域名、端口号其中任一不同即为跨域，但是服务器和服务器之间不存在跨域。

开发环境下我们启动了本地的localhost服务器，使得浏览器和本地服务器是同源，不存在跨域。

那么我们就让本地服务器转发请求给远程服务器，远程服务器返回数据给本地服务器，本地服务器再转返回给浏览器。

这就是**webpack反向代理**。

![webpack反向代理](https://photo-album-1314189846.cos.ap-shanghai.myqcloud.com/202303280925640.png)

### 生产环境下解决跨域问题

**nginx反向代理**

我们的前端项目部署在一个域名下，接口服务在另一个域名，如果直接请求，由于域名不同，会产生跨域的问题。

```nginx
    location /prod-api {
        rewrite ^/prod-api/(.*)$ /prod-api/$1 break;
        proxy_pass http://ihrm.itheima.net/prod-api/;
    }
```



## http版本

HTTP1.0：

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

服务器完成请求处理后立即断开TCP连接。

简单来讲，每次与服务器交互，都需要新开一个连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，在同一个TCP连接里面，客户端可以同时发送多个请求

- 虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着

- 新增了一些请求方法，新增了一些请求头和响应头

HTTP2.0：

- 采用二进制格式而非文本格式

- 多路复用，只需一个连接即可实现并行

- 使用报头压缩，降低开销

- 服务器推送

HTTP3.0：

- 是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。

## http&https


## 状态码

**1xx: 请求处理成功状态码**

代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束

> 100:（客户端继续发送请求，这是临时响应）：这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应
>
> 101：服务器根据客户端的请求切换协议，主要用于websocket或http2升级

**2xx: 请求处理成功状态码**

代表请求已成功被服务器接收、理解、并接受

> 200（成功）：请求已成功，请求所希望的响应头或数据体将随此响应返回
>
> 201（已创建）：请求成功并且服务器创建了新的资源
>
> 202（已创建）：服务器已经接收请求，但尚未处理
>
> 203（非授权信息）：服务器已成功处理请求，但返回的信息可能来自另一来源
>
> 204（无内容）：服务器成功处理请求，但没有返回任何内容
>
> 205（重置内容）：服务器成功处理请求，但没有返回任何内容
>
> 206（部分内容）：服务器成功处理了部分请求

**3xx：请求重定向**

表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向

> 300（多种选择）：针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择
>
> 301（永久移动）：请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置
>
> 302（临时移动）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求
>
> 303（查看其他位置）：请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码
>
> 305 （使用代理）： 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理
>
> 307 （临时重定向）： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求

**4xx: 请求失败**

代表了客户端看起来可能发生了错误，妨碍了服务器的处理

> 400（错误请求）： 服务器不理解请求的语法
>
> 401（未授权）： 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
>
> 403（禁止）： 服务器拒绝请求
>
> 404（未找到）： 服务器找不到请求的网页
>
> 405（方法禁用）： 禁用请求中指定的方法
>
> 406（不接受）： 无法使用请求的内容特性响应请求的网页
>
> 407（需要代理授权）： 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理
>
> 408（请求超时）： 服务器等候请求时发生超时

**5xx：服务器问题**

表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生

> 500（服务器内部错误）：服务器遇到错误，无法完成请求
>
> 501（尚未实施）：服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码
>
> 502（错误网关）： 服务器作为网关或代理，从上游服务器收到无效响应
>
> 503（服务不可用）： 服务器目前无法使用（由于超载或停机维护）
>
> 504（网关超时）： 服务器作为网关或代理，但是没有及时从上游服务器收到请求
>
> 505（HTTP 版本不受支持）： 服务器不支持请求中所用的 HTTP 协议版本

## get和post请求的区别
